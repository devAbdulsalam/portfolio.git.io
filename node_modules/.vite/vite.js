import {
  __commonJS,
  __esm,
  __export,
  __objRest,
  __require,
  __spreadProps as __spreadProps2,
  __spreadValues as __spreadValues2
} from "./chunk-UC7LELEO.js";

// browser-external:fs
var fs_exports = {};
__export(fs_exports, {
  default: () => fs_default
});
var fs_default;
var init_fs = __esm({
  "browser-external:fs"() {
    fs_default = new Proxy({}, {
      get() {
        throw new Error('Module "fs" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:path
var path_exports = {};
__export(path_exports, {
  default: () => path_default
});
var path_default;
var init_path = __esm({
  "browser-external:path"() {
    path_default = new Proxy({}, {
      get() {
        throw new Error('Module "path" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:os
var os_exports = {};
__export(os_exports, {
  default: () => os_default
});
var os_default;
var init_os = __esm({
  "browser-external:os"() {
    os_default = new Proxy({}, {
      get() {
        throw new Error('Module "os" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:tty
var tty_exports = {};
__export(tty_exports, {
  default: () => tty_default
});
var tty_default;
var init_tty = __esm({
  "browser-external:tty"() {
    tty_default = new Proxy({}, {
      get() {
        throw new Error('Module "tty" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:util
var util_exports = {};
__export(util_exports, {
  default: () => util_default
});
var util_default;
var init_util = __esm({
  "browser-external:util"() {
    util_default = new Proxy({}, {
      get() {
        throw new Error('Module "util" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:net
var net_exports = {};
__export(net_exports, {
  default: () => net_default
});
var net_default;
var init_net = __esm({
  "browser-external:net"() {
    net_default = new Proxy({}, {
      get() {
        throw new Error('Module "net" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:events
var events_exports = {};
__export(events_exports, {
  default: () => events_default
});
var events_default;
var init_events = __esm({
  "browser-external:events"() {
    events_default = new Proxy({}, {
      get() {
        throw new Error('Module "events" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:url
var url_exports = {};
__export(url_exports, {
  default: () => url_default
});
var url_default;
var init_url = __esm({
  "browser-external:url"() {
    url_default = new Proxy({}, {
      get() {
        throw new Error('Module "url" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:http
var http_exports = {};
__export(http_exports, {
  default: () => http_default
});
var http_default;
var init_http = __esm({
  "browser-external:http"() {
    http_default = new Proxy({}, {
      get() {
        throw new Error('Module "http" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:stream
var stream_exports = {};
__export(stream_exports, {
  default: () => stream_default
});
var stream_default;
var init_stream = __esm({
  "browser-external:stream"() {
    stream_default = new Proxy({}, {
      get() {
        throw new Error('Module "stream" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/resolve/lib/caller.js
var require_caller = __commonJS({
  "node_modules/resolve/lib/caller.js"(exports2, module2) {
    module2.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_2, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});

// node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "node_modules/path-parse/index.js"(exports2, module2) {
    "use strict";
    var isWindows2 = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win322 = {};
    function win32SplitPath(filename2) {
      return splitWindowsRe.exec(filename2).slice(1);
    }
    win322.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix2 = {};
    function posixSplitPath(filename2) {
      return splitPathRe.exec(filename2).slice(1);
    }
    posix2.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows2)
      module2.exports = win322.parse;
    else
      module2.exports = posix2.parse;
    module2.exports.posix = posix2.parse;
    module2.exports.win32 = win322.parse;
  }
});

// node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "node_modules/resolve/lib/node-modules-paths.js"(exports2, module2) {
    var path2 = (init_path(), path_exports);
    var parse2 = path2.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules2) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse2(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse2(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules2.map(function(moduleDir) {
          return path2.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module2.exports = function nodeModulesPaths(start, opts, request) {
      var modules2 = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(request, start, function() {
          return getNodeModulesDirs(start, modules2);
        }, opts);
      }
      var dirs = getNodeModulesDirs(start, modules2);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "node_modules/resolve/lib/normalize-options.js"(exports2, module2) {
    module2.exports = function(x2, opts) {
      return opts || {};
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice2 = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice2.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result2 = target.apply(this, args.concat(slice2.call(arguments)));
          if (Object(result2) === result2) {
            return result2;
          }
          return this;
        } else {
          return target.apply(that, args.concat(slice2.call(arguments)));
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i2 = 0; i2 < boundLength; i2++) {
        boundArgs.push("$" + i2);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src = __commonJS({
  "node_modules/has/src/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/is-core-module/core.json
var require_core = __commonJS({
  "node_modules/is-core-module/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "node_modules/is-core-module/index.js"(exports2, module2) {
    "use strict";
    var has2 = require_src();
    function specifierIncluded(current, specifier) {
      var nodeParts = current.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i2 = 0; i2 < 3; ++i2) {
        var cur = parseInt(nodeParts[i2] || 0, 10);
        var ver = parseInt(versionParts[i2] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current, range2) {
      var specifiers = range2.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i2 = 0; i2 < specifiers.length; ++i2) {
        if (!specifierIncluded(current, specifiers[i2])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i2 = 0; i2 < specifierValue.length; ++i2) {
          if (matchesRange(current, specifierValue[i2])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current, specifierValue);
    }
    var data2 = require_core();
    module2.exports = function isCore(x2, nodeVersion) {
      return has2(data2, x2) && versionIncluded(nodeVersion, data2[x2]);
    };
  }
});

// node_modules/resolve/lib/async.js
var require_async = __commonJS({
  "node_modules/resolve/lib/async.js"(exports2, module2) {
    var fs3 = (init_fs(), fs_exports);
    var path2 = (init_path(), path_exports);
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions2 = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = fs3.realpath && typeof fs3.realpath.native === "function" ? fs3.realpath.native : fs3.realpath;
    var defaultIsFile = function isFile(file, cb) {
      fs3.stat(file, function(err, stat2) {
        if (!err) {
          return cb(null, stat2.isFile() || stat2.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory2(dir, cb) {
      fs3.stat(dir, function(err, stat2) {
        if (!err) {
          return cb(null, stat2.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath2(x2, cb) {
      realpathFS(x2, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT")
          cb(realpathErr);
        else
          cb(null, realpathErr ? x2 : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath2, x2, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath2(x2, cb);
      } else {
        cb(null, x2);
      }
    };
    var defaultReadPackage = function defaultReadPackage2(readFile2, pkgfile, cb) {
      readFile2(pkgfile, function(readFileErr, body) {
        if (readFileErr)
          cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }
      });
    };
    var getPackageCandidates = function getPackageCandidates2(x2, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x2);
      for (var i2 = 0; i2 < dirs.length; i2++) {
        dirs[i2] = path2.join(dirs[i2], x2);
      }
      return dirs;
    };
    module2.exports = function resolve2(x2, options2, callback) {
      var cb = callback;
      var opts = options2;
      if (typeof options2 === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x2 !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions2(x2, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory2 = opts.isDirectory || defaultIsDir;
      var readFile2 = opts.readFile || fs3.readFile;
      var realpath2 = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions2 = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path2.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || [];
      var absoluteStart = path2.resolve(basedir);
      maybeRealpath(realpath2, absoluteStart, opts, function(err2, realStart) {
        if (err2)
          cb(err2);
        else
          init2(realStart);
      });
      var res;
      function init2(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x2)) {
          res = path2.resolve(basedir2, x2);
          if (x2 === "." || x2 === ".." || x2.slice(-1) === "/")
            res += "/";
          if (/\/$/.test(x2) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else
            loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x2)) {
          return cb(null, x2);
        } else
          loadNodeModules(x2, basedir2, function(err2, n3, pkg) {
            if (err2)
              cb(err2);
            else if (n3) {
              return maybeRealpath(realpath2, n3, opts, function(err3, realN) {
                if (err3) {
                  cb(err3);
                } else {
                  cb(null, realN, pkg);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x2 + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function onfile(err2, m3, pkg) {
        if (err2)
          cb(err2);
        else if (m3)
          cb(null, m3, pkg);
        else
          loadAsDirectory(res, function(err3, d3, pkg2) {
            if (err3)
              cb(err3);
            else if (d3) {
              maybeRealpath(realpath2, d3, opts, function(err4, realD) {
                if (err4) {
                  cb(err4);
                } else {
                  cb(null, realD, pkg2);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x2 + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function loadAsFile(x3, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions2);
        load2(exts, x3, loadAsFilePackage);
        function load2(exts2, x4, loadPackage) {
          if (exts2.length === 0)
            return cb2(null, void 0, loadPackage);
          var file = x4 + exts2[0];
          var pkg = loadPackage;
          if (pkg)
            onpkg(null, pkg);
          else
            loadpkg(path2.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2)
              return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path2.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r2 = opts.pathFilter(pkg, x4, rel);
              if (r2)
                return load2([""].concat(extensions2.slice()), path2.resolve(dir, r2), pkg);
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2)
              return cb2(err2);
            if (ex)
              return cb2(null, file, pkg);
            load2(exts2.slice(1), x4, pkg);
          }
        }
      }
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/")
          return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return cb2(null);
        maybeRealpath(realpath2, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return loadpkg(path2.dirname(dir), cb2);
          var pkgfile = path2.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex)
              return loadpkg(path2.dirname(dir), cb2);
            readPackage(readFile2, pkgfile, function(err3, pkgParam) {
              if (err3)
                cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      function loadAsDirectory(x3, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath2, x3, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return cb2(unwrapErr);
          var pkgfile = path2.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2)
              return cb2(err2);
            if (!ex)
              return loadAsFile(path2.join(x3, "index"), fpkg, cb2);
            readPackage(readFile2, pkgfile, function(err3, pkgParam) {
              if (err3)
                return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path2.resolve(x3, pkg.main), pkg, function(err4, m3, pkg2) {
                  if (err4)
                    return cb2(err4);
                  if (m3)
                    return cb2(null, m3, pkg2);
                  if (!pkg2)
                    return loadAsFile(path2.join(x3, "index"), pkg2, cb2);
                  var dir = path2.resolve(x3, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n3, pkg3) {
                    if (err5)
                      return cb2(err5);
                    if (n3)
                      return cb2(null, n3, pkg3);
                    loadAsFile(path2.join(x3, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path2.join(x3, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0)
          return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory2(path2.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2)
            return cb2(err2);
          if (!isdir2)
            return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        function onfile2(err2, m3, pkg) {
          if (err2)
            return cb2(err2);
          if (m3)
            return cb2(null, m3, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err2, n3, pkg) {
          if (err2)
            return cb2(err2);
          if (n3)
            return cb2(null, n3, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x3, start, cb2) {
        var thunk = function() {
          return getPackageCandidates(x3, start, opts);
        };
        processDirs(cb2, packageIterator ? packageIterator(x3, start, thunk, opts) : thunk());
      }
    };
  }
});

// node_modules/resolve/lib/core.json
var require_core2 = __commonJS({
  "node_modules/resolve/lib/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: "< 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: true,
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: true,
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.6 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: true,
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/resolve/lib/core.js
var require_core3 = __commonJS({
  "node_modules/resolve/lib/core.js"(exports2, module2) {
    var current = process.versions && process.versions.node && process.versions.node.split(".") || [];
    function specifierIncluded(specifier) {
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i2 = 0; i2 < 3; ++i2) {
        var cur = parseInt(current[i2] || 0, 10);
        var ver = parseInt(versionParts[i2] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        } else if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(range2) {
      var specifiers = range2.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i2 = 0; i2 < specifiers.length; ++i2) {
        if (!specifierIncluded(specifiers[i2])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i2 = 0; i2 < specifierValue.length; ++i2) {
          if (matchesRange(specifierValue[i2])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(specifierValue);
    }
    var data2 = require_core2();
    var core2 = {};
    for (mod in data2) {
      if (Object.prototype.hasOwnProperty.call(data2, mod)) {
        core2[mod] = versionIncluded(data2[mod]);
      }
    }
    var mod;
    module2.exports = core2;
  }
});

// node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS({
  "node_modules/resolve/lib/is-core.js"(exports2, module2) {
    var isCoreModule = require_is_core_module();
    module2.exports = function isCore(x2) {
      return isCoreModule(x2);
    };
  }
});

// node_modules/resolve/lib/sync.js
var require_sync = __commonJS({
  "node_modules/resolve/lib/sync.js"(exports2, module2) {
    var isCore = require_is_core_module();
    var fs3 = (init_fs(), fs_exports);
    var path2 = (init_path(), path_exports);
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions2 = require_normalize_options();
    var realpathFS = fs3.realpathSync && typeof fs3.realpathSync.native === "function" ? fs3.realpathSync.native : fs3.realpathSync;
    var defaultIsFile = function isFile(file) {
      try {
        var stat2 = fs3.statSync(file, { throwIfNoEntry: false });
      } catch (e2) {
        if (e2 && (e2.code === "ENOENT" || e2.code === "ENOTDIR"))
          return false;
        throw e2;
      }
      return !!stat2 && (stat2.isFile() || stat2.isFIFO());
    };
    var defaultIsDir = function isDirectory2(dir) {
      try {
        var stat2 = fs3.statSync(dir, { throwIfNoEntry: false });
      } catch (e2) {
        if (e2 && (e2.code === "ENOENT" || e2.code === "ENOTDIR"))
          return false;
        throw e2;
      }
      return !!stat2 && stat2.isDirectory();
    };
    var defaultRealpathSync = function realpathSync2(x2) {
      try {
        return realpathFS(x2);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x2;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync2, x2, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync2(x2);
      }
      return x2;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {
      var body = readFileSync(pkgfile);
      try {
        var pkg = JSON.parse(body);
        return pkg;
      } catch (jsonErr) {
      }
    };
    var getPackageCandidates = function getPackageCandidates2(x2, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x2);
      for (var i2 = 0; i2 < dirs.length; i2++) {
        dirs[i2] = path2.join(dirs[i2], x2);
      }
      return dirs;
    };
    module2.exports = function resolveSync(x2, options2) {
      if (typeof x2 !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions2(x2, options2);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync = opts.readFileSync || fs3.readFileSync;
      var isDirectory2 = opts.isDirectory || defaultIsDir;
      var realpathSync2 = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions2 = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path2.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || [];
      var absoluteStart = maybeRealpathSync(realpathSync2, path2.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x2)) {
        var res = path2.resolve(absoluteStart, x2);
        if (x2 === "." || x2 === ".." || x2.slice(-1) === "/")
          res += "/";
        var m3 = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m3)
          return maybeRealpathSync(realpathSync2, m3, opts);
      } else if (includeCoreModules && isCore(x2)) {
        return x2;
      } else {
        var n3 = loadNodeModulesSync(x2, absoluteStart);
        if (n3)
          return maybeRealpathSync(realpathSync2, n3, opts);
      }
      var err = new Error("Cannot find module '" + x2 + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x3) {
        var pkg = loadpkg(path2.dirname(x3));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path2.relative(pkg.dir, x3);
          var r2 = opts.pathFilter(pkg.pkg, x3, rfile);
          if (r2) {
            x3 = path2.resolve(pkg.dir, r2);
          }
        }
        if (isFile(x3)) {
          return x3;
        }
        for (var i2 = 0; i2 < extensions2.length; i2++) {
          var file = x3 + extensions2[i2];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/")
          return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return;
        var pkgfile = path2.join(maybeRealpathSync(realpathSync2, dir, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path2.dirname(dir));
        }
        var pkg = readPackageSync(readFileSync, pkgfile);
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(pkg, dir);
        }
        return { pkg, dir };
      }
      function loadAsDirectorySync(x3) {
        var pkgfile = path2.join(maybeRealpathSync(realpathSync2, x3, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync, pkgfile);
          } catch (e2) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(pkg, x3);
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m4 = loadAsFileSync(path2.resolve(x3, pkg.main));
              if (m4)
                return m4;
              var n4 = loadAsDirectorySync(path2.resolve(x3, pkg.main));
              if (n4)
                return n4;
            } catch (e2) {
            }
          }
        }
        return loadAsFileSync(path2.join(x3, "/index"));
      }
      function loadNodeModulesSync(x3, start) {
        var thunk = function() {
          return getPackageCandidates(x3, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x3, start, thunk, opts) : thunk();
        for (var i2 = 0; i2 < dirs.length; i2++) {
          var dir = dirs[i2];
          if (isDirectory2(path2.dirname(dir))) {
            var m4 = loadAsFileSync(dir);
            if (m4)
              return m4;
            var n4 = loadAsDirectorySync(dir);
            if (n4)
              return n4;
          }
        }
      }
    };
  }
});

// node_modules/resolve/index.js
var require_resolve = __commonJS({
  "node_modules/resolve/index.js"(exports2, module2) {
    var async2 = require_async();
    async2.core = require_core3();
    async2.isCore = require_is_core();
    async2.sync = require_sync();
    module2.exports = async2;
  }
});

// browser-external:module
var module_exports = {};
__export(module_exports, {
  default: () => module_default
});
var module_default;
var init_module = __esm({
  "browser-external:module"() {
    module_default = new Proxy({}, {
      get() {
        throw new Error('Module "module" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:perf_hooks
var perf_hooks_exports = {};
__export(perf_hooks_exports, {
  default: () => perf_hooks_default
});
var perf_hooks_default;
var init_perf_hooks = __esm({
  "browser-external:perf_hooks"() {
    perf_hooks_default = new Proxy({}, {
      get() {
        throw new Error('Module "perf_hooks" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:https
var https_exports = {};
__export(https_exports, {
  default: () => https_default
});
var https_default;
var init_https = __esm({
  "browser-external:https"() {
    https_default = new Proxy({}, {
      get() {
        throw new Error('Module "https" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:zlib
var zlib_exports = {};
__export(zlib_exports, {
  default: () => zlib_default
});
var zlib_default;
var init_zlib = __esm({
  "browser-external:zlib"() {
    zlib_default = new Proxy({}, {
      get() {
        throw new Error('Module "zlib" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:crypto
var crypto_exports = {};
__export(crypto_exports, {
  default: () => crypto_default
});
var crypto_default;
var init_crypto = __esm({
  "browser-external:crypto"() {
    crypto_default = new Proxy({}, {
      get() {
        throw new Error('Module "crypto" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:tls
var tls_exports = {};
__export(tls_exports, {
  default: () => tls_default
});
var tls_default;
var init_tls = __esm({
  "browser-external:tls"() {
    tls_default = new Proxy({}, {
      get() {
        throw new Error('Module "tls" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:assert
var assert_exports = {};
__export(assert_exports, {
  default: () => assert_default
});
var assert_default;
var init_assert = __esm({
  "browser-external:assert"() {
    assert_default = new Proxy({}, {
      get() {
        throw new Error('Module "assert" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:buffer
var buffer_exports = {};
__export(buffer_exports, {
  default: () => buffer_default
});
var buffer_default;
var init_buffer = __esm({
  "browser-external:buffer"() {
    buffer_default = new Proxy({}, {
      get() {
        throw new Error('Module "buffer" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:querystring
var querystring_exports = {};
__export(querystring_exports, {
  default: () => querystring_default
});
var querystring_default;
var init_querystring = __esm({
  "browser-external:querystring"() {
    querystring_default = new Proxy({}, {
      get() {
        throw new Error('Module "querystring" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:child_process
var child_process_exports = {};
__export(child_process_exports, {
  default: () => child_process_default
});
var child_process_default;
var init_child_process = __esm({
  "browser-external:child_process"() {
    child_process_default = new Proxy({}, {
      get() {
        throw new Error('Module "child_process" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// browser-external:worker_threads
var worker_threads_exports = {};
__export(worker_threads_exports, {
  default: () => worker_threads_default
});
var worker_threads_default;
var init_worker_threads = __esm({
  "browser-external:worker_threads"() {
    worker_threads_default = new Proxy({}, {
      get() {
        throw new Error('Module "worker_threads" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/esbuild/lib/main.js
var require_main = __commonJS({
  "node_modules/esbuild/lib/main.js"(exports2) {
    var __defProp2 = Object.defineProperty;
    var __defProps2 = Object.defineProperties;
    var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
    var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues3 = (a2, b2) => {
      for (var prop in b2 || (b2 = {}))
        if (__hasOwnProp2.call(b2, prop))
          __defNormalProp2(a2, prop, b2[prop]);
      if (__getOwnPropSymbols2)
        for (var prop of __getOwnPropSymbols2(b2)) {
          if (__propIsEnum2.call(b2, prop))
            __defNormalProp2(a2, prop, b2[prop]);
        }
      return a2;
    };
    var __spreadProps3 = (a2, b2) => __defProps2(a2, __getOwnPropDescs2(b2));
    var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
    var __export2 = (target, all) => {
      __markAsModule(target);
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    __export2(exports2, {
      analyzeMetafile: () => analyzeMetafile,
      analyzeMetafileSync: () => analyzeMetafileSync,
      build: () => build2,
      buildSync: () => buildSync,
      formatMessages: () => formatMessages,
      formatMessagesSync: () => formatMessagesSync,
      initialize: () => initialize,
      serve: () => serve,
      transform: () => transform2,
      transformSync: () => transformSync,
      version: () => version2
    });
    function encodePacket(packet) {
      let visit2 = (value) => {
        if (value === null) {
          bb.write8(0);
        } else if (typeof value === "boolean") {
          bb.write8(1);
          bb.write8(+value);
        } else if (typeof value === "number") {
          bb.write8(2);
          bb.write32(value | 0);
        } else if (typeof value === "string") {
          bb.write8(3);
          bb.write(encodeUTF8(value));
        } else if (value instanceof Uint8Array) {
          bb.write8(4);
          bb.write(value);
        } else if (value instanceof Array) {
          bb.write8(5);
          bb.write32(value.length);
          for (let item of value) {
            visit2(item);
          }
        } else {
          let keys = Object.keys(value);
          bb.write8(6);
          bb.write32(keys.length);
          for (let key of keys) {
            bb.write(encodeUTF8(key));
            visit2(value[key]);
          }
        }
      };
      let bb = new ByteBuffer();
      bb.write32(0);
      bb.write32(packet.id << 1 | +!packet.isRequest);
      visit2(packet.value);
      writeUInt32LE(bb.buf, bb.len - 4, 0);
      return bb.buf.subarray(0, bb.len);
    }
    function decodePacket(bytes2) {
      let visit2 = () => {
        switch (bb.read8()) {
          case 0:
            return null;
          case 1:
            return !!bb.read8();
          case 2:
            return bb.read32();
          case 3:
            return decodeUTF8(bb.read());
          case 4:
            return bb.read();
          case 5: {
            let count = bb.read32();
            let value2 = [];
            for (let i2 = 0; i2 < count; i2++) {
              value2.push(visit2());
            }
            return value2;
          }
          case 6: {
            let count = bb.read32();
            let value2 = {};
            for (let i2 = 0; i2 < count; i2++) {
              value2[decodeUTF8(bb.read())] = visit2();
            }
            return value2;
          }
          default:
            throw new Error("Invalid packet");
        }
      };
      let bb = new ByteBuffer(bytes2);
      let id = bb.read32();
      let isRequest = (id & 1) === 0;
      id >>>= 1;
      let value = visit2();
      if (bb.ptr !== bytes2.length) {
        throw new Error("Invalid packet");
      }
      return { id, isRequest, value };
    }
    var ByteBuffer = class {
      constructor(buf = new Uint8Array(1024)) {
        this.buf = buf;
        this.len = 0;
        this.ptr = 0;
      }
      _write(delta) {
        if (this.len + delta > this.buf.length) {
          let clone = new Uint8Array((this.len + delta) * 2);
          clone.set(this.buf);
          this.buf = clone;
        }
        this.len += delta;
        return this.len - delta;
      }
      write8(value) {
        let offset2 = this._write(1);
        this.buf[offset2] = value;
      }
      write32(value) {
        let offset2 = this._write(4);
        writeUInt32LE(this.buf, value, offset2);
      }
      write(bytes2) {
        let offset2 = this._write(4 + bytes2.length);
        writeUInt32LE(this.buf, bytes2.length, offset2);
        this.buf.set(bytes2, offset2 + 4);
      }
      _read(delta) {
        if (this.ptr + delta > this.buf.length) {
          throw new Error("Invalid packet");
        }
        this.ptr += delta;
        return this.ptr - delta;
      }
      read8() {
        return this.buf[this._read(1)];
      }
      read32() {
        return readUInt32LE(this.buf, this._read(4));
      }
      read() {
        let length = this.read32();
        let bytes2 = new Uint8Array(length);
        let ptr = this._read(bytes2.length);
        bytes2.set(this.buf.subarray(ptr, ptr + length));
        return bytes2;
      }
    };
    var encodeUTF8;
    var decodeUTF8;
    if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
      let encoder = new TextEncoder();
      let decoder = new TextDecoder();
      encodeUTF8 = (text) => encoder.encode(text);
      decodeUTF8 = (bytes2) => decoder.decode(bytes2);
    } else if (typeof Buffer !== "undefined") {
      encodeUTF8 = (text) => {
        let buffer = Buffer.from(text);
        if (!(buffer instanceof Uint8Array)) {
          buffer = new Uint8Array(buffer);
        }
        return buffer;
      };
      decodeUTF8 = (bytes2) => {
        let { buffer, byteOffset, byteLength } = bytes2;
        return Buffer.from(buffer, byteOffset, byteLength).toString();
      };
    } else {
      throw new Error("No UTF-8 codec found");
    }
    function readUInt32LE(buffer, offset2) {
      return buffer[offset2++] | buffer[offset2++] << 8 | buffer[offset2++] << 16 | buffer[offset2++] << 24;
    }
    function writeUInt32LE(buffer, value, offset2) {
      buffer[offset2++] = value;
      buffer[offset2++] = value >> 8;
      buffer[offset2++] = value >> 16;
      buffer[offset2++] = value >> 24;
    }
    function validateTarget(target) {
      target += "";
      if (target.indexOf(",") >= 0)
        throw new Error(`Invalid target: ${target}`);
      return target;
    }
    var canBeAnything = () => null;
    var mustBeBoolean = (value) => typeof value === "boolean" ? null : "a boolean";
    var mustBeBooleanOrObject = (value) => typeof value === "boolean" || typeof value === "object" && !Array.isArray(value) ? null : "a boolean or an object";
    var mustBeString = (value) => typeof value === "string" ? null : "a string";
    var mustBeRegExp = (value) => value instanceof RegExp ? null : "a RegExp object";
    var mustBeInteger = (value) => typeof value === "number" && value === (value | 0) ? null : "an integer";
    var mustBeFunction = (value) => typeof value === "function" ? null : "a function";
    var mustBeArray = (value) => Array.isArray(value) ? null : "an array";
    var mustBeObject = (value) => typeof value === "object" && value !== null && !Array.isArray(value) ? null : "an object";
    var mustBeArrayOrRecord = (value) => typeof value === "object" && value !== null ? null : "an array or an object";
    var mustBeObjectOrNull = (value) => typeof value === "object" && !Array.isArray(value) ? null : "an object or null";
    var mustBeStringOrBoolean = (value) => typeof value === "string" || typeof value === "boolean" ? null : "a string or a boolean";
    var mustBeStringOrObject = (value) => typeof value === "string" || typeof value === "object" && value !== null && !Array.isArray(value) ? null : "a string or an object";
    var mustBeStringOrArray = (value) => typeof value === "string" || Array.isArray(value) ? null : "a string or an array";
    var mustBeStringOrUint8Array = (value) => typeof value === "string" || value instanceof Uint8Array ? null : "a string or a Uint8Array";
    function getFlag(object, keys, key, mustBeFn) {
      let value = object[key];
      keys[key + ""] = true;
      if (value === void 0)
        return void 0;
      let mustBe = mustBeFn(value);
      if (mustBe !== null)
        throw new Error(`"${key}" must be ${mustBe}`);
      return value;
    }
    function checkForInvalidFlags(object, keys, where) {
      for (let key in object) {
        if (!(key in keys)) {
          throw new Error(`Invalid option ${where}: "${key}"`);
        }
      }
    }
    function validateInitializeOptions(options2) {
      let keys = Object.create(null);
      let wasmURL = getFlag(options2, keys, "wasmURL", mustBeString);
      let worker = getFlag(options2, keys, "worker", mustBeBoolean);
      checkForInvalidFlags(options2, keys, "in startService() call");
      return {
        wasmURL,
        worker
      };
    }
    function pushLogFlags(flags, options2, keys, isTTY2, logLevelDefault) {
      let color = getFlag(options2, keys, "color", mustBeBoolean);
      let logLevel = getFlag(options2, keys, "logLevel", mustBeString);
      let logLimit = getFlag(options2, keys, "logLimit", mustBeInteger);
      if (color !== void 0)
        flags.push(`--color=${color}`);
      else if (isTTY2)
        flags.push(`--color=true`);
      flags.push(`--log-level=${logLevel || logLevelDefault}`);
      flags.push(`--log-limit=${logLimit || 0}`);
    }
    function pushCommonFlags(flags, options2, keys) {
      let legalComments = getFlag(options2, keys, "legalComments", mustBeString);
      let sourceRoot = getFlag(options2, keys, "sourceRoot", mustBeString);
      let sourcesContent = getFlag(options2, keys, "sourcesContent", mustBeBoolean);
      let target = getFlag(options2, keys, "target", mustBeStringOrArray);
      let format2 = getFlag(options2, keys, "format", mustBeString);
      let globalName = getFlag(options2, keys, "globalName", mustBeString);
      let minify = getFlag(options2, keys, "minify", mustBeBoolean);
      let minifySyntax = getFlag(options2, keys, "minifySyntax", mustBeBoolean);
      let minifyWhitespace = getFlag(options2, keys, "minifyWhitespace", mustBeBoolean);
      let minifyIdentifiers = getFlag(options2, keys, "minifyIdentifiers", mustBeBoolean);
      let charset2 = getFlag(options2, keys, "charset", mustBeString);
      let treeShaking = getFlag(options2, keys, "treeShaking", mustBeBoolean);
      let ignoreAnnotations = getFlag(options2, keys, "ignoreAnnotations", mustBeBoolean);
      let jsx = getFlag(options2, keys, "jsx", mustBeString);
      let jsxFactory = getFlag(options2, keys, "jsxFactory", mustBeString);
      let jsxFragment = getFlag(options2, keys, "jsxFragment", mustBeString);
      let define2 = getFlag(options2, keys, "define", mustBeObject);
      let pure = getFlag(options2, keys, "pure", mustBeArray);
      let keepNames = getFlag(options2, keys, "keepNames", mustBeBoolean);
      if (legalComments)
        flags.push(`--legal-comments=${legalComments}`);
      if (sourceRoot !== void 0)
        flags.push(`--source-root=${sourceRoot}`);
      if (sourcesContent !== void 0)
        flags.push(`--sources-content=${sourcesContent}`);
      if (target) {
        if (Array.isArray(target))
          flags.push(`--target=${Array.from(target).map(validateTarget).join(",")}`);
        else
          flags.push(`--target=${validateTarget(target)}`);
      }
      if (format2)
        flags.push(`--format=${format2}`);
      if (globalName)
        flags.push(`--global-name=${globalName}`);
      if (minify)
        flags.push("--minify");
      if (minifySyntax)
        flags.push("--minify-syntax");
      if (minifyWhitespace)
        flags.push("--minify-whitespace");
      if (minifyIdentifiers)
        flags.push("--minify-identifiers");
      if (charset2)
        flags.push(`--charset=${charset2}`);
      if (treeShaking !== void 0)
        flags.push(`--tree-shaking=${treeShaking}`);
      if (ignoreAnnotations)
        flags.push(`--ignore-annotations`);
      if (jsx)
        flags.push(`--jsx=${jsx}`);
      if (jsxFactory)
        flags.push(`--jsx-factory=${jsxFactory}`);
      if (jsxFragment)
        flags.push(`--jsx-fragment=${jsxFragment}`);
      if (define2) {
        for (let key in define2) {
          if (key.indexOf("=") >= 0)
            throw new Error(`Invalid define: ${key}`);
          flags.push(`--define:${key}=${define2[key]}`);
        }
      }
      if (pure)
        for (let fn2 of pure)
          flags.push(`--pure:${fn2}`);
      if (keepNames)
        flags.push(`--keep-names`);
    }
    function flagsForBuildOptions(callName, options2, isTTY2, logLevelDefault, writeDefault) {
      var _a22;
      let flags = [];
      let entries = [];
      let keys = Object.create(null);
      let stdinContents = null;
      let stdinResolveDir = null;
      let watchMode = null;
      pushLogFlags(flags, options2, keys, isTTY2, logLevelDefault);
      pushCommonFlags(flags, options2, keys);
      let sourcemap = getFlag(options2, keys, "sourcemap", mustBeStringOrBoolean);
      let bundle = getFlag(options2, keys, "bundle", mustBeBoolean);
      let watch2 = getFlag(options2, keys, "watch", mustBeBooleanOrObject);
      let splitting = getFlag(options2, keys, "splitting", mustBeBoolean);
      let preserveSymlinks = getFlag(options2, keys, "preserveSymlinks", mustBeBoolean);
      let metafile = getFlag(options2, keys, "metafile", mustBeBoolean);
      let outfile = getFlag(options2, keys, "outfile", mustBeString);
      let outdir = getFlag(options2, keys, "outdir", mustBeString);
      let outbase = getFlag(options2, keys, "outbase", mustBeString);
      let platform2 = getFlag(options2, keys, "platform", mustBeString);
      let tsconfig = getFlag(options2, keys, "tsconfig", mustBeString);
      let resolveExtensions = getFlag(options2, keys, "resolveExtensions", mustBeArray);
      let nodePathsInput = getFlag(options2, keys, "nodePaths", mustBeArray);
      let mainFields = getFlag(options2, keys, "mainFields", mustBeArray);
      let conditions = getFlag(options2, keys, "conditions", mustBeArray);
      let external = getFlag(options2, keys, "external", mustBeArray);
      let loader = getFlag(options2, keys, "loader", mustBeObject);
      let outExtension = getFlag(options2, keys, "outExtension", mustBeObject);
      let publicPath = getFlag(options2, keys, "publicPath", mustBeString);
      let entryNames = getFlag(options2, keys, "entryNames", mustBeString);
      let chunkNames = getFlag(options2, keys, "chunkNames", mustBeString);
      let assetNames = getFlag(options2, keys, "assetNames", mustBeString);
      let inject = getFlag(options2, keys, "inject", mustBeArray);
      let banner = getFlag(options2, keys, "banner", mustBeObject);
      let footer = getFlag(options2, keys, "footer", mustBeObject);
      let entryPoints = getFlag(options2, keys, "entryPoints", mustBeArrayOrRecord);
      let absWorkingDir = getFlag(options2, keys, "absWorkingDir", mustBeString);
      let stdin = getFlag(options2, keys, "stdin", mustBeObject);
      let write = (_a22 = getFlag(options2, keys, "write", mustBeBoolean)) != null ? _a22 : writeDefault;
      let allowOverwrite = getFlag(options2, keys, "allowOverwrite", mustBeBoolean);
      let incremental = getFlag(options2, keys, "incremental", mustBeBoolean) === true;
      keys.plugins = true;
      checkForInvalidFlags(options2, keys, `in ${callName}() call`);
      if (sourcemap)
        flags.push(`--sourcemap${sourcemap === true ? "" : `=${sourcemap}`}`);
      if (bundle)
        flags.push("--bundle");
      if (allowOverwrite)
        flags.push("--allow-overwrite");
      if (watch2) {
        flags.push("--watch");
        if (typeof watch2 === "boolean") {
          watchMode = {};
        } else {
          let watchKeys = Object.create(null);
          let onRebuild = getFlag(watch2, watchKeys, "onRebuild", mustBeFunction);
          checkForInvalidFlags(watch2, watchKeys, `on "watch" in ${callName}() call`);
          watchMode = { onRebuild };
        }
      }
      if (splitting)
        flags.push("--splitting");
      if (preserveSymlinks)
        flags.push("--preserve-symlinks");
      if (metafile)
        flags.push(`--metafile`);
      if (outfile)
        flags.push(`--outfile=${outfile}`);
      if (outdir)
        flags.push(`--outdir=${outdir}`);
      if (outbase)
        flags.push(`--outbase=${outbase}`);
      if (platform2)
        flags.push(`--platform=${platform2}`);
      if (tsconfig)
        flags.push(`--tsconfig=${tsconfig}`);
      if (resolveExtensions) {
        let values = [];
        for (let value of resolveExtensions) {
          value += "";
          if (value.indexOf(",") >= 0)
            throw new Error(`Invalid resolve extension: ${value}`);
          values.push(value);
        }
        flags.push(`--resolve-extensions=${values.join(",")}`);
      }
      if (publicPath)
        flags.push(`--public-path=${publicPath}`);
      if (entryNames)
        flags.push(`--entry-names=${entryNames}`);
      if (chunkNames)
        flags.push(`--chunk-names=${chunkNames}`);
      if (assetNames)
        flags.push(`--asset-names=${assetNames}`);
      if (mainFields) {
        let values = [];
        for (let value of mainFields) {
          value += "";
          if (value.indexOf(",") >= 0)
            throw new Error(`Invalid main field: ${value}`);
          values.push(value);
        }
        flags.push(`--main-fields=${values.join(",")}`);
      }
      if (conditions) {
        let values = [];
        for (let value of conditions) {
          value += "";
          if (value.indexOf(",") >= 0)
            throw new Error(`Invalid condition: ${value}`);
          values.push(value);
        }
        flags.push(`--conditions=${values.join(",")}`);
      }
      if (external)
        for (let name of external)
          flags.push(`--external:${name}`);
      if (banner) {
        for (let type in banner) {
          if (type.indexOf("=") >= 0)
            throw new Error(`Invalid banner file type: ${type}`);
          flags.push(`--banner:${type}=${banner[type]}`);
        }
      }
      if (footer) {
        for (let type in footer) {
          if (type.indexOf("=") >= 0)
            throw new Error(`Invalid footer file type: ${type}`);
          flags.push(`--footer:${type}=${footer[type]}`);
        }
      }
      if (inject)
        for (let path3 of inject)
          flags.push(`--inject:${path3}`);
      if (loader) {
        for (let ext2 in loader) {
          if (ext2.indexOf("=") >= 0)
            throw new Error(`Invalid loader extension: ${ext2}`);
          flags.push(`--loader:${ext2}=${loader[ext2]}`);
        }
      }
      if (outExtension) {
        for (let ext2 in outExtension) {
          if (ext2.indexOf("=") >= 0)
            throw new Error(`Invalid out extension: ${ext2}`);
          flags.push(`--out-extension:${ext2}=${outExtension[ext2]}`);
        }
      }
      if (entryPoints) {
        if (Array.isArray(entryPoints)) {
          for (let entryPoint of entryPoints) {
            entries.push(["", entryPoint + ""]);
          }
        } else {
          for (let [key, value] of Object.entries(entryPoints)) {
            entries.push([key + "", value + ""]);
          }
        }
      }
      if (stdin) {
        let stdinKeys = Object.create(null);
        let contents = getFlag(stdin, stdinKeys, "contents", mustBeString);
        let resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
        let sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
        let loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
        checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
        if (sourcefile)
          flags.push(`--sourcefile=${sourcefile}`);
        if (loader2)
          flags.push(`--loader=${loader2}`);
        if (resolveDir)
          stdinResolveDir = resolveDir + "";
        stdinContents = contents ? contents + "" : "";
      }
      let nodePaths = [];
      if (nodePathsInput) {
        for (let value of nodePathsInput) {
          value += "";
          nodePaths.push(value);
        }
      }
      return {
        entries,
        flags,
        write,
        stdinContents,
        stdinResolveDir,
        absWorkingDir,
        incremental,
        nodePaths,
        watch: watchMode
      };
    }
    function flagsForTransformOptions(callName, options2, isTTY2, logLevelDefault) {
      let flags = [];
      let keys = Object.create(null);
      pushLogFlags(flags, options2, keys, isTTY2, logLevelDefault);
      pushCommonFlags(flags, options2, keys);
      let sourcemap = getFlag(options2, keys, "sourcemap", mustBeStringOrBoolean);
      let tsconfigRaw = getFlag(options2, keys, "tsconfigRaw", mustBeStringOrObject);
      let sourcefile = getFlag(options2, keys, "sourcefile", mustBeString);
      let loader = getFlag(options2, keys, "loader", mustBeString);
      let banner = getFlag(options2, keys, "banner", mustBeString);
      let footer = getFlag(options2, keys, "footer", mustBeString);
      checkForInvalidFlags(options2, keys, `in ${callName}() call`);
      if (sourcemap)
        flags.push(`--sourcemap=${sourcemap === true ? "external" : sourcemap}`);
      if (tsconfigRaw)
        flags.push(`--tsconfig-raw=${typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);
      if (sourcefile)
        flags.push(`--sourcefile=${sourcefile}`);
      if (loader)
        flags.push(`--loader=${loader}`);
      if (banner)
        flags.push(`--banner=${banner}`);
      if (footer)
        flags.push(`--footer=${footer}`);
      return flags;
    }
    function createChannel(streamIn) {
      let responseCallbacks = new Map();
      let pluginCallbacks = new Map();
      let watchCallbacks = new Map();
      let serveCallbacks = new Map();
      let nextServeID = 0;
      let isClosed = false;
      let nextRequestID = 0;
      let nextBuildKey = 0;
      let stdout = new Uint8Array(16 * 1024);
      let stdoutUsed = 0;
      let readFromStdout = (chunk) => {
        let limit = stdoutUsed + chunk.length;
        if (limit > stdout.length) {
          let swap2 = new Uint8Array(limit * 2);
          swap2.set(stdout);
          stdout = swap2;
        }
        stdout.set(chunk, stdoutUsed);
        stdoutUsed += chunk.length;
        let offset2 = 0;
        while (offset2 + 4 <= stdoutUsed) {
          let length = readUInt32LE(stdout, offset2);
          if (offset2 + 4 + length > stdoutUsed) {
            break;
          }
          offset2 += 4;
          handleIncomingPacket(stdout.subarray(offset2, offset2 + length));
          offset2 += length;
        }
        if (offset2 > 0) {
          stdout.copyWithin(0, offset2, stdoutUsed);
          stdoutUsed -= offset2;
        }
      };
      let afterClose = () => {
        isClosed = true;
        for (let callback of responseCallbacks.values()) {
          callback("The service was stopped", null);
        }
        responseCallbacks.clear();
        for (let callbacks of serveCallbacks.values()) {
          callbacks.onWait("The service was stopped");
        }
        serveCallbacks.clear();
        for (let callback of watchCallbacks.values()) {
          try {
            callback(new Error("The service was stopped"), null);
          } catch (e2) {
            console.error(e2);
          }
        }
        watchCallbacks.clear();
      };
      let sendRequest = (refs, value, callback) => {
        if (isClosed)
          return callback("The service is no longer running", null);
        let id = nextRequestID++;
        responseCallbacks.set(id, (error2, response) => {
          try {
            callback(error2, response);
          } finally {
            if (refs)
              refs.unref();
          }
        });
        if (refs)
          refs.ref();
        streamIn.writeToStdin(encodePacket({ id, isRequest: true, value }));
      };
      let sendResponse = (id, value) => {
        if (isClosed)
          throw new Error("The service is no longer running");
        streamIn.writeToStdin(encodePacket({ id, isRequest: false, value }));
      };
      let handleRequest = async (id, request) => {
        try {
          switch (request.command) {
            case "ping": {
              sendResponse(id, {});
              break;
            }
            case "start": {
              let callback = pluginCallbacks.get(request.key);
              if (!callback)
                sendResponse(id, {});
              else
                sendResponse(id, await callback(request));
              break;
            }
            case "resolve": {
              let callback = pluginCallbacks.get(request.key);
              if (!callback)
                sendResponse(id, {});
              else
                sendResponse(id, await callback(request));
              break;
            }
            case "load": {
              let callback = pluginCallbacks.get(request.key);
              if (!callback)
                sendResponse(id, {});
              else
                sendResponse(id, await callback(request));
              break;
            }
            case "serve-request": {
              let callbacks = serveCallbacks.get(request.serveID);
              if (callbacks && callbacks.onRequest)
                callbacks.onRequest(request.args);
              sendResponse(id, {});
              break;
            }
            case "serve-wait": {
              let callbacks = serveCallbacks.get(request.serveID);
              if (callbacks)
                callbacks.onWait(request.error);
              sendResponse(id, {});
              break;
            }
            case "watch-rebuild": {
              let callback = watchCallbacks.get(request.watchID);
              try {
                if (callback)
                  callback(null, request.args);
              } catch (err) {
                console.error(err);
              }
              sendResponse(id, {});
              break;
            }
            default:
              throw new Error(`Invalid command: ` + request.command);
          }
        } catch (e2) {
          sendResponse(id, { errors: [extractErrorMessageV8(e2, streamIn, null, void 0, "")] });
        }
      };
      let isFirstPacket = true;
      let handleIncomingPacket = (bytes2) => {
        if (isFirstPacket) {
          isFirstPacket = false;
          let binaryVersion = String.fromCharCode(...bytes2);
          if (binaryVersion !== "0.13.15") {
            throw new Error(`Cannot start service: Host version "${"0.13.15"}" does not match binary version ${JSON.stringify(binaryVersion)}`);
          }
          return;
        }
        let packet = decodePacket(bytes2);
        if (packet.isRequest) {
          handleRequest(packet.id, packet.value);
        } else {
          let callback = responseCallbacks.get(packet.id);
          responseCallbacks.delete(packet.id);
          if (packet.value.error)
            callback(packet.value.error, {});
          else
            callback(null, packet.value);
        }
      };
      let handlePlugins = async (initialOptions, plugins2, buildKey, stash) => {
        let onStartCallbacks = [];
        let onEndCallbacks = [];
        let onResolveCallbacks = {};
        let onLoadCallbacks = {};
        let nextCallbackID = 0;
        let i2 = 0;
        let requestPlugins = [];
        plugins2 = [...plugins2];
        for (let item of plugins2) {
          let keys = {};
          if (typeof item !== "object")
            throw new Error(`Plugin at index ${i2} must be an object`);
          let name = getFlag(item, keys, "name", mustBeString);
          if (typeof name !== "string" || name === "")
            throw new Error(`Plugin at index ${i2} is missing a name`);
          try {
            let setup2 = getFlag(item, keys, "setup", mustBeFunction);
            if (typeof setup2 !== "function")
              throw new Error(`Plugin is missing a setup function`);
            checkForInvalidFlags(item, keys, `on plugin ${JSON.stringify(name)}`);
            let plugin = {
              name,
              onResolve: [],
              onLoad: []
            };
            i2++;
            let promise2 = setup2({
              initialOptions,
              onStart(callback2) {
                let registeredText = `This error came from the "onStart" callback registered here`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
                onStartCallbacks.push({ name, callback: callback2, note: registeredNote });
              },
              onEnd(callback2) {
                let registeredText = `This error came from the "onEnd" callback registered here`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
                onEndCallbacks.push({ name, callback: callback2, note: registeredNote });
              },
              onResolve(options2, callback2) {
                let registeredText = `This error came from the "onResolve" callback registered here`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
                let keys2 = {};
                let filter2 = getFlag(options2, keys2, "filter", mustBeRegExp);
                let namespace = getFlag(options2, keys2, "namespace", mustBeString);
                checkForInvalidFlags(options2, keys2, `in onResolve() call for plugin ${JSON.stringify(name)}`);
                if (filter2 == null)
                  throw new Error(`onResolve() call is missing a filter`);
                let id = nextCallbackID++;
                onResolveCallbacks[id] = { name, callback: callback2, note: registeredNote };
                plugin.onResolve.push({ id, filter: filter2.source, namespace: namespace || "" });
              },
              onLoad(options2, callback2) {
                let registeredText = `This error came from the "onLoad" callback registered here`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
                let keys2 = {};
                let filter2 = getFlag(options2, keys2, "filter", mustBeRegExp);
                let namespace = getFlag(options2, keys2, "namespace", mustBeString);
                checkForInvalidFlags(options2, keys2, `in onLoad() call for plugin ${JSON.stringify(name)}`);
                if (filter2 == null)
                  throw new Error(`onLoad() call is missing a filter`);
                let id = nextCallbackID++;
                onLoadCallbacks[id] = { name, callback: callback2, note: registeredNote };
                plugin.onLoad.push({ id, filter: filter2.source, namespace: namespace || "" });
              }
            });
            if (promise2)
              await promise2;
            requestPlugins.push(plugin);
          } catch (e2) {
            return { ok: false, error: e2, pluginName: name };
          }
        }
        const callback = async (request) => {
          switch (request.command) {
            case "start": {
              let response = { errors: [], warnings: [] };
              await Promise.all(onStartCallbacks.map(async ({ name, callback: callback2, note }) => {
                try {
                  let result2 = await callback2();
                  if (result2 != null) {
                    if (typeof result2 !== "object")
                      throw new Error(`Expected onStart() callback in plugin ${JSON.stringify(name)} to return an object`);
                    let keys = {};
                    let errors = getFlag(result2, keys, "errors", mustBeArray);
                    let warnings2 = getFlag(result2, keys, "warnings", mustBeArray);
                    checkForInvalidFlags(result2, keys, `from onStart() callback in plugin ${JSON.stringify(name)}`);
                    if (errors != null)
                      response.errors.push(...sanitizeMessages(errors, "errors", stash, name));
                    if (warnings2 != null)
                      response.warnings.push(...sanitizeMessages(warnings2, "warnings", stash, name));
                  }
                } catch (e2) {
                  response.errors.push(extractErrorMessageV8(e2, streamIn, stash, note && note(), name));
                }
              }));
              return response;
            }
            case "resolve": {
              let response = {}, name = "", callback2, note;
              for (let id of request.ids) {
                try {
                  ({ name, callback: callback2, note } = onResolveCallbacks[id]);
                  let result2 = await callback2({
                    path: request.path,
                    importer: request.importer,
                    namespace: request.namespace,
                    resolveDir: request.resolveDir,
                    kind: request.kind,
                    pluginData: stash.load(request.pluginData)
                  });
                  if (result2 != null) {
                    if (typeof result2 !== "object")
                      throw new Error(`Expected onResolve() callback in plugin ${JSON.stringify(name)} to return an object`);
                    let keys = {};
                    let pluginName = getFlag(result2, keys, "pluginName", mustBeString);
                    let path3 = getFlag(result2, keys, "path", mustBeString);
                    let namespace = getFlag(result2, keys, "namespace", mustBeString);
                    let external = getFlag(result2, keys, "external", mustBeBoolean);
                    let sideEffects = getFlag(result2, keys, "sideEffects", mustBeBoolean);
                    let pluginData = getFlag(result2, keys, "pluginData", canBeAnything);
                    let errors = getFlag(result2, keys, "errors", mustBeArray);
                    let warnings2 = getFlag(result2, keys, "warnings", mustBeArray);
                    let watchFiles = getFlag(result2, keys, "watchFiles", mustBeArray);
                    let watchDirs = getFlag(result2, keys, "watchDirs", mustBeArray);
                    checkForInvalidFlags(result2, keys, `from onResolve() callback in plugin ${JSON.stringify(name)}`);
                    response.id = id;
                    if (pluginName != null)
                      response.pluginName = pluginName;
                    if (path3 != null)
                      response.path = path3;
                    if (namespace != null)
                      response.namespace = namespace;
                    if (external != null)
                      response.external = external;
                    if (sideEffects != null)
                      response.sideEffects = sideEffects;
                    if (pluginData != null)
                      response.pluginData = stash.store(pluginData);
                    if (errors != null)
                      response.errors = sanitizeMessages(errors, "errors", stash, name);
                    if (warnings2 != null)
                      response.warnings = sanitizeMessages(warnings2, "warnings", stash, name);
                    if (watchFiles != null)
                      response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
                    if (watchDirs != null)
                      response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
                    break;
                  }
                } catch (e2) {
                  return { id, errors: [extractErrorMessageV8(e2, streamIn, stash, note && note(), name)] };
                }
              }
              return response;
            }
            case "load": {
              let response = {}, name = "", callback2, note;
              for (let id of request.ids) {
                try {
                  ({ name, callback: callback2, note } = onLoadCallbacks[id]);
                  let result2 = await callback2({
                    path: request.path,
                    namespace: request.namespace,
                    pluginData: stash.load(request.pluginData)
                  });
                  if (result2 != null) {
                    if (typeof result2 !== "object")
                      throw new Error(`Expected onLoad() callback in plugin ${JSON.stringify(name)} to return an object`);
                    let keys = {};
                    let pluginName = getFlag(result2, keys, "pluginName", mustBeString);
                    let contents = getFlag(result2, keys, "contents", mustBeStringOrUint8Array);
                    let resolveDir = getFlag(result2, keys, "resolveDir", mustBeString);
                    let pluginData = getFlag(result2, keys, "pluginData", canBeAnything);
                    let loader = getFlag(result2, keys, "loader", mustBeString);
                    let errors = getFlag(result2, keys, "errors", mustBeArray);
                    let warnings2 = getFlag(result2, keys, "warnings", mustBeArray);
                    let watchFiles = getFlag(result2, keys, "watchFiles", mustBeArray);
                    let watchDirs = getFlag(result2, keys, "watchDirs", mustBeArray);
                    checkForInvalidFlags(result2, keys, `from onLoad() callback in plugin ${JSON.stringify(name)}`);
                    response.id = id;
                    if (pluginName != null)
                      response.pluginName = pluginName;
                    if (contents instanceof Uint8Array)
                      response.contents = contents;
                    else if (contents != null)
                      response.contents = encodeUTF8(contents);
                    if (resolveDir != null)
                      response.resolveDir = resolveDir;
                    if (pluginData != null)
                      response.pluginData = stash.store(pluginData);
                    if (loader != null)
                      response.loader = loader;
                    if (errors != null)
                      response.errors = sanitizeMessages(errors, "errors", stash, name);
                    if (warnings2 != null)
                      response.warnings = sanitizeMessages(warnings2, "warnings", stash, name);
                    if (watchFiles != null)
                      response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
                    if (watchDirs != null)
                      response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
                    break;
                  }
                } catch (e2) {
                  return { id, errors: [extractErrorMessageV8(e2, streamIn, stash, note && note(), name)] };
                }
              }
              return response;
            }
            default:
              throw new Error(`Invalid command: ` + request.command);
          }
        };
        let runOnEndCallbacks = (result2, logPluginError, done) => done();
        if (onEndCallbacks.length > 0) {
          runOnEndCallbacks = (result2, logPluginError, done) => {
            (async () => {
              for (const { name, callback: callback2, note } of onEndCallbacks) {
                try {
                  await callback2(result2);
                } catch (e2) {
                  result2.errors.push(await new Promise((resolve2) => logPluginError(e2, name, note && note(), resolve2)));
                }
              }
            })().then(done);
          };
        }
        let refCount = 0;
        return {
          ok: true,
          requestPlugins,
          runOnEndCallbacks,
          pluginRefs: {
            ref() {
              if (++refCount === 1)
                pluginCallbacks.set(buildKey, callback);
            },
            unref() {
              if (--refCount === 0)
                pluginCallbacks.delete(buildKey);
            }
          }
        };
      };
      let buildServeData = (refs, options2, request) => {
        let keys = {};
        let port = getFlag(options2, keys, "port", mustBeInteger);
        let host = getFlag(options2, keys, "host", mustBeString);
        let servedir = getFlag(options2, keys, "servedir", mustBeString);
        let onRequest = getFlag(options2, keys, "onRequest", mustBeFunction);
        let serveID = nextServeID++;
        let onWait;
        let wait = new Promise((resolve2, reject) => {
          onWait = (error2) => {
            serveCallbacks.delete(serveID);
            if (error2 !== null)
              reject(new Error(error2));
            else
              resolve2();
          };
        });
        request.serve = { serveID };
        checkForInvalidFlags(options2, keys, `in serve() call`);
        if (port !== void 0)
          request.serve.port = port;
        if (host !== void 0)
          request.serve.host = host;
        if (servedir !== void 0)
          request.serve.servedir = servedir;
        serveCallbacks.set(serveID, {
          onRequest,
          onWait
        });
        return {
          wait,
          stop() {
            sendRequest(refs, { command: "serve-stop", serveID }, () => {
            });
          }
        };
      };
      const buildLogLevelDefault = "warning";
      const transformLogLevelDefault = "silent";
      let buildOrServe = (args) => {
        let key = nextBuildKey++;
        const details = createObjectStash();
        let plugins2;
        let { refs, options: options2, isTTY: isTTY2, callback } = args;
        if (typeof options2 === "object") {
          let value = options2.plugins;
          if (value !== void 0) {
            if (!Array.isArray(value))
              throw new Error(`"plugins" must be an array`);
            plugins2 = value;
          }
        }
        let logPluginError = (e2, pluginName, note, done) => {
          let flags = [];
          try {
            pushLogFlags(flags, options2, {}, isTTY2, buildLogLevelDefault);
          } catch {
          }
          const message = extractErrorMessageV8(e2, streamIn, details, note, pluginName);
          sendRequest(refs, { command: "error", flags, error: message }, () => {
            message.detail = details.load(message.detail);
            done(message);
          });
        };
        let handleError = (e2, pluginName) => {
          logPluginError(e2, pluginName, void 0, (error2) => {
            callback(failureErrorWithLog("Build failed", [error2], []), null);
          });
        };
        if (plugins2 && plugins2.length > 0) {
          if (streamIn.isSync)
            return handleError(new Error("Cannot use plugins in synchronous API calls"), "");
          handlePlugins(options2, plugins2, key, details).then((result2) => {
            if (!result2.ok) {
              handleError(result2.error, result2.pluginName);
            } else {
              try {
                buildOrServeContinue(__spreadProps3(__spreadValues3({}, args), {
                  key,
                  details,
                  logPluginError,
                  requestPlugins: result2.requestPlugins,
                  runOnEndCallbacks: result2.runOnEndCallbacks,
                  pluginRefs: result2.pluginRefs
                }));
              } catch (e2) {
                handleError(e2, "");
              }
            }
          }, (e2) => handleError(e2, ""));
        } else {
          try {
            buildOrServeContinue(__spreadProps3(__spreadValues3({}, args), {
              key,
              details,
              logPluginError,
              requestPlugins: null,
              runOnEndCallbacks: (result2, logPluginError2, done) => done(),
              pluginRefs: null
            }));
          } catch (e2) {
            handleError(e2, "");
          }
        }
      };
      let buildOrServeContinue = ({
        callName,
        refs: callerRefs,
        serveOptions,
        options: options2,
        isTTY: isTTY2,
        defaultWD: defaultWD2,
        callback,
        key,
        details,
        logPluginError,
        requestPlugins,
        runOnEndCallbacks,
        pluginRefs
      }) => {
        const refs = {
          ref() {
            if (pluginRefs)
              pluginRefs.ref();
            if (callerRefs)
              callerRefs.ref();
          },
          unref() {
            if (pluginRefs)
              pluginRefs.unref();
            if (callerRefs)
              callerRefs.unref();
          }
        };
        let writeDefault = !streamIn.isBrowser;
        let {
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir,
          incremental,
          nodePaths,
          watch: watch2
        } = flagsForBuildOptions(callName, options2, isTTY2, buildLogLevelDefault, writeDefault);
        let request = {
          command: "build",
          key,
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir: absWorkingDir || defaultWD2,
          incremental,
          nodePaths
        };
        if (requestPlugins)
          request.plugins = requestPlugins;
        let serve2 = serveOptions && buildServeData(refs, serveOptions, request);
        let rebuild;
        let stop;
        let copyResponseToResult = (response, result2) => {
          if (response.outputFiles)
            result2.outputFiles = response.outputFiles.map(convertOutputFiles);
          if (response.metafile)
            result2.metafile = JSON.parse(response.metafile);
          if (response.writeToStdout !== void 0)
            console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
        };
        let buildResponseToResult = (response, callback2) => {
          let result2 = {
            errors: replaceDetailsInMessages(response.errors, details),
            warnings: replaceDetailsInMessages(response.warnings, details)
          };
          copyResponseToResult(response, result2);
          runOnEndCallbacks(result2, logPluginError, () => {
            if (result2.errors.length > 0) {
              return callback2(failureErrorWithLog("Build failed", result2.errors, result2.warnings), null);
            }
            if (response.rebuildID !== void 0) {
              if (!rebuild) {
                let isDisposed = false;
                rebuild = () => new Promise((resolve2, reject) => {
                  if (isDisposed || isClosed)
                    throw new Error("Cannot rebuild");
                  sendRequest(refs, { command: "rebuild", rebuildID: response.rebuildID }, (error2, response2) => {
                    if (error2) {
                      const message = { pluginName: "", text: error2, location: null, notes: [], detail: void 0 };
                      return callback2(failureErrorWithLog("Build failed", [message], []), null);
                    }
                    buildResponseToResult(response2, (error3, result3) => {
                      if (error3)
                        reject(error3);
                      else
                        resolve2(result3);
                    });
                  });
                });
                refs.ref();
                rebuild.dispose = () => {
                  if (isDisposed)
                    return;
                  isDisposed = true;
                  sendRequest(refs, { command: "rebuild-dispose", rebuildID: response.rebuildID }, () => {
                  });
                  refs.unref();
                };
              }
              result2.rebuild = rebuild;
            }
            if (response.watchID !== void 0) {
              if (!stop) {
                let isStopped = false;
                refs.ref();
                stop = () => {
                  if (isStopped)
                    return;
                  isStopped = true;
                  watchCallbacks.delete(response.watchID);
                  sendRequest(refs, { command: "watch-stop", watchID: response.watchID }, () => {
                  });
                  refs.unref();
                };
                if (watch2) {
                  watchCallbacks.set(response.watchID, (serviceStopError, watchResponse) => {
                    if (serviceStopError) {
                      if (watch2.onRebuild)
                        watch2.onRebuild(serviceStopError, null);
                      return;
                    }
                    let result22 = {
                      errors: replaceDetailsInMessages(watchResponse.errors, details),
                      warnings: replaceDetailsInMessages(watchResponse.warnings, details)
                    };
                    copyResponseToResult(watchResponse, result22);
                    runOnEndCallbacks(result22, logPluginError, () => {
                      if (result22.errors.length > 0) {
                        if (watch2.onRebuild)
                          watch2.onRebuild(failureErrorWithLog("Build failed", result22.errors, result22.warnings), null);
                        return;
                      }
                      if (watchResponse.rebuildID !== void 0)
                        result22.rebuild = rebuild;
                      result22.stop = stop;
                      if (watch2.onRebuild)
                        watch2.onRebuild(null, result22);
                    });
                  });
                }
              }
              result2.stop = stop;
            }
            callback2(null, result2);
          });
        };
        if (write && streamIn.isBrowser)
          throw new Error(`Cannot enable "write" in the browser`);
        if (incremental && streamIn.isSync)
          throw new Error(`Cannot use "incremental" with a synchronous build`);
        if (watch2 && streamIn.isSync)
          throw new Error(`Cannot use "watch" with a synchronous build`);
        sendRequest(refs, request, (error2, response) => {
          if (error2)
            return callback(new Error(error2), null);
          if (serve2) {
            let serveResponse = response;
            let isStopped = false;
            refs.ref();
            let result2 = {
              port: serveResponse.port,
              host: serveResponse.host,
              wait: serve2.wait,
              stop() {
                if (isStopped)
                  return;
                isStopped = true;
                serve2.stop();
                refs.unref();
              }
            };
            refs.ref();
            serve2.wait.then(refs.unref, refs.unref);
            return callback(null, result2);
          }
          return buildResponseToResult(response, callback);
        });
      };
      let transform22 = ({ callName, refs, input, options: options2, isTTY: isTTY2, fs: fs32, callback }) => {
        const details = createObjectStash();
        let start = (inputPath) => {
          try {
            if (typeof input !== "string")
              throw new Error('The input to "transform" must be a string');
            let flags = flagsForTransformOptions(callName, options2, isTTY2, transformLogLevelDefault);
            let request = {
              command: "transform",
              flags,
              inputFS: inputPath !== null,
              input: inputPath !== null ? inputPath : input
            };
            sendRequest(refs, request, (error2, response) => {
              if (error2)
                return callback(new Error(error2), null);
              let errors = replaceDetailsInMessages(response.errors, details);
              let warnings2 = replaceDetailsInMessages(response.warnings, details);
              let outstanding = 1;
              let next = () => --outstanding === 0 && callback(null, { warnings: warnings2, code: response.code, map: response.map });
              if (errors.length > 0)
                return callback(failureErrorWithLog("Transform failed", errors, warnings2), null);
              if (response.codeFS) {
                outstanding++;
                fs32.readFile(response.code, (err, contents) => {
                  if (err !== null) {
                    callback(err, null);
                  } else {
                    response.code = contents;
                    next();
                  }
                });
              }
              if (response.mapFS) {
                outstanding++;
                fs32.readFile(response.map, (err, contents) => {
                  if (err !== null) {
                    callback(err, null);
                  } else {
                    response.map = contents;
                    next();
                  }
                });
              }
              next();
            });
          } catch (e2) {
            let flags = [];
            try {
              pushLogFlags(flags, options2, {}, isTTY2, transformLogLevelDefault);
            } catch {
            }
            const error2 = extractErrorMessageV8(e2, streamIn, details, void 0, "");
            sendRequest(refs, { command: "error", flags, error: error2 }, () => {
              error2.detail = details.load(error2.detail);
              callback(failureErrorWithLog("Transform failed", [error2], []), null);
            });
          }
        };
        if (typeof input === "string" && input.length > 1024 * 1024) {
          let next = start;
          start = () => fs32.writeFile(input, next);
        }
        start(null);
      };
      let formatMessages2 = ({ callName, refs, messages, options: options2, callback }) => {
        let result2 = sanitizeMessages(messages, "messages", null, "");
        if (!options2)
          throw new Error(`Missing second argument in ${callName}() call`);
        let keys = {};
        let kind = getFlag(options2, keys, "kind", mustBeString);
        let color = getFlag(options2, keys, "color", mustBeBoolean);
        let terminalWidth = getFlag(options2, keys, "terminalWidth", mustBeInteger);
        checkForInvalidFlags(options2, keys, `in ${callName}() call`);
        if (kind === void 0)
          throw new Error(`Missing "kind" in ${callName}() call`);
        if (kind !== "error" && kind !== "warning")
          throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);
        let request = {
          command: "format-msgs",
          messages: result2,
          isWarning: kind === "warning"
        };
        if (color !== void 0)
          request.color = color;
        if (terminalWidth !== void 0)
          request.terminalWidth = terminalWidth;
        sendRequest(refs, request, (error2, response) => {
          if (error2)
            return callback(new Error(error2), null);
          callback(null, response.messages);
        });
      };
      let analyzeMetafile2 = ({ callName, refs, metafile, options: options2, callback }) => {
        if (options2 === void 0)
          options2 = {};
        let keys = {};
        let color = getFlag(options2, keys, "color", mustBeBoolean);
        let verbose = getFlag(options2, keys, "verbose", mustBeBoolean);
        checkForInvalidFlags(options2, keys, `in ${callName}() call`);
        let request = {
          command: "analyze-metafile",
          metafile
        };
        if (color !== void 0)
          request.color = color;
        if (verbose !== void 0)
          request.verbose = verbose;
        sendRequest(refs, request, (error2, response) => {
          if (error2)
            return callback(new Error(error2), null);
          callback(null, response.result);
        });
      };
      return {
        readFromStdout,
        afterClose,
        service: {
          buildOrServe,
          transform: transform22,
          formatMessages: formatMessages2,
          analyzeMetafile: analyzeMetafile2
        }
      };
    }
    function createObjectStash() {
      const map2 = new Map();
      let nextID = 0;
      return {
        load(id) {
          return map2.get(id);
        },
        store(value) {
          if (value === void 0)
            return -1;
          const id = nextID++;
          map2.set(id, value);
          return id;
        }
      };
    }
    function extractCallerV8(e2, streamIn, ident) {
      let note;
      let tried = false;
      return () => {
        if (tried)
          return note;
        tried = true;
        try {
          let lines = (e2.stack + "").split("\n");
          lines.splice(1, 1);
          let location = parseStackLinesV8(streamIn, lines, ident);
          if (location) {
            note = { text: e2.message, location };
            return note;
          }
        } catch {
        }
      };
    }
    function extractErrorMessageV8(e2, streamIn, stash, note, pluginName) {
      let text = "Internal error";
      let location = null;
      try {
        text = (e2 && e2.message || e2) + "";
      } catch {
      }
      try {
        location = parseStackLinesV8(streamIn, (e2.stack + "").split("\n"), "");
      } catch {
      }
      return { pluginName, text, location, notes: note ? [note] : [], detail: stash ? stash.store(e2) : -1 };
    }
    function parseStackLinesV8(streamIn, lines, ident) {
      let at2 = "    at ";
      if (streamIn.readFileSync && !lines[0].startsWith(at2) && lines[1].startsWith(at2)) {
        for (let i2 = 1; i2 < lines.length; i2++) {
          let line = lines[i2];
          if (!line.startsWith(at2))
            continue;
          line = line.slice(at2.length);
          while (true) {
            let match2 = /^(?:new |async )?\S+ \((.*)\)$/.exec(line);
            if (match2) {
              line = match2[1];
              continue;
            }
            match2 = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line);
            if (match2) {
              line = match2[1];
              continue;
            }
            match2 = /^(\S+):(\d+):(\d+)$/.exec(line);
            if (match2) {
              let contents;
              try {
                contents = streamIn.readFileSync(match2[1], "utf8");
              } catch {
                break;
              }
              let lineText = contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match2[2] - 1] || "";
              let column = +match2[3] - 1;
              let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;
              return {
                file: match2[1],
                namespace: "file",
                line: +match2[2],
                column: encodeUTF8(lineText.slice(0, column)).length,
                length: encodeUTF8(lineText.slice(column, column + length)).length,
                lineText: lineText + "\n" + lines.slice(1).join("\n"),
                suggestion: ""
              };
            }
            break;
          }
        }
      }
      return null;
    }
    function failureErrorWithLog(text, errors, warnings2) {
      let limit = 5;
      let summary = errors.length < 1 ? "" : ` with ${errors.length} error${errors.length < 2 ? "" : "s"}:` + errors.slice(0, limit + 1).map((e2, i2) => {
        if (i2 === limit)
          return "\n...";
        if (!e2.location)
          return `
error: ${e2.text}`;
        let { file, line, column } = e2.location;
        let pluginText = e2.pluginName ? `[plugin: ${e2.pluginName}] ` : "";
        return `
${file}:${line}:${column}: error: ${pluginText}${e2.text}`;
      }).join("");
      let error2 = new Error(`${text}${summary}`);
      error2.errors = errors;
      error2.warnings = warnings2;
      return error2;
    }
    function replaceDetailsInMessages(messages, stash) {
      for (const message of messages) {
        message.detail = stash.load(message.detail);
      }
      return messages;
    }
    function sanitizeLocation(location, where) {
      if (location == null)
        return null;
      let keys = {};
      let file = getFlag(location, keys, "file", mustBeString);
      let namespace = getFlag(location, keys, "namespace", mustBeString);
      let line = getFlag(location, keys, "line", mustBeInteger);
      let column = getFlag(location, keys, "column", mustBeInteger);
      let length = getFlag(location, keys, "length", mustBeInteger);
      let lineText = getFlag(location, keys, "lineText", mustBeString);
      let suggestion = getFlag(location, keys, "suggestion", mustBeString);
      checkForInvalidFlags(location, keys, where);
      return {
        file: file || "",
        namespace: namespace || "",
        line: line || 0,
        column: column || 0,
        length: length || 0,
        lineText: lineText || "",
        suggestion: suggestion || ""
      };
    }
    function sanitizeMessages(messages, property, stash, fallbackPluginName) {
      let messagesClone = [];
      let index2 = 0;
      for (const message of messages) {
        let keys = {};
        let pluginName = getFlag(message, keys, "pluginName", mustBeString);
        let text = getFlag(message, keys, "text", mustBeString);
        let location = getFlag(message, keys, "location", mustBeObjectOrNull);
        let notes = getFlag(message, keys, "notes", mustBeArray);
        let detail = getFlag(message, keys, "detail", canBeAnything);
        let where = `in element ${index2} of "${property}"`;
        checkForInvalidFlags(message, keys, where);
        let notesClone = [];
        if (notes) {
          for (const note of notes) {
            let noteKeys = {};
            let noteText = getFlag(note, noteKeys, "text", mustBeString);
            let noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
            checkForInvalidFlags(note, noteKeys, where);
            notesClone.push({
              text: noteText || "",
              location: sanitizeLocation(noteLocation, where)
            });
          }
        }
        messagesClone.push({
          pluginName: pluginName || fallbackPluginName,
          text: text || "",
          location: sanitizeLocation(location, where),
          notes: notesClone,
          detail: stash ? stash.store(detail) : -1
        });
        index2++;
      }
      return messagesClone;
    }
    function sanitizeStringArray(values, property) {
      const result2 = [];
      for (const value of values) {
        if (typeof value !== "string")
          throw new Error(`${JSON.stringify(property)} must be an array of strings`);
        result2.push(value);
      }
      return result2;
    }
    function convertOutputFiles({ path: path3, contents }) {
      let text = null;
      return {
        path: path3,
        contents,
        get text() {
          if (text === null)
            text = decodeUTF8(contents);
          return text;
        }
      };
    }
    var fs3 = (init_fs(), fs_exports);
    var os3 = (init_os(), os_exports);
    var path2 = (init_path(), path_exports);
    var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;
    var knownWindowsPackages = {
      "win32 arm64 LE": "esbuild-windows-arm64",
      "win32 ia32 LE": "esbuild-windows-32",
      "win32 x64 LE": "esbuild-windows-64"
    };
    var knownUnixlikePackages = {
      "android arm64 LE": "esbuild-android-arm64",
      "darwin arm64 LE": "esbuild-darwin-arm64",
      "darwin x64 LE": "esbuild-darwin-64",
      "freebsd arm64 LE": "esbuild-freebsd-arm64",
      "freebsd x64 LE": "esbuild-freebsd-64",
      "linux arm LE": "esbuild-linux-arm",
      "linux arm64 LE": "esbuild-linux-arm64",
      "linux ia32 LE": "esbuild-linux-32",
      "linux mips64el LE": "esbuild-linux-mips64le",
      "linux ppc64 LE": "esbuild-linux-ppc64le",
      "linux x64 LE": "esbuild-linux-64",
      "netbsd x64 LE": "esbuild-netbsd-64",
      "openbsd x64 LE": "esbuild-openbsd-64",
      "sunos x64 LE": "esbuild-sunos-64"
    };
    function pkgAndSubpathForCurrentPlatform() {
      let pkg;
      let subpath;
      let platformKey = `${process.platform} ${os3.arch()} ${os3.endianness()}`;
      if (platformKey in knownWindowsPackages) {
        pkg = knownWindowsPackages[platformKey];
        subpath = "esbuild.exe";
      } else if (platformKey in knownUnixlikePackages) {
        pkg = knownUnixlikePackages[platformKey];
        subpath = "bin/esbuild";
      } else {
        throw new Error(`Unsupported platform: ${platformKey}`);
      }
      return { pkg, subpath };
    }
    function downloadedBinPath(pkg, subpath) {
      const esbuildLibDir = path2.dirname(__require.resolve("esbuild"));
      return path2.join(esbuildLibDir, `downloaded-${pkg}-${path2.basename(subpath)}`);
    }
    function generateBinPath() {
      if (ESBUILD_BINARY_PATH) {
        return ESBUILD_BINARY_PATH;
      }
      const { pkg, subpath } = pkgAndSubpathForCurrentPlatform();
      let binPath;
      try {
        binPath = __require.resolve(`${pkg}/${subpath}`);
      } catch (e2) {
        binPath = downloadedBinPath(pkg, subpath);
        if (!fs3.existsSync(binPath)) {
          try {
            __require.resolve(pkg);
          } catch {
            throw new Error(`The package "${pkg}" could not be found, and is needed by esbuild.

If you are installing esbuild with npm, make sure that you don't specify the
"--no-optional" flag. The "optionalDependencies" package.json feature is used
by esbuild to install the correct binary executable for your current platform.`);
          }
          throw e2;
        }
      }
      let isYarnPnP = false;
      try {
        __require("pnpapi");
        isYarnPnP = true;
      } catch (e2) {
      }
      if (isYarnPnP) {
        const esbuildLibDir = path2.dirname(__require.resolve("esbuild"));
        const binTargetPath = path2.join(esbuildLibDir, `pnpapi-${pkg}-${path2.basename(subpath)}`);
        if (!fs3.existsSync(binTargetPath)) {
          fs3.copyFileSync(binPath, binTargetPath);
          fs3.chmodSync(binTargetPath, 493);
        }
        return binTargetPath;
      }
      return binPath;
    }
    var child_process = (init_child_process(), child_process_exports);
    var crypto2 = (init_crypto(), crypto_exports);
    var path22 = (init_path(), path_exports);
    var fs22 = (init_fs(), fs_exports);
    var os22 = (init_os(), os_exports);
    var tty2 = (init_tty(), tty_exports);
    var worker_threads;
    if (process.env.ESBUILD_WORKER_THREADS !== "0") {
      try {
        worker_threads = (init_worker_threads(), worker_threads_exports);
      } catch {
      }
      let [major, minor] = process.versions.node.split(".");
      if (+major < 12 || +major === 12 && +minor < 17 || +major === 13 && +minor < 13) {
        worker_threads = void 0;
      }
    }
    var _a2;
    var isInternalWorkerThread = ((_a2 = worker_threads == null ? void 0 : worker_threads.workerData) == null ? void 0 : _a2.esbuildVersion) === "0.13.15";
    var esbuildCommandAndArgs = () => {
      if ((!ESBUILD_BINARY_PATH || false) && (path22.basename(__filename) !== "main.js" || path22.basename(__dirname) !== "lib")) {
        throw new Error(`The esbuild JavaScript API cannot be bundled. Please mark the "esbuild" package as external so it's not included in the bundle.

More information: The file containing the code for esbuild's JavaScript API (${__filename}) does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found.`);
      }
      if (false) {
        return ["node", [path22.join(__dirname, "..", "bin", "esbuild")]];
      }
      return [generateBinPath(), []];
    };
    var isTTY = () => tty2.isatty(2);
    var fsSync = {
      readFile(tempFile, callback) {
        try {
          let contents = fs22.readFileSync(tempFile, "utf8");
          try {
            fs22.unlinkSync(tempFile);
          } catch {
          }
          callback(null, contents);
        } catch (err) {
          callback(err, null);
        }
      },
      writeFile(contents, callback) {
        try {
          let tempFile = randomFileName();
          fs22.writeFileSync(tempFile, contents);
          callback(tempFile);
        } catch {
          callback(null);
        }
      }
    };
    var fsAsync = {
      readFile(tempFile, callback) {
        try {
          fs22.readFile(tempFile, "utf8", (err, contents) => {
            try {
              fs22.unlink(tempFile, () => callback(err, contents));
            } catch {
              callback(err, contents);
            }
          });
        } catch (err) {
          callback(err, null);
        }
      },
      writeFile(contents, callback) {
        try {
          let tempFile = randomFileName();
          fs22.writeFile(tempFile, contents, (err) => err !== null ? callback(null) : callback(tempFile));
        } catch {
          callback(null);
        }
      }
    };
    var version2 = "0.13.15";
    var build2 = (options2) => ensureServiceIsRunning().build(options2);
    var serve = (serveOptions, buildOptions) => ensureServiceIsRunning().serve(serveOptions, buildOptions);
    var transform2 = (input, options2) => ensureServiceIsRunning().transform(input, options2);
    var formatMessages = (messages, options2) => ensureServiceIsRunning().formatMessages(messages, options2);
    var analyzeMetafile = (messages, options2) => ensureServiceIsRunning().analyzeMetafile(messages, options2);
    var buildSync = (options2) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.buildSync(options2);
      }
      let result2;
      runServiceSync((service) => service.buildOrServe({
        callName: "buildSync",
        refs: null,
        serveOptions: null,
        options: options2,
        isTTY: isTTY(),
        defaultWD,
        callback: (err, res) => {
          if (err)
            throw err;
          result2 = res;
        }
      }));
      return result2;
    };
    var transformSync = (input, options2) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.transformSync(input, options2);
      }
      let result2;
      runServiceSync((service) => service.transform({
        callName: "transformSync",
        refs: null,
        input,
        options: options2 || {},
        isTTY: isTTY(),
        fs: fsSync,
        callback: (err, res) => {
          if (err)
            throw err;
          result2 = res;
        }
      }));
      return result2;
    };
    var formatMessagesSync = (messages, options2) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.formatMessagesSync(messages, options2);
      }
      let result2;
      runServiceSync((service) => service.formatMessages({
        callName: "formatMessagesSync",
        refs: null,
        messages,
        options: options2,
        callback: (err, res) => {
          if (err)
            throw err;
          result2 = res;
        }
      }));
      return result2;
    };
    var analyzeMetafileSync = (metafile, options2) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.analyzeMetafileSync(metafile, options2);
      }
      let result2;
      runServiceSync((service) => service.analyzeMetafile({
        callName: "analyzeMetafileSync",
        refs: null,
        metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
        options: options2,
        callback: (err, res) => {
          if (err)
            throw err;
          result2 = res;
        }
      }));
      return result2;
    };
    var initializeWasCalled = false;
    var initialize = (options2) => {
      options2 = validateInitializeOptions(options2 || {});
      if (options2.wasmURL)
        throw new Error(`The "wasmURL" option only works in the browser`);
      if (options2.worker)
        throw new Error(`The "worker" option only works in the browser`);
      if (initializeWasCalled)
        throw new Error('Cannot call "initialize" more than once');
      ensureServiceIsRunning();
      initializeWasCalled = true;
      return Promise.resolve();
    };
    var defaultWD = process.cwd();
    var longLivedService;
    var ensureServiceIsRunning = () => {
      if (longLivedService)
        return longLivedService;
      let [command2, args] = esbuildCommandAndArgs();
      let child = child_process.spawn(command2, args.concat(`--service=${"0.13.15"}`, "--ping"), {
        windowsHide: true,
        stdio: ["pipe", "pipe", "inherit"],
        cwd: defaultWD
      });
      let { readFromStdout, afterClose, service } = createChannel({
        writeToStdin(bytes2) {
          child.stdin.write(bytes2);
        },
        readFileSync: fs22.readFileSync,
        isSync: false,
        isBrowser: false
      });
      const stdin = child.stdin;
      const stdout = child.stdout;
      stdout.on("data", readFromStdout);
      stdout.on("end", afterClose);
      let refCount = 0;
      child.unref();
      if (stdin.unref) {
        stdin.unref();
      }
      if (stdout.unref) {
        stdout.unref();
      }
      const refs = {
        ref() {
          if (++refCount === 1)
            child.ref();
        },
        unref() {
          if (--refCount === 0)
            child.unref();
        }
      };
      longLivedService = {
        build: (options2) => {
          return new Promise((resolve2, reject) => {
            service.buildOrServe({
              callName: "build",
              refs,
              serveOptions: null,
              options: options2,
              isTTY: isTTY(),
              defaultWD,
              callback: (err, res) => err ? reject(err) : resolve2(res)
            });
          });
        },
        serve: (serveOptions, buildOptions) => {
          if (serveOptions === null || typeof serveOptions !== "object")
            throw new Error("The first argument must be an object");
          return new Promise((resolve2, reject) => service.buildOrServe({
            callName: "serve",
            refs,
            serveOptions,
            options: buildOptions,
            isTTY: isTTY(),
            defaultWD,
            callback: (err, res) => err ? reject(err) : resolve2(res)
          }));
        },
        transform: (input, options2) => {
          return new Promise((resolve2, reject) => service.transform({
            callName: "transform",
            refs,
            input,
            options: options2 || {},
            isTTY: isTTY(),
            fs: fsAsync,
            callback: (err, res) => err ? reject(err) : resolve2(res)
          }));
        },
        formatMessages: (messages, options2) => {
          return new Promise((resolve2, reject) => service.formatMessages({
            callName: "formatMessages",
            refs,
            messages,
            options: options2,
            callback: (err, res) => err ? reject(err) : resolve2(res)
          }));
        },
        analyzeMetafile: (metafile, options2) => {
          return new Promise((resolve2, reject) => service.analyzeMetafile({
            callName: "analyzeMetafile",
            refs,
            metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
            options: options2,
            callback: (err, res) => err ? reject(err) : resolve2(res)
          }));
        }
      };
      return longLivedService;
    };
    var runServiceSync = (callback) => {
      let [command2, args] = esbuildCommandAndArgs();
      let stdin = new Uint8Array();
      let { readFromStdout, afterClose, service } = createChannel({
        writeToStdin(bytes2) {
          if (stdin.length !== 0)
            throw new Error("Must run at most one command");
          stdin = bytes2;
        },
        isSync: true,
        isBrowser: false
      });
      callback(service);
      let stdout = child_process.execFileSync(command2, args.concat(`--service=${"0.13.15"}`), {
        cwd: defaultWD,
        windowsHide: true,
        input: stdin,
        maxBuffer: +process.env.ESBUILD_MAX_BUFFER || 16 * 1024 * 1024
      });
      readFromStdout(stdout);
      afterClose();
    };
    var randomFileName = () => {
      return path22.join(os22.tmpdir(), `esbuild-${crypto2.randomBytes(32).toString("hex")}`);
    };
    var workerThreadService = null;
    var startWorkerThreadService = (worker_threads2) => {
      let { port1: mainPort, port2: workerPort } = new worker_threads2.MessageChannel();
      let worker = new worker_threads2.Worker(__filename, {
        workerData: { workerPort, defaultWD, esbuildVersion: "0.13.15" },
        transferList: [workerPort],
        execArgv: []
      });
      let nextID = 0;
      let wasStopped = false;
      let fakeBuildError = (text) => {
        let error2 = new Error(`Build failed with 1 error:
error: ${text}`);
        let errors = [{ pluginName: "", text, location: null, notes: [], detail: void 0 }];
        error2.errors = errors;
        error2.warnings = [];
        return error2;
      };
      let validateBuildSyncOptions = (options2) => {
        if (!options2)
          return;
        let plugins2 = options2.plugins;
        let incremental = options2.incremental;
        let watch2 = options2.watch;
        if (plugins2 && plugins2.length > 0)
          throw fakeBuildError(`Cannot use plugins in synchronous API calls`);
        if (incremental)
          throw fakeBuildError(`Cannot use "incremental" with a synchronous build`);
        if (watch2)
          throw fakeBuildError(`Cannot use "watch" with a synchronous build`);
      };
      let applyProperties = (object, properties) => {
        for (let key in properties) {
          object[key] = properties[key];
        }
      };
      let runCallSync = (command2, args) => {
        if (wasStopped)
          throw new Error("The service was stopped");
        let id = nextID++;
        let sharedBuffer = new SharedArrayBuffer(8);
        let sharedBufferView = new Int32Array(sharedBuffer);
        let msg = { sharedBuffer, id, command: command2, args };
        worker.postMessage(msg);
        let status2 = Atomics.wait(sharedBufferView, 0, 0);
        if (status2 !== "ok" && status2 !== "not-equal")
          throw new Error("Internal error: Atomics.wait() failed: " + status2);
        let { message: { id: id2, resolve: resolve2, reject, properties } } = worker_threads2.receiveMessageOnPort(mainPort);
        if (id !== id2)
          throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
        if (reject) {
          applyProperties(reject, properties);
          throw reject;
        }
        return resolve2;
      };
      worker.unref();
      return {
        buildSync(options2) {
          validateBuildSyncOptions(options2);
          return runCallSync("build", [options2]);
        },
        transformSync(input, options2) {
          return runCallSync("transform", [input, options2]);
        },
        formatMessagesSync(messages, options2) {
          return runCallSync("formatMessages", [messages, options2]);
        },
        analyzeMetafileSync(metafile, options2) {
          return runCallSync("analyzeMetafile", [metafile, options2]);
        }
      };
    };
    var startSyncServiceWorker = () => {
      let workerPort = worker_threads.workerData.workerPort;
      let parentPort = worker_threads.parentPort;
      let service = ensureServiceIsRunning();
      defaultWD = worker_threads.workerData.defaultWD;
      let extractProperties = (object) => {
        let properties = {};
        if (object && typeof object === "object") {
          for (let key in object) {
            properties[key] = object[key];
          }
        }
        return properties;
      };
      parentPort.on("message", (msg) => {
        (async () => {
          let { sharedBuffer, id, command: command2, args } = msg;
          let sharedBufferView = new Int32Array(sharedBuffer);
          try {
            switch (command2) {
              case "build":
                workerPort.postMessage({ id, resolve: await service.build(args[0]) });
                break;
              case "transform":
                workerPort.postMessage({ id, resolve: await service.transform(args[0], args[1]) });
                break;
              case "formatMessages":
                workerPort.postMessage({ id, resolve: await service.formatMessages(args[0], args[1]) });
                break;
              case "analyzeMetafile":
                workerPort.postMessage({ id, resolve: await service.analyzeMetafile(args[0], args[1]) });
                break;
              default:
                throw new Error(`Invalid command: ${command2}`);
            }
          } catch (reject) {
            workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
          }
          Atomics.add(sharedBufferView, 0, 1);
          Atomics.notify(sharedBufferView, 0, Infinity);
        })();
      });
    };
    if (isInternalWorkerThread) {
      startSyncServiceWorker();
    }
  }
});

// browser-external:readline
var readline_exports = {};
__export(readline_exports, {
  default: () => readline_default
});
var readline_default;
var init_readline = __esm({
  "browser-external:readline"() {
    readline_default = new Proxy({}, {
      get() {
        throw new Error('Module "readline" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/supports-color/browser.js
var require_browser = __commonJS({
  "node_modules/supports-color/browser.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      stdout: false,
      stderr: false
    };
  }
});

// node_modules/vite/dist/node/chunks/dep-ac1b4bf9.js
var require_dep_ac1b4bf9 = __commonJS({
  "node_modules/vite/dist/node/chunks/dep-ac1b4bf9.js"(exports2) {
    "use strict";
    var openParentheses = "(".charCodeAt(0);
    var closeParentheses = ")".charCodeAt(0);
    var singleQuote = "'".charCodeAt(0);
    var doubleQuote = '"'.charCodeAt(0);
    var backslash2 = "\\".charCodeAt(0);
    var slash2 = "/".charCodeAt(0);
    var comma = ",".charCodeAt(0);
    var colon = ":".charCodeAt(0);
    var star2 = "*".charCodeAt(0);
    var uLower = "u".charCodeAt(0);
    var uUpper = "U".charCodeAt(0);
    var plus$1 = "+".charCodeAt(0);
    var isUnicodeRange = /^[a-f0-9?-]+$/i;
    var parse$12 = function(input) {
      var tokens = [];
      var value = input;
      var next, quote, prev, token, escape2, escapePos, whitespacePos, parenthesesOpenPos;
      var pos = 0;
      var code = value.charCodeAt(pos);
      var max = value.length;
      var stack = [{ nodes: tokens }];
      var balanced2 = 0;
      var parent;
      var name = "";
      var before = "";
      var after = "";
      while (pos < max) {
        if (code <= 32) {
          next = pos;
          do {
            next += 1;
            code = value.charCodeAt(next);
          } while (code <= 32);
          token = value.slice(pos, next);
          prev = tokens[tokens.length - 1];
          if (code === closeParentheses && balanced2) {
            after = token;
          } else if (prev && prev.type === "div") {
            prev.after = token;
          } else if (code === comma || code === colon || code === slash2 && value.charCodeAt(next + 1) !== star2 && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
            before = token;
          } else {
            tokens.push({
              type: "space",
              sourceIndex: pos,
              value: token
            });
          }
          pos = next;
        } else if (code === singleQuote || code === doubleQuote) {
          next = pos;
          quote = code === singleQuote ? "'" : '"';
          token = {
            type: "string",
            sourceIndex: pos,
            quote
          };
          do {
            escape2 = false;
            next = value.indexOf(quote, next + 1);
            if (~next) {
              escapePos = next;
              while (value.charCodeAt(escapePos - 1) === backslash2) {
                escapePos -= 1;
                escape2 = !escape2;
              }
            } else {
              value += quote;
              next = value.length - 1;
              token.unclosed = true;
            }
          } while (escape2);
          token.value = value.slice(pos + 1, next);
          tokens.push(token);
          pos = next + 1;
          code = value.charCodeAt(pos);
        } else if (code === slash2 && value.charCodeAt(pos + 1) === star2) {
          token = {
            type: "comment",
            sourceIndex: pos
          };
          next = value.indexOf("*/", pos);
          if (next === -1) {
            token.unclosed = true;
            next = value.length;
          }
          token.value = value.slice(pos + 2, next);
          tokens.push(token);
          pos = next + 2;
          code = value.charCodeAt(pos);
        } else if ((code === slash2 || code === star2) && parent && parent.type === "function" && parent.value === "calc") {
          token = value[pos];
          tokens.push({
            type: "word",
            sourceIndex: pos - before.length,
            value: token
          });
          pos += 1;
          code = value.charCodeAt(pos);
        } else if (code === slash2 || code === comma || code === colon) {
          token = value[pos];
          tokens.push({
            type: "div",
            sourceIndex: pos - before.length,
            value: token,
            before,
            after: ""
          });
          before = "";
          pos += 1;
          code = value.charCodeAt(pos);
        } else if (openParentheses === code) {
          next = pos;
          do {
            next += 1;
            code = value.charCodeAt(next);
          } while (code <= 32);
          parenthesesOpenPos = pos;
          token = {
            type: "function",
            sourceIndex: pos - name.length,
            value: name,
            before: value.slice(parenthesesOpenPos + 1, next)
          };
          pos = next;
          if (name === "url" && code !== singleQuote && code !== doubleQuote) {
            next -= 1;
            do {
              escape2 = false;
              next = value.indexOf(")", next + 1);
              if (~next) {
                escapePos = next;
                while (value.charCodeAt(escapePos - 1) === backslash2) {
                  escapePos -= 1;
                  escape2 = !escape2;
                }
              } else {
                value += ")";
                next = value.length - 1;
                token.unclosed = true;
              }
            } while (escape2);
            whitespacePos = next;
            do {
              whitespacePos -= 1;
              code = value.charCodeAt(whitespacePos);
            } while (code <= 32);
            if (parenthesesOpenPos < whitespacePos) {
              if (pos !== whitespacePos + 1) {
                token.nodes = [
                  {
                    type: "word",
                    sourceIndex: pos,
                    value: value.slice(pos, whitespacePos + 1)
                  }
                ];
              } else {
                token.nodes = [];
              }
              if (token.unclosed && whitespacePos + 1 !== next) {
                token.after = "";
                token.nodes.push({
                  type: "space",
                  sourceIndex: whitespacePos + 1,
                  value: value.slice(whitespacePos + 1, next)
                });
              } else {
                token.after = value.slice(whitespacePos + 1, next);
              }
            } else {
              token.after = "";
              token.nodes = [];
            }
            pos = next + 1;
            code = value.charCodeAt(pos);
            tokens.push(token);
          } else {
            balanced2 += 1;
            token.after = "";
            tokens.push(token);
            stack.push(token);
            tokens = token.nodes = [];
            parent = token;
          }
          name = "";
        } else if (closeParentheses === code && balanced2) {
          pos += 1;
          code = value.charCodeAt(pos);
          parent.after = after;
          after = "";
          balanced2 -= 1;
          stack.pop();
          parent = stack[balanced2];
          tokens = parent.nodes;
        } else {
          next = pos;
          do {
            if (code === backslash2) {
              next += 1;
            }
            next += 1;
            code = value.charCodeAt(next);
          } while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash2 || code === openParentheses || code === star2 && parent && parent.type === "function" && parent.value === "calc" || code === slash2 && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced2));
          token = value.slice(pos, next);
          if (openParentheses === code) {
            name = token;
          } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus$1 === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
            tokens.push({
              type: "unicode-range",
              sourceIndex: pos,
              value: token
            });
          } else {
            tokens.push({
              type: "word",
              sourceIndex: pos,
              value: token
            });
          }
          pos = next;
        }
      }
      for (pos = stack.length - 1; pos; pos -= 1) {
        stack[pos].unclosed = true;
      }
      return stack[0].nodes;
    };
    var walk$12 = function walk3(nodes, cb, bubble) {
      var i2, max, node2, result2;
      for (i2 = 0, max = nodes.length; i2 < max; i2 += 1) {
        node2 = nodes[i2];
        if (!bubble) {
          result2 = cb(node2, i2, nodes);
        }
        if (result2 !== false && node2.type === "function" && Array.isArray(node2.nodes)) {
          walk3(node2.nodes, cb, bubble);
        }
        if (bubble) {
          cb(node2, i2, nodes);
        }
      }
    };
    function stringifyNode(node2, custom) {
      var type = node2.type;
      var value = node2.value;
      var buf;
      var customResult;
      if (custom && (customResult = custom(node2)) !== void 0) {
        return customResult;
      } else if (type === "word" || type === "space") {
        return value;
      } else if (type === "string") {
        buf = node2.quote || "";
        return buf + value + (node2.unclosed ? "" : buf);
      } else if (type === "comment") {
        return "/*" + value + (node2.unclosed ? "" : "*/");
      } else if (type === "div") {
        return (node2.before || "") + value + (node2.after || "");
      } else if (Array.isArray(node2.nodes)) {
        buf = stringify$12(node2.nodes, custom);
        if (type !== "function") {
          return buf;
        }
        return value + "(" + (node2.before || "") + buf + (node2.after || "") + (node2.unclosed ? "" : ")");
      }
      return value;
    }
    function stringify$12(nodes, custom) {
      var result2, i2;
      if (Array.isArray(nodes)) {
        result2 = "";
        for (i2 = nodes.length - 1; ~i2; i2 -= 1) {
          result2 = stringifyNode(nodes[i2], custom) + result2;
        }
        return result2;
      }
      return stringifyNode(nodes, custom);
    }
    var stringify_1 = stringify$12;
    var minus = "-".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var dot = ".".charCodeAt(0);
    var exp = "e".charCodeAt(0);
    var EXP = "E".charCodeAt(0);
    function likeNumber(value) {
      var code = value.charCodeAt(0);
      var nextCode;
      if (code === plus || code === minus) {
        nextCode = value.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        var nextNextCode = value.charCodeAt(2);
        if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code === dot) {
        nextCode = value.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code >= 48 && code <= 57) {
        return true;
      }
      return false;
    }
    var unit = function(value) {
      var pos = 0;
      var length = value.length;
      var code;
      var nextCode;
      var nextNextCode;
      if (length === 0 || !likeNumber(value)) {
        return false;
      }
      code = value.charCodeAt(pos);
      if (code === plus || code === minus) {
        pos++;
      }
      while (pos < length) {
        code = value.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
      code = value.charCodeAt(pos);
      nextCode = value.charCodeAt(pos + 1);
      if (code === dot && nextCode >= 48 && nextCode <= 57) {
        pos += 2;
        while (pos < length) {
          code = value.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      code = value.charCodeAt(pos);
      nextCode = value.charCodeAt(pos + 1);
      nextNextCode = value.charCodeAt(pos + 2);
      if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
        pos += nextCode === plus || nextCode === minus ? 3 : 2;
        while (pos < length) {
          code = value.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      return {
        number: value.slice(0, pos),
        unit: value.slice(pos)
      };
    };
    var parse2 = parse$12;
    var walk2 = walk$12;
    var stringify2 = stringify_1;
    function ValueParser(value) {
      if (this instanceof ValueParser) {
        this.nodes = parse2(value);
        return this;
      }
      return new ValueParser(value);
    }
    ValueParser.prototype.toString = function() {
      return Array.isArray(this.nodes) ? stringify2(this.nodes) : "";
    };
    ValueParser.prototype.walk = function(cb, bubble) {
      walk2(this.nodes, cb, bubble);
      return this;
    };
    ValueParser.unit = unit;
    ValueParser.walk = walk2;
    ValueParser.stringify = stringify2;
    var lib2 = ValueParser;
    exports2.lib = lib2;
  }
});

// node_modules/vite/dist/node/chunks/dep-2d8e2cb1.js
var require_dep_2d8e2cb1 = __commonJS({
  "node_modules/vite/dist/node/chunks/dep-2d8e2cb1.js"(exports, module) {
    "use strict";
    var path$3 = (init_path(), path_exports);
    var resolve$2 = require_resolve();
    var fs$1 = (init_fs(), fs_exports);
    var index$1 = require_dep_ac1b4bf9();
    function _interopDefaultLegacy(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2["default"] : e2;
    }
    function _mergeNamespaces(n3, m3) {
      for (var i2 = 0; i2 < m3.length; i2++) {
        var e2 = m3[i2];
        if (typeof e2 !== "string" && !Array.isArray(e2)) {
          for (var k2 in e2) {
            if (k2 !== "default" && !(k2 in n3)) {
              n3[k2] = e2[k2];
            }
          }
        }
      }
      return n3;
    }
    var path__default = _interopDefaultLegacy(path$3);
    var resolve__default = _interopDefaultLegacy(resolve$2);
    var fs__default = _interopDefaultLegacy(fs$1);
    var joinMedia$1 = function(parentMedia, childMedia) {
      if (!parentMedia.length && childMedia.length)
        return childMedia;
      if (parentMedia.length && !childMedia.length)
        return parentMedia;
      if (!parentMedia.length && !childMedia.length)
        return [];
      const media = [];
      parentMedia.forEach((parentItem) => {
        childMedia.forEach((childItem) => {
          if (parentItem !== childItem)
            media.push(`${parentItem} and ${childItem}`);
        });
      });
      return media;
    };
    var resolve$1 = resolve__default;
    var moduleDirectories = ["web_modules", "node_modules"];
    function resolveModule(id, opts) {
      return new Promise((res, rej) => {
        resolve$1(id, opts, (err, path2) => err ? rej(err) : res(path2));
      });
    }
    var resolveId$1 = function(id, base2, options2) {
      const paths = options2.path;
      const resolveOpts = {
        basedir: base2,
        moduleDirectory: moduleDirectories.concat(options2.addModulesDirectories),
        paths,
        extensions: [".css"],
        packageFilter: function processPackage(pkg) {
          if (pkg.style)
            pkg.main = pkg.style;
          else if (!pkg.main || !/\.css$/.test(pkg.main))
            pkg.main = "index.css";
          return pkg;
        },
        preserveSymlinks: false
      };
      return resolveModule(`./${id}`, resolveOpts).catch(() => resolveModule(id, resolveOpts)).catch(() => {
        if (paths.indexOf(base2) === -1)
          paths.unshift(base2);
        throw new Error(`Failed to find '${id}'
  in [
    ${paths.join(",\n        ")}
  ]`);
      });
    };
    var readCache$1 = { exports: {} };
    var pify$2 = { exports: {} };
    var processFn = function(fn2, P2, opts) {
      return function() {
        var that = this;
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < arguments.length; i2++) {
          args[i2] = arguments[i2];
        }
        return new P2(function(resolve2, reject) {
          args.push(function(err, result2) {
            if (err) {
              reject(err);
            } else if (opts.multiArgs) {
              var results = new Array(arguments.length - 1);
              for (var i3 = 1; i3 < arguments.length; i3++) {
                results[i3 - 1] = arguments[i3];
              }
              resolve2(results);
            } else {
              resolve2(result2);
            }
          });
          fn2.apply(that, args);
        });
      };
    };
    var pify$1 = pify$2.exports = function(obj, P2, opts) {
      if (typeof P2 !== "function") {
        opts = P2;
        P2 = Promise;
      }
      opts = opts || {};
      opts.exclude = opts.exclude || [/.+Sync$/];
      var filter2 = function(key) {
        var match2 = function(pattern2) {
          return typeof pattern2 === "string" ? key === pattern2 : pattern2.test(key);
        };
        return opts.include ? opts.include.some(match2) : !opts.exclude.some(match2);
      };
      var ret = typeof obj === "function" ? function() {
        if (opts.excludeMain) {
          return obj.apply(this, arguments);
        }
        return processFn(obj, P2, opts).apply(this, arguments);
      } : {};
      return Object.keys(obj).reduce(function(ret2, key) {
        var x2 = obj[key];
        ret2[key] = typeof x2 === "function" && filter2(key) ? processFn(x2, P2, opts) : x2;
        return ret2;
      }, ret);
    };
    pify$1.all = pify$1;
    var fs = fs__default;
    var path$2 = path__default;
    var pify = pify$2.exports;
    var stat = pify(fs.stat);
    var readFile = pify(fs.readFile);
    var resolve = path$2.resolve;
    var cache = Object.create(null);
    function convert(content2, encoding2) {
      if (Buffer.isEncoding(encoding2)) {
        return content2.toString(encoding2);
      }
      return content2;
    }
    readCache$1.exports = function(path2, encoding2) {
      path2 = resolve(path2);
      return stat(path2).then(function(stats) {
        var item = cache[path2];
        if (item && item.mtime.getTime() === stats.mtime.getTime()) {
          return convert(item.content, encoding2);
        }
        return readFile(path2).then(function(data2) {
          cache[path2] = {
            mtime: stats.mtime,
            content: data2
          };
          return convert(data2, encoding2);
        });
      }).catch(function(err) {
        cache[path2] = null;
        return Promise.reject(err);
      });
    };
    readCache$1.exports.sync = function(path2, encoding2) {
      path2 = resolve(path2);
      try {
        var stats = fs.statSync(path2);
        var item = cache[path2];
        if (item && item.mtime.getTime() === stats.mtime.getTime()) {
          return convert(item.content, encoding2);
        }
        var data2 = fs.readFileSync(path2);
        cache[path2] = {
          mtime: stats.mtime,
          content: data2
        };
        return convert(data2, encoding2);
      } catch (err) {
        cache[path2] = null;
        throw err;
      }
    };
    readCache$1.exports.get = function(path2, encoding2) {
      path2 = resolve(path2);
      if (cache[path2]) {
        return convert(cache[path2].content, encoding2);
      }
      return null;
    };
    readCache$1.exports.clear = function() {
      cache = Object.create(null);
    };
    var readCache = readCache$1.exports;
    var loadContent$1 = (filename2) => readCache(filename2, "utf-8");
    var path$1 = path__default;
    var sugarss;
    var processContent$1 = function processContent(result, content, filename, options, postcss) {
      const { plugins } = options;
      const ext = path$1.extname(filename);
      const parserList = [];
      if (ext === ".sss") {
        if (!sugarss) {
          try {
            sugarss = eval("require")("sugarss");
          } catch {
          }
        }
        if (sugarss)
          return runPostcss(postcss, content, filename, plugins, [sugarss]);
      }
      if (result.opts.syntax && result.opts.syntax.parse) {
        parserList.push(result.opts.syntax.parse);
      }
      if (result.opts.parser)
        parserList.push(result.opts.parser);
      parserList.push(null);
      return runPostcss(postcss, content, filename, plugins, parserList);
    };
    function runPostcss(postcss2, content2, filename2, plugins2, parsers, index2) {
      if (!index2)
        index2 = 0;
      return postcss2(plugins2).process(content2, {
        from: filename2,
        parser: parsers[index2]
      }).catch((err) => {
        index2++;
        if (index2 === parsers.length)
          throw err;
        return runPostcss(postcss2, content2, filename2, plugins2, parsers, index2);
      });
    }
    var valueParser = index$1.lib;
    var { stringify } = valueParser;
    function split(params, start) {
      const list2 = [];
      const last = params.reduce((item, node2, index2) => {
        if (index2 < start)
          return "";
        if (node2.type === "div" && node2.value === ",") {
          list2.push(item);
          return "";
        }
        return item + stringify(node2);
      }, "");
      list2.push(last);
      return list2;
    }
    var parseStatements$1 = function(result2, styles2) {
      const statements = [];
      let nodes = [];
      styles2.each((node2) => {
        let stmt;
        if (node2.type === "atrule") {
          if (node2.name === "import")
            stmt = parseImport(result2, node2);
          else if (node2.name === "media")
            stmt = parseMedia(result2, node2);
          else if (node2.name === "charset")
            stmt = parseCharset(result2, node2);
        }
        if (stmt) {
          if (nodes.length) {
            statements.push({
              type: "nodes",
              nodes,
              media: []
            });
            nodes = [];
          }
          statements.push(stmt);
        } else
          nodes.push(node2);
      });
      if (nodes.length) {
        statements.push({
          type: "nodes",
          nodes,
          media: []
        });
      }
      return statements;
    };
    function parseMedia(result2, atRule) {
      const params = valueParser(atRule.params).nodes;
      return {
        type: "media",
        node: atRule,
        media: split(params, 0)
      };
    }
    function parseCharset(result2, atRule) {
      if (atRule.prev()) {
        return result2.warn("@charset must precede all other statements", {
          node: atRule
        });
      }
      return {
        type: "charset",
        node: atRule,
        media: []
      };
    }
    function parseImport(result2, atRule) {
      let prev = atRule.prev();
      if (prev) {
        do {
          if (prev.type !== "comment" && (prev.type !== "atrule" || prev.name !== "import" && prev.name !== "charset")) {
            return result2.warn("@import must precede all other statements (besides @charset)", { node: atRule });
          }
          prev = prev.prev();
        } while (prev);
      }
      if (atRule.nodes) {
        return result2.warn("It looks like you didn't end your @import statement correctly. Child nodes are attached to it.", { node: atRule });
      }
      const params = valueParser(atRule.params).nodes;
      const stmt = {
        type: "import",
        node: atRule,
        media: []
      };
      if (!params.length || (params[0].type !== "string" || !params[0].value) && (params[0].type !== "function" || params[0].value !== "url" || !params[0].nodes.length || !params[0].nodes[0].value)) {
        return result2.warn(`Unable to find uri in '${atRule.toString()}'`, {
          node: atRule
        });
      }
      if (params[0].type === "string")
        stmt.uri = params[0].value;
      else
        stmt.uri = params[0].nodes[0].value;
      stmt.fullUri = stringify(params[0]);
      if (params.length > 2) {
        if (params[1].type !== "space") {
          return result2.warn("Invalid import media statement", { node: atRule });
        }
        stmt.media = split(params, 2);
      }
      return stmt;
    }
    var path = path__default;
    var joinMedia = joinMedia$1;
    var resolveId = resolveId$1;
    var loadContent = loadContent$1;
    var processContent = processContent$1;
    var parseStatements = parseStatements$1;
    function AtImport(options2) {
      options2 = __spreadValues2({
        root: process.cwd(),
        path: [],
        skipDuplicates: true,
        resolve: resolveId,
        load: loadContent,
        plugins: [],
        addModulesDirectories: []
      }, options2);
      options2.root = path.resolve(options2.root);
      if (typeof options2.path === "string")
        options2.path = [options2.path];
      if (!Array.isArray(options2.path))
        options2.path = [];
      options2.path = options2.path.map((p2) => path.resolve(options2.root, p2));
      return {
        postcssPlugin: "postcss-import",
        Once(styles2, { result: result2, atRule, postcss: postcss2 }) {
          const state = {
            importedFiles: {},
            hashFiles: {}
          };
          if (styles2.source && styles2.source.input && styles2.source.input.file) {
            state.importedFiles[styles2.source.input.file] = {};
          }
          if (options2.plugins && !Array.isArray(options2.plugins)) {
            throw new Error("plugins option must be an array");
          }
          return parseStyles(result2, styles2, options2, state, []).then((bundle) => {
            applyRaws(bundle);
            applyMedia(bundle);
            applyStyles(bundle, styles2);
          });
          function applyRaws(bundle) {
            bundle.forEach((stmt, index2) => {
              if (index2 === 0)
                return;
              if (stmt.parent) {
                const { before } = stmt.parent.node.raws;
                if (stmt.type === "nodes")
                  stmt.nodes[0].raws.before = before;
                else
                  stmt.node.raws.before = before;
              } else if (stmt.type === "nodes") {
                stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || "\n";
              }
            });
          }
          function applyMedia(bundle) {
            bundle.forEach((stmt) => {
              if (!stmt.media.length || stmt.type === "charset")
                return;
              if (stmt.type === "import") {
                stmt.node.params = `${stmt.fullUri} ${stmt.media.join(", ")}`;
              } else if (stmt.type === "media")
                stmt.node.params = stmt.media.join(", ");
              else {
                const { nodes } = stmt;
                const { parent } = nodes[0];
                const mediaNode = atRule({
                  name: "media",
                  params: stmt.media.join(", "),
                  source: parent.source
                });
                parent.insertBefore(nodes[0], mediaNode);
                nodes.forEach((node2) => {
                  node2.parent = void 0;
                });
                nodes[0].raws.before = nodes[0].raws.before || "\n";
                mediaNode.append(nodes);
                stmt.type = "media";
                stmt.node = mediaNode;
                delete stmt.nodes;
              }
            });
          }
          function applyStyles(bundle, styles3) {
            styles3.nodes = [];
            bundle.forEach((stmt) => {
              if (["charset", "import", "media"].includes(stmt.type)) {
                stmt.node.parent = void 0;
                styles3.append(stmt.node);
              } else if (stmt.type === "nodes") {
                stmt.nodes.forEach((node2) => {
                  node2.parent = void 0;
                  styles3.append(node2);
                });
              }
            });
          }
          function parseStyles(result3, styles3, options3, state2, media) {
            const statements = parseStatements(result3, styles3);
            return Promise.resolve(statements).then((stmts) => {
              return stmts.reduce((promise2, stmt) => {
                return promise2.then(() => {
                  stmt.media = joinMedia(media, stmt.media || []);
                  if (stmt.type !== "import" || /^(?:[a-z]+:)?\/\//i.test(stmt.uri)) {
                    return;
                  }
                  if (options3.filter && !options3.filter(stmt.uri)) {
                    return;
                  }
                  return resolveImportId(result3, stmt, options3, state2);
                });
              }, Promise.resolve());
            }).then(() => {
              let charset2;
              const imports = [];
              const bundle = [];
              function handleCharset(stmt) {
                if (!charset2)
                  charset2 = stmt;
                else if (stmt.node.params.toLowerCase() !== charset2.node.params.toLowerCase()) {
                  throw new Error(`Incompatable @charset statements:
  ${stmt.node.params} specified in ${stmt.node.source.input.file}
  ${charset2.node.params} specified in ${charset2.node.source.input.file}`);
                }
              }
              statements.forEach((stmt) => {
                if (stmt.type === "charset")
                  handleCharset(stmt);
                else if (stmt.type === "import") {
                  if (stmt.children) {
                    stmt.children.forEach((child, index2) => {
                      if (child.type === "import")
                        imports.push(child);
                      else if (child.type === "charset")
                        handleCharset(child);
                      else
                        bundle.push(child);
                      if (index2 === 0)
                        child.parent = stmt;
                    });
                  } else
                    imports.push(stmt);
                } else if (stmt.type === "media" || stmt.type === "nodes") {
                  bundle.push(stmt);
                }
              });
              return charset2 ? [charset2, ...imports.concat(bundle)] : imports.concat(bundle);
            });
          }
          function resolveImportId(result3, stmt, options3, state2) {
            const atRule2 = stmt.node;
            let sourceFile;
            if (atRule2.source && atRule2.source.input && atRule2.source.input.file) {
              sourceFile = atRule2.source.input.file;
            }
            const base2 = sourceFile ? path.dirname(atRule2.source.input.file) : options3.root;
            return Promise.resolve(options3.resolve(stmt.uri, base2, options3)).then((paths) => {
              if (!Array.isArray(paths))
                paths = [paths];
              return Promise.all(paths.map((file) => {
                return !path.isAbsolute(file) ? resolveId(file, base2, options3) : file;
              }));
            }).then((resolved) => {
              resolved.forEach((file) => {
                result3.messages.push({
                  type: "dependency",
                  plugin: "postcss-import",
                  file,
                  parent: sourceFile
                });
              });
              return Promise.all(resolved.map((file) => {
                return loadImportContent(result3, stmt, file, options3, state2);
              }));
            }).then((result4) => {
              stmt.children = result4.reduce((result5, statements) => {
                return statements ? result5.concat(statements) : result5;
              }, []);
            });
          }
          function loadImportContent(result3, stmt, filename2, options3, state2) {
            const atRule2 = stmt.node;
            const { media } = stmt;
            if (options3.skipDuplicates) {
              if (state2.importedFiles[filename2] && state2.importedFiles[filename2][media]) {
                return;
              }
              if (!state2.importedFiles[filename2])
                state2.importedFiles[filename2] = {};
              state2.importedFiles[filename2][media] = true;
            }
            return Promise.resolve(options3.load(filename2, options3)).then((content2) => {
              if (content2.trim() === "") {
                result3.warn(`${filename2} is empty`, { node: atRule2 });
                return;
              }
              if (state2.hashFiles[content2] && state2.hashFiles[content2][media])
                return;
              return processContent(result3, content2, filename2, options3, postcss2).then((importedResult) => {
                const styles3 = importedResult.root;
                result3.messages = result3.messages.concat(importedResult.messages);
                if (options3.skipDuplicates) {
                  const hasImport = styles3.some((child) => {
                    return child.type === "atrule" && child.name === "import";
                  });
                  if (!hasImport) {
                    if (!state2.hashFiles[content2])
                      state2.hashFiles[content2] = {};
                    state2.hashFiles[content2][media] = true;
                  }
                }
                return parseStyles(result3, styles3, options3, state2, media);
              });
            });
          }
        }
      };
    }
    AtImport.postcss = true;
    var postcssImport = AtImport;
    var index = _mergeNamespaces({
      __proto__: null,
      "default": postcssImport
    }, [postcssImport]);
    exports.index = index;
  }
});

// node_modules/picocolors/picocolors.browser.js
var require_picocolors_browser = __commonJS({
  "node_modules/picocolors/picocolors.browser.js"(exports2, module2) {
    var x2 = String;
    var create = function() {
      return { isColorSupported: false, reset: x2, bold: x2, dim: x2, italic: x2, underline: x2, inverse: x2, hidden: x2, strikethrough: x2, black: x2, red: x2, green: x2, yellow: x2, blue: x2, magenta: x2, cyan: x2, white: x2, gray: x2, bgBlack: x2, bgRed: x2, bgGreen: x2, bgYellow: x2, bgBlue: x2, bgMagenta: x2, bgCyan: x2, bgWhite: x2 };
    };
    module2.exports = create();
    module2.exports.createColors = create;
  }
});

// (disabled):node_modules/postcss/lib/terminal-highlight
var require_terminal_highlight = __commonJS({
  "(disabled):node_modules/postcss/lib/terminal-highlight"() {
  }
});

// node_modules/postcss/lib/css-syntax-error.js
var require_css_syntax_error = __commonJS({
  "node_modules/postcss/lib/css-syntax-error.js"(exports2, module2) {
    "use strict";
    var pico = require_picocolors_browser();
    var terminalHighlight = require_terminal_highlight();
    var CssSyntaxError = class extends Error {
      constructor(message, line, column, source2, file, plugin) {
        super(message);
        this.name = "CssSyntaxError";
        this.reason = message;
        if (file) {
          this.file = file;
        }
        if (source2) {
          this.source = source2;
        }
        if (plugin) {
          this.plugin = plugin;
        }
        if (typeof line !== "undefined" && typeof column !== "undefined") {
          if (typeof line === "number") {
            this.line = line;
            this.column = column;
          } else {
            this.line = line.line;
            this.column = line.column;
            this.endLine = column.line;
            this.endColumn = column.column;
          }
        }
        this.setMessage();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, CssSyntaxError);
        }
      }
      setMessage() {
        this.message = this.plugin ? this.plugin + ": " : "";
        this.message += this.file ? this.file : "<css input>";
        if (typeof this.line !== "undefined") {
          this.message += ":" + this.line + ":" + this.column;
        }
        this.message += ": " + this.reason;
      }
      showSourceCode(color) {
        if (!this.source)
          return "";
        let css = this.source;
        if (color == null)
          color = pico.isColorSupported;
        if (terminalHighlight) {
          if (color)
            css = terminalHighlight(css);
        }
        let lines = css.split(/\r?\n/);
        let start = Math.max(this.line - 3, 0);
        let end = Math.min(this.line + 2, lines.length);
        let maxWidth = String(end).length;
        let mark2, aside;
        if (color) {
          let { bold, red, gray } = pico.createColors(true);
          mark2 = (text) => bold(red(text));
          aside = (text) => gray(text);
        } else {
          mark2 = aside = (str) => str;
        }
        return lines.slice(start, end).map((line, index2) => {
          let number = start + 1 + index2;
          let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
          if (number === this.line) {
            let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
            return mark2(">") + aside(gutter) + line + "\n " + spacing + mark2("^");
          }
          return " " + aside(gutter) + line;
        }).join("\n");
      }
      toString() {
        let code = this.showSourceCode();
        if (code) {
          code = "\n\n" + code + "\n";
        }
        return this.name + ": " + this.message + code;
      }
    };
    module2.exports = CssSyntaxError;
    CssSyntaxError.default = CssSyntaxError;
  }
});

// node_modules/postcss/lib/symbols.js
var require_symbols = __commonJS({
  "node_modules/postcss/lib/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports.isClean = Symbol("isClean");
    module2.exports.my = Symbol("my");
  }
});

// node_modules/postcss/lib/stringifier.js
var require_stringifier = __commonJS({
  "node_modules/postcss/lib/stringifier.js"(exports2, module2) {
    "use strict";
    var DEFAULT_RAW = {
      colon: ": ",
      indent: "    ",
      beforeDecl: "\n",
      beforeRule: "\n",
      beforeOpen: " ",
      beforeClose: "\n",
      beforeComment: "\n",
      after: "\n",
      emptyBody: "",
      commentLeft: " ",
      commentRight: " ",
      semicolon: false
    };
    function capitalize(str) {
      return str[0].toUpperCase() + str.slice(1);
    }
    var Stringifier = class {
      constructor(builder) {
        this.builder = builder;
      }
      stringify(node2, semicolon) {
        if (!this[node2.type]) {
          throw new Error("Unknown AST node type " + node2.type + ". Maybe you need to change PostCSS stringifier.");
        }
        this[node2.type](node2, semicolon);
      }
      document(node2) {
        this.body(node2);
      }
      root(node2) {
        this.body(node2);
        if (node2.raws.after)
          this.builder(node2.raws.after);
      }
      comment(node2) {
        let left = this.raw(node2, "left", "commentLeft");
        let right = this.raw(node2, "right", "commentRight");
        this.builder("/*" + left + node2.text + right + "*/", node2);
      }
      decl(node2, semicolon) {
        let between = this.raw(node2, "between", "colon");
        let string2 = node2.prop + between + this.rawValue(node2, "value");
        if (node2.important) {
          string2 += node2.raws.important || " !important";
        }
        if (semicolon)
          string2 += ";";
        this.builder(string2, node2);
      }
      rule(node2) {
        this.block(node2, this.rawValue(node2, "selector"));
        if (node2.raws.ownSemicolon) {
          this.builder(node2.raws.ownSemicolon, node2, "end");
        }
      }
      atrule(node2, semicolon) {
        let name = "@" + node2.name;
        let params = node2.params ? this.rawValue(node2, "params") : "";
        if (typeof node2.raws.afterName !== "undefined") {
          name += node2.raws.afterName;
        } else if (params) {
          name += " ";
        }
        if (node2.nodes) {
          this.block(node2, name + params);
        } else {
          let end = (node2.raws.between || "") + (semicolon ? ";" : "");
          this.builder(name + params + end, node2);
        }
      }
      body(node2) {
        let last = node2.nodes.length - 1;
        while (last > 0) {
          if (node2.nodes[last].type !== "comment")
            break;
          last -= 1;
        }
        let semicolon = this.raw(node2, "semicolon");
        for (let i2 = 0; i2 < node2.nodes.length; i2++) {
          let child = node2.nodes[i2];
          let before = this.raw(child, "before");
          if (before)
            this.builder(before);
          this.stringify(child, last !== i2 || semicolon);
        }
      }
      block(node2, start) {
        let between = this.raw(node2, "between", "beforeOpen");
        this.builder(start + between + "{", node2, "start");
        let after;
        if (node2.nodes && node2.nodes.length) {
          this.body(node2);
          after = this.raw(node2, "after");
        } else {
          after = this.raw(node2, "after", "emptyBody");
        }
        if (after)
          this.builder(after);
        this.builder("}", node2, "end");
      }
      raw(node2, own, detect) {
        let value;
        if (!detect)
          detect = own;
        if (own) {
          value = node2.raws[own];
          if (typeof value !== "undefined")
            return value;
        }
        let parent = node2.parent;
        if (detect === "before") {
          if (!parent || parent.type === "root" && parent.first === node2) {
            return "";
          }
          if (parent && parent.type === "document") {
            return "";
          }
        }
        if (!parent)
          return DEFAULT_RAW[detect];
        let root = node2.root();
        if (!root.rawCache)
          root.rawCache = {};
        if (typeof root.rawCache[detect] !== "undefined") {
          return root.rawCache[detect];
        }
        if (detect === "before" || detect === "after") {
          return this.beforeAfter(node2, detect);
        } else {
          let method = "raw" + capitalize(detect);
          if (this[method]) {
            value = this[method](root, node2);
          } else {
            root.walk((i2) => {
              value = i2.raws[own];
              if (typeof value !== "undefined")
                return false;
            });
          }
        }
        if (typeof value === "undefined")
          value = DEFAULT_RAW[detect];
        root.rawCache[detect] = value;
        return value;
      }
      rawSemicolon(root) {
        let value;
        root.walk((i2) => {
          if (i2.nodes && i2.nodes.length && i2.last.type === "decl") {
            value = i2.raws.semicolon;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawEmptyBody(root) {
        let value;
        root.walk((i2) => {
          if (i2.nodes && i2.nodes.length === 0) {
            value = i2.raws.after;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawIndent(root) {
        if (root.raws.indent)
          return root.raws.indent;
        let value;
        root.walk((i2) => {
          let p2 = i2.parent;
          if (p2 && p2 !== root && p2.parent && p2.parent === root) {
            if (typeof i2.raws.before !== "undefined") {
              let parts = i2.raws.before.split("\n");
              value = parts[parts.length - 1];
              value = value.replace(/\S/g, "");
              return false;
            }
          }
        });
        return value;
      }
      rawBeforeComment(root, node2) {
        let value;
        root.walkComments((i2) => {
          if (typeof i2.raws.before !== "undefined") {
            value = i2.raws.before;
            if (value.includes("\n")) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value === "undefined") {
          value = this.raw(node2, null, "beforeDecl");
        } else if (value) {
          value = value.replace(/\S/g, "");
        }
        return value;
      }
      rawBeforeDecl(root, node2) {
        let value;
        root.walkDecls((i2) => {
          if (typeof i2.raws.before !== "undefined") {
            value = i2.raws.before;
            if (value.includes("\n")) {
              value = value.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value === "undefined") {
          value = this.raw(node2, null, "beforeRule");
        } else if (value) {
          value = value.replace(/\S/g, "");
        }
        return value;
      }
      rawBeforeRule(root) {
        let value;
        root.walk((i2) => {
          if (i2.nodes && (i2.parent !== root || root.first !== i2)) {
            if (typeof i2.raws.before !== "undefined") {
              value = i2.raws.before;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value)
          value = value.replace(/\S/g, "");
        return value;
      }
      rawBeforeClose(root) {
        let value;
        root.walk((i2) => {
          if (i2.nodes && i2.nodes.length > 0) {
            if (typeof i2.raws.after !== "undefined") {
              value = i2.raws.after;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value)
          value = value.replace(/\S/g, "");
        return value;
      }
      rawBeforeOpen(root) {
        let value;
        root.walk((i2) => {
          if (i2.type !== "decl") {
            value = i2.raws.between;
            if (typeof value !== "undefined")
              return false;
          }
        });
        return value;
      }
      rawColon(root) {
        let value;
        root.walkDecls((i2) => {
          if (typeof i2.raws.between !== "undefined") {
            value = i2.raws.between.replace(/[^\s:]/g, "");
            return false;
          }
        });
        return value;
      }
      beforeAfter(node2, detect) {
        let value;
        if (node2.type === "decl") {
          value = this.raw(node2, null, "beforeDecl");
        } else if (node2.type === "comment") {
          value = this.raw(node2, null, "beforeComment");
        } else if (detect === "before") {
          value = this.raw(node2, null, "beforeRule");
        } else {
          value = this.raw(node2, null, "beforeClose");
        }
        let buf = node2.parent;
        let depth2 = 0;
        while (buf && buf.type !== "root") {
          depth2 += 1;
          buf = buf.parent;
        }
        if (value.includes("\n")) {
          let indent = this.raw(node2, null, "indent");
          if (indent.length) {
            for (let step = 0; step < depth2; step++)
              value += indent;
          }
        }
        return value;
      }
      rawValue(node2, prop) {
        let value = node2[prop];
        let raw = node2.raws[prop];
        if (raw && raw.value === value) {
          return raw.raw;
        }
        return value;
      }
    };
    module2.exports = Stringifier;
    Stringifier.default = Stringifier;
  }
});

// node_modules/postcss/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/postcss/lib/stringify.js"(exports2, module2) {
    "use strict";
    var Stringifier = require_stringifier();
    function stringify2(node2, builder) {
      let str = new Stringifier(builder);
      str.stringify(node2);
    }
    module2.exports = stringify2;
    stringify2.default = stringify2;
  }
});

// node_modules/postcss/lib/node.js
var require_node = __commonJS({
  "node_modules/postcss/lib/node.js"(exports2, module2) {
    "use strict";
    var { isClean, my } = require_symbols();
    var CssSyntaxError = require_css_syntax_error();
    var Stringifier = require_stringifier();
    var stringify2 = require_stringify();
    function cloneNode(obj, parent) {
      let cloned = new obj.constructor();
      for (let i2 in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, i2)) {
          continue;
        }
        if (i2 === "proxyCache")
          continue;
        let value = obj[i2];
        let type = typeof value;
        if (i2 === "parent" && type === "object") {
          if (parent)
            cloned[i2] = parent;
        } else if (i2 === "source") {
          cloned[i2] = value;
        } else if (Array.isArray(value)) {
          cloned[i2] = value.map((j2) => cloneNode(j2, cloned));
        } else {
          if (type === "object" && value !== null)
            value = cloneNode(value);
          cloned[i2] = value;
        }
      }
      return cloned;
    }
    var Node2 = class {
      constructor(defaults2 = {}) {
        this.raws = {};
        this[isClean] = false;
        this[my] = true;
        for (let name in defaults2) {
          if (name === "nodes") {
            this.nodes = [];
            for (let node2 of defaults2[name]) {
              if (typeof node2.clone === "function") {
                this.append(node2.clone());
              } else {
                this.append(node2);
              }
            }
          } else {
            this[name] = defaults2[name];
          }
        }
      }
      error(message, opts = {}) {
        if (this.source) {
          let { start, end } = this.rangeBy(opts);
          return this.source.input.error(message, { line: start.line, column: start.column }, { line: end.line, column: end.column }, opts);
        }
        return new CssSyntaxError(message);
      }
      warn(result2, text, opts) {
        let data2 = { node: this };
        for (let i2 in opts)
          data2[i2] = opts[i2];
        return result2.warn(text, data2);
      }
      remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = void 0;
        return this;
      }
      toString(stringifier = stringify2) {
        if (stringifier.stringify)
          stringifier = stringifier.stringify;
        let result2 = "";
        stringifier(this, (i2) => {
          result2 += i2;
        });
        return result2;
      }
      assign(overrides = {}) {
        for (let name in overrides) {
          this[name] = overrides[name];
        }
        return this;
      }
      clone(overrides = {}) {
        let cloned = cloneNode(this);
        for (let name in overrides) {
          cloned[name] = overrides[name];
        }
        return cloned;
      }
      cloneBefore(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertBefore(this, cloned);
        return cloned;
      }
      cloneAfter(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertAfter(this, cloned);
        return cloned;
      }
      replaceWith(...nodes) {
        if (this.parent) {
          let bookmark = this;
          let foundSelf = false;
          for (let node2 of nodes) {
            if (node2 === this) {
              foundSelf = true;
            } else if (foundSelf) {
              this.parent.insertAfter(bookmark, node2);
              bookmark = node2;
            } else {
              this.parent.insertBefore(bookmark, node2);
            }
          }
          if (!foundSelf) {
            this.remove();
          }
        }
        return this;
      }
      next() {
        if (!this.parent)
          return void 0;
        let index2 = this.parent.index(this);
        return this.parent.nodes[index2 + 1];
      }
      prev() {
        if (!this.parent)
          return void 0;
        let index2 = this.parent.index(this);
        return this.parent.nodes[index2 - 1];
      }
      before(add) {
        this.parent.insertBefore(this, add);
        return this;
      }
      after(add) {
        this.parent.insertAfter(this, add);
        return this;
      }
      root() {
        let result2 = this;
        while (result2.parent && result2.parent.type !== "document") {
          result2 = result2.parent;
        }
        return result2;
      }
      raw(prop, defaultType) {
        let str = new Stringifier();
        return str.raw(this, prop, defaultType);
      }
      cleanRaws(keepBetween) {
        delete this.raws.before;
        delete this.raws.after;
        if (!keepBetween)
          delete this.raws.between;
      }
      toJSON(_2, inputs) {
        let fixed = {};
        let emitInputs = inputs == null;
        inputs = inputs || new Map();
        let inputsNextIndex = 0;
        for (let name in this) {
          if (!Object.prototype.hasOwnProperty.call(this, name)) {
            continue;
          }
          if (name === "parent" || name === "proxyCache")
            continue;
          let value = this[name];
          if (Array.isArray(value)) {
            fixed[name] = value.map((i2) => {
              if (typeof i2 === "object" && i2.toJSON) {
                return i2.toJSON(null, inputs);
              } else {
                return i2;
              }
            });
          } else if (typeof value === "object" && value.toJSON) {
            fixed[name] = value.toJSON(null, inputs);
          } else if (name === "source") {
            let inputId = inputs.get(value.input);
            if (inputId == null) {
              inputId = inputsNextIndex;
              inputs.set(value.input, inputsNextIndex);
              inputsNextIndex++;
            }
            fixed[name] = {
              inputId,
              start: value.start,
              end: value.end
            };
          } else {
            fixed[name] = value;
          }
        }
        if (emitInputs) {
          fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
        }
        return fixed;
      }
      positionInside(index2) {
        let string2 = this.toString();
        let column = this.source.start.column;
        let line = this.source.start.line;
        for (let i2 = 0; i2 < index2; i2++) {
          if (string2[i2] === "\n") {
            column = 1;
            line += 1;
          } else {
            column += 1;
          }
        }
        return { line, column };
      }
      positionBy(opts) {
        let pos = this.source.start;
        if (opts.index) {
          pos = this.positionInside(opts.index);
        } else if (opts.word) {
          let index2 = this.toString().indexOf(opts.word);
          if (index2 !== -1)
            pos = this.positionInside(index2);
        }
        return pos;
      }
      rangeBy(opts) {
        let start = {
          line: this.source.start.line,
          column: this.source.start.column
        };
        let end = this.source.end ? {
          line: this.source.end.line,
          column: this.source.end.column + 1
        } : {
          line: start.line,
          column: start.column + 1
        };
        if (opts.word) {
          let index2 = this.toString().indexOf(opts.word);
          if (index2 !== -1) {
            start = this.positionInside(index2);
            end = this.positionInside(index2 + opts.word.length);
          }
        } else {
          if (opts.start) {
            start = {
              line: opts.start.line,
              column: opts.start.column
            };
          } else if (opts.index) {
            start = this.positionInside(opts.index);
          }
          if (opts.end) {
            end = {
              line: opts.end.line,
              column: opts.end.column
            };
          } else if (opts.endIndex) {
            end = this.positionInside(opts.endIndex);
          } else if (opts.index) {
            end = this.positionInside(opts.index + 1);
          }
        }
        if (end.line < start.line || end.line === start.line && end.column <= start.column) {
          end = { line: start.line, column: start.column + 1 };
        }
        return { start, end };
      }
      getProxyProcessor() {
        return {
          set(node2, prop, value) {
            if (node2[prop] === value)
              return true;
            node2[prop] = value;
            if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || prop === "text") {
              node2.markDirty();
            }
            return true;
          },
          get(node2, prop) {
            if (prop === "proxyOf") {
              return node2;
            } else if (prop === "root") {
              return () => node2.root().toProxy();
            } else {
              return node2[prop];
            }
          }
        };
      }
      toProxy() {
        if (!this.proxyCache) {
          this.proxyCache = new Proxy(this, this.getProxyProcessor());
        }
        return this.proxyCache;
      }
      addToError(error2) {
        error2.postcssNode = this;
        if (error2.stack && this.source && /\n\s{4}at /.test(error2.stack)) {
          let s2 = this.source;
          error2.stack = error2.stack.replace(/\n\s{4}at /, `$&${s2.input.from}:${s2.start.line}:${s2.start.column}$&`);
        }
        return error2;
      }
      markDirty() {
        if (this[isClean]) {
          this[isClean] = false;
          let next = this;
          while (next = next.parent) {
            next[isClean] = false;
          }
        }
      }
      get proxyOf() {
        return this;
      }
    };
    module2.exports = Node2;
    Node2.default = Node2;
  }
});

// node_modules/postcss/lib/declaration.js
var require_declaration = __commonJS({
  "node_modules/postcss/lib/declaration.js"(exports2, module2) {
    "use strict";
    var Node2 = require_node();
    var Declaration = class extends Node2 {
      constructor(defaults2) {
        if (defaults2 && typeof defaults2.value !== "undefined" && typeof defaults2.value !== "string") {
          defaults2 = __spreadProps2(__spreadValues2({}, defaults2), { value: String(defaults2.value) });
        }
        super(defaults2);
        this.type = "decl";
      }
      get variable() {
        return this.prop.startsWith("--") || this.prop[0] === "$";
      }
    };
    module2.exports = Declaration;
    Declaration.default = Declaration;
  }
});

// node_modules/source-map-js/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map-js/lib/base64.js"(exports2) {
    var intToCharMap2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports2.encode = function(number) {
      if (0 <= number && number < intToCharMap2.length) {
        return intToCharMap2[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports2.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash2 = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash2) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map-js/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map-js/lib/base64-vlq.js"(exports2) {
    var base642 = require_base64();
    var VLQ_BASE_SHIFT2 = 5;
    var VLQ_BASE2 = 1 << VLQ_BASE_SHIFT2;
    var VLQ_BASE_MASK2 = VLQ_BASE2 - 1;
    var VLQ_CONTINUATION_BIT2 = VLQ_BASE2;
    function toVLQSigned2(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned2(aValue) {
      var isNegative2 = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative2 ? -shifted : shifted;
    }
    exports2.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned2(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK2;
        vlq >>>= VLQ_BASE_SHIFT2;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT2;
        }
        encoded += base642.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result2 = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base642.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT2);
        digit &= VLQ_BASE_MASK2;
        result2 = result2 + (digit << shift);
        shift += VLQ_BASE_SHIFT2;
      } while (continuation);
      aOutParam.value = fromVLQSigned2(result2);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map-js/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map-js/lib/util.js"(exports2) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match2 = aUrl.match(urlRegexp);
      if (!match2) {
        return null;
      }
      return {
        scheme: match2[1],
        auth: match2[2],
        host: match2[3],
        port: match2[4],
        path: match2[5]
      };
    }
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url2 = "";
      if (aParsedUrl.scheme) {
        url2 += aParsedUrl.scheme + ":";
      }
      url2 += "//";
      if (aParsedUrl.auth) {
        url2 += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url2 += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url2 += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url2 += aParsedUrl.path;
      }
      return url2;
    }
    exports2.urlGenerate = urlGenerate;
    var MAX_CACHED_INPUTS = 32;
    function lruMemoize(f2) {
      var cache2 = [];
      return function(input) {
        for (var i2 = 0; i2 < cache2.length; i2++) {
          if (cache2[i2].input === input) {
            var temp = cache2[0];
            cache2[0] = cache2[i2];
            cache2[i2] = temp;
            return cache2[0].result;
          }
        }
        var result2 = f2(input);
        cache2.unshift({
          input,
          result: result2
        });
        if (cache2.length > MAX_CACHED_INPUTS) {
          cache2.pop();
        }
        return result2;
      };
    }
    var normalize = lruMemoize(function normalize2(aPath) {
      var path2 = aPath;
      var url2 = urlParse(aPath);
      if (url2) {
        if (!url2.path) {
          return aPath;
        }
        path2 = url2.path;
      }
      var isAbsolute2 = exports2.isAbsolute(path2);
      var parts = [];
      var start = 0;
      var i2 = 0;
      while (true) {
        start = i2;
        i2 = path2.indexOf("/", start);
        if (i2 === -1) {
          parts.push(path2.slice(start));
          break;
        } else {
          parts.push(path2.slice(start, i2));
          while (i2 < path2.length && path2[i2] === "/") {
            i2++;
          }
        }
      }
      for (var part, up = 0, i2 = parts.length - 1; i2 >= 0; i2--) {
        part = parts[i2];
        if (part === ".") {
          parts.splice(i2, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i2 + 1, up);
            up = 0;
          } else {
            parts.splice(i2, 2);
            up--;
          }
        }
      }
      path2 = parts.join("/");
      if (path2 === "") {
        path2 = isAbsolute2 ? "/" : ".";
      }
      if (url2) {
        url2.path = path2;
        return urlGenerate(url2);
      }
      return path2;
    });
    exports2.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports2.join = join;
    exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index2 = aRoot.lastIndexOf("/");
        if (index2 < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index2);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports2.relative = relative;
    var supportsNullProto = function() {
      var obj = Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s2) {
      return s2;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports2.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s2) {
      if (!s2) {
        return false;
      }
      var length = s2.length;
      if (length < 9) {
        return false;
      }
      if (s2.charCodeAt(length - 1) !== 95 || s2.charCodeAt(length - 2) !== 95 || s2.charCodeAt(length - 3) !== 111 || s2.charCodeAt(length - 4) !== 116 || s2.charCodeAt(length - 5) !== 111 || s2.charCodeAt(length - 6) !== 114 || s2.charCodeAt(length - 7) !== 112 || s2.charCodeAt(length - 8) !== 95 || s2.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i2 = length - 10; i2 >= 0; i2--) {
        if (s2.charCodeAt(i2) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
      var cmp;
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports2.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index2 = parsed.path.lastIndexOf("/");
          if (index2 >= 0) {
            parsed.path = parsed.path.substring(0, index2 + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports2.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map-js/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map-js/lib/array-set.js"(exports2) {
    var util2 = require_util();
    var has2 = Object.prototype.hasOwnProperty;
    var hasNativeMap2 = typeof Map !== "undefined";
    function ArraySet2() {
      this._array = [];
      this._set = hasNativeMap2 ? new Map() : Object.create(null);
    }
    ArraySet2.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set2 = new ArraySet2();
      for (var i2 = 0, len = aArray.length; i2 < len; i2++) {
        set2.add(aArray[i2], aAllowDuplicates);
      }
      return set2;
    };
    ArraySet2.prototype.size = function ArraySet_size() {
      return hasNativeMap2 ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet2.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap2 ? aStr : util2.toSetString(aStr);
      var isDuplicate = hasNativeMap2 ? this.has(aStr) : has2.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap2) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet2.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap2) {
        return this._set.has(aStr);
      } else {
        var sStr = util2.toSetString(aStr);
        return has2.call(this._set, sStr);
      }
    };
    ArraySet2.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap2) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util2.toSetString(aStr);
        if (has2.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet2.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet2.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports2.ArraySet = ArraySet2;
  }
});

// node_modules/source-map-js/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map-js/lib/mapping-list.js"(exports2) {
    var util2 = require_util();
    function generatedPositionAfter2(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util2.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList2() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList2.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList2.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter2(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList2.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util2.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports2.MappingList = MappingList2;
  }
});

// node_modules/source-map-js/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map-js/lib/source-map-generator.js"(exports2) {
    var base64VLQ2 = require_base64_vlq();
    var util2 = require_util();
    var ArraySet2 = require_array_set().ArraySet;
    var MappingList2 = require_mapping_list().MappingList;
    function SourceMapGenerator2(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util2.getArg(aArgs, "file", null);
      this._sourceRoot = util2.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util2.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet2();
      this._names = new ArraySet2();
      this._mappings = new MappingList2();
      this._sourcesContents = null;
    }
    SourceMapGenerator2.prototype._version = 3;
    SourceMapGenerator2.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator2({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util2.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util2.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content2 = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content2 != null) {
          generator.setSourceContent(sourceFile, content2);
        }
      });
      return generator;
    };
    SourceMapGenerator2.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util2.getArg(aArgs, "generated");
      var original = util2.getArg(aArgs, "original", null);
      var source2 = util2.getArg(aArgs, "source", null);
      var name = util2.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source2, name);
      }
      if (source2 != null) {
        source2 = String(source2);
        if (!this._sources.has(source2)) {
          this._sources.add(source2);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source2,
        name
      });
    };
    SourceMapGenerator2.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source2 = aSourceFile;
      if (this._sourceRoot != null) {
        source2 = util2.relative(this._sourceRoot, source2);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util2.toSetString(source2)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util2.toSetString(source2)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator2.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util2.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet2();
      var newNames = new ArraySet2();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util2.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util2.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source2 = mapping.source;
        if (source2 != null && !newSources.has(source2)) {
          newSources.add(source2);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content2 = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content2 != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util2.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util2.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content2);
        }
      }, this);
    };
    SourceMapGenerator2.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator2.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result2 = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i2 = 0, len = mappings.length; i2 < len; i2++) {
        mapping = mappings[i2];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i2 > 0) {
            if (!util2.compareByGeneratedPositionsInflated(mapping, mappings[i2 - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ2.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ2.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ2.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ2.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ2.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result2 += next;
      }
      return result2;
    };
    SourceMapGenerator2.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source2) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source2 = util2.relative(aSourceRoot, source2);
        }
        var key = util2.toSetString(source2);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator2.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map2 = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map2.file = this._file;
      }
      if (this._sourceRoot != null) {
        map2.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map2.sourcesContent = this._generateSourcesContent(map2.sources, map2.sourceRoot);
      }
      return map2;
    };
    SourceMapGenerator2.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports2.SourceMapGenerator = SourceMapGenerator2;
  }
});

// node_modules/source-map-js/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map-js/lib/binary-search.js"(exports2) {
    exports2.GREATEST_LOWER_BOUND = 1;
    exports2.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index2 = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports2.GREATEST_LOWER_BOUND);
      if (index2 < 0) {
        return -1;
      }
      while (index2 - 1 >= 0) {
        if (aCompare(aHaystack[index2], aHaystack[index2 - 1], true) !== 0) {
          break;
        }
        --index2;
      }
      return index2;
    };
  }
});

// node_modules/source-map-js/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/source-map-js/lib/quick-sort.js"(exports2) {
    function SortTemplate(comparator) {
      function swap2(ary, x2, y3) {
        var temp = ary[x2];
        ary[x2] = ary[y3];
        ary[y3] = temp;
      }
      function randomIntInRange2(low, high) {
        return Math.round(low + Math.random() * (high - low));
      }
      function doQuickSort2(ary, comparator2, p2, r2) {
        if (p2 < r2) {
          var pivotIndex = randomIntInRange2(p2, r2);
          var i2 = p2 - 1;
          swap2(ary, pivotIndex, r2);
          var pivot = ary[r2];
          for (var j2 = p2; j2 < r2; j2++) {
            if (comparator2(ary[j2], pivot, false) <= 0) {
              i2 += 1;
              swap2(ary, i2, j2);
            }
          }
          swap2(ary, i2 + 1, j2);
          var q2 = i2 + 1;
          doQuickSort2(ary, comparator2, p2, q2 - 1);
          doQuickSort2(ary, comparator2, q2 + 1, r2);
        }
      }
      return doQuickSort2;
    }
    function cloneSort(comparator) {
      let template2 = SortTemplate.toString();
      let templateFn = new Function(`return ${template2}`)();
      return templateFn(comparator);
    }
    var sortCache = new WeakMap();
    exports2.quickSort = function(ary, comparator, start = 0) {
      let doQuickSort2 = sortCache.get(comparator);
      if (doQuickSort2 === void 0) {
        doQuickSort2 = cloneSort(comparator);
        sortCache.set(comparator, doQuickSort2);
      }
      doQuickSort2(ary, comparator, start, ary.length - 1);
    };
  }
});

// node_modules/source-map-js/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map-js/lib/source-map-consumer.js"(exports2) {
    var util2 = require_util();
    var binarySearch2 = require_binary_search();
    var ArraySet2 = require_array_set().ArraySet;
    var base64VLQ2 = require_base64_vlq();
    var quickSort2 = require_quick_sort().quickSort;
    function SourceMapConsumer2(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util2.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer2(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer2(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer2.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer2.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer2.prototype._version = 3;
    SourceMapConsumer2.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer2.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer2.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer2.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer2.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index2) {
      var c2 = aStr.charAt(index2);
      return c2 === ";" || c2 === ",";
    };
    SourceMapConsumer2.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer2.GENERATED_ORDER = 1;
    SourceMapConsumer2.ORIGINAL_ORDER = 2;
    SourceMapConsumer2.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer2.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer2.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context2 = aContext || null;
      var order = aOrder || SourceMapConsumer2.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer2.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer2.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      var boundCallback = aCallback.bind(context2);
      var names = this._names;
      var sources = this._sources;
      var sourceMapURL = this._sourceMapURL;
      for (var i2 = 0, n3 = mappings.length; i2 < n3; i2++) {
        var mapping = mappings[i2];
        var source2 = mapping.source === null ? null : sources.at(mapping.source);
        source2 = util2.computeSourceURL(sourceRoot, source2, sourceMapURL);
        boundCallback({
          source: source2,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : names.at(mapping.name)
        });
      }
    };
    SourceMapConsumer2.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util2.getArg(aArgs, "line");
      var needle = {
        source: util2.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util2.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index2 = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util2.compareByOriginalPositions, binarySearch2.LEAST_UPPER_BOUND);
      if (index2 >= 0) {
        var mapping = this._originalMappings[index2];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util2.getArg(mapping, "generatedLine", null),
              column: util2.getArg(mapping, "generatedColumn", null),
              lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index2];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util2.getArg(mapping, "generatedLine", null),
              column: util2.getArg(mapping, "generatedColumn", null),
              lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index2];
          }
        }
      }
      return mappings;
    };
    exports2.SourceMapConsumer = SourceMapConsumer2;
    function BasicSourceMapConsumer2(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util2.parseSourceMapInput(aSourceMap);
      }
      var version2 = util2.getArg(sourceMap, "version");
      var sources = util2.getArg(sourceMap, "sources");
      var names = util2.getArg(sourceMap, "names", []);
      var sourceRoot = util2.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util2.getArg(sourceMap, "sourcesContent", null);
      var mappings = util2.getArg(sourceMap, "mappings");
      var file = util2.getArg(sourceMap, "file", null);
      if (version2 != this._version) {
        throw new Error("Unsupported version: " + version2);
      }
      if (sourceRoot) {
        sourceRoot = util2.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util2.normalize).map(function(source2) {
        return sourceRoot && util2.isAbsolute(sourceRoot) && util2.isAbsolute(source2) ? util2.relative(sourceRoot, source2) : source2;
      });
      this._names = ArraySet2.fromArray(names.map(String), true);
      this._sources = ArraySet2.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s2) {
        return util2.computeSourceURL(sourceRoot, s2, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer2.prototype = Object.create(SourceMapConsumer2.prototype);
    BasicSourceMapConsumer2.prototype.consumer = SourceMapConsumer2;
    BasicSourceMapConsumer2.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util2.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i2;
      for (i2 = 0; i2 < this._absoluteSources.length; ++i2) {
        if (this._absoluteSources[i2] == aSource) {
          return i2;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer2.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer2.prototype);
      var names = smc._names = ArraySet2.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet2.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s2) {
        return util2.computeSourceURL(smc.sourceRoot, s2, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i2 = 0, length = generatedMappings.length; i2 < length; i2++) {
        var srcMapping = generatedMappings[i2];
        var destMapping = new Mapping2();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort2(smc.__originalMappings, util2.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer2.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer2.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping2() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    var compareGenerated = util2.compareByGeneratedPositionsDeflatedNoLine;
    function sortGenerated(array2, start) {
      let l2 = array2.length;
      let n3 = array2.length - start;
      if (n3 <= 1) {
        return;
      } else if (n3 == 2) {
        let a2 = array2[start];
        let b2 = array2[start + 1];
        if (compareGenerated(a2, b2) > 0) {
          array2[start] = b2;
          array2[start + 1] = a2;
        }
      } else if (n3 < 20) {
        for (let i2 = start; i2 < l2; i2++) {
          for (let j2 = i2; j2 > start; j2--) {
            let a2 = array2[j2 - 1];
            let b2 = array2[j2];
            if (compareGenerated(a2, b2) <= 0) {
              break;
            }
            array2[j2 - 1] = b2;
            array2[j2] = a2;
          }
        }
      } else {
        quickSort2(array2, compareGenerated, start);
      }
    }
    BasicSourceMapConsumer2.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index2 = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      let subarrayStart = 0;
      while (index2 < length) {
        if (aStr.charAt(index2) === ";") {
          generatedLine++;
          index2++;
          previousGeneratedColumn = 0;
          sortGenerated(generatedMappings, subarrayStart);
          subarrayStart = generatedMappings.length;
        } else if (aStr.charAt(index2) === ",") {
          index2++;
        } else {
          mapping = new Mapping2();
          mapping.generatedLine = generatedLine;
          for (end = index2; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index2, end);
          segment = [];
          while (index2 < end) {
            base64VLQ2.decode(aStr, index2, temp);
            value = temp.value;
            index2 = temp.rest;
            segment.push(value);
          }
          if (segment.length === 2) {
            throw new Error("Found a source, but no line and column");
          }
          if (segment.length === 3) {
            throw new Error("Found a source and line, but no column");
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            let currentSource = mapping.source;
            while (originalMappings.length <= currentSource) {
              originalMappings.push(null);
            }
            if (originalMappings[currentSource] === null) {
              originalMappings[currentSource] = [];
            }
            originalMappings[currentSource].push(mapping);
          }
        }
      }
      sortGenerated(generatedMappings, subarrayStart);
      this.__generatedMappings = generatedMappings;
      for (var i2 = 0; i2 < originalMappings.length; i2++) {
        if (originalMappings[i2] != null) {
          quickSort2(originalMappings[i2], util2.compareByOriginalPositionsNoSource);
        }
      }
      this.__originalMappings = [].concat(...originalMappings);
    };
    BasicSourceMapConsumer2.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch2.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer2.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index2 = 0; index2 < this._generatedMappings.length; ++index2) {
        var mapping = this._generatedMappings[index2];
        if (index2 + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index2 + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer2.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util2.getArg(aArgs, "line"),
        generatedColumn: util2.getArg(aArgs, "column")
      };
      var index2 = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util2.compareByGeneratedPositionsDeflated, util2.getArg(aArgs, "bias", SourceMapConsumer2.GREATEST_LOWER_BOUND));
      if (index2 >= 0) {
        var mapping = this._generatedMappings[index2];
        if (mapping.generatedLine === needle.generatedLine) {
          var source2 = util2.getArg(mapping, "source", null);
          if (source2 !== null) {
            source2 = this._sources.at(source2);
            source2 = util2.computeSourceURL(this.sourceRoot, source2, this._sourceMapURL);
          }
          var name = util2.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source: source2,
            line: util2.getArg(mapping, "originalLine", null),
            column: util2.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer2.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer2.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index2 = this._findSourceIndex(aSource);
      if (index2 >= 0) {
        return this.sourcesContent[index2];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util2.relative(this.sourceRoot, relativeSource);
      }
      var url2;
      if (this.sourceRoot != null && (url2 = util2.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url2.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url2.path || url2.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer2.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source2 = util2.getArg(aArgs, "source");
      source2 = this._findSourceIndex(source2);
      if (source2 < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source: source2,
        originalLine: util2.getArg(aArgs, "line"),
        originalColumn: util2.getArg(aArgs, "column")
      };
      var index2 = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util2.compareByOriginalPositions, util2.getArg(aArgs, "bias", SourceMapConsumer2.GREATEST_LOWER_BOUND));
      if (index2 >= 0) {
        var mapping = this._originalMappings[index2];
        if (mapping.source === needle.source) {
          return {
            line: util2.getArg(mapping, "generatedLine", null),
            column: util2.getArg(mapping, "generatedColumn", null),
            lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports2.BasicSourceMapConsumer = BasicSourceMapConsumer2;
    function IndexedSourceMapConsumer2(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util2.parseSourceMapInput(aSourceMap);
      }
      var version2 = util2.getArg(sourceMap, "version");
      var sections = util2.getArg(sourceMap, "sections");
      if (version2 != this._version) {
        throw new Error("Unsupported version: " + version2);
      }
      this._sources = new ArraySet2();
      this._names = new ArraySet2();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s2) {
        if (s2.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset2 = util2.getArg(s2, "offset");
        var offsetLine = util2.getArg(offset2, "line");
        var offsetColumn = util2.getArg(offset2, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset2;
        return {
          generatedOffset: {
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer2(util2.getArg(s2, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer2.prototype = Object.create(SourceMapConsumer2.prototype);
    IndexedSourceMapConsumer2.prototype.constructor = SourceMapConsumer2;
    IndexedSourceMapConsumer2.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer2.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i2 = 0; i2 < this._sections.length; i2++) {
          for (var j2 = 0; j2 < this._sections[i2].consumer.sources.length; j2++) {
            sources.push(this._sections[i2].consumer.sources[j2]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer2.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util2.getArg(aArgs, "line"),
        generatedColumn: util2.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch2.search(needle, this._sections, function(needle2, section2) {
        var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }
        return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
      });
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer2.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s2) {
        return s2.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer2.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        var content2 = section.consumer.sourceContentFor(aSource, true);
        if (content2) {
          return content2;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer2.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        if (section.consumer._findSourceIndex(util2.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer2.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j2 = 0; j2 < sectionMappings.length; j2++) {
          var mapping = sectionMappings[j2];
          var source2 = section.consumer._sources.at(mapping.source);
          source2 = util2.computeSourceURL(section.consumer.sourceRoot, source2, this._sourceMapURL);
          this._sources.add(source2);
          source2 = this._sources.indexOf(source2);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source: source2,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort2(this.__generatedMappings, util2.compareByGeneratedPositionsDeflated);
      quickSort2(this.__originalMappings, util2.compareByOriginalPositions);
    };
    exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer2;
  }
});

// node_modules/source-map-js/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map-js/lib/source-node.js"(exports2) {
    var SourceMapGenerator2 = require_source_map_generator().SourceMapGenerator;
    var util2 = require_util();
    var REGEX_NEWLINE2 = /(\r?\n)/;
    var NEWLINE_CODE2 = 10;
    var isSourceNode2 = "$$$isSourceNode$$$";
    function SourceNode2(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode2] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode2.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node2 = new SourceNode2();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE2);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node2.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node2.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node2.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content2 = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content2 != null) {
          if (aRelativePath != null) {
            sourceFile = util2.join(aRelativePath, sourceFile);
          }
          node2.setSourceContent(sourceFile, content2);
        }
      });
      return node2;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node2.add(code);
        } else {
          var source2 = aRelativePath ? util2.join(aRelativePath, mapping.source) : mapping.source;
          node2.add(new SourceNode2(mapping.originalLine, mapping.originalColumn, source2, code, mapping.name));
        }
      }
    };
    SourceNode2.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode2] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode2.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i2 = aChunk.length - 1; i2 >= 0; i2--) {
          this.prepend(aChunk[i2]);
        }
      } else if (aChunk[isSourceNode2] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode2.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i2 = 0, len = this.children.length; i2 < len; i2++) {
        chunk = this.children[i2];
        if (chunk[isSourceNode2]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode2.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i2;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i2 = 0; i2 < len - 1; i2++) {
          newChildren.push(this.children[i2]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i2]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode2.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode2]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode2.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util2.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode2.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i2 = 0, len = this.children.length; i2 < len; i2++) {
        if (this.children[i2][isSourceNode2]) {
          this.children[i2].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i2 = 0, len = sources.length; i2 < len; i2++) {
        aFn(util2.fromSetString(sources[i2]), this.sourceContents[sources[i2]]);
      }
    };
    SourceNode2.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode2.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map2 = new SourceMapGenerator2(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map2.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map2.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE2) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map2.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map2.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map: map2 };
    };
    exports2.SourceNode = SourceNode2;
  }
});

// node_modules/source-map-js/source-map.js
var require_source_map = __commonJS({
  "node_modules/source-map-js/source-map.js"(exports2) {
    exports2.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports2.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports2.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/nanoid/non-secure/index.js
var non_secure_exports = {};
__export(non_secure_exports, {
  customAlphabet: () => customAlphabet,
  nanoid: () => nanoid
});
var urlAlphabet, customAlphabet, nanoid;
var init_non_secure = __esm({
  "node_modules/nanoid/non-secure/index.js"() {
    urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    customAlphabet = (alphabet, size) => {
      return () => {
        let id = "";
        let i2 = size;
        while (i2--) {
          id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
      };
    };
    nanoid = (size = 21) => {
      let id = "";
      let i2 = size;
      while (i2--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    };
  }
});

// node_modules/postcss/lib/previous-map.js
var require_previous_map = __commonJS({
  "node_modules/postcss/lib/previous-map.js"(exports2, module2) {
    "use strict";
    var { SourceMapConsumer: SourceMapConsumer2, SourceMapGenerator: SourceMapGenerator2 } = require_source_map();
    var { existsSync, readFileSync } = (init_fs(), fs_exports);
    var { dirname, join } = (init_path(), path_exports);
    function fromBase64(str) {
      if (Buffer) {
        return Buffer.from(str, "base64").toString();
      } else {
        return window.atob(str);
      }
    }
    var PreviousMap = class {
      constructor(css, opts) {
        if (opts.map === false)
          return;
        this.loadAnnotation(css);
        this.inline = this.startWith(this.annotation, "data:");
        let prev = opts.map ? opts.map.prev : void 0;
        let text = this.loadMap(opts.from, prev);
        if (!this.mapFile && opts.from) {
          this.mapFile = opts.from;
        }
        if (this.mapFile)
          this.root = dirname(this.mapFile);
        if (text)
          this.text = text;
      }
      consumer() {
        if (!this.consumerCache) {
          this.consumerCache = new SourceMapConsumer2(this.text);
        }
        return this.consumerCache;
      }
      withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
      }
      startWith(string2, start) {
        if (!string2)
          return false;
        return string2.substr(0, start.length) === start;
      }
      getAnnotationURL(sourceMapString) {
        return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
      }
      loadAnnotation(css) {
        let comments = css.match(/\/\*\s*# sourceMappingURL=/gm);
        if (!comments)
          return;
        let start = css.lastIndexOf(comments.pop());
        let end = css.indexOf("*/", start);
        if (start > -1 && end > -1) {
          this.annotation = this.getAnnotationURL(css.substring(start, end));
        }
      }
      decodeInline(text) {
        let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
        let baseUri = /^data:application\/json;base64,/;
        let charsetUri = /^data:application\/json;charset=utf-?8,/;
        let uri = /^data:application\/json,/;
        if (charsetUri.test(text) || uri.test(text)) {
          return decodeURIComponent(text.substr(RegExp.lastMatch.length));
        }
        if (baseCharsetUri.test(text) || baseUri.test(text)) {
          return fromBase64(text.substr(RegExp.lastMatch.length));
        }
        let encoding2 = text.match(/data:application\/json;([^,]+),/)[1];
        throw new Error("Unsupported source map encoding " + encoding2);
      }
      loadFile(path2) {
        this.root = dirname(path2);
        if (existsSync(path2)) {
          this.mapFile = path2;
          return readFileSync(path2, "utf-8").toString().trim();
        }
      }
      loadMap(file, prev) {
        if (prev === false)
          return false;
        if (prev) {
          if (typeof prev === "string") {
            return prev;
          } else if (typeof prev === "function") {
            let prevPath = prev(file);
            if (prevPath) {
              let map2 = this.loadFile(prevPath);
              if (!map2) {
                throw new Error("Unable to load previous source map: " + prevPath.toString());
              }
              return map2;
            }
          } else if (prev instanceof SourceMapConsumer2) {
            return SourceMapGenerator2.fromSourceMap(prev).toString();
          } else if (prev instanceof SourceMapGenerator2) {
            return prev.toString();
          } else if (this.isMap(prev)) {
            return JSON.stringify(prev);
          } else {
            throw new Error("Unsupported previous source map format: " + prev.toString());
          }
        } else if (this.inline) {
          return this.decodeInline(this.annotation);
        } else if (this.annotation) {
          let map2 = this.annotation;
          if (file)
            map2 = join(dirname(file), map2);
          return this.loadFile(map2);
        }
      }
      isMap(map2) {
        if (typeof map2 !== "object")
          return false;
        return typeof map2.mappings === "string" || typeof map2._mappings === "string" || Array.isArray(map2.sections);
      }
    };
    module2.exports = PreviousMap;
    PreviousMap.default = PreviousMap;
  }
});

// node_modules/postcss/lib/input.js
var require_input = __commonJS({
  "node_modules/postcss/lib/input.js"(exports2, module2) {
    "use strict";
    var { SourceMapConsumer: SourceMapConsumer2, SourceMapGenerator: SourceMapGenerator2 } = require_source_map();
    var { fileURLToPath, pathToFileURL } = (init_url(), url_exports);
    var { resolve: resolve2, isAbsolute: isAbsolute2 } = (init_path(), path_exports);
    var { nanoid: nanoid2 } = (init_non_secure(), non_secure_exports);
    var terminalHighlight = require_terminal_highlight();
    var CssSyntaxError = require_css_syntax_error();
    var PreviousMap = require_previous_map();
    var fromOffsetCache = Symbol("fromOffsetCache");
    var sourceMapAvailable = Boolean(SourceMapConsumer2 && SourceMapGenerator2);
    var pathAvailable = Boolean(resolve2 && isAbsolute2);
    var Input = class {
      constructor(css, opts = {}) {
        if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
          throw new Error(`PostCSS received ${css} instead of CSS string`);
        }
        this.css = css.toString();
        if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
          this.hasBOM = true;
          this.css = this.css.slice(1);
        } else {
          this.hasBOM = false;
        }
        if (opts.from) {
          if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute2(opts.from)) {
            this.file = opts.from;
          } else {
            this.file = resolve2(opts.from);
          }
        }
        if (pathAvailable && sourceMapAvailable) {
          let map2 = new PreviousMap(this.css, opts);
          if (map2.text) {
            this.map = map2;
            let file = map2.consumer().file;
            if (!this.file && file)
              this.file = this.mapResolve(file);
          }
        }
        if (!this.file) {
          this.id = "<input css " + nanoid2(6) + ">";
        }
        if (this.map)
          this.map.file = this.from;
      }
      fromOffset(offset2) {
        let lastLine, lineToIndex;
        if (!this[fromOffsetCache]) {
          let lines = this.css.split("\n");
          lineToIndex = new Array(lines.length);
          let prevIndex = 0;
          for (let i2 = 0, l2 = lines.length; i2 < l2; i2++) {
            lineToIndex[i2] = prevIndex;
            prevIndex += lines[i2].length + 1;
          }
          this[fromOffsetCache] = lineToIndex;
        } else {
          lineToIndex = this[fromOffsetCache];
        }
        lastLine = lineToIndex[lineToIndex.length - 1];
        let min2 = 0;
        if (offset2 >= lastLine) {
          min2 = lineToIndex.length - 1;
        } else {
          let max = lineToIndex.length - 2;
          let mid;
          while (min2 < max) {
            mid = min2 + (max - min2 >> 1);
            if (offset2 < lineToIndex[mid]) {
              max = mid - 1;
            } else if (offset2 >= lineToIndex[mid + 1]) {
              min2 = mid + 1;
            } else {
              min2 = mid;
              break;
            }
          }
        }
        return {
          line: min2 + 1,
          col: offset2 - lineToIndex[min2] + 1
        };
      }
      error(message, line, column, opts = {}) {
        let result2, endLine, endColumn;
        if (line && typeof line === "object") {
          let start = line;
          let end = column;
          if (typeof line.offset === "number") {
            let pos = this.fromOffset(start.offset);
            line = pos.line;
            column = pos.col;
          } else {
            line = start.line;
            column = start.column;
          }
          if (typeof end.offset === "number") {
            let pos = this.fromOffset(end.offset);
            endLine = pos.line;
            endColumn = pos.col;
          } else {
            endLine = end.line;
            endColumn = end.column;
          }
        } else if (!column) {
          let pos = this.fromOffset(line);
          line = pos.line;
          column = pos.col;
        }
        let origin = this.origin(line, column, endLine, endColumn);
        if (origin) {
          result2 = new CssSyntaxError(message, origin.endLine === void 0 ? origin.line : { line: origin.line, column: origin.column }, origin.endLine === void 0 ? origin.column : { line: origin.endLine, column: origin.endColumn }, origin.source, origin.file, opts.plugin);
        } else {
          result2 = new CssSyntaxError(message, endLine === void 0 ? line : { line, column }, endLine === void 0 ? column : { line: endLine, column: endColumn }, this.css, this.file, opts.plugin);
        }
        result2.input = { line, column, endLine, endColumn, source: this.css };
        if (this.file) {
          if (pathToFileURL) {
            result2.input.url = pathToFileURL(this.file).toString();
          }
          result2.input.file = this.file;
        }
        return result2;
      }
      origin(line, column, endLine, endColumn) {
        if (!this.map)
          return false;
        let consumer = this.map.consumer();
        let from = consumer.originalPositionFor({ line, column });
        if (!from.source)
          return false;
        let to2;
        if (typeof endLine === "number") {
          to2 = consumer.originalPositionFor({ line: endLine, column: endColumn });
        }
        let fromUrl;
        if (isAbsolute2(from.source)) {
          fromUrl = pathToFileURL(from.source);
        } else {
          fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile));
        }
        let result2 = {
          url: fromUrl.toString(),
          line: from.line,
          column: from.column,
          endLine: to2 && to2.line,
          endColumn: to2 && to2.column
        };
        if (fromUrl.protocol === "file:") {
          if (fileURLToPath) {
            result2.file = fileURLToPath(fromUrl);
          } else {
            throw new Error(`file: protocol is not available in this PostCSS build`);
          }
        }
        let source2 = consumer.sourceContentFor(from.source);
        if (source2)
          result2.source = source2;
        return result2;
      }
      mapResolve(file) {
        if (/^\w+:\/\//.test(file)) {
          return file;
        }
        return resolve2(this.map.consumer().sourceRoot || this.map.root || ".", file);
      }
      get from() {
        return this.file || this.id;
      }
      toJSON() {
        let json2 = {};
        for (let name of ["hasBOM", "css", "file", "id"]) {
          if (this[name] != null) {
            json2[name] = this[name];
          }
        }
        if (this.map) {
          json2.map = __spreadValues2({}, this.map);
          if (json2.map.consumerCache) {
            json2.map.consumerCache = void 0;
          }
        }
        return json2;
      }
    };
    module2.exports = Input;
    Input.default = Input;
    if (terminalHighlight && terminalHighlight.registerInput) {
      terminalHighlight.registerInput(Input);
    }
  }
});

// node_modules/postcss/lib/map-generator.js
var require_map_generator = __commonJS({
  "node_modules/postcss/lib/map-generator.js"(exports2, module2) {
    "use strict";
    var { SourceMapConsumer: SourceMapConsumer2, SourceMapGenerator: SourceMapGenerator2 } = require_source_map();
    var { dirname, resolve: resolve2, relative, sep } = (init_path(), path_exports);
    var { pathToFileURL } = (init_url(), url_exports);
    var Input = require_input();
    var sourceMapAvailable = Boolean(SourceMapConsumer2 && SourceMapGenerator2);
    var pathAvailable = Boolean(dirname && resolve2 && relative && sep);
    var MapGenerator = class {
      constructor(stringify2, root, opts, cssString) {
        this.stringify = stringify2;
        this.mapOpts = opts.map || {};
        this.root = root;
        this.opts = opts;
        this.css = cssString;
      }
      isMap() {
        if (typeof this.opts.map !== "undefined") {
          return !!this.opts.map;
        }
        return this.previous().length > 0;
      }
      previous() {
        if (!this.previousMaps) {
          this.previousMaps = [];
          if (this.root) {
            this.root.walk((node2) => {
              if (node2.source && node2.source.input.map) {
                let map2 = node2.source.input.map;
                if (!this.previousMaps.includes(map2)) {
                  this.previousMaps.push(map2);
                }
              }
            });
          } else {
            let input = new Input(this.css, this.opts);
            if (input.map)
              this.previousMaps.push(input.map);
          }
        }
        return this.previousMaps;
      }
      isInline() {
        if (typeof this.mapOpts.inline !== "undefined") {
          return this.mapOpts.inline;
        }
        let annotation = this.mapOpts.annotation;
        if (typeof annotation !== "undefined" && annotation !== true) {
          return false;
        }
        if (this.previous().length) {
          return this.previous().some((i2) => i2.inline);
        }
        return true;
      }
      isSourcesContent() {
        if (typeof this.mapOpts.sourcesContent !== "undefined") {
          return this.mapOpts.sourcesContent;
        }
        if (this.previous().length) {
          return this.previous().some((i2) => i2.withContent());
        }
        return true;
      }
      clearAnnotation() {
        if (this.mapOpts.annotation === false)
          return;
        if (this.root) {
          let node2;
          for (let i2 = this.root.nodes.length - 1; i2 >= 0; i2--) {
            node2 = this.root.nodes[i2];
            if (node2.type !== "comment")
              continue;
            if (node2.text.indexOf("# sourceMappingURL=") === 0) {
              this.root.removeChild(i2);
            }
          }
        } else if (this.css) {
          this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, "");
        }
      }
      setSourcesContent() {
        let already = {};
        if (this.root) {
          this.root.walk((node2) => {
            if (node2.source) {
              let from = node2.source.input.from;
              if (from && !already[from]) {
                already[from] = true;
                this.map.setSourceContent(this.toUrl(this.path(from)), node2.source.input.css);
              }
            }
          });
        } else if (this.css) {
          let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
          this.map.setSourceContent(from, this.css);
        }
      }
      applyPrevMaps() {
        for (let prev of this.previous()) {
          let from = this.toUrl(this.path(prev.file));
          let root = prev.root || dirname(prev.file);
          let map2;
          if (this.mapOpts.sourcesContent === false) {
            map2 = new SourceMapConsumer2(prev.text);
            if (map2.sourcesContent) {
              map2.sourcesContent = map2.sourcesContent.map(() => null);
            }
          } else {
            map2 = prev.consumer();
          }
          this.map.applySourceMap(map2, from, this.toUrl(this.path(root)));
        }
      }
      isAnnotation() {
        if (this.isInline()) {
          return true;
        }
        if (typeof this.mapOpts.annotation !== "undefined") {
          return this.mapOpts.annotation;
        }
        if (this.previous().length) {
          return this.previous().some((i2) => i2.annotation);
        }
        return true;
      }
      toBase64(str) {
        if (Buffer) {
          return Buffer.from(str).toString("base64");
        } else {
          return window.btoa(unescape(encodeURIComponent(str)));
        }
      }
      addAnnotation() {
        let content2;
        if (this.isInline()) {
          content2 = "data:application/json;base64," + this.toBase64(this.map.toString());
        } else if (typeof this.mapOpts.annotation === "string") {
          content2 = this.mapOpts.annotation;
        } else if (typeof this.mapOpts.annotation === "function") {
          content2 = this.mapOpts.annotation(this.opts.to, this.root);
        } else {
          content2 = this.outputFile() + ".map";
        }
        let eol = "\n";
        if (this.css.includes("\r\n"))
          eol = "\r\n";
        this.css += eol + "/*# sourceMappingURL=" + content2 + " */";
      }
      outputFile() {
        if (this.opts.to) {
          return this.path(this.opts.to);
        } else if (this.opts.from) {
          return this.path(this.opts.from);
        } else {
          return "to.css";
        }
      }
      generateMap() {
        if (this.root) {
          this.generateString();
        } else if (this.previous().length === 1) {
          let prev = this.previous()[0].consumer();
          prev.file = this.outputFile();
          this.map = SourceMapGenerator2.fromSourceMap(prev);
        } else {
          this.map = new SourceMapGenerator2({ file: this.outputFile() });
          this.map.addMapping({
            source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>",
            generated: { line: 1, column: 0 },
            original: { line: 1, column: 0 }
          });
        }
        if (this.isSourcesContent())
          this.setSourcesContent();
        if (this.root && this.previous().length > 0)
          this.applyPrevMaps();
        if (this.isAnnotation())
          this.addAnnotation();
        if (this.isInline()) {
          return [this.css];
        } else {
          return [this.css, this.map];
        }
      }
      path(file) {
        if (file.indexOf("<") === 0)
          return file;
        if (/^\w+:\/\//.test(file))
          return file;
        if (this.mapOpts.absolute)
          return file;
        let from = this.opts.to ? dirname(this.opts.to) : ".";
        if (typeof this.mapOpts.annotation === "string") {
          from = dirname(resolve2(from, this.mapOpts.annotation));
        }
        file = relative(from, file);
        return file;
      }
      toUrl(path2) {
        if (sep === "\\") {
          path2 = path2.replace(/\\/g, "/");
        }
        return encodeURI(path2).replace(/[#?]/g, encodeURIComponent);
      }
      sourcePath(node2) {
        if (this.mapOpts.from) {
          return this.toUrl(this.mapOpts.from);
        } else if (this.mapOpts.absolute) {
          if (pathToFileURL) {
            return pathToFileURL(node2.source.input.from).toString();
          } else {
            throw new Error("`map.absolute` option is not available in this PostCSS build");
          }
        } else {
          return this.toUrl(this.path(node2.source.input.from));
        }
      }
      generateString() {
        this.css = "";
        this.map = new SourceMapGenerator2({ file: this.outputFile() });
        let line = 1;
        let column = 1;
        let noSource = "<no source>";
        let mapping = {
          source: "",
          generated: { line: 0, column: 0 },
          original: { line: 0, column: 0 }
        };
        let lines, last;
        this.stringify(this.root, (str, node2, type) => {
          this.css += str;
          if (node2 && type !== "end") {
            mapping.generated.line = line;
            mapping.generated.column = column - 1;
            if (node2.source && node2.source.start) {
              mapping.source = this.sourcePath(node2);
              mapping.original.line = node2.source.start.line;
              mapping.original.column = node2.source.start.column - 1;
              this.map.addMapping(mapping);
            } else {
              mapping.source = noSource;
              mapping.original.line = 1;
              mapping.original.column = 0;
              this.map.addMapping(mapping);
            }
          }
          lines = str.match(/\n/g);
          if (lines) {
            line += lines.length;
            last = str.lastIndexOf("\n");
            column = str.length - last;
          } else {
            column += str.length;
          }
          if (node2 && type !== "start") {
            let p2 = node2.parent || { raws: {} };
            if (node2.type !== "decl" || node2 !== p2.last || p2.raws.semicolon) {
              if (node2.source && node2.source.end) {
                mapping.source = this.sourcePath(node2);
                mapping.original.line = node2.source.end.line;
                mapping.original.column = node2.source.end.column - 1;
                mapping.generated.line = line;
                mapping.generated.column = column - 2;
                this.map.addMapping(mapping);
              } else {
                mapping.source = noSource;
                mapping.original.line = 1;
                mapping.original.column = 0;
                mapping.generated.line = line;
                mapping.generated.column = column - 1;
                this.map.addMapping(mapping);
              }
            }
          }
        });
      }
      generate() {
        this.clearAnnotation();
        if (pathAvailable && sourceMapAvailable && this.isMap()) {
          return this.generateMap();
        } else {
          let result2 = "";
          this.stringify(this.root, (i2) => {
            result2 += i2;
          });
          return [result2];
        }
      }
    };
    module2.exports = MapGenerator;
  }
});

// node_modules/postcss/lib/comment.js
var require_comment = __commonJS({
  "node_modules/postcss/lib/comment.js"(exports2, module2) {
    "use strict";
    var Node2 = require_node();
    var Comment2 = class extends Node2 {
      constructor(defaults2) {
        super(defaults2);
        this.type = "comment";
      }
    };
    module2.exports = Comment2;
    Comment2.default = Comment2;
  }
});

// node_modules/postcss/lib/container.js
var require_container = __commonJS({
  "node_modules/postcss/lib/container.js"(exports2, module2) {
    "use strict";
    var { isClean, my } = require_symbols();
    var Declaration = require_declaration();
    var Comment2 = require_comment();
    var Node2 = require_node();
    var parse2;
    var Rule;
    var AtRule;
    function cleanSource(nodes) {
      return nodes.map((i2) => {
        if (i2.nodes)
          i2.nodes = cleanSource(i2.nodes);
        delete i2.source;
        return i2;
      });
    }
    function markDirtyUp(node2) {
      node2[isClean] = false;
      if (node2.proxyOf.nodes) {
        for (let i2 of node2.proxyOf.nodes) {
          markDirtyUp(i2);
        }
      }
    }
    var Container = class extends Node2 {
      push(child) {
        child.parent = this;
        this.proxyOf.nodes.push(child);
        return this;
      }
      each(callback) {
        if (!this.proxyOf.nodes)
          return void 0;
        let iterator = this.getIterator();
        let index2, result2;
        while (this.indexes[iterator] < this.proxyOf.nodes.length) {
          index2 = this.indexes[iterator];
          result2 = callback(this.proxyOf.nodes[index2], index2);
          if (result2 === false)
            break;
          this.indexes[iterator] += 1;
        }
        delete this.indexes[iterator];
        return result2;
      }
      walk(callback) {
        return this.each((child, i2) => {
          let result2;
          try {
            result2 = callback(child, i2);
          } catch (e2) {
            throw child.addToError(e2);
          }
          if (result2 !== false && child.walk) {
            result2 = child.walk(callback);
          }
          return result2;
        });
      }
      walkDecls(prop, callback) {
        if (!callback) {
          callback = prop;
          return this.walk((child, i2) => {
            if (child.type === "decl") {
              return callback(child, i2);
            }
          });
        }
        if (prop instanceof RegExp) {
          return this.walk((child, i2) => {
            if (child.type === "decl" && prop.test(child.prop)) {
              return callback(child, i2);
            }
          });
        }
        return this.walk((child, i2) => {
          if (child.type === "decl" && child.prop === prop) {
            return callback(child, i2);
          }
        });
      }
      walkRules(selector, callback) {
        if (!callback) {
          callback = selector;
          return this.walk((child, i2) => {
            if (child.type === "rule") {
              return callback(child, i2);
            }
          });
        }
        if (selector instanceof RegExp) {
          return this.walk((child, i2) => {
            if (child.type === "rule" && selector.test(child.selector)) {
              return callback(child, i2);
            }
          });
        }
        return this.walk((child, i2) => {
          if (child.type === "rule" && child.selector === selector) {
            return callback(child, i2);
          }
        });
      }
      walkAtRules(name, callback) {
        if (!callback) {
          callback = name;
          return this.walk((child, i2) => {
            if (child.type === "atrule") {
              return callback(child, i2);
            }
          });
        }
        if (name instanceof RegExp) {
          return this.walk((child, i2) => {
            if (child.type === "atrule" && name.test(child.name)) {
              return callback(child, i2);
            }
          });
        }
        return this.walk((child, i2) => {
          if (child.type === "atrule" && child.name === name) {
            return callback(child, i2);
          }
        });
      }
      walkComments(callback) {
        return this.walk((child, i2) => {
          if (child.type === "comment") {
            return callback(child, i2);
          }
        });
      }
      append(...children) {
        for (let child of children) {
          let nodes = this.normalize(child, this.last);
          for (let node2 of nodes)
            this.proxyOf.nodes.push(node2);
        }
        this.markDirty();
        return this;
      }
      prepend(...children) {
        children = children.reverse();
        for (let child of children) {
          let nodes = this.normalize(child, this.first, "prepend").reverse();
          for (let node2 of nodes)
            this.proxyOf.nodes.unshift(node2);
          for (let id in this.indexes) {
            this.indexes[id] = this.indexes[id] + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      cleanRaws(keepBetween) {
        super.cleanRaws(keepBetween);
        if (this.nodes) {
          for (let node2 of this.nodes)
            node2.cleanRaws(keepBetween);
        }
      }
      insertBefore(exist, add) {
        exist = this.index(exist);
        let type = exist === 0 ? "prepend" : false;
        let nodes = this.normalize(add, this.proxyOf.nodes[exist], type).reverse();
        for (let node2 of nodes)
          this.proxyOf.nodes.splice(exist, 0, node2);
        let index2;
        for (let id in this.indexes) {
          index2 = this.indexes[id];
          if (exist <= index2) {
            this.indexes[id] = index2 + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      insertAfter(exist, add) {
        exist = this.index(exist);
        let nodes = this.normalize(add, this.proxyOf.nodes[exist]).reverse();
        for (let node2 of nodes)
          this.proxyOf.nodes.splice(exist + 1, 0, node2);
        let index2;
        for (let id in this.indexes) {
          index2 = this.indexes[id];
          if (exist < index2) {
            this.indexes[id] = index2 + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      removeChild(child) {
        child = this.index(child);
        this.proxyOf.nodes[child].parent = void 0;
        this.proxyOf.nodes.splice(child, 1);
        let index2;
        for (let id in this.indexes) {
          index2 = this.indexes[id];
          if (index2 >= child) {
            this.indexes[id] = index2 - 1;
          }
        }
        this.markDirty();
        return this;
      }
      removeAll() {
        for (let node2 of this.proxyOf.nodes)
          node2.parent = void 0;
        this.proxyOf.nodes = [];
        this.markDirty();
        return this;
      }
      replaceValues(pattern2, opts, callback) {
        if (!callback) {
          callback = opts;
          opts = {};
        }
        this.walkDecls((decl) => {
          if (opts.props && !opts.props.includes(decl.prop))
            return;
          if (opts.fast && !decl.value.includes(opts.fast))
            return;
          decl.value = decl.value.replace(pattern2, callback);
        });
        this.markDirty();
        return this;
      }
      every(condition) {
        return this.nodes.every(condition);
      }
      some(condition) {
        return this.nodes.some(condition);
      }
      index(child) {
        if (typeof child === "number")
          return child;
        if (child.proxyOf)
          child = child.proxyOf;
        return this.proxyOf.nodes.indexOf(child);
      }
      get first() {
        if (!this.proxyOf.nodes)
          return void 0;
        return this.proxyOf.nodes[0];
      }
      get last() {
        if (!this.proxyOf.nodes)
          return void 0;
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
      }
      normalize(nodes, sample) {
        if (typeof nodes === "string") {
          nodes = cleanSource(parse2(nodes).nodes);
        } else if (Array.isArray(nodes)) {
          nodes = nodes.slice(0);
          for (let i2 of nodes) {
            if (i2.parent)
              i2.parent.removeChild(i2, "ignore");
          }
        } else if (nodes.type === "root" && this.type !== "document") {
          nodes = nodes.nodes.slice(0);
          for (let i2 of nodes) {
            if (i2.parent)
              i2.parent.removeChild(i2, "ignore");
          }
        } else if (nodes.type) {
          nodes = [nodes];
        } else if (nodes.prop) {
          if (typeof nodes.value === "undefined") {
            throw new Error("Value field is missed in node creation");
          } else if (typeof nodes.value !== "string") {
            nodes.value = String(nodes.value);
          }
          nodes = [new Declaration(nodes)];
        } else if (nodes.selector) {
          nodes = [new Rule(nodes)];
        } else if (nodes.name) {
          nodes = [new AtRule(nodes)];
        } else if (nodes.text) {
          nodes = [new Comment2(nodes)];
        } else {
          throw new Error("Unknown node type in node creation");
        }
        let processed = nodes.map((i2) => {
          if (!i2[my])
            Container.rebuild(i2);
          i2 = i2.proxyOf;
          if (i2.parent)
            i2.parent.removeChild(i2);
          if (i2[isClean])
            markDirtyUp(i2);
          if (typeof i2.raws.before === "undefined") {
            if (sample && typeof sample.raws.before !== "undefined") {
              i2.raws.before = sample.raws.before.replace(/\S/g, "");
            }
          }
          i2.parent = this;
          return i2;
        });
        return processed;
      }
      getProxyProcessor() {
        return {
          set(node2, prop, value) {
            if (node2[prop] === value)
              return true;
            node2[prop] = value;
            if (prop === "name" || prop === "params" || prop === "selector") {
              node2.markDirty();
            }
            return true;
          },
          get(node2, prop) {
            if (prop === "proxyOf") {
              return node2;
            } else if (!node2[prop]) {
              return node2[prop];
            } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
              return (...args) => {
                return node2[prop](...args.map((i2) => {
                  if (typeof i2 === "function") {
                    return (child, index2) => i2(child.toProxy(), index2);
                  } else {
                    return i2;
                  }
                }));
              };
            } else if (prop === "every" || prop === "some") {
              return (cb) => {
                return node2[prop]((child, ...other) => cb(child.toProxy(), ...other));
              };
            } else if (prop === "root") {
              return () => node2.root().toProxy();
            } else if (prop === "nodes") {
              return node2.nodes.map((i2) => i2.toProxy());
            } else if (prop === "first" || prop === "last") {
              return node2[prop].toProxy();
            } else {
              return node2[prop];
            }
          }
        };
      }
      getIterator() {
        if (!this.lastEach)
          this.lastEach = 0;
        if (!this.indexes)
          this.indexes = {};
        this.lastEach += 1;
        let iterator = this.lastEach;
        this.indexes[iterator] = 0;
        return iterator;
      }
    };
    Container.registerParse = (dependant) => {
      parse2 = dependant;
    };
    Container.registerRule = (dependant) => {
      Rule = dependant;
    };
    Container.registerAtRule = (dependant) => {
      AtRule = dependant;
    };
    module2.exports = Container;
    Container.default = Container;
    Container.rebuild = (node2) => {
      if (node2.type === "atrule") {
        Object.setPrototypeOf(node2, AtRule.prototype);
      } else if (node2.type === "rule") {
        Object.setPrototypeOf(node2, Rule.prototype);
      } else if (node2.type === "decl") {
        Object.setPrototypeOf(node2, Declaration.prototype);
      } else if (node2.type === "comment") {
        Object.setPrototypeOf(node2, Comment2.prototype);
      }
      node2[my] = true;
      if (node2.nodes) {
        node2.nodes.forEach((child) => {
          Container.rebuild(child);
        });
      }
    };
  }
});

// node_modules/postcss/lib/document.js
var require_document = __commonJS({
  "node_modules/postcss/lib/document.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var LazyResult;
    var Processor;
    var Document2 = class extends Container {
      constructor(defaults2) {
        super(__spreadValues2({ type: "document" }, defaults2));
        if (!this.nodes) {
          this.nodes = [];
        }
      }
      toResult(opts = {}) {
        let lazy = new LazyResult(new Processor(), this, opts);
        return lazy.stringify();
      }
    };
    Document2.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Document2.registerProcessor = (dependant) => {
      Processor = dependant;
    };
    module2.exports = Document2;
    Document2.default = Document2;
  }
});

// node_modules/postcss/lib/warn-once.js
var require_warn_once = __commonJS({
  "node_modules/postcss/lib/warn-once.js"(exports2, module2) {
    "use strict";
    var printed = {};
    module2.exports = function warnOnce(message) {
      if (printed[message])
        return;
      printed[message] = true;
      if (typeof console !== "undefined" && console.warn) {
        console.warn(message);
      }
    };
  }
});

// node_modules/postcss/lib/warning.js
var require_warning = __commonJS({
  "node_modules/postcss/lib/warning.js"(exports2, module2) {
    "use strict";
    var Warning = class {
      constructor(text, opts = {}) {
        this.type = "warning";
        this.text = text;
        if (opts.node && opts.node.source) {
          let range2 = opts.node.rangeBy(opts);
          this.line = range2.start.line;
          this.column = range2.start.column;
          this.endLine = range2.end.line;
          this.endColumn = range2.end.column;
        }
        for (let opt in opts)
          this[opt] = opts[opt];
      }
      toString() {
        if (this.node) {
          return this.node.error(this.text, {
            plugin: this.plugin,
            index: this.index,
            word: this.word
          }).message;
        }
        if (this.plugin) {
          return this.plugin + ": " + this.text;
        }
        return this.text;
      }
    };
    module2.exports = Warning;
    Warning.default = Warning;
  }
});

// node_modules/postcss/lib/result.js
var require_result = __commonJS({
  "node_modules/postcss/lib/result.js"(exports2, module2) {
    "use strict";
    var Warning = require_warning();
    var Result = class {
      constructor(processor, root, opts) {
        this.processor = processor;
        this.messages = [];
        this.root = root;
        this.opts = opts;
        this.css = void 0;
        this.map = void 0;
      }
      toString() {
        return this.css;
      }
      warn(text, opts = {}) {
        if (!opts.plugin) {
          if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
            opts.plugin = this.lastPlugin.postcssPlugin;
          }
        }
        let warning = new Warning(text, opts);
        this.messages.push(warning);
        return warning;
      }
      warnings() {
        return this.messages.filter((i2) => i2.type === "warning");
      }
      get content() {
        return this.css;
      }
    };
    module2.exports = Result;
    Result.default = Result;
  }
});

// node_modules/postcss/lib/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/postcss/lib/tokenize.js"(exports2, module2) {
    "use strict";
    var SINGLE_QUOTE2 = "'".charCodeAt(0);
    var DOUBLE_QUOTE2 = '"'.charCodeAt(0);
    var BACKSLASH = "\\".charCodeAt(0);
    var SLASH2 = "/".charCodeAt(0);
    var NEWLINE2 = "\n".charCodeAt(0);
    var SPACE2 = " ".charCodeAt(0);
    var FEED = "\f".charCodeAt(0);
    var TAB = "	".charCodeAt(0);
    var CR = "\r".charCodeAt(0);
    var OPEN_SQUARE = "[".charCodeAt(0);
    var CLOSE_SQUARE = "]".charCodeAt(0);
    var OPEN_PARENTHESES = "(".charCodeAt(0);
    var CLOSE_PARENTHESES = ")".charCodeAt(0);
    var OPEN_CURLY = "{".charCodeAt(0);
    var CLOSE_CURLY = "}".charCodeAt(0);
    var SEMICOLON = ";".charCodeAt(0);
    var ASTERISK = "*".charCodeAt(0);
    var COLON2 = ":".charCodeAt(0);
    var AT = "@".charCodeAt(0);
    var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
    var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
    var RE_BAD_BRACKET = /.[\n"'(/\\]/;
    var RE_HEX_ESCAPE = /[\da-f]/i;
    module2.exports = function tokenizer2(input, options2 = {}) {
      let css = input.css.valueOf();
      let ignore2 = options2.ignoreErrors;
      let code, next, quote, content2, escape2;
      let escaped2, escapePos, prev, n3, currentToken;
      let length = css.length;
      let pos = 0;
      let buffer = [];
      let returned = [];
      function position() {
        return pos;
      }
      function unclosed(what) {
        throw input.error("Unclosed " + what, pos);
      }
      function endOfFile() {
        return returned.length === 0 && pos >= length;
      }
      function nextToken(opts) {
        if (returned.length)
          return returned.pop();
        if (pos >= length)
          return;
        let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
        code = css.charCodeAt(pos);
        switch (code) {
          case NEWLINE2:
          case SPACE2:
          case TAB:
          case CR:
          case FEED: {
            next = pos;
            do {
              next += 1;
              code = css.charCodeAt(next);
            } while (code === SPACE2 || code === NEWLINE2 || code === TAB || code === CR || code === FEED);
            currentToken = ["space", css.slice(pos, next)];
            pos = next - 1;
            break;
          }
          case OPEN_SQUARE:
          case CLOSE_SQUARE:
          case OPEN_CURLY:
          case CLOSE_CURLY:
          case COLON2:
          case SEMICOLON:
          case CLOSE_PARENTHESES: {
            let controlChar = String.fromCharCode(code);
            currentToken = [controlChar, controlChar, pos];
            break;
          }
          case OPEN_PARENTHESES: {
            prev = buffer.length ? buffer.pop()[1] : "";
            n3 = css.charCodeAt(pos + 1);
            if (prev === "url" && n3 !== SINGLE_QUOTE2 && n3 !== DOUBLE_QUOTE2 && n3 !== SPACE2 && n3 !== NEWLINE2 && n3 !== TAB && n3 !== FEED && n3 !== CR) {
              next = pos;
              do {
                escaped2 = false;
                next = css.indexOf(")", next + 1);
                if (next === -1) {
                  if (ignore2 || ignoreUnclosed) {
                    next = pos;
                    break;
                  } else {
                    unclosed("bracket");
                  }
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped2 = !escaped2;
                }
              } while (escaped2);
              currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              next = css.indexOf(")", pos + 1);
              content2 = css.slice(pos, next + 1);
              if (next === -1 || RE_BAD_BRACKET.test(content2)) {
                currentToken = ["(", "(", pos];
              } else {
                currentToken = ["brackets", content2, pos, next];
                pos = next;
              }
            }
            break;
          }
          case SINGLE_QUOTE2:
          case DOUBLE_QUOTE2: {
            quote = code === SINGLE_QUOTE2 ? "'" : '"';
            next = pos;
            do {
              escaped2 = false;
              next = css.indexOf(quote, next + 1);
              if (next === -1) {
                if (ignore2 || ignoreUnclosed) {
                  next = pos + 1;
                  break;
                } else {
                  unclosed("string");
                }
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                escapePos -= 1;
                escaped2 = !escaped2;
              }
            } while (escaped2);
            currentToken = ["string", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          case AT: {
            RE_AT_END.lastIndex = pos + 1;
            RE_AT_END.test(css);
            if (RE_AT_END.lastIndex === 0) {
              next = css.length - 1;
            } else {
              next = RE_AT_END.lastIndex - 2;
            }
            currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          case BACKSLASH: {
            next = pos;
            escape2 = true;
            while (css.charCodeAt(next + 1) === BACKSLASH) {
              next += 1;
              escape2 = !escape2;
            }
            code = css.charCodeAt(next + 1);
            if (escape2 && code !== SLASH2 && code !== SPACE2 && code !== NEWLINE2 && code !== TAB && code !== CR && code !== FEED) {
              next += 1;
              if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                  next += 1;
                }
                if (css.charCodeAt(next + 1) === SPACE2) {
                  next += 1;
                }
              }
            }
            currentToken = ["word", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          default: {
            if (code === SLASH2 && css.charCodeAt(pos + 1) === ASTERISK) {
              next = css.indexOf("*/", pos + 2) + 1;
              if (next === 0) {
                if (ignore2 || ignoreUnclosed) {
                  next = css.length;
                } else {
                  unclosed("comment");
                }
              }
              currentToken = ["comment", css.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              RE_WORD_END.lastIndex = pos + 1;
              RE_WORD_END.test(css);
              if (RE_WORD_END.lastIndex === 0) {
                next = css.length - 1;
              } else {
                next = RE_WORD_END.lastIndex - 2;
              }
              currentToken = ["word", css.slice(pos, next + 1), pos, next];
              buffer.push(currentToken);
              pos = next;
            }
            break;
          }
        }
        pos++;
        return currentToken;
      }
      function back(token) {
        returned.push(token);
      }
      return {
        back,
        nextToken,
        endOfFile,
        position
      };
    };
  }
});

// node_modules/postcss/lib/at-rule.js
var require_at_rule = __commonJS({
  "node_modules/postcss/lib/at-rule.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var AtRule = class extends Container {
      constructor(defaults2) {
        super(defaults2);
        this.type = "atrule";
      }
      append(...children) {
        if (!this.proxyOf.nodes)
          this.nodes = [];
        return super.append(...children);
      }
      prepend(...children) {
        if (!this.proxyOf.nodes)
          this.nodes = [];
        return super.prepend(...children);
      }
    };
    module2.exports = AtRule;
    AtRule.default = AtRule;
    Container.registerAtRule(AtRule);
  }
});

// node_modules/postcss/lib/root.js
var require_root = __commonJS({
  "node_modules/postcss/lib/root.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var LazyResult;
    var Processor;
    var Root = class extends Container {
      constructor(defaults2) {
        super(defaults2);
        this.type = "root";
        if (!this.nodes)
          this.nodes = [];
      }
      removeChild(child, ignore2) {
        let index2 = this.index(child);
        if (!ignore2 && index2 === 0 && this.nodes.length > 1) {
          this.nodes[1].raws.before = this.nodes[index2].raws.before;
        }
        return super.removeChild(child);
      }
      normalize(child, sample, type) {
        let nodes = super.normalize(child);
        if (sample) {
          if (type === "prepend") {
            if (this.nodes.length > 1) {
              sample.raws.before = this.nodes[1].raws.before;
            } else {
              delete sample.raws.before;
            }
          } else if (this.first !== sample) {
            for (let node2 of nodes) {
              node2.raws.before = sample.raws.before;
            }
          }
        }
        return nodes;
      }
      toResult(opts = {}) {
        let lazy = new LazyResult(new Processor(), this, opts);
        return lazy.stringify();
      }
    };
    Root.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Root.registerProcessor = (dependant) => {
      Processor = dependant;
    };
    module2.exports = Root;
    Root.default = Root;
  }
});

// node_modules/postcss/lib/list.js
var require_list = __commonJS({
  "node_modules/postcss/lib/list.js"(exports2, module2) {
    "use strict";
    var list2 = {
      split(string2, separators, last) {
        let array2 = [];
        let current = "";
        let split2 = false;
        let func = 0;
        let quote = false;
        let escape2 = false;
        for (let letter of string2) {
          if (escape2) {
            escape2 = false;
          } else if (letter === "\\") {
            escape2 = true;
          } else if (quote) {
            if (letter === quote) {
              quote = false;
            }
          } else if (letter === '"' || letter === "'") {
            quote = letter;
          } else if (letter === "(") {
            func += 1;
          } else if (letter === ")") {
            if (func > 0)
              func -= 1;
          } else if (func === 0) {
            if (separators.includes(letter))
              split2 = true;
          }
          if (split2) {
            if (current !== "")
              array2.push(current.trim());
            current = "";
            split2 = false;
          } else {
            current += letter;
          }
        }
        if (last || current !== "")
          array2.push(current.trim());
        return array2;
      },
      space(string2) {
        let spaces = [" ", "\n", "	"];
        return list2.split(string2, spaces);
      },
      comma(string2) {
        return list2.split(string2, [","], true);
      }
    };
    module2.exports = list2;
    list2.default = list2;
  }
});

// node_modules/postcss/lib/rule.js
var require_rule = __commonJS({
  "node_modules/postcss/lib/rule.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var list2 = require_list();
    var Rule = class extends Container {
      constructor(defaults2) {
        super(defaults2);
        this.type = "rule";
        if (!this.nodes)
          this.nodes = [];
      }
      get selectors() {
        return list2.comma(this.selector);
      }
      set selectors(values) {
        let match2 = this.selector ? this.selector.match(/,\s*/) : null;
        let sep = match2 ? match2[0] : "," + this.raw("between", "beforeOpen");
        this.selector = values.join(sep);
      }
    };
    module2.exports = Rule;
    Rule.default = Rule;
    Container.registerRule(Rule);
  }
});

// node_modules/postcss/lib/parser.js
var require_parser = __commonJS({
  "node_modules/postcss/lib/parser.js"(exports2, module2) {
    "use strict";
    var Declaration = require_declaration();
    var tokenizer2 = require_tokenize();
    var Comment2 = require_comment();
    var AtRule = require_at_rule();
    var Root = require_root();
    var Rule = require_rule();
    var Parser2 = class {
      constructor(input) {
        this.input = input;
        this.root = new Root();
        this.current = this.root;
        this.spaces = "";
        this.semicolon = false;
        this.customProperty = false;
        this.createTokenizer();
        this.root.source = { input, start: { offset: 0, line: 1, column: 1 } };
      }
      createTokenizer() {
        this.tokenizer = tokenizer2(this.input);
      }
      parse() {
        let token;
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          switch (token[0]) {
            case "space":
              this.spaces += token[1];
              break;
            case ";":
              this.freeSemicolon(token);
              break;
            case "}":
              this.end(token);
              break;
            case "comment":
              this.comment(token);
              break;
            case "at-word":
              this.atrule(token);
              break;
            case "{":
              this.emptyRule(token);
              break;
            default:
              this.other(token);
              break;
          }
        }
        this.endFile();
      }
      comment(token) {
        let node2 = new Comment2();
        this.init(node2, token[2]);
        node2.source.end = this.getPosition(token[3] || token[2]);
        let text = token[1].slice(2, -2);
        if (/^\s*$/.test(text)) {
          node2.text = "";
          node2.raws.left = text;
          node2.raws.right = "";
        } else {
          let match2 = text.match(/^(\s*)([^]*\S)(\s*)$/);
          node2.text = match2[2];
          node2.raws.left = match2[1];
          node2.raws.right = match2[3];
        }
      }
      emptyRule(token) {
        let node2 = new Rule();
        this.init(node2, token[2]);
        node2.selector = "";
        node2.raws.between = "";
        this.current = node2;
      }
      other(start) {
        let end = false;
        let type = null;
        let colon = false;
        let bracket = null;
        let brackets = [];
        let customProperty = start[1].startsWith("--");
        let tokens = [];
        let token = start;
        while (token) {
          type = token[0];
          tokens.push(token);
          if (type === "(" || type === "[") {
            if (!bracket)
              bracket = token;
            brackets.push(type === "(" ? ")" : "]");
          } else if (customProperty && colon && type === "{") {
            if (!bracket)
              bracket = token;
            brackets.push("}");
          } else if (brackets.length === 0) {
            if (type === ";") {
              if (colon) {
                this.decl(tokens, customProperty);
                return;
              } else {
                break;
              }
            } else if (type === "{") {
              this.rule(tokens);
              return;
            } else if (type === "}") {
              this.tokenizer.back(tokens.pop());
              end = true;
              break;
            } else if (type === ":") {
              colon = true;
            }
          } else if (type === brackets[brackets.length - 1]) {
            brackets.pop();
            if (brackets.length === 0)
              bracket = null;
          }
          token = this.tokenizer.nextToken();
        }
        if (this.tokenizer.endOfFile())
          end = true;
        if (brackets.length > 0)
          this.unclosedBracket(bracket);
        if (end && colon) {
          while (tokens.length) {
            token = tokens[tokens.length - 1][0];
            if (token !== "space" && token !== "comment")
              break;
            this.tokenizer.back(tokens.pop());
          }
          this.decl(tokens, customProperty);
        } else {
          this.unknownWord(tokens);
        }
      }
      rule(tokens) {
        tokens.pop();
        let node2 = new Rule();
        this.init(node2, tokens[0][2]);
        node2.raws.between = this.spacesAndCommentsFromEnd(tokens);
        this.raw(node2, "selector", tokens);
        this.current = node2;
      }
      decl(tokens, customProperty) {
        let node2 = new Declaration();
        this.init(node2, tokens[0][2]);
        let last = tokens[tokens.length - 1];
        if (last[0] === ";") {
          this.semicolon = true;
          tokens.pop();
        }
        node2.source.end = this.getPosition(last[3] || last[2]);
        while (tokens[0][0] !== "word") {
          if (tokens.length === 1)
            this.unknownWord(tokens);
          node2.raws.before += tokens.shift()[1];
        }
        node2.source.start = this.getPosition(tokens[0][2]);
        node2.prop = "";
        while (tokens.length) {
          let type = tokens[0][0];
          if (type === ":" || type === "space" || type === "comment") {
            break;
          }
          node2.prop += tokens.shift()[1];
        }
        node2.raws.between = "";
        let token;
        while (tokens.length) {
          token = tokens.shift();
          if (token[0] === ":") {
            node2.raws.between += token[1];
            break;
          } else {
            if (token[0] === "word" && /\w/.test(token[1])) {
              this.unknownWord([token]);
            }
            node2.raws.between += token[1];
          }
        }
        if (node2.prop[0] === "_" || node2.prop[0] === "*") {
          node2.raws.before += node2.prop[0];
          node2.prop = node2.prop.slice(1);
        }
        let firstSpaces = this.spacesAndCommentsFromStart(tokens);
        this.precheckMissedSemicolon(tokens);
        for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
          token = tokens[i2];
          if (token[1].toLowerCase() === "!important") {
            node2.important = true;
            let string2 = this.stringFrom(tokens, i2);
            string2 = this.spacesFromEnd(tokens) + string2;
            if (string2 !== " !important")
              node2.raws.important = string2;
            break;
          } else if (token[1].toLowerCase() === "important") {
            let cache2 = tokens.slice(0);
            let str = "";
            for (let j2 = i2; j2 > 0; j2--) {
              let type = cache2[j2][0];
              if (str.trim().indexOf("!") === 0 && type !== "space") {
                break;
              }
              str = cache2.pop()[1] + str;
            }
            if (str.trim().indexOf("!") === 0) {
              node2.important = true;
              node2.raws.important = str;
              tokens = cache2;
            }
          }
          if (token[0] !== "space" && token[0] !== "comment") {
            break;
          }
        }
        let hasWord = tokens.some((i2) => i2[0] !== "space" && i2[0] !== "comment");
        this.raw(node2, "value", tokens);
        if (hasWord) {
          node2.raws.between += firstSpaces;
        } else {
          node2.value = firstSpaces + node2.value;
        }
        if (node2.value.includes(":") && !customProperty) {
          this.checkMissedSemicolon(tokens);
        }
      }
      atrule(token) {
        let node2 = new AtRule();
        node2.name = token[1].slice(1);
        if (node2.name === "") {
          this.unnamedAtrule(node2, token);
        }
        this.init(node2, token[2]);
        let type;
        let prev;
        let shift;
        let last = false;
        let open2 = false;
        let params = [];
        let brackets = [];
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          type = token[0];
          if (type === "(" || type === "[") {
            brackets.push(type === "(" ? ")" : "]");
          } else if (type === "{" && brackets.length > 0) {
            brackets.push("}");
          } else if (type === brackets[brackets.length - 1]) {
            brackets.pop();
          }
          if (brackets.length === 0) {
            if (type === ";") {
              node2.source.end = this.getPosition(token[2]);
              this.semicolon = true;
              break;
            } else if (type === "{") {
              open2 = true;
              break;
            } else if (type === "}") {
              if (params.length > 0) {
                shift = params.length - 1;
                prev = params[shift];
                while (prev && prev[0] === "space") {
                  prev = params[--shift];
                }
                if (prev) {
                  node2.source.end = this.getPosition(prev[3] || prev[2]);
                }
              }
              this.end(token);
              break;
            } else {
              params.push(token);
            }
          } else {
            params.push(token);
          }
          if (this.tokenizer.endOfFile()) {
            last = true;
            break;
          }
        }
        node2.raws.between = this.spacesAndCommentsFromEnd(params);
        if (params.length) {
          node2.raws.afterName = this.spacesAndCommentsFromStart(params);
          this.raw(node2, "params", params);
          if (last) {
            token = params[params.length - 1];
            node2.source.end = this.getPosition(token[3] || token[2]);
            this.spaces = node2.raws.between;
            node2.raws.between = "";
          }
        } else {
          node2.raws.afterName = "";
          node2.params = "";
        }
        if (open2) {
          node2.nodes = [];
          this.current = node2;
        }
      }
      end(token) {
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.semicolon = false;
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        this.spaces = "";
        if (this.current.parent) {
          this.current.source.end = this.getPosition(token[2]);
          this.current = this.current.parent;
        } else {
          this.unexpectedClose(token);
        }
      }
      endFile() {
        if (this.current.parent)
          this.unclosedBlock();
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
      }
      freeSemicolon(token) {
        this.spaces += token[1];
        if (this.current.nodes) {
          let prev = this.current.nodes[this.current.nodes.length - 1];
          if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
            prev.raws.ownSemicolon = this.spaces;
            this.spaces = "";
          }
        }
      }
      getPosition(offset2) {
        let pos = this.input.fromOffset(offset2);
        return {
          offset: offset2,
          line: pos.line,
          column: pos.col
        };
      }
      init(node2, offset2) {
        this.current.push(node2);
        node2.source = {
          start: this.getPosition(offset2),
          input: this.input
        };
        node2.raws.before = this.spaces;
        this.spaces = "";
        if (node2.type !== "comment")
          this.semicolon = false;
      }
      raw(node2, prop, tokens) {
        let token, type;
        let length = tokens.length;
        let value = "";
        let clean = true;
        let next, prev;
        let pattern2 = /^([#.|])?(\w)+/i;
        for (let i2 = 0; i2 < length; i2 += 1) {
          token = tokens[i2];
          type = token[0];
          if (type === "comment" && node2.type === "rule") {
            prev = tokens[i2 - 1];
            next = tokens[i2 + 1];
            if (prev[0] !== "space" && next[0] !== "space" && pattern2.test(prev[1]) && pattern2.test(next[1])) {
              value += token[1];
            } else {
              clean = false;
            }
            continue;
          }
          if (type === "comment" || type === "space" && i2 === length - 1) {
            clean = false;
          } else {
            value += token[1];
          }
        }
        if (!clean) {
          let raw = tokens.reduce((all, i2) => all + i2[1], "");
          node2.raws[prop] = { value, raw };
        }
        node2[prop] = value;
      }
      spacesAndCommentsFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space" && lastTokenType !== "comment")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      spacesAndCommentsFromStart(tokens) {
        let next;
        let spaces = "";
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== "space" && next !== "comment")
            break;
          spaces += tokens.shift()[1];
        }
        return spaces;
      }
      spacesFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space")
            break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      stringFrom(tokens, from) {
        let result2 = "";
        for (let i2 = from; i2 < tokens.length; i2++) {
          result2 += tokens[i2][1];
        }
        tokens.splice(from, tokens.length - from);
        return result2;
      }
      colon(tokens) {
        let brackets = 0;
        let token, type, prev;
        for (let [i2, element] of tokens.entries()) {
          token = element;
          type = token[0];
          if (type === "(") {
            brackets += 1;
          }
          if (type === ")") {
            brackets -= 1;
          }
          if (brackets === 0 && type === ":") {
            if (!prev) {
              this.doubleColon(token);
            } else if (prev[0] === "word" && prev[1] === "progid") {
              continue;
            } else {
              return i2;
            }
          }
          prev = token;
        }
        return false;
      }
      unclosedBracket(bracket) {
        throw this.input.error("Unclosed bracket", { offset: bracket[2] }, { offset: bracket[2] + 1 });
      }
      unknownWord(tokens) {
        throw this.input.error("Unknown word", { offset: tokens[0][2] }, { offset: tokens[0][2] + tokens[0][1].length });
      }
      unexpectedClose(token) {
        throw this.input.error("Unexpected }", { offset: token[2] }, { offset: token[2] + 1 });
      }
      unclosedBlock() {
        let pos = this.current.source.start;
        throw this.input.error("Unclosed block", pos.line, pos.column);
      }
      doubleColon(token) {
        throw this.input.error("Double colon", { offset: token[2] }, { offset: token[2] + token[1].length });
      }
      unnamedAtrule(node2, token) {
        throw this.input.error("At-rule without name", { offset: token[2] }, { offset: token[2] + token[1].length });
      }
      precheckMissedSemicolon() {
      }
      checkMissedSemicolon(tokens) {
        let colon = this.colon(tokens);
        if (colon === false)
          return;
        let founded = 0;
        let token;
        for (let j2 = colon - 1; j2 >= 0; j2--) {
          token = tokens[j2];
          if (token[0] !== "space") {
            founded += 1;
            if (founded === 2)
              break;
          }
        }
        throw this.input.error("Missed semicolon", token[0] === "word" ? token[3] + 1 : token[2]);
      }
    };
    module2.exports = Parser2;
  }
});

// node_modules/postcss/lib/parse.js
var require_parse = __commonJS({
  "node_modules/postcss/lib/parse.js"(exports2, module2) {
    "use strict";
    var Container = require_container();
    var Parser2 = require_parser();
    var Input = require_input();
    function parse2(css, opts) {
      let input = new Input(css, opts);
      let parser2 = new Parser2(input);
      try {
        parser2.parse();
      } catch (e2) {
        if (true) {
          if (e2.name === "CssSyntaxError" && opts && opts.from) {
            if (/\.scss$/i.test(opts.from)) {
              e2.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
            } else if (/\.sass/i.test(opts.from)) {
              e2.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
            } else if (/\.less$/i.test(opts.from)) {
              e2.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
            }
          }
        }
        throw e2;
      }
      return parser2.root;
    }
    module2.exports = parse2;
    parse2.default = parse2;
    Container.registerParse(parse2);
  }
});

// node_modules/postcss/lib/lazy-result.js
var require_lazy_result = __commonJS({
  "node_modules/postcss/lib/lazy-result.js"(exports2, module2) {
    "use strict";
    var { isClean, my } = require_symbols();
    var MapGenerator = require_map_generator();
    var stringify2 = require_stringify();
    var Container = require_container();
    var Document2 = require_document();
    var warnOnce = require_warn_once();
    var Result = require_result();
    var parse2 = require_parse();
    var Root = require_root();
    var TYPE_TO_CLASS_NAME = {
      document: "Document",
      root: "Root",
      atrule: "AtRule",
      rule: "Rule",
      decl: "Declaration",
      comment: "Comment"
    };
    var PLUGIN_PROPS = {
      postcssPlugin: true,
      prepare: true,
      Once: true,
      Document: true,
      Root: true,
      Declaration: true,
      Rule: true,
      AtRule: true,
      Comment: true,
      DeclarationExit: true,
      RuleExit: true,
      AtRuleExit: true,
      CommentExit: true,
      RootExit: true,
      DocumentExit: true,
      OnceExit: true
    };
    var NOT_VISITORS = {
      postcssPlugin: true,
      prepare: true,
      Once: true
    };
    var CHILDREN = 0;
    function isPromise(obj) {
      return typeof obj === "object" && typeof obj.then === "function";
    }
    function getEvents(node2) {
      let key = false;
      let type = TYPE_TO_CLASS_NAME[node2.type];
      if (node2.type === "decl") {
        key = node2.prop.toLowerCase();
      } else if (node2.type === "atrule") {
        key = node2.name.toLowerCase();
      }
      if (key && node2.append) {
        return [
          type,
          type + "-" + key,
          CHILDREN,
          type + "Exit",
          type + "Exit-" + key
        ];
      } else if (key) {
        return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
      } else if (node2.append) {
        return [type, CHILDREN, type + "Exit"];
      } else {
        return [type, type + "Exit"];
      }
    }
    function toStack(node2) {
      let events2;
      if (node2.type === "document") {
        events2 = ["Document", CHILDREN, "DocumentExit"];
      } else if (node2.type === "root") {
        events2 = ["Root", CHILDREN, "RootExit"];
      } else {
        events2 = getEvents(node2);
      }
      return {
        node: node2,
        events: events2,
        eventIndex: 0,
        visitors: [],
        visitorIndex: 0,
        iterator: 0
      };
    }
    function cleanMarks(node2) {
      node2[isClean] = false;
      if (node2.nodes)
        node2.nodes.forEach((i2) => cleanMarks(i2));
      return node2;
    }
    var postcss2 = {};
    var LazyResult = class {
      constructor(processor, css, opts) {
        this.stringified = false;
        this.processed = false;
        let root;
        if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
          root = cleanMarks(css);
        } else if (css instanceof LazyResult || css instanceof Result) {
          root = cleanMarks(css.root);
          if (css.map) {
            if (typeof opts.map === "undefined")
              opts.map = {};
            if (!opts.map.inline)
              opts.map.inline = false;
            opts.map.prev = css.map;
          }
        } else {
          let parser2 = parse2;
          if (opts.syntax)
            parser2 = opts.syntax.parse;
          if (opts.parser)
            parser2 = opts.parser;
          if (parser2.parse)
            parser2 = parser2.parse;
          try {
            root = parser2(css, opts);
          } catch (error2) {
            this.processed = true;
            this.error = error2;
          }
          if (root && !root[my]) {
            Container.rebuild(root);
          }
        }
        this.result = new Result(processor, root, opts);
        this.helpers = __spreadProps2(__spreadValues2({}, postcss2), { result: this.result, postcss: postcss2 });
        this.plugins = this.processor.plugins.map((plugin) => {
          if (typeof plugin === "object" && plugin.prepare) {
            return __spreadValues2(__spreadValues2({}, plugin), plugin.prepare(this.result));
          } else {
            return plugin;
          }
        });
      }
      get [Symbol.toStringTag]() {
        return "LazyResult";
      }
      get processor() {
        return this.result.processor;
      }
      get opts() {
        return this.result.opts;
      }
      get css() {
        return this.stringify().css;
      }
      get content() {
        return this.stringify().content;
      }
      get map() {
        return this.stringify().map;
      }
      get root() {
        return this.sync().root;
      }
      get messages() {
        return this.sync().messages;
      }
      warnings() {
        return this.sync().warnings();
      }
      toString() {
        return this.css;
      }
      then(onFulfilled, onRejected) {
        if (true) {
          if (!("from" in this.opts)) {
            warnOnce("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.");
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      async() {
        if (this.error)
          return Promise.reject(this.error);
        if (this.processed)
          return Promise.resolve(this.result);
        if (!this.processing) {
          this.processing = this.runAsync();
        }
        return this.processing;
      }
      sync() {
        if (this.error)
          throw this.error;
        if (this.processed)
          return this.result;
        this.processed = true;
        if (this.processing) {
          throw this.getAsyncError();
        }
        for (let plugin of this.plugins) {
          let promise2 = this.runOnRoot(plugin);
          if (isPromise(promise2)) {
            throw this.getAsyncError();
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root = this.result.root;
          while (!root[isClean]) {
            root[isClean] = true;
            this.walkSync(root);
          }
          if (this.listeners.OnceExit) {
            if (root.type === "document") {
              for (let subRoot of root.nodes) {
                this.visitSync(this.listeners.OnceExit, subRoot);
              }
            } else {
              this.visitSync(this.listeners.OnceExit, root);
            }
          }
        }
        return this.result;
      }
      stringify() {
        if (this.error)
          throw this.error;
        if (this.stringified)
          return this.result;
        this.stringified = true;
        this.sync();
        let opts = this.result.opts;
        let str = stringify2;
        if (opts.syntax)
          str = opts.syntax.stringify;
        if (opts.stringifier)
          str = opts.stringifier;
        if (str.stringify)
          str = str.stringify;
        let map2 = new MapGenerator(str, this.result.root, this.result.opts);
        let data2 = map2.generate();
        this.result.css = data2[0];
        this.result.map = data2[1];
        return this.result;
      }
      walkSync(node2) {
        node2[isClean] = true;
        let events2 = getEvents(node2);
        for (let event of events2) {
          if (event === CHILDREN) {
            if (node2.nodes) {
              node2.each((child) => {
                if (!child[isClean])
                  this.walkSync(child);
              });
            }
          } else {
            let visitors = this.listeners[event];
            if (visitors) {
              if (this.visitSync(visitors, node2.toProxy()))
                return;
            }
          }
        }
      }
      visitSync(visitors, node2) {
        for (let [plugin, visitor] of visitors) {
          this.result.lastPlugin = plugin;
          let promise2;
          try {
            promise2 = visitor(node2, this.helpers);
          } catch (e2) {
            throw this.handleError(e2, node2.proxyOf);
          }
          if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
            return true;
          }
          if (isPromise(promise2)) {
            throw this.getAsyncError();
          }
        }
      }
      runOnRoot(plugin) {
        this.result.lastPlugin = plugin;
        try {
          if (typeof plugin === "object" && plugin.Once) {
            if (this.result.root.type === "document") {
              let roots = this.result.root.nodes.map((root) => plugin.Once(root, this.helpers));
              if (isPromise(roots[0])) {
                return Promise.all(roots);
              }
              return roots;
            }
            return plugin.Once(this.result.root, this.helpers);
          } else if (typeof plugin === "function") {
            return plugin(this.result.root, this.result);
          }
        } catch (error2) {
          throw this.handleError(error2);
        }
      }
      getAsyncError() {
        throw new Error("Use process(css).then(cb) to work with async plugins");
      }
      handleError(error2, node2) {
        let plugin = this.result.lastPlugin;
        try {
          if (node2)
            node2.addToError(error2);
          this.error = error2;
          if (error2.name === "CssSyntaxError" && !error2.plugin) {
            error2.plugin = plugin.postcssPlugin;
            error2.setMessage();
          } else if (plugin.postcssVersion) {
            if (true) {
              let pluginName = plugin.postcssPlugin;
              let pluginVer = plugin.postcssVersion;
              let runtimeVer = this.result.processor.version;
              let a2 = pluginVer.split(".");
              let b2 = runtimeVer.split(".");
              if (a2[0] !== b2[0] || parseInt(a2[1]) > parseInt(b2[1])) {
                console.error("Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below.");
              }
            }
          }
        } catch (err) {
          if (console && console.error)
            console.error(err);
        }
        return error2;
      }
      async runAsync() {
        this.plugin = 0;
        for (let i2 = 0; i2 < this.plugins.length; i2++) {
          let plugin = this.plugins[i2];
          let promise2 = this.runOnRoot(plugin);
          if (isPromise(promise2)) {
            try {
              await promise2;
            } catch (error2) {
              throw this.handleError(error2);
            }
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root = this.result.root;
          while (!root[isClean]) {
            root[isClean] = true;
            let stack = [toStack(root)];
            while (stack.length > 0) {
              let promise2 = this.visitTick(stack);
              if (isPromise(promise2)) {
                try {
                  await promise2;
                } catch (e2) {
                  let node2 = stack[stack.length - 1].node;
                  throw this.handleError(e2, node2);
                }
              }
            }
          }
          if (this.listeners.OnceExit) {
            for (let [plugin, visitor] of this.listeners.OnceExit) {
              this.result.lastPlugin = plugin;
              try {
                if (root.type === "document") {
                  let roots = root.nodes.map((subRoot) => visitor(subRoot, this.helpers));
                  await Promise.all(roots);
                } else {
                  await visitor(root, this.helpers);
                }
              } catch (e2) {
                throw this.handleError(e2);
              }
            }
          }
        }
        this.processed = true;
        return this.stringify();
      }
      prepareVisitors() {
        this.listeners = {};
        let add = (plugin, type, cb) => {
          if (!this.listeners[type])
            this.listeners[type] = [];
          this.listeners[type].push([plugin, cb]);
        };
        for (let plugin of this.plugins) {
          if (typeof plugin === "object") {
            for (let event in plugin) {
              if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                throw new Error(`Unknown event ${event} in ${plugin.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
              }
              if (!NOT_VISITORS[event]) {
                if (typeof plugin[event] === "object") {
                  for (let filter2 in plugin[event]) {
                    if (filter2 === "*") {
                      add(plugin, event, plugin[event][filter2]);
                    } else {
                      add(plugin, event + "-" + filter2.toLowerCase(), plugin[event][filter2]);
                    }
                  }
                } else if (typeof plugin[event] === "function") {
                  add(plugin, event, plugin[event]);
                }
              }
            }
          }
        }
        this.hasListener = Object.keys(this.listeners).length > 0;
      }
      visitTick(stack) {
        let visit2 = stack[stack.length - 1];
        let { node: node2, visitors } = visit2;
        if (node2.type !== "root" && node2.type !== "document" && !node2.parent) {
          stack.pop();
          return;
        }
        if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {
          let [plugin, visitor] = visitors[visit2.visitorIndex];
          visit2.visitorIndex += 1;
          if (visit2.visitorIndex === visitors.length) {
            visit2.visitors = [];
            visit2.visitorIndex = 0;
          }
          this.result.lastPlugin = plugin;
          try {
            return visitor(node2.toProxy(), this.helpers);
          } catch (e2) {
            throw this.handleError(e2, node2);
          }
        }
        if (visit2.iterator !== 0) {
          let iterator = visit2.iterator;
          let child;
          while (child = node2.nodes[node2.indexes[iterator]]) {
            node2.indexes[iterator] += 1;
            if (!child[isClean]) {
              child[isClean] = true;
              stack.push(toStack(child));
              return;
            }
          }
          visit2.iterator = 0;
          delete node2.indexes[iterator];
        }
        let events2 = visit2.events;
        while (visit2.eventIndex < events2.length) {
          let event = events2[visit2.eventIndex];
          visit2.eventIndex += 1;
          if (event === CHILDREN) {
            if (node2.nodes && node2.nodes.length) {
              node2[isClean] = true;
              visit2.iterator = node2.getIterator();
            }
            return;
          } else if (this.listeners[event]) {
            visit2.visitors = this.listeners[event];
            return;
          }
        }
        stack.pop();
      }
    };
    LazyResult.registerPostcss = (dependant) => {
      postcss2 = dependant;
    };
    module2.exports = LazyResult;
    LazyResult.default = LazyResult;
    Root.registerLazyResult(LazyResult);
    Document2.registerLazyResult(LazyResult);
  }
});

// node_modules/postcss/lib/no-work-result.js
var require_no_work_result = __commonJS({
  "node_modules/postcss/lib/no-work-result.js"(exports2, module2) {
    "use strict";
    var MapGenerator = require_map_generator();
    var stringify2 = require_stringify();
    var warnOnce = require_warn_once();
    var parse2 = require_parse();
    var Result = require_result();
    var NoWorkResult = class {
      constructor(processor, css, opts) {
        css = css.toString();
        this.stringified = false;
        this._processor = processor;
        this._css = css;
        this._opts = opts;
        this._map = void 0;
        let root;
        let str = stringify2;
        this.result = new Result(this._processor, root, this._opts);
        this.result.css = css;
        let self2 = this;
        Object.defineProperty(this.result, "root", {
          get() {
            return self2.root;
          }
        });
        let map2 = new MapGenerator(str, root, this._opts, css);
        if (map2.isMap()) {
          let [generatedCSS, generatedMap] = map2.generate();
          if (generatedCSS) {
            this.result.css = generatedCSS;
          }
          if (generatedMap) {
            this.result.map = generatedMap;
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "NoWorkResult";
      }
      get processor() {
        return this.result.processor;
      }
      get opts() {
        return this.result.opts;
      }
      get css() {
        return this.result.css;
      }
      get content() {
        return this.result.css;
      }
      get map() {
        return this.result.map;
      }
      get root() {
        if (this._root) {
          return this._root;
        }
        let root;
        let parser2 = parse2;
        try {
          root = parser2(this._css, this._opts);
        } catch (error2) {
          this.error = error2;
        }
        this._root = root;
        return root;
      }
      get messages() {
        return [];
      }
      warnings() {
        return [];
      }
      toString() {
        return this._css;
      }
      then(onFulfilled, onRejected) {
        if (true) {
          if (!("from" in this._opts)) {
            warnOnce("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.");
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      async() {
        if (this.error)
          return Promise.reject(this.error);
        return Promise.resolve(this.result);
      }
      sync() {
        if (this.error)
          throw this.error;
        return this.result;
      }
    };
    module2.exports = NoWorkResult;
    NoWorkResult.default = NoWorkResult;
  }
});

// node_modules/postcss/lib/processor.js
var require_processor = __commonJS({
  "node_modules/postcss/lib/processor.js"(exports2, module2) {
    "use strict";
    var NoWorkResult = require_no_work_result();
    var LazyResult = require_lazy_result();
    var Document2 = require_document();
    var Root = require_root();
    var Processor = class {
      constructor(plugins2 = []) {
        this.version = "8.4.5";
        this.plugins = this.normalize(plugins2);
      }
      use(plugin) {
        this.plugins = this.plugins.concat(this.normalize([plugin]));
        return this;
      }
      process(css, opts = {}) {
        if (this.plugins.length === 0 && typeof opts.parser === "undefined" && typeof opts.stringifier === "undefined" && typeof opts.syntax === "undefined") {
          return new NoWorkResult(this, css, opts);
        } else {
          return new LazyResult(this, css, opts);
        }
      }
      normalize(plugins2) {
        let normalized = [];
        for (let i2 of plugins2) {
          if (i2.postcss === true) {
            i2 = i2();
          } else if (i2.postcss) {
            i2 = i2.postcss;
          }
          if (typeof i2 === "object" && Array.isArray(i2.plugins)) {
            normalized = normalized.concat(i2.plugins);
          } else if (typeof i2 === "object" && i2.postcssPlugin) {
            normalized.push(i2);
          } else if (typeof i2 === "function") {
            normalized.push(i2);
          } else if (typeof i2 === "object" && (i2.parse || i2.stringify)) {
            if (true) {
              throw new Error("PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.");
            }
          } else {
            throw new Error(i2 + " is not a PostCSS plugin");
          }
        }
        return normalized;
      }
    };
    module2.exports = Processor;
    Processor.default = Processor;
    Root.registerProcessor(Processor);
    Document2.registerProcessor(Processor);
  }
});

// node_modules/postcss/lib/fromJSON.js
var require_fromJSON = __commonJS({
  "node_modules/postcss/lib/fromJSON.js"(exports2, module2) {
    "use strict";
    var Declaration = require_declaration();
    var PreviousMap = require_previous_map();
    var Comment2 = require_comment();
    var AtRule = require_at_rule();
    var Input = require_input();
    var Root = require_root();
    var Rule = require_rule();
    function fromJSON(json2, inputs) {
      if (Array.isArray(json2))
        return json2.map((n3) => fromJSON(n3));
      let _a2 = json2, { inputs: ownInputs } = _a2, defaults2 = __objRest(_a2, ["inputs"]);
      if (ownInputs) {
        inputs = [];
        for (let input of ownInputs) {
          let inputHydrated = __spreadProps2(__spreadValues2({}, input), { __proto__: Input.prototype });
          if (inputHydrated.map) {
            inputHydrated.map = __spreadProps2(__spreadValues2({}, inputHydrated.map), {
              __proto__: PreviousMap.prototype
            });
          }
          inputs.push(inputHydrated);
        }
      }
      if (defaults2.nodes) {
        defaults2.nodes = json2.nodes.map((n3) => fromJSON(n3, inputs));
      }
      if (defaults2.source) {
        let _b = defaults2.source, { inputId } = _b, source2 = __objRest(_b, ["inputId"]);
        defaults2.source = source2;
        if (inputId != null) {
          defaults2.source.input = inputs[inputId];
        }
      }
      if (defaults2.type === "root") {
        return new Root(defaults2);
      } else if (defaults2.type === "decl") {
        return new Declaration(defaults2);
      } else if (defaults2.type === "rule") {
        return new Rule(defaults2);
      } else if (defaults2.type === "comment") {
        return new Comment2(defaults2);
      } else if (defaults2.type === "atrule") {
        return new AtRule(defaults2);
      } else {
        throw new Error("Unknown node type: " + json2.type);
      }
    }
    module2.exports = fromJSON;
    fromJSON.default = fromJSON;
  }
});

// node_modules/postcss/lib/postcss.js
var require_postcss = __commonJS({
  "node_modules/postcss/lib/postcss.js"(exports2, module2) {
    "use strict";
    var CssSyntaxError = require_css_syntax_error();
    var Declaration = require_declaration();
    var LazyResult = require_lazy_result();
    var Container = require_container();
    var Processor = require_processor();
    var stringify2 = require_stringify();
    var fromJSON = require_fromJSON();
    var Document2 = require_document();
    var Warning = require_warning();
    var Comment2 = require_comment();
    var AtRule = require_at_rule();
    var Result = require_result();
    var Input = require_input();
    var parse2 = require_parse();
    var list2 = require_list();
    var Rule = require_rule();
    var Root = require_root();
    var Node2 = require_node();
    function postcss2(...plugins2) {
      if (plugins2.length === 1 && Array.isArray(plugins2[0])) {
        plugins2 = plugins2[0];
      }
      return new Processor(plugins2);
    }
    postcss2.plugin = function plugin(name, initializer) {
      if (console && console.warn) {
        console.warn(name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration");
        if (process.env.LANG && process.env.LANG.startsWith("cn")) {
          console.warn(name + ": \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:\nhttps://www.w3ctech.com/topic/2226");
        }
      }
      function creator(...args) {
        let transformer = initializer(...args);
        transformer.postcssPlugin = name;
        transformer.postcssVersion = new Processor().version;
        return transformer;
      }
      let cache2;
      Object.defineProperty(creator, "postcss", {
        get() {
          if (!cache2)
            cache2 = creator();
          return cache2;
        }
      });
      creator.process = function(css, processOpts, pluginOpts) {
        return postcss2([creator(pluginOpts)]).process(css, processOpts);
      };
      return creator;
    };
    postcss2.stringify = stringify2;
    postcss2.parse = parse2;
    postcss2.fromJSON = fromJSON;
    postcss2.list = list2;
    postcss2.comment = (defaults2) => new Comment2(defaults2);
    postcss2.atRule = (defaults2) => new AtRule(defaults2);
    postcss2.decl = (defaults2) => new Declaration(defaults2);
    postcss2.rule = (defaults2) => new Rule(defaults2);
    postcss2.root = (defaults2) => new Root(defaults2);
    postcss2.document = (defaults2) => new Document2(defaults2);
    postcss2.CssSyntaxError = CssSyntaxError;
    postcss2.Declaration = Declaration;
    postcss2.Container = Container;
    postcss2.Processor = Processor;
    postcss2.Document = Document2;
    postcss2.Comment = Comment2;
    postcss2.Warning = Warning;
    postcss2.AtRule = AtRule;
    postcss2.Result = Result;
    postcss2.Input = Input;
    postcss2.Rule = Rule;
    postcss2.Root = Root;
    postcss2.Node = Node2;
    LazyResult.registerPostcss(postcss2);
    module2.exports = postcss2;
    postcss2.default = postcss2;
  }
});

// node_modules/vite/dist/node/chunks/dep-be90506c.js
var require_dep_be90506c = __commonJS({
  "node_modules/vite/dist/node/chunks/dep-be90506c.js"(exports2) {
    "use strict";
    var require$$02 = require_postcss();
    var build$2 = require_dep_76613303();
    var path$42 = (init_path(), path_exports);
    var require$$12 = (init_crypto(), crypto_exports);
    var fs3 = (init_fs(), fs_exports);
    var require$$0$12 = (init_util(), util_exports);
    var index$12 = require_dep_ac1b4bf9();
    function _interopDefaultLegacy2(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2["default"] : e2;
    }
    function _mergeNamespaces2(n3, m3) {
      for (var i2 = 0; i2 < m3.length; i2++) {
        var e2 = m3[i2];
        if (typeof e2 !== "string" && !Array.isArray(e2)) {
          for (var k2 in e2) {
            if (k2 !== "default" && !(k2 in n3)) {
              n3[k2] = e2[k2];
            }
          }
        }
      }
      return n3;
    }
    var require$$0__default2 = _interopDefaultLegacy2(require$$02);
    var path__default2 = _interopDefaultLegacy2(path$42);
    var require$$1__default2 = _interopDefaultLegacy2(require$$12);
    var fs__default2 = _interopDefaultLegacy2(fs3);
    var require$$0__default$12 = _interopDefaultLegacy2(require$$0$12);
    var build$12 = { exports: {} };
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "ss"
    };
    var freeGlobal = typeof build$2.commonjsGlobal == "object" && build$2.commonjsGlobal && build$2.commonjsGlobal.Object === Object && build$2.commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root$2 = freeGlobal || freeSelf || Function("return this")();
    function arrayReduce(array2, iteratee, accumulator, initAccum) {
      var index3 = -1, length = array2 ? array2.length : 0;
      if (initAccum && length) {
        accumulator = array2[++index3];
      }
      while (++index3 < length) {
        accumulator = iteratee(accumulator, array2[index3], index3, array2);
      }
      return accumulator;
    }
    function asciiToArray(string3) {
      return string3.split("");
    }
    function asciiWords(string3) {
      return string3.match(reAsciiWord) || [];
    }
    function basePropertyOf(object2) {
      return function(key) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    function hasUnicode(string3) {
      return reHasUnicode.test(string3);
    }
    function hasUnicodeWord(string3) {
      return reHasUnicodeWord.test(string3);
    }
    function stringToArray(string3) {
      return hasUnicode(string3) ? unicodeToArray(string3) : asciiToArray(string3);
    }
    function unicodeToArray(string3) {
      return string3.match(reUnicode) || [];
    }
    function unicodeWords(string3) {
      return string3.match(reUnicodeWord) || [];
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol$1 = root$2.Symbol;
    var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseSlice(array2, start, end) {
      var index3 = -1, length = array2.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result2 = Array(length);
      while (++index3 < length) {
        result2[index3] = array2[index3 + start];
      }
      return result2;
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result2 = value + "";
      return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
    }
    function castSlice(array2, start, end) {
      var length = array2.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array2 : baseSlice(array2, start, end);
    }
    function createCaseFirst(methodName) {
      return function(string3) {
        string3 = toString2(string3);
        var strSymbols = hasUnicode(string3) ? stringToArray(string3) : void 0;
        var chr = strSymbols ? strSymbols[0] : string3.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string3.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    function createCompounder(callback) {
      return function(string3) {
        return arrayReduce(words(deburr(string3).replace(reApos, "")), callback, "");
      };
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString2(value) {
      return value == null ? "" : baseToString(value);
    }
    var camelCase = createCompounder(function(result2, word2, index3) {
      word2 = word2.toLowerCase();
      return result2 + (index3 ? capitalize(word2) : word2);
    });
    function capitalize(string3) {
      return upperFirst(toString2(string3).toLowerCase());
    }
    function deburr(string3) {
      string3 = toString2(string3);
      return string3 && string3.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    var upperFirst = createCaseFirst("toUpperCase");
    function words(string3, pattern2, guard) {
      string3 = toString2(string3);
      pattern2 = guard ? void 0 : pattern2;
      if (pattern2 === void 0) {
        return hasUnicodeWord(string3) ? unicodeWords(string3) : asciiWords(string3);
      }
      return string3.match(pattern2) || [];
    }
    var lodash_camelcase = camelCase;
    var lib$2 = {};
    var lib$12 = { exports: {} };
    var parse2 = { exports: {} };
    var util$12 = {};
    var unicode$1 = {};
    Object.defineProperty(unicode$1, "__esModule", { value: true });
    unicode$1.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
    unicode$1.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/;
    unicode$1.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
    Object.defineProperty(util$12, "__esModule", { value: true });
    util$12.isSpaceSeparator = isSpaceSeparator;
    util$12.isIdStartChar = isIdStartChar;
    util$12.isIdContinueChar = isIdContinueChar;
    util$12.isDigit = isDigit;
    util$12.isHexDigit = isHexDigit2;
    var _unicode = unicode$1;
    var unicode = _interopRequireWildcard(_unicode);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function isSpaceSeparator(c2) {
      return unicode.Space_Separator.test(c2);
    }
    function isIdStartChar(c2) {
      return c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode.ID_Start.test(c2);
    }
    function isIdContinueChar(c2) {
      return c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "\u200C" || c2 === "\u200D" || unicode.ID_Continue.test(c2);
    }
    function isDigit(c2) {
      return /[0-9]/.test(c2);
    }
    function isHexDigit2(c2) {
      return /[0-9A-Fa-f]/.test(c2);
    }
    (function(module3, exports3) {
      Object.defineProperty(exports3, "__esModule", { value: true });
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      exports3.default = parse3;
      var _util = util$12;
      var util3 = _interopRequireWildcard2(_util);
      function _interopRequireWildcard2(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key2 in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key2))
                newObj[key2] = obj[key2];
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }
      var source2 = void 0;
      var parseState = void 0;
      var stack = void 0;
      var pos = void 0;
      var line = void 0;
      var column = void 0;
      var token = void 0;
      var key = void 0;
      var root2 = void 0;
      function parse3(text, reviver) {
        source2 = String(text);
        parseState = "start";
        stack = [];
        pos = 0;
        line = 1;
        column = 0;
        token = void 0;
        key = void 0;
        root2 = void 0;
        do {
          token = lex();
          parseStates[parseState]();
        } while (token.type !== "eof");
        if (typeof reviver === "function") {
          return internalize({ "": root2 }, "", reviver);
        }
        return root2;
      }
      function internalize(holder, name, reviver) {
        var value = holder[name];
        if (value != null && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object") {
          for (var _key in value) {
            var replacement2 = internalize(value, _key, reviver);
            if (replacement2 === void 0) {
              delete value[_key];
            } else {
              value[_key] = replacement2;
            }
          }
        }
        return reviver.call(holder, name, value);
      }
      var lexState = void 0;
      var buffer = void 0;
      var doubleQuote2 = void 0;
      var _sign = void 0;
      var c2 = void 0;
      function lex() {
        lexState = "default";
        buffer = "";
        doubleQuote2 = false;
        _sign = 1;
        for (; ; ) {
          c2 = peek();
          var _token = lexStates[lexState]();
          if (_token) {
            return _token;
          }
        }
      }
      function peek() {
        if (source2[pos]) {
          return String.fromCodePoint(source2.codePointAt(pos));
        }
      }
      function read2() {
        var c3 = peek();
        if (c3 === "\n") {
          line++;
          column = 0;
        } else if (c3) {
          column += c3.length;
        } else {
          column++;
        }
        if (c3) {
          pos += c3.length;
        }
        return c3;
      }
      var lexStates = { default: function _default() {
        switch (c2) {
          case "	":
          case "\v":
          case "\f":
          case " ":
          case "\xA0":
          case "\uFEFF":
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read2();
            return;
          case "/":
            read2();
            lexState = "comment";
            return;
          case void 0:
            read2();
            return newToken("eof");
        }
        if (util3.isSpaceSeparator(c2)) {
          read2();
          return;
        }
        return lexStates[parseState]();
      }, comment: function comment2() {
        switch (c2) {
          case "*":
            read2();
            lexState = "multiLineComment";
            return;
          case "/":
            read2();
            lexState = "singleLineComment";
            return;
        }
        throw invalidChar(read2());
      }, multiLineComment: function multiLineComment() {
        switch (c2) {
          case "*":
            read2();
            lexState = "multiLineCommentAsterisk";
            return;
          case void 0:
            throw invalidChar(read2());
        }
        read2();
      }, multiLineCommentAsterisk: function multiLineCommentAsterisk() {
        switch (c2) {
          case "*":
            read2();
            return;
          case "/":
            read2();
            lexState = "default";
            return;
          case void 0:
            throw invalidChar(read2());
        }
        read2();
        lexState = "multiLineComment";
      }, singleLineComment: function singleLineComment() {
        switch (c2) {
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read2();
            lexState = "default";
            return;
          case void 0:
            read2();
            return newToken("eof");
        }
        read2();
      }, value: function value() {
        switch (c2) {
          case "{":
          case "[":
            return newToken("punctuator", read2());
          case "n":
            read2();
            literal2("ull");
            return newToken("null", null);
          case "t":
            read2();
            literal2("rue");
            return newToken("boolean", true);
          case "f":
            read2();
            literal2("alse");
            return newToken("boolean", false);
          case "-":
          case "+":
            if (read2() === "-") {
              _sign = -1;
            }
            lexState = "sign";
            return;
          case ".":
            buffer = read2();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read2();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read2();
            lexState = "decimalInteger";
            return;
          case "I":
            read2();
            literal2("nfinity");
            return newToken("numeric", Infinity);
          case "N":
            read2();
            literal2("aN");
            return newToken("numeric", NaN);
          case '"':
          case "'":
            doubleQuote2 = read2() === '"';
            buffer = "";
            lexState = "string";
            return;
        }
        throw invalidChar(read2());
      }, identifierNameStartEscape: function identifierNameStartEscape() {
        if (c2 !== "u") {
          throw invalidChar(read2());
        }
        read2();
        var u2 = unicodeEscape();
        switch (u2) {
          case "$":
          case "_":
            break;
          default:
            if (!util3.isIdStartChar(u2)) {
              throw invalidIdentifier();
            }
            break;
        }
        buffer += u2;
        lexState = "identifierName";
      }, identifierName: function identifierName() {
        switch (c2) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            buffer += read2();
            return;
          case "\\":
            read2();
            lexState = "identifierNameEscape";
            return;
        }
        if (util3.isIdContinueChar(c2)) {
          buffer += read2();
          return;
        }
        return newToken("identifier", buffer);
      }, identifierNameEscape: function identifierNameEscape() {
        if (c2 !== "u") {
          throw invalidChar(read2());
        }
        read2();
        var u2 = unicodeEscape();
        switch (u2) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            break;
          default:
            if (!util3.isIdContinueChar(u2)) {
              throw invalidIdentifier();
            }
            break;
        }
        buffer += u2;
        lexState = "identifierName";
      }, sign: function sign() {
        switch (c2) {
          case ".":
            buffer = read2();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read2();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read2();
            lexState = "decimalInteger";
            return;
          case "I":
            read2();
            literal2("nfinity");
            return newToken("numeric", _sign * Infinity);
          case "N":
            read2();
            literal2("aN");
            return newToken("numeric", NaN);
        }
        throw invalidChar(read2());
      }, zero: function zero() {
        switch (c2) {
          case ".":
            buffer += read2();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read2();
            lexState = "decimalExponent";
            return;
          case "x":
          case "X":
            buffer += read2();
            lexState = "hexadecimal";
            return;
        }
        return newToken("numeric", _sign * 0);
      }, decimalInteger: function decimalInteger() {
        switch (c2) {
          case ".":
            buffer += read2();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read2();
            lexState = "decimalExponent";
            return;
        }
        if (util3.isDigit(c2)) {
          buffer += read2();
          return;
        }
        return newToken("numeric", _sign * Number(buffer));
      }, decimalPointLeading: function decimalPointLeading() {
        if (util3.isDigit(c2)) {
          buffer += read2();
          lexState = "decimalFraction";
          return;
        }
        throw invalidChar(read2());
      }, decimalPoint: function decimalPoint() {
        switch (c2) {
          case "e":
          case "E":
            buffer += read2();
            lexState = "decimalExponent";
            return;
        }
        if (util3.isDigit(c2)) {
          buffer += read2();
          lexState = "decimalFraction";
          return;
        }
        return newToken("numeric", _sign * Number(buffer));
      }, decimalFraction: function decimalFraction() {
        switch (c2) {
          case "e":
          case "E":
            buffer += read2();
            lexState = "decimalExponent";
            return;
        }
        if (util3.isDigit(c2)) {
          buffer += read2();
          return;
        }
        return newToken("numeric", _sign * Number(buffer));
      }, decimalExponent: function decimalExponent() {
        switch (c2) {
          case "+":
          case "-":
            buffer += read2();
            lexState = "decimalExponentSign";
            return;
        }
        if (util3.isDigit(c2)) {
          buffer += read2();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read2());
      }, decimalExponentSign: function decimalExponentSign() {
        if (util3.isDigit(c2)) {
          buffer += read2();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read2());
      }, decimalExponentInteger: function decimalExponentInteger() {
        if (util3.isDigit(c2)) {
          buffer += read2();
          return;
        }
        return newToken("numeric", _sign * Number(buffer));
      }, hexadecimal: function hexadecimal() {
        if (util3.isHexDigit(c2)) {
          buffer += read2();
          lexState = "hexadecimalInteger";
          return;
        }
        throw invalidChar(read2());
      }, hexadecimalInteger: function hexadecimalInteger() {
        if (util3.isHexDigit(c2)) {
          buffer += read2();
          return;
        }
        return newToken("numeric", _sign * Number(buffer));
      }, string: function string3() {
        switch (c2) {
          case "\\":
            read2();
            buffer += escape2();
            return;
          case '"':
            if (doubleQuote2) {
              read2();
              return newToken("string", buffer);
            }
            buffer += read2();
            return;
          case "'":
            if (!doubleQuote2) {
              read2();
              return newToken("string", buffer);
            }
            buffer += read2();
            return;
          case "\n":
          case "\r":
            throw invalidChar(read2());
          case "\u2028":
          case "\u2029":
            separatorChar(c2);
            break;
          case void 0:
            throw invalidChar(read2());
        }
        buffer += read2();
      }, start: function start() {
        switch (c2) {
          case "{":
          case "[":
            return newToken("punctuator", read2());
        }
        lexState = "value";
      }, beforePropertyName: function beforePropertyName() {
        switch (c2) {
          case "$":
          case "_":
            buffer = read2();
            lexState = "identifierName";
            return;
          case "\\":
            read2();
            lexState = "identifierNameStartEscape";
            return;
          case "}":
            return newToken("punctuator", read2());
          case '"':
          case "'":
            doubleQuote2 = read2() === '"';
            lexState = "string";
            return;
        }
        if (util3.isIdStartChar(c2)) {
          buffer += read2();
          lexState = "identifierName";
          return;
        }
        throw invalidChar(read2());
      }, afterPropertyName: function afterPropertyName() {
        if (c2 === ":") {
          return newToken("punctuator", read2());
        }
        throw invalidChar(read2());
      }, beforePropertyValue: function beforePropertyValue() {
        lexState = "value";
      }, afterPropertyValue: function afterPropertyValue() {
        switch (c2) {
          case ",":
          case "}":
            return newToken("punctuator", read2());
        }
        throw invalidChar(read2());
      }, beforeArrayValue: function beforeArrayValue() {
        if (c2 === "]") {
          return newToken("punctuator", read2());
        }
        lexState = "value";
      }, afterArrayValue: function afterArrayValue() {
        switch (c2) {
          case ",":
          case "]":
            return newToken("punctuator", read2());
        }
        throw invalidChar(read2());
      }, end: function end() {
        throw invalidChar(read2());
      } };
      function newToken(type, value) {
        return { type, value, line, column };
      }
      function literal2(s2) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = s2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _c = _step.value;
            var p2 = peek();
            if (p2 !== _c) {
              throw invalidChar(read2());
            }
            read2();
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      function escape2() {
        var c3 = peek();
        switch (c3) {
          case "b":
            read2();
            return "\b";
          case "f":
            read2();
            return "\f";
          case "n":
            read2();
            return "\n";
          case "r":
            read2();
            return "\r";
          case "t":
            read2();
            return "	";
          case "v":
            read2();
            return "\v";
          case "0":
            read2();
            if (util3.isDigit(peek())) {
              throw invalidChar(read2());
            }
            return "\0";
          case "x":
            read2();
            return hexEscape();
          case "u":
            read2();
            return unicodeEscape();
          case "\n":
          case "\u2028":
          case "\u2029":
            read2();
            return "";
          case "\r":
            read2();
            if (peek() === "\n") {
              read2();
            }
            return "";
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            throw invalidChar(read2());
          case void 0:
            throw invalidChar(read2());
        }
        return read2();
      }
      function hexEscape() {
        var buffer2 = "";
        var c3 = peek();
        if (!util3.isHexDigit(c3)) {
          throw invalidChar(read2());
        }
        buffer2 += read2();
        c3 = peek();
        if (!util3.isHexDigit(c3)) {
          throw invalidChar(read2());
        }
        buffer2 += read2();
        return String.fromCodePoint(parseInt(buffer2, 16));
      }
      function unicodeEscape() {
        var buffer2 = "";
        var count = 4;
        while (count-- > 0) {
          var _c2 = peek();
          if (!util3.isHexDigit(_c2)) {
            throw invalidChar(read2());
          }
          buffer2 += read2();
        }
        return String.fromCodePoint(parseInt(buffer2, 16));
      }
      var parseStates = { start: function start() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        push2();
      }, beforePropertyName: function beforePropertyName() {
        switch (token.type) {
          case "identifier":
          case "string":
            key = token.value;
            parseState = "afterPropertyName";
            return;
          case "punctuator":
            pop();
            return;
          case "eof":
            throw invalidEOF();
        }
      }, afterPropertyName: function afterPropertyName() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        parseState = "beforePropertyValue";
      }, beforePropertyValue: function beforePropertyValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        push2();
      }, beforeArrayValue: function beforeArrayValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        if (token.type === "punctuator" && token.value === "]") {
          pop();
          return;
        }
        push2();
      }, afterPropertyValue: function afterPropertyValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        switch (token.value) {
          case ",":
            parseState = "beforePropertyName";
            return;
          case "}":
            pop();
        }
      }, afterArrayValue: function afterArrayValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        switch (token.value) {
          case ",":
            parseState = "beforeArrayValue";
            return;
          case "]":
            pop();
        }
      }, end: function end() {
      } };
      function push2() {
        var value = void 0;
        switch (token.type) {
          case "punctuator":
            switch (token.value) {
              case "{":
                value = {};
                break;
              case "[":
                value = [];
                break;
            }
            break;
          case "null":
          case "boolean":
          case "numeric":
          case "string":
            value = token.value;
            break;
        }
        if (root2 === void 0) {
          root2 = value;
        } else {
          var parent = stack[stack.length - 1];
          if (Array.isArray(parent)) {
            parent.push(value);
          } else {
            parent[key] = value;
          }
        }
        if (value !== null && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object") {
          stack.push(value);
          if (Array.isArray(value)) {
            parseState = "beforeArrayValue";
          } else {
            parseState = "beforePropertyName";
          }
        } else {
          var current = stack[stack.length - 1];
          if (current == null) {
            parseState = "end";
          } else if (Array.isArray(current)) {
            parseState = "afterArrayValue";
          } else {
            parseState = "afterPropertyValue";
          }
        }
      }
      function pop() {
        stack.pop();
        var current = stack[stack.length - 1];
        if (current == null) {
          parseState = "end";
        } else if (Array.isArray(current)) {
          parseState = "afterArrayValue";
        } else {
          parseState = "afterPropertyValue";
        }
      }
      function invalidChar(c3) {
        if (c3 === void 0) {
          return syntaxError2("JSON5: invalid end of input at " + line + ":" + column);
        }
        return syntaxError2("JSON5: invalid character '" + formatChar(c3) + "' at " + line + ":" + column);
      }
      function invalidEOF() {
        return syntaxError2("JSON5: invalid end of input at " + line + ":" + column);
      }
      function invalidIdentifier() {
        column -= 5;
        return syntaxError2("JSON5: invalid identifier character at " + line + ":" + column);
      }
      function separatorChar(c3) {
        console.warn("JSON5: '" + c3 + "' is not valid ECMAScript; consider escaping");
      }
      function formatChar(c3) {
        var replacements = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
        if (replacements[c3]) {
          return replacements[c3];
        }
        if (c3 < " ") {
          var hexString = c3.charCodeAt(0).toString(16);
          return "\\x" + ("00" + hexString).substring(hexString.length);
        }
        return c3;
      }
      function syntaxError2(message) {
        var err = new SyntaxError(message);
        err.lineNumber = line;
        err.columnNumber = column;
        return err;
      }
      module3.exports = exports3["default"];
    })(parse2, parse2.exports);
    var stringify2 = { exports: {} };
    (function(module3, exports3) {
      Object.defineProperty(exports3, "__esModule", { value: true });
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      exports3.default = stringify3;
      var _util = util$12;
      var util3 = _interopRequireWildcard2(_util);
      function _interopRequireWildcard2(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                newObj[key] = obj[key];
            }
          }
          newObj.default = obj;
          return newObj;
        }
      }
      function stringify3(value, replacer, space2) {
        var stack = [];
        var indent = "";
        var propertyList = void 0;
        var replacerFunc = void 0;
        var gap = "";
        var quote = void 0;
        if (replacer != null && (typeof replacer === "undefined" ? "undefined" : _typeof(replacer)) === "object" && !Array.isArray(replacer)) {
          space2 = replacer.space;
          quote = replacer.quote;
          replacer = replacer.replacer;
        }
        if (typeof replacer === "function") {
          replacerFunc = replacer;
        } else if (Array.isArray(replacer)) {
          propertyList = [];
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = replacer[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var v2 = _step.value;
              var item = void 0;
              if (typeof v2 === "string") {
                item = v2;
              } else if (typeof v2 === "number" || v2 instanceof String || v2 instanceof Number) {
                item = String(v2);
              }
              if (item !== void 0 && propertyList.indexOf(item) < 0) {
                propertyList.push(item);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
        if (space2 instanceof Number) {
          space2 = Number(space2);
        } else if (space2 instanceof String) {
          space2 = String(space2);
        }
        if (typeof space2 === "number") {
          if (space2 > 0) {
            space2 = Math.min(10, Math.floor(space2));
            gap = "          ".substr(0, space2);
          }
        } else if (typeof space2 === "string") {
          gap = space2.substr(0, 10);
        }
        return serializeProperty("", { "": value });
        function serializeProperty(key, holder) {
          var value2 = holder[key];
          if (value2 != null) {
            if (typeof value2.toJSON5 === "function") {
              value2 = value2.toJSON5(key);
            } else if (typeof value2.toJSON === "function") {
              value2 = value2.toJSON(key);
            }
          }
          if (replacerFunc) {
            value2 = replacerFunc.call(holder, key, value2);
          }
          if (value2 instanceof Number) {
            value2 = Number(value2);
          } else if (value2 instanceof String) {
            value2 = String(value2);
          } else if (value2 instanceof Boolean) {
            value2 = value2.valueOf();
          }
          switch (value2) {
            case null:
              return "null";
            case true:
              return "true";
            case false:
              return "false";
          }
          if (typeof value2 === "string") {
            return quoteString(value2);
          }
          if (typeof value2 === "number") {
            return String(value2);
          }
          if ((typeof value2 === "undefined" ? "undefined" : _typeof(value2)) === "object") {
            return Array.isArray(value2) ? serializeArray2(value2) : serializeObject2(value2);
          }
          return void 0;
        }
        function quoteString(value2) {
          var quotes = { "'": 0.1, '"': 0.2 };
          var replacements = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
          var product = "";
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = value2[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var c2 = _step2.value;
              switch (c2) {
                case "'":
                case '"':
                  quotes[c2]++;
                  product += c2;
                  continue;
              }
              if (replacements[c2]) {
                product += replacements[c2];
                continue;
              }
              if (c2 < " ") {
                var hexString = c2.charCodeAt(0).toString(16);
                product += "\\x" + ("00" + hexString).substring(hexString.length);
                continue;
              }
              product += c2;
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var quoteChar = quote || Object.keys(quotes).reduce(function(a2, b2) {
            return quotes[a2] < quotes[b2] ? a2 : b2;
          });
          product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
          return quoteChar + product + quoteChar;
        }
        function serializeObject2(value2) {
          if (stack.indexOf(value2) >= 0) {
            throw TypeError("Converting circular structure to JSON5");
          }
          stack.push(value2);
          var stepback = indent;
          indent = indent + gap;
          var keys = propertyList || Object.keys(value2);
          var partial2 = [];
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var key = _step3.value;
              var propertyString = serializeProperty(key, value2);
              if (propertyString !== void 0) {
                var member = serializeKey(key) + ":";
                if (gap !== "") {
                  member += " ";
                }
                member += propertyString;
                partial2.push(member);
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          var final = void 0;
          if (partial2.length === 0) {
            final = "{}";
          } else {
            var properties = void 0;
            if (gap === "") {
              properties = partial2.join(",");
              final = "{" + properties + "}";
            } else {
              var separator = ",\n" + indent;
              properties = partial2.join(separator);
              final = "{\n" + indent + properties + ",\n" + stepback + "}";
            }
          }
          stack.pop();
          indent = stepback;
          return final;
        }
        function serializeKey(key) {
          if (key.length === 0) {
            return quoteString(key);
          }
          var firstChar = String.fromCodePoint(key.codePointAt(0));
          if (!util3.isIdStartChar(firstChar)) {
            return quoteString(key);
          }
          for (var i2 = firstChar.length; i2 < key.length; i2++) {
            if (!util3.isIdContinueChar(String.fromCodePoint(key.codePointAt(i2)))) {
              return quoteString(key);
            }
          }
          return key;
        }
        function serializeArray2(value2) {
          if (stack.indexOf(value2) >= 0) {
            throw TypeError("Converting circular structure to JSON5");
          }
          stack.push(value2);
          var stepback = indent;
          indent = indent + gap;
          var partial2 = [];
          for (var i2 = 0; i2 < value2.length; i2++) {
            var propertyString = serializeProperty(String(i2), value2);
            partial2.push(propertyString !== void 0 ? propertyString : "null");
          }
          var final = void 0;
          if (partial2.length === 0) {
            final = "[]";
          } else {
            if (gap === "") {
              var properties = partial2.join(",");
              final = "[" + properties + "]";
            } else {
              var separator = ",\n" + indent;
              var _properties = partial2.join(separator);
              final = "[\n" + indent + _properties + ",\n" + stepback + "]";
            }
          }
          stack.pop();
          indent = stepback;
          return final;
        }
      }
      module3.exports = exports3["default"];
    })(stringify2, stringify2.exports);
    (function(module3, exports3) {
      Object.defineProperty(exports3, "__esModule", { value: true });
      var _parse = parse2.exports;
      var _parse2 = _interopRequireDefault2(_parse);
      var _stringify = stringify2.exports;
      var _stringify2 = _interopRequireDefault2(_stringify);
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      exports3.default = { parse: _parse2.default, stringify: _stringify2.default };
      module3.exports = exports3["default"];
    })(lib$12, lib$12.exports);
    var JSON5 = lib$12.exports;
    var specialValues = {
      null: null,
      true: true,
      false: false
    };
    function parseQuery$2(query) {
      if (query.substr(0, 1) !== "?") {
        throw new Error("A valid query string passed to parseQuery should begin with '?'");
      }
      query = query.substr(1);
      if (!query) {
        return {};
      }
      if (query.substr(0, 1) === "{" && query.substr(-1) === "}") {
        return JSON5.parse(query);
      }
      const queryArgs = query.split(/[,&]/g);
      const result2 = {};
      queryArgs.forEach((arg) => {
        const idx = arg.indexOf("=");
        if (idx >= 0) {
          let name = arg.substr(0, idx);
          let value = decodeURIComponent(arg.substr(idx + 1));
          if (specialValues.hasOwnProperty(value)) {
            value = specialValues[value];
          }
          if (name.substr(-2) === "[]") {
            name = decodeURIComponent(name.substr(0, name.length - 2));
            if (!Array.isArray(result2[name])) {
              result2[name] = [];
            }
            result2[name].push(value);
          } else {
            name = decodeURIComponent(name);
            result2[name] = value;
          }
        } else {
          if (arg.substr(0, 1) === "-") {
            result2[decodeURIComponent(arg.substr(1))] = false;
          } else if (arg.substr(0, 1) === "+") {
            result2[decodeURIComponent(arg.substr(1))] = true;
          } else {
            result2[decodeURIComponent(arg)] = true;
          }
        }
      });
      return result2;
    }
    var parseQuery_1 = parseQuery$2;
    var parseQuery$1 = parseQuery_1;
    function getOptions$1(loaderContext) {
      const query = loaderContext.query;
      if (typeof query === "string" && query !== "") {
        return parseQuery$1(loaderContext.query);
      }
      if (!query || typeof query !== "object") {
        return null;
      }
      return query;
    }
    var getOptions_1 = getOptions$1;
    var path$32 = path__default2;
    var matchRelativePath = /^\.\.?[/\\]/;
    function isAbsolutePath(str2) {
      return path$32.posix.isAbsolute(str2) || path$32.win32.isAbsolute(str2);
    }
    function isRelativePath(str2) {
      return matchRelativePath.test(str2);
    }
    function stringifyRequest$1(loaderContext, request) {
      const splitted = request.split("!");
      const context2 = loaderContext.context || loaderContext.options && loaderContext.options.context;
      return JSON.stringify(splitted.map((part) => {
        const splittedPart = part.match(/^(.*?)(\?.*)/);
        const query = splittedPart ? splittedPart[2] : "";
        let singlePath = splittedPart ? splittedPart[1] : part;
        if (isAbsolutePath(singlePath) && context2) {
          singlePath = path$32.relative(context2, singlePath);
          if (isAbsolutePath(singlePath)) {
            return singlePath + query;
          }
          if (isRelativePath(singlePath) === false) {
            singlePath = "./" + singlePath;
          }
        }
        return singlePath.replace(/\\/g, "/") + query;
      }).join("!"));
    }
    var stringifyRequest_1 = stringifyRequest$1;
    function getRemainingRequest$1(loaderContext) {
      if (loaderContext.remainingRequest) {
        return loaderContext.remainingRequest;
      }
      const request = loaderContext.loaders.slice(loaderContext.loaderIndex + 1).map((obj) => obj.request).concat([loaderContext.resource]);
      return request.join("!");
    }
    var getRemainingRequest_1 = getRemainingRequest$1;
    function getCurrentRequest$1(loaderContext) {
      if (loaderContext.currentRequest) {
        return loaderContext.currentRequest;
      }
      const request = loaderContext.loaders.slice(loaderContext.loaderIndex).map((obj) => obj.request).concat([loaderContext.resource]);
      return request.join("!");
    }
    var getCurrentRequest_1 = getCurrentRequest$1;
    var path$22 = path__default2;
    function isUrlRequest$1(url2, root2) {
      if (/^[a-z][a-z0-9+.-]*:/i.test(url2) && !path$22.win32.isAbsolute(url2)) {
        return false;
      }
      if (/^\/\//.test(url2)) {
        return false;
      }
      if (/^[{}[\]#*;,'$%&(=?`^<>]/.test(url2)) {
        return false;
      }
      if ((root2 === void 0 || root2 === false) && /^\//.test(url2)) {
        return false;
      }
      return true;
    }
    var isUrlRequest_1 = isUrlRequest$1;
    var matchNativeWin32Path = /^[A-Z]:[/\\]|^\\\\/i;
    function urlToRequest$1(url2, root2) {
      if (url2 === "") {
        return "";
      }
      const moduleRequestRegex = /^[^?]*~/;
      let request;
      if (matchNativeWin32Path.test(url2)) {
        request = url2;
      } else if (root2 !== void 0 && root2 !== false && /^\//.test(url2)) {
        switch (typeof root2) {
          case "string":
            if (moduleRequestRegex.test(root2)) {
              request = root2.replace(/([^~/])$/, "$1/") + url2.slice(1);
            } else {
              request = root2 + url2;
            }
            break;
          case "boolean":
            request = url2;
            break;
          default:
            throw new Error("Unexpected parameters to loader-utils 'urlToRequest': url = " + url2 + ", root = " + root2 + ".");
        }
      } else if (/^\.\.?\//.test(url2)) {
        request = url2;
      } else {
        request = "./" + url2;
      }
      if (moduleRequestRegex.test(request)) {
        request = request.replace(moduleRequestRegex, "");
      }
      return request;
    }
    var urlToRequest_1 = urlToRequest$1;
    function parseString$1(str2) {
      try {
        if (str2[0] === '"') {
          return JSON.parse(str2);
        }
        if (str2[0] === "'" && str2.substr(str2.length - 1) === "'") {
          return parseString$1(str2.replace(/\\.|"/g, (x2) => x2 === '"' ? '\\"' : x2).replace(/^'|'$/g, '"'));
        }
        return JSON.parse('"' + str2 + '"');
      } catch (e2) {
        return str2;
      }
    }
    var parseString_1 = parseString$1;
    var big = { exports: {} };
    (function(module3) {
      (function(GLOBAL) {
        var Big, DP = 20, RM = 1, MAX_DP = 1e6, MAX_POWER = 1e6, NE = -7, PE = 21, NAME = "[big.js] ", INVALID = NAME + "Invalid ", INVALID_DP = INVALID + "decimal places", INVALID_RM = INVALID + "rounding mode", DIV_BY_ZERO = NAME + "Division by zero", P2 = {}, UNDEFINED = void 0, NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
        function _Big_() {
          function Big2(n3) {
            var x2 = this;
            if (!(x2 instanceof Big2))
              return n3 === UNDEFINED ? _Big_() : new Big2(n3);
            if (n3 instanceof Big2) {
              x2.s = n3.s;
              x2.e = n3.e;
              x2.c = n3.c.slice();
            } else {
              parse3(x2, n3);
            }
            x2.constructor = Big2;
          }
          Big2.prototype = P2;
          Big2.DP = DP;
          Big2.RM = RM;
          Big2.NE = NE;
          Big2.PE = PE;
          Big2.version = "5.2.2";
          return Big2;
        }
        function parse3(x2, n3) {
          var e2, i2, nl;
          if (n3 === 0 && 1 / n3 < 0)
            n3 = "-0";
          else if (!NUMERIC.test(n3 += ""))
            throw Error(INVALID + "number");
          x2.s = n3.charAt(0) == "-" ? (n3 = n3.slice(1), -1) : 1;
          if ((e2 = n3.indexOf(".")) > -1)
            n3 = n3.replace(".", "");
          if ((i2 = n3.search(/e/i)) > 0) {
            if (e2 < 0)
              e2 = i2;
            e2 += +n3.slice(i2 + 1);
            n3 = n3.substring(0, i2);
          } else if (e2 < 0) {
            e2 = n3.length;
          }
          nl = n3.length;
          for (i2 = 0; i2 < nl && n3.charAt(i2) == "0"; )
            ++i2;
          if (i2 == nl) {
            x2.c = [x2.e = 0];
          } else {
            for (; nl > 0 && n3.charAt(--nl) == "0"; )
              ;
            x2.e = e2 - i2 - 1;
            x2.c = [];
            for (e2 = 0; i2 <= nl; )
              x2.c[e2++] = +n3.charAt(i2++);
          }
          return x2;
        }
        function round(x2, dp, rm, more) {
          var xc = x2.c, i2 = x2.e + dp + 1;
          if (i2 < xc.length) {
            if (rm === 1) {
              more = xc[i2] >= 5;
            } else if (rm === 2) {
              more = xc[i2] > 5 || xc[i2] == 5 && (more || i2 < 0 || xc[i2 + 1] !== UNDEFINED || xc[i2 - 1] & 1);
            } else if (rm === 3) {
              more = more || !!xc[0];
            } else {
              more = false;
              if (rm !== 0)
                throw Error(INVALID_RM);
            }
            if (i2 < 1) {
              xc.length = 1;
              if (more) {
                x2.e = -dp;
                xc[0] = 1;
              } else {
                xc[0] = x2.e = 0;
              }
            } else {
              xc.length = i2--;
              if (more) {
                for (; ++xc[i2] > 9; ) {
                  xc[i2] = 0;
                  if (!i2--) {
                    ++x2.e;
                    xc.unshift(1);
                  }
                }
              }
              for (i2 = xc.length; !xc[--i2]; )
                xc.pop();
            }
          } else if (rm < 0 || rm > 3 || rm !== ~~rm) {
            throw Error(INVALID_RM);
          }
          return x2;
        }
        function stringify3(x2, id2, n3, k2) {
          var e2, s2, Big2 = x2.constructor, z2 = !x2.c[0];
          if (n3 !== UNDEFINED) {
            if (n3 !== ~~n3 || n3 < (id2 == 3) || n3 > MAX_DP) {
              throw Error(id2 == 3 ? INVALID + "precision" : INVALID_DP);
            }
            x2 = new Big2(x2);
            n3 = k2 - x2.e;
            if (x2.c.length > ++k2)
              round(x2, n3, Big2.RM);
            if (id2 == 2)
              k2 = x2.e + n3 + 1;
            for (; x2.c.length < k2; )
              x2.c.push(0);
          }
          e2 = x2.e;
          s2 = x2.c.join("");
          n3 = s2.length;
          if (id2 != 2 && (id2 == 1 || id2 == 3 && k2 <= e2 || e2 <= Big2.NE || e2 >= Big2.PE)) {
            s2 = s2.charAt(0) + (n3 > 1 ? "." + s2.slice(1) : "") + (e2 < 0 ? "e" : "e+") + e2;
          } else if (e2 < 0) {
            for (; ++e2; )
              s2 = "0" + s2;
            s2 = "0." + s2;
          } else if (e2 > 0) {
            if (++e2 > n3)
              for (e2 -= n3; e2--; )
                s2 += "0";
            else if (e2 < n3)
              s2 = s2.slice(0, e2) + "." + s2.slice(e2);
          } else if (n3 > 1) {
            s2 = s2.charAt(0) + "." + s2.slice(1);
          }
          return x2.s < 0 && (!z2 || id2 == 4) ? "-" + s2 : s2;
        }
        P2.abs = function() {
          var x2 = new this.constructor(this);
          x2.s = 1;
          return x2;
        };
        P2.cmp = function(y3) {
          var isneg, x2 = this, xc = x2.c, yc = (y3 = new x2.constructor(y3)).c, i2 = x2.s, j2 = y3.s, k2 = x2.e, l2 = y3.e;
          if (!xc[0] || !yc[0])
            return !xc[0] ? !yc[0] ? 0 : -j2 : i2;
          if (i2 != j2)
            return i2;
          isneg = i2 < 0;
          if (k2 != l2)
            return k2 > l2 ^ isneg ? 1 : -1;
          j2 = (k2 = xc.length) < (l2 = yc.length) ? k2 : l2;
          for (i2 = -1; ++i2 < j2; ) {
            if (xc[i2] != yc[i2])
              return xc[i2] > yc[i2] ^ isneg ? 1 : -1;
          }
          return k2 == l2 ? 0 : k2 > l2 ^ isneg ? 1 : -1;
        };
        P2.div = function(y3) {
          var x2 = this, Big2 = x2.constructor, a2 = x2.c, b2 = (y3 = new Big2(y3)).c, k2 = x2.s == y3.s ? 1 : -1, dp = Big2.DP;
          if (dp !== ~~dp || dp < 0 || dp > MAX_DP)
            throw Error(INVALID_DP);
          if (!b2[0])
            throw Error(DIV_BY_ZERO);
          if (!a2[0])
            return new Big2(k2 * 0);
          var bl, bt2, n3, cmp, ri2, bz = b2.slice(), ai2 = bl = b2.length, al = a2.length, r2 = a2.slice(0, bl), rl = r2.length, q2 = y3, qc = q2.c = [], qi2 = 0, d3 = dp + (q2.e = x2.e - y3.e) + 1;
          q2.s = k2;
          k2 = d3 < 0 ? 0 : d3;
          bz.unshift(0);
          for (; rl++ < bl; )
            r2.push(0);
          do {
            for (n3 = 0; n3 < 10; n3++) {
              if (bl != (rl = r2.length)) {
                cmp = bl > rl ? 1 : -1;
              } else {
                for (ri2 = -1, cmp = 0; ++ri2 < bl; ) {
                  if (b2[ri2] != r2[ri2]) {
                    cmp = b2[ri2] > r2[ri2] ? 1 : -1;
                    break;
                  }
                }
              }
              if (cmp < 0) {
                for (bt2 = rl == bl ? b2 : bz; rl; ) {
                  if (r2[--rl] < bt2[rl]) {
                    ri2 = rl;
                    for (; ri2 && !r2[--ri2]; )
                      r2[ri2] = 9;
                    --r2[ri2];
                    r2[rl] += 10;
                  }
                  r2[rl] -= bt2[rl];
                }
                for (; !r2[0]; )
                  r2.shift();
              } else {
                break;
              }
            }
            qc[qi2++] = cmp ? n3 : ++n3;
            if (r2[0] && cmp)
              r2[rl] = a2[ai2] || 0;
            else
              r2 = [a2[ai2]];
          } while ((ai2++ < al || r2[0] !== UNDEFINED) && k2--);
          if (!qc[0] && qi2 != 1) {
            qc.shift();
            q2.e--;
          }
          if (qi2 > d3)
            round(q2, dp, Big2.RM, r2[0] !== UNDEFINED);
          return q2;
        };
        P2.eq = function(y3) {
          return !this.cmp(y3);
        };
        P2.gt = function(y3) {
          return this.cmp(y3) > 0;
        };
        P2.gte = function(y3) {
          return this.cmp(y3) > -1;
        };
        P2.lt = function(y3) {
          return this.cmp(y3) < 0;
        };
        P2.lte = function(y3) {
          return this.cmp(y3) < 1;
        };
        P2.minus = P2.sub = function(y3) {
          var i2, j2, t, xlty, x2 = this, Big2 = x2.constructor, a2 = x2.s, b2 = (y3 = new Big2(y3)).s;
          if (a2 != b2) {
            y3.s = -b2;
            return x2.plus(y3);
          }
          var xc = x2.c.slice(), xe2 = x2.e, yc = y3.c, ye2 = y3.e;
          if (!xc[0] || !yc[0]) {
            return yc[0] ? (y3.s = -b2, y3) : new Big2(xc[0] ? x2 : 0);
          }
          if (a2 = xe2 - ye2) {
            if (xlty = a2 < 0) {
              a2 = -a2;
              t = xc;
            } else {
              ye2 = xe2;
              t = yc;
            }
            t.reverse();
            for (b2 = a2; b2--; )
              t.push(0);
            t.reverse();
          } else {
            j2 = ((xlty = xc.length < yc.length) ? xc : yc).length;
            for (a2 = b2 = 0; b2 < j2; b2++) {
              if (xc[b2] != yc[b2]) {
                xlty = xc[b2] < yc[b2];
                break;
              }
            }
          }
          if (xlty) {
            t = xc;
            xc = yc;
            yc = t;
            y3.s = -y3.s;
          }
          if ((b2 = (j2 = yc.length) - (i2 = xc.length)) > 0)
            for (; b2--; )
              xc[i2++] = 0;
          for (b2 = i2; j2 > a2; ) {
            if (xc[--j2] < yc[j2]) {
              for (i2 = j2; i2 && !xc[--i2]; )
                xc[i2] = 9;
              --xc[i2];
              xc[j2] += 10;
            }
            xc[j2] -= yc[j2];
          }
          for (; xc[--b2] === 0; )
            xc.pop();
          for (; xc[0] === 0; ) {
            xc.shift();
            --ye2;
          }
          if (!xc[0]) {
            y3.s = 1;
            xc = [ye2 = 0];
          }
          y3.c = xc;
          y3.e = ye2;
          return y3;
        };
        P2.mod = function(y3) {
          var ygtx, x2 = this, Big2 = x2.constructor, a2 = x2.s, b2 = (y3 = new Big2(y3)).s;
          if (!y3.c[0])
            throw Error(DIV_BY_ZERO);
          x2.s = y3.s = 1;
          ygtx = y3.cmp(x2) == 1;
          x2.s = a2;
          y3.s = b2;
          if (ygtx)
            return new Big2(x2);
          a2 = Big2.DP;
          b2 = Big2.RM;
          Big2.DP = Big2.RM = 0;
          x2 = x2.div(y3);
          Big2.DP = a2;
          Big2.RM = b2;
          return this.minus(x2.times(y3));
        };
        P2.plus = P2.add = function(y3) {
          var t, x2 = this, Big2 = x2.constructor, a2 = x2.s, b2 = (y3 = new Big2(y3)).s;
          if (a2 != b2) {
            y3.s = -b2;
            return x2.minus(y3);
          }
          var xe2 = x2.e, xc = x2.c, ye2 = y3.e, yc = y3.c;
          if (!xc[0] || !yc[0])
            return yc[0] ? y3 : new Big2(xc[0] ? x2 : a2 * 0);
          xc = xc.slice();
          if (a2 = xe2 - ye2) {
            if (a2 > 0) {
              ye2 = xe2;
              t = yc;
            } else {
              a2 = -a2;
              t = xc;
            }
            t.reverse();
            for (; a2--; )
              t.push(0);
            t.reverse();
          }
          if (xc.length - yc.length < 0) {
            t = yc;
            yc = xc;
            xc = t;
          }
          a2 = yc.length;
          for (b2 = 0; a2; xc[a2] %= 10)
            b2 = (xc[--a2] = xc[a2] + yc[a2] + b2) / 10 | 0;
          if (b2) {
            xc.unshift(b2);
            ++ye2;
          }
          for (a2 = xc.length; xc[--a2] === 0; )
            xc.pop();
          y3.c = xc;
          y3.e = ye2;
          return y3;
        };
        P2.pow = function(n3) {
          var x2 = this, one = new x2.constructor(1), y3 = one, isneg = n3 < 0;
          if (n3 !== ~~n3 || n3 < -MAX_POWER || n3 > MAX_POWER)
            throw Error(INVALID + "exponent");
          if (isneg)
            n3 = -n3;
          for (; ; ) {
            if (n3 & 1)
              y3 = y3.times(x2);
            n3 >>= 1;
            if (!n3)
              break;
            x2 = x2.times(x2);
          }
          return isneg ? one.div(y3) : y3;
        };
        P2.round = function(dp, rm) {
          var Big2 = this.constructor;
          if (dp === UNDEFINED)
            dp = 0;
          else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP)
            throw Error(INVALID_DP);
          return round(new Big2(this), dp, rm === UNDEFINED ? Big2.RM : rm);
        };
        P2.sqrt = function() {
          var r2, c2, t, x2 = this, Big2 = x2.constructor, s2 = x2.s, e2 = x2.e, half = new Big2(0.5);
          if (!x2.c[0])
            return new Big2(x2);
          if (s2 < 0)
            throw Error(NAME + "No square root");
          s2 = Math.sqrt(x2 + "");
          if (s2 === 0 || s2 === 1 / 0) {
            c2 = x2.c.join("");
            if (!(c2.length + e2 & 1))
              c2 += "0";
            s2 = Math.sqrt(c2);
            e2 = ((e2 + 1) / 2 | 0) - (e2 < 0 || e2 & 1);
            r2 = new Big2((s2 == 1 / 0 ? "1e" : (s2 = s2.toExponential()).slice(0, s2.indexOf("e") + 1)) + e2);
          } else {
            r2 = new Big2(s2);
          }
          e2 = r2.e + (Big2.DP += 4);
          do {
            t = r2;
            r2 = half.times(t.plus(x2.div(t)));
          } while (t.c.slice(0, e2).join("") !== r2.c.slice(0, e2).join(""));
          return round(r2, Big2.DP -= 4, Big2.RM);
        };
        P2.times = P2.mul = function(y3) {
          var c2, x2 = this, Big2 = x2.constructor, xc = x2.c, yc = (y3 = new Big2(y3)).c, a2 = xc.length, b2 = yc.length, i2 = x2.e, j2 = y3.e;
          y3.s = x2.s == y3.s ? 1 : -1;
          if (!xc[0] || !yc[0])
            return new Big2(y3.s * 0);
          y3.e = i2 + j2;
          if (a2 < b2) {
            c2 = xc;
            xc = yc;
            yc = c2;
            j2 = a2;
            a2 = b2;
            b2 = j2;
          }
          for (c2 = new Array(j2 = a2 + b2); j2--; )
            c2[j2] = 0;
          for (i2 = b2; i2--; ) {
            b2 = 0;
            for (j2 = a2 + i2; j2 > i2; ) {
              b2 = c2[j2] + yc[i2] * xc[j2 - i2 - 1] + b2;
              c2[j2--] = b2 % 10;
              b2 = b2 / 10 | 0;
            }
            c2[j2] = (c2[j2] + b2) % 10;
          }
          if (b2)
            ++y3.e;
          else
            c2.shift();
          for (i2 = c2.length; !c2[--i2]; )
            c2.pop();
          y3.c = c2;
          return y3;
        };
        P2.toExponential = function(dp) {
          return stringify3(this, 1, dp, dp);
        };
        P2.toFixed = function(dp) {
          return stringify3(this, 2, dp, this.e + dp);
        };
        P2.toPrecision = function(sd) {
          return stringify3(this, 3, sd, sd - 1);
        };
        P2.toString = function() {
          return stringify3(this);
        };
        P2.valueOf = P2.toJSON = function() {
          return stringify3(this, 4);
        };
        Big = _Big_();
        Big["default"] = Big.Big = Big;
        if (module3.exports) {
          module3.exports = Big;
        } else {
          GLOBAL.Big = Big;
        }
      })(build$2.commonjsGlobal);
    })(big);
    var baseEncodeTables = {
      26: "abcdefghijklmnopqrstuvwxyz",
      32: "123456789abcdefghjkmnpqrstuvwxyz",
      36: "0123456789abcdefghijklmnopqrstuvwxyz",
      49: "abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
      52: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
      58: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
      62: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
      64: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_"
    };
    function encodeBufferToBase(buffer, base2) {
      const encodeTable = baseEncodeTables[base2];
      if (!encodeTable) {
        throw new Error("Unknown encoding base" + base2);
      }
      const readLength = buffer.length;
      const Big = big.exports;
      Big.RM = Big.DP = 0;
      let b2 = new Big(0);
      for (let i2 = readLength - 1; i2 >= 0; i2--) {
        b2 = b2.times(256).plus(buffer[i2]);
      }
      let output = "";
      while (b2.gt(0)) {
        output = encodeTable[b2.mod(base2)] + output;
        b2 = b2.div(base2);
      }
      Big.DP = 20;
      Big.RM = 1;
      return output;
    }
    function getHashDigest$2(buffer, hashType, digestType, maxLength) {
      hashType = hashType || "md5";
      maxLength = maxLength || 9999;
      const hash2 = require$$1__default2.createHash(hashType);
      hash2.update(buffer);
      if (digestType === "base26" || digestType === "base32" || digestType === "base36" || digestType === "base49" || digestType === "base52" || digestType === "base58" || digestType === "base62" || digestType === "base64") {
        return encodeBufferToBase(hash2.digest(), digestType.substr(4)).substr(0, maxLength);
      } else {
        return hash2.digest(digestType || "hex").substr(0, maxLength);
      }
    }
    var getHashDigest_1 = getHashDigest$2;
    var emojisList$1 = [
      "\u{1F004}\uFE0F",
      "\u{1F0CF}",
      "\u{1F170}\uFE0F",
      "\u{1F171}\uFE0F",
      "\u{1F17E}\uFE0F",
      "\u{1F17F}\uFE0F",
      "\u{1F18E}",
      "\u{1F191}",
      "\u{1F192}",
      "\u{1F193}",
      "\u{1F194}",
      "\u{1F195}",
      "\u{1F196}",
      "\u{1F197}",
      "\u{1F198}",
      "\u{1F199}",
      "\u{1F19A}",
      "\u{1F1E6}\u{1F1E8}",
      "\u{1F1E6}\u{1F1E9}",
      "\u{1F1E6}\u{1F1EA}",
      "\u{1F1E6}\u{1F1EB}",
      "\u{1F1E6}\u{1F1EC}",
      "\u{1F1E6}\u{1F1EE}",
      "\u{1F1E6}\u{1F1F1}",
      "\u{1F1E6}\u{1F1F2}",
      "\u{1F1E6}\u{1F1F4}",
      "\u{1F1E6}\u{1F1F6}",
      "\u{1F1E6}\u{1F1F7}",
      "\u{1F1E6}\u{1F1F8}",
      "\u{1F1E6}\u{1F1F9}",
      "\u{1F1E6}\u{1F1FA}",
      "\u{1F1E6}\u{1F1FC}",
      "\u{1F1E6}\u{1F1FD}",
      "\u{1F1E6}\u{1F1FF}",
      "\u{1F1E6}",
      "\u{1F1E7}\u{1F1E6}",
      "\u{1F1E7}\u{1F1E7}",
      "\u{1F1E7}\u{1F1E9}",
      "\u{1F1E7}\u{1F1EA}",
      "\u{1F1E7}\u{1F1EB}",
      "\u{1F1E7}\u{1F1EC}",
      "\u{1F1E7}\u{1F1ED}",
      "\u{1F1E7}\u{1F1EE}",
      "\u{1F1E7}\u{1F1EF}",
      "\u{1F1E7}\u{1F1F1}",
      "\u{1F1E7}\u{1F1F2}",
      "\u{1F1E7}\u{1F1F3}",
      "\u{1F1E7}\u{1F1F4}",
      "\u{1F1E7}\u{1F1F6}",
      "\u{1F1E7}\u{1F1F7}",
      "\u{1F1E7}\u{1F1F8}",
      "\u{1F1E7}\u{1F1F9}",
      "\u{1F1E7}\u{1F1FB}",
      "\u{1F1E7}\u{1F1FC}",
      "\u{1F1E7}\u{1F1FE}",
      "\u{1F1E7}\u{1F1FF}",
      "\u{1F1E7}",
      "\u{1F1E8}\u{1F1E6}",
      "\u{1F1E8}\u{1F1E8}",
      "\u{1F1E8}\u{1F1E9}",
      "\u{1F1E8}\u{1F1EB}",
      "\u{1F1E8}\u{1F1EC}",
      "\u{1F1E8}\u{1F1ED}",
      "\u{1F1E8}\u{1F1EE}",
      "\u{1F1E8}\u{1F1F0}",
      "\u{1F1E8}\u{1F1F1}",
      "\u{1F1E8}\u{1F1F2}",
      "\u{1F1E8}\u{1F1F3}",
      "\u{1F1E8}\u{1F1F4}",
      "\u{1F1E8}\u{1F1F5}",
      "\u{1F1E8}\u{1F1F7}",
      "\u{1F1E8}\u{1F1FA}",
      "\u{1F1E8}\u{1F1FB}",
      "\u{1F1E8}\u{1F1FC}",
      "\u{1F1E8}\u{1F1FD}",
      "\u{1F1E8}\u{1F1FE}",
      "\u{1F1E8}\u{1F1FF}",
      "\u{1F1E8}",
      "\u{1F1E9}\u{1F1EA}",
      "\u{1F1E9}\u{1F1EC}",
      "\u{1F1E9}\u{1F1EF}",
      "\u{1F1E9}\u{1F1F0}",
      "\u{1F1E9}\u{1F1F2}",
      "\u{1F1E9}\u{1F1F4}",
      "\u{1F1E9}\u{1F1FF}",
      "\u{1F1E9}",
      "\u{1F1EA}\u{1F1E6}",
      "\u{1F1EA}\u{1F1E8}",
      "\u{1F1EA}\u{1F1EA}",
      "\u{1F1EA}\u{1F1EC}",
      "\u{1F1EA}\u{1F1ED}",
      "\u{1F1EA}\u{1F1F7}",
      "\u{1F1EA}\u{1F1F8}",
      "\u{1F1EA}\u{1F1F9}",
      "\u{1F1EA}\u{1F1FA}",
      "\u{1F1EA}",
      "\u{1F1EB}\u{1F1EE}",
      "\u{1F1EB}\u{1F1EF}",
      "\u{1F1EB}\u{1F1F0}",
      "\u{1F1EB}\u{1F1F2}",
      "\u{1F1EB}\u{1F1F4}",
      "\u{1F1EB}\u{1F1F7}",
      "\u{1F1EB}",
      "\u{1F1EC}\u{1F1E6}",
      "\u{1F1EC}\u{1F1E7}",
      "\u{1F1EC}\u{1F1E9}",
      "\u{1F1EC}\u{1F1EA}",
      "\u{1F1EC}\u{1F1EB}",
      "\u{1F1EC}\u{1F1EC}",
      "\u{1F1EC}\u{1F1ED}",
      "\u{1F1EC}\u{1F1EE}",
      "\u{1F1EC}\u{1F1F1}",
      "\u{1F1EC}\u{1F1F2}",
      "\u{1F1EC}\u{1F1F3}",
      "\u{1F1EC}\u{1F1F5}",
      "\u{1F1EC}\u{1F1F6}",
      "\u{1F1EC}\u{1F1F7}",
      "\u{1F1EC}\u{1F1F8}",
      "\u{1F1EC}\u{1F1F9}",
      "\u{1F1EC}\u{1F1FA}",
      "\u{1F1EC}\u{1F1FC}",
      "\u{1F1EC}\u{1F1FE}",
      "\u{1F1EC}",
      "\u{1F1ED}\u{1F1F0}",
      "\u{1F1ED}\u{1F1F2}",
      "\u{1F1ED}\u{1F1F3}",
      "\u{1F1ED}\u{1F1F7}",
      "\u{1F1ED}\u{1F1F9}",
      "\u{1F1ED}\u{1F1FA}",
      "\u{1F1ED}",
      "\u{1F1EE}\u{1F1E8}",
      "\u{1F1EE}\u{1F1E9}",
      "\u{1F1EE}\u{1F1EA}",
      "\u{1F1EE}\u{1F1F1}",
      "\u{1F1EE}\u{1F1F2}",
      "\u{1F1EE}\u{1F1F3}",
      "\u{1F1EE}\u{1F1F4}",
      "\u{1F1EE}\u{1F1F6}",
      "\u{1F1EE}\u{1F1F7}",
      "\u{1F1EE}\u{1F1F8}",
      "\u{1F1EE}\u{1F1F9}",
      "\u{1F1EE}",
      "\u{1F1EF}\u{1F1EA}",
      "\u{1F1EF}\u{1F1F2}",
      "\u{1F1EF}\u{1F1F4}",
      "\u{1F1EF}\u{1F1F5}",
      "\u{1F1EF}",
      "\u{1F1F0}\u{1F1EA}",
      "\u{1F1F0}\u{1F1EC}",
      "\u{1F1F0}\u{1F1ED}",
      "\u{1F1F0}\u{1F1EE}",
      "\u{1F1F0}\u{1F1F2}",
      "\u{1F1F0}\u{1F1F3}",
      "\u{1F1F0}\u{1F1F5}",
      "\u{1F1F0}\u{1F1F7}",
      "\u{1F1F0}\u{1F1FC}",
      "\u{1F1F0}\u{1F1FE}",
      "\u{1F1F0}\u{1F1FF}",
      "\u{1F1F0}",
      "\u{1F1F1}\u{1F1E6}",
      "\u{1F1F1}\u{1F1E7}",
      "\u{1F1F1}\u{1F1E8}",
      "\u{1F1F1}\u{1F1EE}",
      "\u{1F1F1}\u{1F1F0}",
      "\u{1F1F1}\u{1F1F7}",
      "\u{1F1F1}\u{1F1F8}",
      "\u{1F1F1}\u{1F1F9}",
      "\u{1F1F1}\u{1F1FA}",
      "\u{1F1F1}\u{1F1FB}",
      "\u{1F1F1}\u{1F1FE}",
      "\u{1F1F1}",
      "\u{1F1F2}\u{1F1E6}",
      "\u{1F1F2}\u{1F1E8}",
      "\u{1F1F2}\u{1F1E9}",
      "\u{1F1F2}\u{1F1EA}",
      "\u{1F1F2}\u{1F1EB}",
      "\u{1F1F2}\u{1F1EC}",
      "\u{1F1F2}\u{1F1ED}",
      "\u{1F1F2}\u{1F1F0}",
      "\u{1F1F2}\u{1F1F1}",
      "\u{1F1F2}\u{1F1F2}",
      "\u{1F1F2}\u{1F1F3}",
      "\u{1F1F2}\u{1F1F4}",
      "\u{1F1F2}\u{1F1F5}",
      "\u{1F1F2}\u{1F1F6}",
      "\u{1F1F2}\u{1F1F7}",
      "\u{1F1F2}\u{1F1F8}",
      "\u{1F1F2}\u{1F1F9}",
      "\u{1F1F2}\u{1F1FA}",
      "\u{1F1F2}\u{1F1FB}",
      "\u{1F1F2}\u{1F1FC}",
      "\u{1F1F2}\u{1F1FD}",
      "\u{1F1F2}\u{1F1FE}",
      "\u{1F1F2}\u{1F1FF}",
      "\u{1F1F2}",
      "\u{1F1F3}\u{1F1E6}",
      "\u{1F1F3}\u{1F1E8}",
      "\u{1F1F3}\u{1F1EA}",
      "\u{1F1F3}\u{1F1EB}",
      "\u{1F1F3}\u{1F1EC}",
      "\u{1F1F3}\u{1F1EE}",
      "\u{1F1F3}\u{1F1F1}",
      "\u{1F1F3}\u{1F1F4}",
      "\u{1F1F3}\u{1F1F5}",
      "\u{1F1F3}\u{1F1F7}",
      "\u{1F1F3}\u{1F1FA}",
      "\u{1F1F3}\u{1F1FF}",
      "\u{1F1F3}",
      "\u{1F1F4}\u{1F1F2}",
      "\u{1F1F4}",
      "\u{1F1F5}\u{1F1E6}",
      "\u{1F1F5}\u{1F1EA}",
      "\u{1F1F5}\u{1F1EB}",
      "\u{1F1F5}\u{1F1EC}",
      "\u{1F1F5}\u{1F1ED}",
      "\u{1F1F5}\u{1F1F0}",
      "\u{1F1F5}\u{1F1F1}",
      "\u{1F1F5}\u{1F1F2}",
      "\u{1F1F5}\u{1F1F3}",
      "\u{1F1F5}\u{1F1F7}",
      "\u{1F1F5}\u{1F1F8}",
      "\u{1F1F5}\u{1F1F9}",
      "\u{1F1F5}\u{1F1FC}",
      "\u{1F1F5}\u{1F1FE}",
      "\u{1F1F5}",
      "\u{1F1F6}\u{1F1E6}",
      "\u{1F1F6}",
      "\u{1F1F7}\u{1F1EA}",
      "\u{1F1F7}\u{1F1F4}",
      "\u{1F1F7}\u{1F1F8}",
      "\u{1F1F7}\u{1F1FA}",
      "\u{1F1F7}\u{1F1FC}",
      "\u{1F1F7}",
      "\u{1F1F8}\u{1F1E6}",
      "\u{1F1F8}\u{1F1E7}",
      "\u{1F1F8}\u{1F1E8}",
      "\u{1F1F8}\u{1F1E9}",
      "\u{1F1F8}\u{1F1EA}",
      "\u{1F1F8}\u{1F1EC}",
      "\u{1F1F8}\u{1F1ED}",
      "\u{1F1F8}\u{1F1EE}",
      "\u{1F1F8}\u{1F1EF}",
      "\u{1F1F8}\u{1F1F0}",
      "\u{1F1F8}\u{1F1F1}",
      "\u{1F1F8}\u{1F1F2}",
      "\u{1F1F8}\u{1F1F3}",
      "\u{1F1F8}\u{1F1F4}",
      "\u{1F1F8}\u{1F1F7}",
      "\u{1F1F8}\u{1F1F8}",
      "\u{1F1F8}\u{1F1F9}",
      "\u{1F1F8}\u{1F1FB}",
      "\u{1F1F8}\u{1F1FD}",
      "\u{1F1F8}\u{1F1FE}",
      "\u{1F1F8}\u{1F1FF}",
      "\u{1F1F8}",
      "\u{1F1F9}\u{1F1E6}",
      "\u{1F1F9}\u{1F1E8}",
      "\u{1F1F9}\u{1F1E9}",
      "\u{1F1F9}\u{1F1EB}",
      "\u{1F1F9}\u{1F1EC}",
      "\u{1F1F9}\u{1F1ED}",
      "\u{1F1F9}\u{1F1EF}",
      "\u{1F1F9}\u{1F1F0}",
      "\u{1F1F9}\u{1F1F1}",
      "\u{1F1F9}\u{1F1F2}",
      "\u{1F1F9}\u{1F1F3}",
      "\u{1F1F9}\u{1F1F4}",
      "\u{1F1F9}\u{1F1F7}",
      "\u{1F1F9}\u{1F1F9}",
      "\u{1F1F9}\u{1F1FB}",
      "\u{1F1F9}\u{1F1FC}",
      "\u{1F1F9}\u{1F1FF}",
      "\u{1F1F9}",
      "\u{1F1FA}\u{1F1E6}",
      "\u{1F1FA}\u{1F1EC}",
      "\u{1F1FA}\u{1F1F2}",
      "\u{1F1FA}\u{1F1F3}",
      "\u{1F1FA}\u{1F1F8}",
      "\u{1F1FA}\u{1F1FE}",
      "\u{1F1FA}\u{1F1FF}",
      "\u{1F1FA}",
      "\u{1F1FB}\u{1F1E6}",
      "\u{1F1FB}\u{1F1E8}",
      "\u{1F1FB}\u{1F1EA}",
      "\u{1F1FB}\u{1F1EC}",
      "\u{1F1FB}\u{1F1EE}",
      "\u{1F1FB}\u{1F1F3}",
      "\u{1F1FB}\u{1F1FA}",
      "\u{1F1FB}",
      "\u{1F1FC}\u{1F1EB}",
      "\u{1F1FC}\u{1F1F8}",
      "\u{1F1FC}",
      "\u{1F1FD}\u{1F1F0}",
      "\u{1F1FD}",
      "\u{1F1FE}\u{1F1EA}",
      "\u{1F1FE}\u{1F1F9}",
      "\u{1F1FE}",
      "\u{1F1FF}\u{1F1E6}",
      "\u{1F1FF}\u{1F1F2}",
      "\u{1F1FF}\u{1F1FC}",
      "\u{1F1FF}",
      "\u{1F201}",
      "\u{1F202}\uFE0F",
      "\u{1F21A}\uFE0F",
      "\u{1F22F}\uFE0F",
      "\u{1F232}",
      "\u{1F233}",
      "\u{1F234}",
      "\u{1F235}",
      "\u{1F236}",
      "\u{1F237}\uFE0F",
      "\u{1F238}",
      "\u{1F239}",
      "\u{1F23A}",
      "\u{1F250}",
      "\u{1F251}",
      "\u{1F300}",
      "\u{1F301}",
      "\u{1F302}",
      "\u{1F303}",
      "\u{1F304}",
      "\u{1F305}",
      "\u{1F306}",
      "\u{1F307}",
      "\u{1F308}",
      "\u{1F309}",
      "\u{1F30A}",
      "\u{1F30B}",
      "\u{1F30C}",
      "\u{1F30D}",
      "\u{1F30E}",
      "\u{1F30F}",
      "\u{1F310}",
      "\u{1F311}",
      "\u{1F312}",
      "\u{1F313}",
      "\u{1F314}",
      "\u{1F315}",
      "\u{1F316}",
      "\u{1F317}",
      "\u{1F318}",
      "\u{1F319}",
      "\u{1F31A}",
      "\u{1F31B}",
      "\u{1F31C}",
      "\u{1F31D}",
      "\u{1F31E}",
      "\u{1F31F}",
      "\u{1F320}",
      "\u{1F321}\uFE0F",
      "\u{1F324}\uFE0F",
      "\u{1F325}\uFE0F",
      "\u{1F326}\uFE0F",
      "\u{1F327}\uFE0F",
      "\u{1F328}\uFE0F",
      "\u{1F329}\uFE0F",
      "\u{1F32A}\uFE0F",
      "\u{1F32B}\uFE0F",
      "\u{1F32C}\uFE0F",
      "\u{1F32D}",
      "\u{1F32E}",
      "\u{1F32F}",
      "\u{1F330}",
      "\u{1F331}",
      "\u{1F332}",
      "\u{1F333}",
      "\u{1F334}",
      "\u{1F335}",
      "\u{1F336}\uFE0F",
      "\u{1F337}",
      "\u{1F338}",
      "\u{1F339}",
      "\u{1F33A}",
      "\u{1F33B}",
      "\u{1F33C}",
      "\u{1F33D}",
      "\u{1F33E}",
      "\u{1F33F}",
      "\u{1F340}",
      "\u{1F341}",
      "\u{1F342}",
      "\u{1F343}",
      "\u{1F344}",
      "\u{1F345}",
      "\u{1F346}",
      "\u{1F347}",
      "\u{1F348}",
      "\u{1F349}",
      "\u{1F34A}",
      "\u{1F34B}",
      "\u{1F34C}",
      "\u{1F34D}",
      "\u{1F34E}",
      "\u{1F34F}",
      "\u{1F350}",
      "\u{1F351}",
      "\u{1F352}",
      "\u{1F353}",
      "\u{1F354}",
      "\u{1F355}",
      "\u{1F356}",
      "\u{1F357}",
      "\u{1F358}",
      "\u{1F359}",
      "\u{1F35A}",
      "\u{1F35B}",
      "\u{1F35C}",
      "\u{1F35D}",
      "\u{1F35E}",
      "\u{1F35F}",
      "\u{1F360}",
      "\u{1F361}",
      "\u{1F362}",
      "\u{1F363}",
      "\u{1F364}",
      "\u{1F365}",
      "\u{1F366}",
      "\u{1F367}",
      "\u{1F368}",
      "\u{1F369}",
      "\u{1F36A}",
      "\u{1F36B}",
      "\u{1F36C}",
      "\u{1F36D}",
      "\u{1F36E}",
      "\u{1F36F}",
      "\u{1F370}",
      "\u{1F371}",
      "\u{1F372}",
      "\u{1F373}",
      "\u{1F374}",
      "\u{1F375}",
      "\u{1F376}",
      "\u{1F377}",
      "\u{1F378}",
      "\u{1F379}",
      "\u{1F37A}",
      "\u{1F37B}",
      "\u{1F37C}",
      "\u{1F37D}\uFE0F",
      "\u{1F37E}",
      "\u{1F37F}",
      "\u{1F380}",
      "\u{1F381}",
      "\u{1F382}",
      "\u{1F383}",
      "\u{1F384}",
      "\u{1F385}\u{1F3FB}",
      "\u{1F385}\u{1F3FC}",
      "\u{1F385}\u{1F3FD}",
      "\u{1F385}\u{1F3FE}",
      "\u{1F385}\u{1F3FF}",
      "\u{1F385}",
      "\u{1F386}",
      "\u{1F387}",
      "\u{1F388}",
      "\u{1F389}",
      "\u{1F38A}",
      "\u{1F38B}",
      "\u{1F38C}",
      "\u{1F38D}",
      "\u{1F38E}",
      "\u{1F38F}",
      "\u{1F390}",
      "\u{1F391}",
      "\u{1F392}",
      "\u{1F393}",
      "\u{1F396}\uFE0F",
      "\u{1F397}\uFE0F",
      "\u{1F399}\uFE0F",
      "\u{1F39A}\uFE0F",
      "\u{1F39B}\uFE0F",
      "\u{1F39E}\uFE0F",
      "\u{1F39F}\uFE0F",
      "\u{1F3A0}",
      "\u{1F3A1}",
      "\u{1F3A2}",
      "\u{1F3A3}",
      "\u{1F3A4}",
      "\u{1F3A5}",
      "\u{1F3A6}",
      "\u{1F3A7}",
      "\u{1F3A8}",
      "\u{1F3A9}",
      "\u{1F3AA}",
      "\u{1F3AB}",
      "\u{1F3AC}",
      "\u{1F3AD}",
      "\u{1F3AE}",
      "\u{1F3AF}",
      "\u{1F3B0}",
      "\u{1F3B1}",
      "\u{1F3B2}",
      "\u{1F3B3}",
      "\u{1F3B4}",
      "\u{1F3B5}",
      "\u{1F3B6}",
      "\u{1F3B7}",
      "\u{1F3B8}",
      "\u{1F3B9}",
      "\u{1F3BA}",
      "\u{1F3BB}",
      "\u{1F3BC}",
      "\u{1F3BD}",
      "\u{1F3BE}",
      "\u{1F3BF}",
      "\u{1F3C0}",
      "\u{1F3C1}",
      "\u{1F3C2}\u{1F3FB}",
      "\u{1F3C2}\u{1F3FC}",
      "\u{1F3C2}\u{1F3FD}",
      "\u{1F3C2}\u{1F3FE}",
      "\u{1F3C2}\u{1F3FF}",
      "\u{1F3C2}",
      "\u{1F3C3}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F3C3}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F3C3}\u{1F3FB}",
      "\u{1F3C3}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F3C3}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F3C3}\u{1F3FC}",
      "\u{1F3C3}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F3C3}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F3C3}\u{1F3FD}",
      "\u{1F3C3}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F3C3}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F3C3}\u{1F3FE}",
      "\u{1F3C3}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F3C3}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F3C3}\u{1F3FF}",
      "\u{1F3C3}\u200D\u2640\uFE0F",
      "\u{1F3C3}\u200D\u2642\uFE0F",
      "\u{1F3C3}",
      "\u{1F3C4}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F3C4}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F3C4}\u{1F3FB}",
      "\u{1F3C4}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F3C4}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F3C4}\u{1F3FC}",
      "\u{1F3C4}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F3C4}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F3C4}\u{1F3FD}",
      "\u{1F3C4}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F3C4}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F3C4}\u{1F3FE}",
      "\u{1F3C4}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F3C4}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F3C4}\u{1F3FF}",
      "\u{1F3C4}\u200D\u2640\uFE0F",
      "\u{1F3C4}\u200D\u2642\uFE0F",
      "\u{1F3C4}",
      "\u{1F3C5}",
      "\u{1F3C6}",
      "\u{1F3C7}\u{1F3FB}",
      "\u{1F3C7}\u{1F3FC}",
      "\u{1F3C7}\u{1F3FD}",
      "\u{1F3C7}\u{1F3FE}",
      "\u{1F3C7}\u{1F3FF}",
      "\u{1F3C7}",
      "\u{1F3C8}",
      "\u{1F3C9}",
      "\u{1F3CA}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F3CA}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F3CA}\u{1F3FB}",
      "\u{1F3CA}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F3CA}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F3CA}\u{1F3FC}",
      "\u{1F3CA}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F3CA}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F3CA}\u{1F3FD}",
      "\u{1F3CA}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F3CA}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F3CA}\u{1F3FE}",
      "\u{1F3CA}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F3CA}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F3CA}\u{1F3FF}",
      "\u{1F3CA}\u200D\u2640\uFE0F",
      "\u{1F3CA}\u200D\u2642\uFE0F",
      "\u{1F3CA}",
      "\u{1F3CB}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F3CB}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F3CB}\u{1F3FB}",
      "\u{1F3CB}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F3CB}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F3CB}\u{1F3FC}",
      "\u{1F3CB}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F3CB}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F3CB}\u{1F3FD}",
      "\u{1F3CB}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F3CB}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F3CB}\u{1F3FE}",
      "\u{1F3CB}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F3CB}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F3CB}\u{1F3FF}",
      "\u{1F3CB}\uFE0F\u200D\u2640\uFE0F",
      "\u{1F3CB}\uFE0F\u200D\u2642\uFE0F",
      "\u{1F3CB}\uFE0F",
      "\u{1F3CC}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F3CC}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F3CC}\u{1F3FB}",
      "\u{1F3CC}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F3CC}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F3CC}\u{1F3FC}",
      "\u{1F3CC}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F3CC}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F3CC}\u{1F3FD}",
      "\u{1F3CC}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F3CC}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F3CC}\u{1F3FE}",
      "\u{1F3CC}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F3CC}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F3CC}\u{1F3FF}",
      "\u{1F3CC}\uFE0F\u200D\u2640\uFE0F",
      "\u{1F3CC}\uFE0F\u200D\u2642\uFE0F",
      "\u{1F3CC}\uFE0F",
      "\u{1F3CD}\uFE0F",
      "\u{1F3CE}\uFE0F",
      "\u{1F3CF}",
      "\u{1F3D0}",
      "\u{1F3D1}",
      "\u{1F3D2}",
      "\u{1F3D3}",
      "\u{1F3D4}\uFE0F",
      "\u{1F3D5}\uFE0F",
      "\u{1F3D6}\uFE0F",
      "\u{1F3D7}\uFE0F",
      "\u{1F3D8}\uFE0F",
      "\u{1F3D9}\uFE0F",
      "\u{1F3DA}\uFE0F",
      "\u{1F3DB}\uFE0F",
      "\u{1F3DC}\uFE0F",
      "\u{1F3DD}\uFE0F",
      "\u{1F3DE}\uFE0F",
      "\u{1F3DF}\uFE0F",
      "\u{1F3E0}",
      "\u{1F3E1}",
      "\u{1F3E2}",
      "\u{1F3E3}",
      "\u{1F3E4}",
      "\u{1F3E5}",
      "\u{1F3E6}",
      "\u{1F3E7}",
      "\u{1F3E8}",
      "\u{1F3E9}",
      "\u{1F3EA}",
      "\u{1F3EB}",
      "\u{1F3EC}",
      "\u{1F3ED}",
      "\u{1F3EE}",
      "\u{1F3EF}",
      "\u{1F3F0}",
      "\u{1F3F3}\uFE0F\u200D\u{1F308}",
      "\u{1F3F3}\uFE0F",
      "\u{1F3F4}\u200D\u2620\uFE0F",
      "\u{1F3F4}\u{E0067}\u{E0062}\u{E0065}\u{E006E}\u{E0067}\u{E007F}",
      "\u{1F3F4}\u{E0067}\u{E0062}\u{E0073}\u{E0063}\u{E0074}\u{E007F}",
      "\u{1F3F4}\u{E0067}\u{E0062}\u{E0077}\u{E006C}\u{E0073}\u{E007F}",
      "\u{1F3F4}",
      "\u{1F3F5}\uFE0F",
      "\u{1F3F7}\uFE0F",
      "\u{1F3F8}",
      "\u{1F3F9}",
      "\u{1F3FA}",
      "\u{1F3FB}",
      "\u{1F3FC}",
      "\u{1F3FD}",
      "\u{1F3FE}",
      "\u{1F3FF}",
      "\u{1F400}",
      "\u{1F401}",
      "\u{1F402}",
      "\u{1F403}",
      "\u{1F404}",
      "\u{1F405}",
      "\u{1F406}",
      "\u{1F407}",
      "\u{1F408}",
      "\u{1F409}",
      "\u{1F40A}",
      "\u{1F40B}",
      "\u{1F40C}",
      "\u{1F40D}",
      "\u{1F40E}",
      "\u{1F40F}",
      "\u{1F410}",
      "\u{1F411}",
      "\u{1F412}",
      "\u{1F413}",
      "\u{1F414}",
      "\u{1F415}\u200D\u{1F9BA}",
      "\u{1F415}",
      "\u{1F416}",
      "\u{1F417}",
      "\u{1F418}",
      "\u{1F419}",
      "\u{1F41A}",
      "\u{1F41B}",
      "\u{1F41C}",
      "\u{1F41D}",
      "\u{1F41E}",
      "\u{1F41F}",
      "\u{1F420}",
      "\u{1F421}",
      "\u{1F422}",
      "\u{1F423}",
      "\u{1F424}",
      "\u{1F425}",
      "\u{1F426}",
      "\u{1F427}",
      "\u{1F428}",
      "\u{1F429}",
      "\u{1F42A}",
      "\u{1F42B}",
      "\u{1F42C}",
      "\u{1F42D}",
      "\u{1F42E}",
      "\u{1F42F}",
      "\u{1F430}",
      "\u{1F431}",
      "\u{1F432}",
      "\u{1F433}",
      "\u{1F434}",
      "\u{1F435}",
      "\u{1F436}",
      "\u{1F437}",
      "\u{1F438}",
      "\u{1F439}",
      "\u{1F43A}",
      "\u{1F43B}",
      "\u{1F43C}",
      "\u{1F43D}",
      "\u{1F43E}",
      "\u{1F43F}\uFE0F",
      "\u{1F440}",
      "\u{1F441}\u200D\u{1F5E8}",
      "\u{1F441}\uFE0F",
      "\u{1F442}\u{1F3FB}",
      "\u{1F442}\u{1F3FC}",
      "\u{1F442}\u{1F3FD}",
      "\u{1F442}\u{1F3FE}",
      "\u{1F442}\u{1F3FF}",
      "\u{1F442}",
      "\u{1F443}\u{1F3FB}",
      "\u{1F443}\u{1F3FC}",
      "\u{1F443}\u{1F3FD}",
      "\u{1F443}\u{1F3FE}",
      "\u{1F443}\u{1F3FF}",
      "\u{1F443}",
      "\u{1F444}",
      "\u{1F445}",
      "\u{1F446}\u{1F3FB}",
      "\u{1F446}\u{1F3FC}",
      "\u{1F446}\u{1F3FD}",
      "\u{1F446}\u{1F3FE}",
      "\u{1F446}\u{1F3FF}",
      "\u{1F446}",
      "\u{1F447}\u{1F3FB}",
      "\u{1F447}\u{1F3FC}",
      "\u{1F447}\u{1F3FD}",
      "\u{1F447}\u{1F3FE}",
      "\u{1F447}\u{1F3FF}",
      "\u{1F447}",
      "\u{1F448}\u{1F3FB}",
      "\u{1F448}\u{1F3FC}",
      "\u{1F448}\u{1F3FD}",
      "\u{1F448}\u{1F3FE}",
      "\u{1F448}\u{1F3FF}",
      "\u{1F448}",
      "\u{1F449}\u{1F3FB}",
      "\u{1F449}\u{1F3FC}",
      "\u{1F449}\u{1F3FD}",
      "\u{1F449}\u{1F3FE}",
      "\u{1F449}\u{1F3FF}",
      "\u{1F449}",
      "\u{1F44A}\u{1F3FB}",
      "\u{1F44A}\u{1F3FC}",
      "\u{1F44A}\u{1F3FD}",
      "\u{1F44A}\u{1F3FE}",
      "\u{1F44A}\u{1F3FF}",
      "\u{1F44A}",
      "\u{1F44B}\u{1F3FB}",
      "\u{1F44B}\u{1F3FC}",
      "\u{1F44B}\u{1F3FD}",
      "\u{1F44B}\u{1F3FE}",
      "\u{1F44B}\u{1F3FF}",
      "\u{1F44B}",
      "\u{1F44C}\u{1F3FB}",
      "\u{1F44C}\u{1F3FC}",
      "\u{1F44C}\u{1F3FD}",
      "\u{1F44C}\u{1F3FE}",
      "\u{1F44C}\u{1F3FF}",
      "\u{1F44C}",
      "\u{1F44D}\u{1F3FB}",
      "\u{1F44D}\u{1F3FC}",
      "\u{1F44D}\u{1F3FD}",
      "\u{1F44D}\u{1F3FE}",
      "\u{1F44D}\u{1F3FF}",
      "\u{1F44D}",
      "\u{1F44E}\u{1F3FB}",
      "\u{1F44E}\u{1F3FC}",
      "\u{1F44E}\u{1F3FD}",
      "\u{1F44E}\u{1F3FE}",
      "\u{1F44E}\u{1F3FF}",
      "\u{1F44E}",
      "\u{1F44F}\u{1F3FB}",
      "\u{1F44F}\u{1F3FC}",
      "\u{1F44F}\u{1F3FD}",
      "\u{1F44F}\u{1F3FE}",
      "\u{1F44F}\u{1F3FF}",
      "\u{1F44F}",
      "\u{1F450}\u{1F3FB}",
      "\u{1F450}\u{1F3FC}",
      "\u{1F450}\u{1F3FD}",
      "\u{1F450}\u{1F3FE}",
      "\u{1F450}\u{1F3FF}",
      "\u{1F450}",
      "\u{1F451}",
      "\u{1F452}",
      "\u{1F453}",
      "\u{1F454}",
      "\u{1F455}",
      "\u{1F456}",
      "\u{1F457}",
      "\u{1F458}",
      "\u{1F459}",
      "\u{1F45A}",
      "\u{1F45B}",
      "\u{1F45C}",
      "\u{1F45D}",
      "\u{1F45E}",
      "\u{1F45F}",
      "\u{1F460}",
      "\u{1F461}",
      "\u{1F462}",
      "\u{1F463}",
      "\u{1F464}",
      "\u{1F465}",
      "\u{1F466}\u{1F3FB}",
      "\u{1F466}\u{1F3FC}",
      "\u{1F466}\u{1F3FD}",
      "\u{1F466}\u{1F3FE}",
      "\u{1F466}\u{1F3FF}",
      "\u{1F466}",
      "\u{1F467}\u{1F3FB}",
      "\u{1F467}\u{1F3FC}",
      "\u{1F467}\u{1F3FD}",
      "\u{1F467}\u{1F3FE}",
      "\u{1F467}\u{1F3FF}",
      "\u{1F467}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F33E}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F373}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F393}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F3A4}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F3A8}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F3EB}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F3ED}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F4BB}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F4BC}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F527}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F52C}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F680}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F692}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F9AF}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F9B0}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F9B1}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F9B2}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F9B3}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F9BC}",
      "\u{1F468}\u{1F3FB}\u200D\u{1F9BD}",
      "\u{1F468}\u{1F3FB}\u200D\u2695\uFE0F",
      "\u{1F468}\u{1F3FB}\u200D\u2696\uFE0F",
      "\u{1F468}\u{1F3FB}\u200D\u2708\uFE0F",
      "\u{1F468}\u{1F3FB}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F33E}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F373}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F393}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F3A4}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F3A8}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F3EB}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F3ED}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F4BB}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F4BC}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F527}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F52C}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F680}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F692}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F9AF}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F9B0}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F9B1}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F9B2}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F9B3}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F9BC}",
      "\u{1F468}\u{1F3FC}\u200D\u{1F9BD}",
      "\u{1F468}\u{1F3FC}\u200D\u2695\uFE0F",
      "\u{1F468}\u{1F3FC}\u200D\u2696\uFE0F",
      "\u{1F468}\u{1F3FC}\u200D\u2708\uFE0F",
      "\u{1F468}\u{1F3FC}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F33E}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F373}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F393}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F3A4}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F3A8}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F3EB}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F3ED}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F4BB}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F4BC}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F527}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F52C}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F680}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F692}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F9AF}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F9B0}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F9B1}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F9B2}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F9B3}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F9BC}",
      "\u{1F468}\u{1F3FD}\u200D\u{1F9BD}",
      "\u{1F468}\u{1F3FD}\u200D\u2695\uFE0F",
      "\u{1F468}\u{1F3FD}\u200D\u2696\uFE0F",
      "\u{1F468}\u{1F3FD}\u200D\u2708\uFE0F",
      "\u{1F468}\u{1F3FD}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F33E}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F373}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F393}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F3A4}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F3A8}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F3EB}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F3ED}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F4BB}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F4BC}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F527}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F52C}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F680}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F692}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F9AF}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F9B0}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F9B1}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F9B2}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F9B3}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F9BC}",
      "\u{1F468}\u{1F3FE}\u200D\u{1F9BD}",
      "\u{1F468}\u{1F3FE}\u200D\u2695\uFE0F",
      "\u{1F468}\u{1F3FE}\u200D\u2696\uFE0F",
      "\u{1F468}\u{1F3FE}\u200D\u2708\uFE0F",
      "\u{1F468}\u{1F3FE}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F33E}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F373}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F393}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F3A4}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F3A8}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F3EB}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F3ED}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F4BB}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F4BC}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F527}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F52C}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F680}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F692}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F9AF}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F9B0}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F9B1}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F9B2}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F9B3}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F9BC}",
      "\u{1F468}\u{1F3FF}\u200D\u{1F9BD}",
      "\u{1F468}\u{1F3FF}\u200D\u2695\uFE0F",
      "\u{1F468}\u{1F3FF}\u200D\u2696\uFE0F",
      "\u{1F468}\u{1F3FF}\u200D\u2708\uFE0F",
      "\u{1F468}\u{1F3FF}",
      "\u{1F468}\u200D\u{1F33E}",
      "\u{1F468}\u200D\u{1F373}",
      "\u{1F468}\u200D\u{1F393}",
      "\u{1F468}\u200D\u{1F3A4}",
      "\u{1F468}\u200D\u{1F3A8}",
      "\u{1F468}\u200D\u{1F3EB}",
      "\u{1F468}\u200D\u{1F3ED}",
      "\u{1F468}\u200D\u{1F466}\u200D\u{1F466}",
      "\u{1F468}\u200D\u{1F466}",
      "\u{1F468}\u200D\u{1F467}\u200D\u{1F466}",
      "\u{1F468}\u200D\u{1F467}\u200D\u{1F467}",
      "\u{1F468}\u200D\u{1F467}",
      "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}\u200D\u{1F466}",
      "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}",
      "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F466}",
      "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F467}",
      "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}",
      "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
      "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}",
      "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
      "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
      "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}",
      "\u{1F468}\u200D\u{1F4BB}",
      "\u{1F468}\u200D\u{1F4BC}",
      "\u{1F468}\u200D\u{1F527}",
      "\u{1F468}\u200D\u{1F52C}",
      "\u{1F468}\u200D\u{1F680}",
      "\u{1F468}\u200D\u{1F692}",
      "\u{1F468}\u200D\u{1F9AF}",
      "\u{1F468}\u200D\u{1F9B0}",
      "\u{1F468}\u200D\u{1F9B1}",
      "\u{1F468}\u200D\u{1F9B2}",
      "\u{1F468}\u200D\u{1F9B3}",
      "\u{1F468}\u200D\u{1F9BC}",
      "\u{1F468}\u200D\u{1F9BD}",
      "\u{1F468}\u200D\u2695\uFE0F",
      "\u{1F468}\u200D\u2696\uFE0F",
      "\u{1F468}\u200D\u2708\uFE0F",
      "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F468}",
      "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}",
      "\u{1F468}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F33E}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F373}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F393}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F3A4}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F3A8}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F3EB}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F3ED}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F4BB}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F4BC}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F527}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F52C}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F680}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F692}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F9AF}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F9B0}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F9B1}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F9B2}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F9B3}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F9BC}",
      "\u{1F469}\u{1F3FB}\u200D\u{1F9BD}",
      "\u{1F469}\u{1F3FB}\u200D\u2695\uFE0F",
      "\u{1F469}\u{1F3FB}\u200D\u2696\uFE0F",
      "\u{1F469}\u{1F3FB}\u200D\u2708\uFE0F",
      "\u{1F469}\u{1F3FB}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F33E}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F373}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F393}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F3A4}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F3A8}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F3EB}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F3ED}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F4BB}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F4BC}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F527}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F52C}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F680}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F692}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F9AF}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F9B0}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F9B1}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F9B2}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F9B3}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F9BC}",
      "\u{1F469}\u{1F3FC}\u200D\u{1F9BD}",
      "\u{1F469}\u{1F3FC}\u200D\u2695\uFE0F",
      "\u{1F469}\u{1F3FC}\u200D\u2696\uFE0F",
      "\u{1F469}\u{1F3FC}\u200D\u2708\uFE0F",
      "\u{1F469}\u{1F3FC}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F33E}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F373}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F393}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F3A4}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F3A8}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F3EB}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F3ED}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F4BB}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F4BC}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F527}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F52C}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F680}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F692}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FC}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F9AF}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F9B0}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F9B1}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F9B2}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F9B3}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F9BC}",
      "\u{1F469}\u{1F3FD}\u200D\u{1F9BD}",
      "\u{1F469}\u{1F3FD}\u200D\u2695\uFE0F",
      "\u{1F469}\u{1F3FD}\u200D\u2696\uFE0F",
      "\u{1F469}\u{1F3FD}\u200D\u2708\uFE0F",
      "\u{1F469}\u{1F3FD}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F33E}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F373}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F393}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F3A4}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F3A8}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F3EB}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F3ED}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F4BB}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F4BC}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F527}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F52C}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F680}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F692}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FF}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FC}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FD}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F9AF}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F9B0}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F9B1}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F9B2}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F9B3}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F9BC}",
      "\u{1F469}\u{1F3FE}\u200D\u{1F9BD}",
      "\u{1F469}\u{1F3FE}\u200D\u2695\uFE0F",
      "\u{1F469}\u{1F3FE}\u200D\u2696\uFE0F",
      "\u{1F469}\u{1F3FE}\u200D\u2708\uFE0F",
      "\u{1F469}\u{1F3FE}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F33E}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F373}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F393}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F3A4}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F3A8}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F3EB}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F3ED}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F4BB}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F4BC}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F527}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F52C}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F680}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F692}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FB}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FC}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FD}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F468}\u{1F3FE}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FB}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FC}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FD}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F469}\u{1F3FE}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F9AF}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F9B0}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F9B1}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F9B2}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F9B3}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F9BC}",
      "\u{1F469}\u{1F3FF}\u200D\u{1F9BD}",
      "\u{1F469}\u{1F3FF}\u200D\u2695\uFE0F",
      "\u{1F469}\u{1F3FF}\u200D\u2696\uFE0F",
      "\u{1F469}\u{1F3FF}\u200D\u2708\uFE0F",
      "\u{1F469}\u{1F3FF}",
      "\u{1F469}\u200D\u{1F33E}",
      "\u{1F469}\u200D\u{1F373}",
      "\u{1F469}\u200D\u{1F393}",
      "\u{1F469}\u200D\u{1F3A4}",
      "\u{1F469}\u200D\u{1F3A8}",
      "\u{1F469}\u200D\u{1F3EB}",
      "\u{1F469}\u200D\u{1F3ED}",
      "\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
      "\u{1F469}\u200D\u{1F466}",
      "\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
      "\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
      "\u{1F469}\u200D\u{1F467}",
      "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}",
      "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}",
      "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}",
      "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}",
      "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}",
      "\u{1F469}\u200D\u{1F4BB}",
      "\u{1F469}\u200D\u{1F4BC}",
      "\u{1F469}\u200D\u{1F527}",
      "\u{1F469}\u200D\u{1F52C}",
      "\u{1F469}\u200D\u{1F680}",
      "\u{1F469}\u200D\u{1F692}",
      "\u{1F469}\u200D\u{1F9AF}",
      "\u{1F469}\u200D\u{1F9B0}",
      "\u{1F469}\u200D\u{1F9B1}",
      "\u{1F469}\u200D\u{1F9B2}",
      "\u{1F469}\u200D\u{1F9B3}",
      "\u{1F469}\u200D\u{1F9BC}",
      "\u{1F469}\u200D\u{1F9BD}",
      "\u{1F469}\u200D\u2695\uFE0F",
      "\u{1F469}\u200D\u2696\uFE0F",
      "\u{1F469}\u200D\u2708\uFE0F",
      "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F468}",
      "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F469}",
      "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}",
      "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}",
      "\u{1F469}",
      "\u{1F46A}",
      "\u{1F46B}\u{1F3FB}",
      "\u{1F46B}\u{1F3FC}",
      "\u{1F46B}\u{1F3FD}",
      "\u{1F46B}\u{1F3FE}",
      "\u{1F46B}\u{1F3FF}",
      "\u{1F46B}",
      "\u{1F46C}\u{1F3FB}",
      "\u{1F46C}\u{1F3FC}",
      "\u{1F46C}\u{1F3FD}",
      "\u{1F46C}\u{1F3FE}",
      "\u{1F46C}\u{1F3FF}",
      "\u{1F46C}",
      "\u{1F46D}\u{1F3FB}",
      "\u{1F46D}\u{1F3FC}",
      "\u{1F46D}\u{1F3FD}",
      "\u{1F46D}\u{1F3FE}",
      "\u{1F46D}\u{1F3FF}",
      "\u{1F46D}",
      "\u{1F46E}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F46E}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F46E}\u{1F3FB}",
      "\u{1F46E}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F46E}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F46E}\u{1F3FC}",
      "\u{1F46E}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F46E}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F46E}\u{1F3FD}",
      "\u{1F46E}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F46E}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F46E}\u{1F3FE}",
      "\u{1F46E}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F46E}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F46E}\u{1F3FF}",
      "\u{1F46E}\u200D\u2640\uFE0F",
      "\u{1F46E}\u200D\u2642\uFE0F",
      "\u{1F46E}",
      "\u{1F46F}\u200D\u2640\uFE0F",
      "\u{1F46F}\u200D\u2642\uFE0F",
      "\u{1F46F}",
      "\u{1F470}\u{1F3FB}",
      "\u{1F470}\u{1F3FC}",
      "\u{1F470}\u{1F3FD}",
      "\u{1F470}\u{1F3FE}",
      "\u{1F470}\u{1F3FF}",
      "\u{1F470}",
      "\u{1F471}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F471}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F471}\u{1F3FB}",
      "\u{1F471}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F471}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F471}\u{1F3FC}",
      "\u{1F471}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F471}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F471}\u{1F3FD}",
      "\u{1F471}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F471}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F471}\u{1F3FE}",
      "\u{1F471}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F471}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F471}\u{1F3FF}",
      "\u{1F471}\u200D\u2640\uFE0F",
      "\u{1F471}\u200D\u2642\uFE0F",
      "\u{1F471}",
      "\u{1F472}\u{1F3FB}",
      "\u{1F472}\u{1F3FC}",
      "\u{1F472}\u{1F3FD}",
      "\u{1F472}\u{1F3FE}",
      "\u{1F472}\u{1F3FF}",
      "\u{1F472}",
      "\u{1F473}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F473}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F473}\u{1F3FB}",
      "\u{1F473}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F473}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F473}\u{1F3FC}",
      "\u{1F473}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F473}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F473}\u{1F3FD}",
      "\u{1F473}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F473}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F473}\u{1F3FE}",
      "\u{1F473}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F473}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F473}\u{1F3FF}",
      "\u{1F473}\u200D\u2640\uFE0F",
      "\u{1F473}\u200D\u2642\uFE0F",
      "\u{1F473}",
      "\u{1F474}\u{1F3FB}",
      "\u{1F474}\u{1F3FC}",
      "\u{1F474}\u{1F3FD}",
      "\u{1F474}\u{1F3FE}",
      "\u{1F474}\u{1F3FF}",
      "\u{1F474}",
      "\u{1F475}\u{1F3FB}",
      "\u{1F475}\u{1F3FC}",
      "\u{1F475}\u{1F3FD}",
      "\u{1F475}\u{1F3FE}",
      "\u{1F475}\u{1F3FF}",
      "\u{1F475}",
      "\u{1F476}\u{1F3FB}",
      "\u{1F476}\u{1F3FC}",
      "\u{1F476}\u{1F3FD}",
      "\u{1F476}\u{1F3FE}",
      "\u{1F476}\u{1F3FF}",
      "\u{1F476}",
      "\u{1F477}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F477}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F477}\u{1F3FB}",
      "\u{1F477}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F477}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F477}\u{1F3FC}",
      "\u{1F477}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F477}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F477}\u{1F3FD}",
      "\u{1F477}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F477}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F477}\u{1F3FE}",
      "\u{1F477}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F477}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F477}\u{1F3FF}",
      "\u{1F477}\u200D\u2640\uFE0F",
      "\u{1F477}\u200D\u2642\uFE0F",
      "\u{1F477}",
      "\u{1F478}\u{1F3FB}",
      "\u{1F478}\u{1F3FC}",
      "\u{1F478}\u{1F3FD}",
      "\u{1F478}\u{1F3FE}",
      "\u{1F478}\u{1F3FF}",
      "\u{1F478}",
      "\u{1F479}",
      "\u{1F47A}",
      "\u{1F47B}",
      "\u{1F47C}\u{1F3FB}",
      "\u{1F47C}\u{1F3FC}",
      "\u{1F47C}\u{1F3FD}",
      "\u{1F47C}\u{1F3FE}",
      "\u{1F47C}\u{1F3FF}",
      "\u{1F47C}",
      "\u{1F47D}",
      "\u{1F47E}",
      "\u{1F47F}",
      "\u{1F480}",
      "\u{1F481}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F481}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F481}\u{1F3FB}",
      "\u{1F481}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F481}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F481}\u{1F3FC}",
      "\u{1F481}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F481}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F481}\u{1F3FD}",
      "\u{1F481}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F481}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F481}\u{1F3FE}",
      "\u{1F481}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F481}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F481}\u{1F3FF}",
      "\u{1F481}\u200D\u2640\uFE0F",
      "\u{1F481}\u200D\u2642\uFE0F",
      "\u{1F481}",
      "\u{1F482}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F482}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F482}\u{1F3FB}",
      "\u{1F482}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F482}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F482}\u{1F3FC}",
      "\u{1F482}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F482}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F482}\u{1F3FD}",
      "\u{1F482}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F482}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F482}\u{1F3FE}",
      "\u{1F482}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F482}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F482}\u{1F3FF}",
      "\u{1F482}\u200D\u2640\uFE0F",
      "\u{1F482}\u200D\u2642\uFE0F",
      "\u{1F482}",
      "\u{1F483}\u{1F3FB}",
      "\u{1F483}\u{1F3FC}",
      "\u{1F483}\u{1F3FD}",
      "\u{1F483}\u{1F3FE}",
      "\u{1F483}\u{1F3FF}",
      "\u{1F483}",
      "\u{1F484}",
      "\u{1F485}\u{1F3FB}",
      "\u{1F485}\u{1F3FC}",
      "\u{1F485}\u{1F3FD}",
      "\u{1F485}\u{1F3FE}",
      "\u{1F485}\u{1F3FF}",
      "\u{1F485}",
      "\u{1F486}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F486}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F486}\u{1F3FB}",
      "\u{1F486}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F486}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F486}\u{1F3FC}",
      "\u{1F486}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F486}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F486}\u{1F3FD}",
      "\u{1F486}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F486}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F486}\u{1F3FE}",
      "\u{1F486}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F486}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F486}\u{1F3FF}",
      "\u{1F486}\u200D\u2640\uFE0F",
      "\u{1F486}\u200D\u2642\uFE0F",
      "\u{1F486}",
      "\u{1F487}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F487}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F487}\u{1F3FB}",
      "\u{1F487}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F487}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F487}\u{1F3FC}",
      "\u{1F487}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F487}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F487}\u{1F3FD}",
      "\u{1F487}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F487}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F487}\u{1F3FE}",
      "\u{1F487}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F487}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F487}\u{1F3FF}",
      "\u{1F487}\u200D\u2640\uFE0F",
      "\u{1F487}\u200D\u2642\uFE0F",
      "\u{1F487}",
      "\u{1F488}",
      "\u{1F489}",
      "\u{1F48A}",
      "\u{1F48B}",
      "\u{1F48C}",
      "\u{1F48D}",
      "\u{1F48E}",
      "\u{1F48F}",
      "\u{1F490}",
      "\u{1F491}",
      "\u{1F492}",
      "\u{1F493}",
      "\u{1F494}",
      "\u{1F495}",
      "\u{1F496}",
      "\u{1F497}",
      "\u{1F498}",
      "\u{1F499}",
      "\u{1F49A}",
      "\u{1F49B}",
      "\u{1F49C}",
      "\u{1F49D}",
      "\u{1F49E}",
      "\u{1F49F}",
      "\u{1F4A0}",
      "\u{1F4A1}",
      "\u{1F4A2}",
      "\u{1F4A3}",
      "\u{1F4A4}",
      "\u{1F4A5}",
      "\u{1F4A6}",
      "\u{1F4A7}",
      "\u{1F4A8}",
      "\u{1F4A9}",
      "\u{1F4AA}\u{1F3FB}",
      "\u{1F4AA}\u{1F3FC}",
      "\u{1F4AA}\u{1F3FD}",
      "\u{1F4AA}\u{1F3FE}",
      "\u{1F4AA}\u{1F3FF}",
      "\u{1F4AA}",
      "\u{1F4AB}",
      "\u{1F4AC}",
      "\u{1F4AD}",
      "\u{1F4AE}",
      "\u{1F4AF}",
      "\u{1F4B0}",
      "\u{1F4B1}",
      "\u{1F4B2}",
      "\u{1F4B3}",
      "\u{1F4B4}",
      "\u{1F4B5}",
      "\u{1F4B6}",
      "\u{1F4B7}",
      "\u{1F4B8}",
      "\u{1F4B9}",
      "\u{1F4BA}",
      "\u{1F4BB}",
      "\u{1F4BC}",
      "\u{1F4BD}",
      "\u{1F4BE}",
      "\u{1F4BF}",
      "\u{1F4C0}",
      "\u{1F4C1}",
      "\u{1F4C2}",
      "\u{1F4C3}",
      "\u{1F4C4}",
      "\u{1F4C5}",
      "\u{1F4C6}",
      "\u{1F4C7}",
      "\u{1F4C8}",
      "\u{1F4C9}",
      "\u{1F4CA}",
      "\u{1F4CB}",
      "\u{1F4CC}",
      "\u{1F4CD}",
      "\u{1F4CE}",
      "\u{1F4CF}",
      "\u{1F4D0}",
      "\u{1F4D1}",
      "\u{1F4D2}",
      "\u{1F4D3}",
      "\u{1F4D4}",
      "\u{1F4D5}",
      "\u{1F4D6}",
      "\u{1F4D7}",
      "\u{1F4D8}",
      "\u{1F4D9}",
      "\u{1F4DA}",
      "\u{1F4DB}",
      "\u{1F4DC}",
      "\u{1F4DD}",
      "\u{1F4DE}",
      "\u{1F4DF}",
      "\u{1F4E0}",
      "\u{1F4E1}",
      "\u{1F4E2}",
      "\u{1F4E3}",
      "\u{1F4E4}",
      "\u{1F4E5}",
      "\u{1F4E6}",
      "\u{1F4E7}",
      "\u{1F4E8}",
      "\u{1F4E9}",
      "\u{1F4EA}",
      "\u{1F4EB}",
      "\u{1F4EC}",
      "\u{1F4ED}",
      "\u{1F4EE}",
      "\u{1F4EF}",
      "\u{1F4F0}",
      "\u{1F4F1}",
      "\u{1F4F2}",
      "\u{1F4F3}",
      "\u{1F4F4}",
      "\u{1F4F5}",
      "\u{1F4F6}",
      "\u{1F4F7}",
      "\u{1F4F8}",
      "\u{1F4F9}",
      "\u{1F4FA}",
      "\u{1F4FB}",
      "\u{1F4FC}",
      "\u{1F4FD}\uFE0F",
      "\u{1F4FF}",
      "\u{1F500}",
      "\u{1F501}",
      "\u{1F502}",
      "\u{1F503}",
      "\u{1F504}",
      "\u{1F505}",
      "\u{1F506}",
      "\u{1F507}",
      "\u{1F508}",
      "\u{1F509}",
      "\u{1F50A}",
      "\u{1F50B}",
      "\u{1F50C}",
      "\u{1F50D}",
      "\u{1F50E}",
      "\u{1F50F}",
      "\u{1F510}",
      "\u{1F511}",
      "\u{1F512}",
      "\u{1F513}",
      "\u{1F514}",
      "\u{1F515}",
      "\u{1F516}",
      "\u{1F517}",
      "\u{1F518}",
      "\u{1F519}",
      "\u{1F51A}",
      "\u{1F51B}",
      "\u{1F51C}",
      "\u{1F51D}",
      "\u{1F51E}",
      "\u{1F51F}",
      "\u{1F520}",
      "\u{1F521}",
      "\u{1F522}",
      "\u{1F523}",
      "\u{1F524}",
      "\u{1F525}",
      "\u{1F526}",
      "\u{1F527}",
      "\u{1F528}",
      "\u{1F529}",
      "\u{1F52A}",
      "\u{1F52B}",
      "\u{1F52C}",
      "\u{1F52D}",
      "\u{1F52E}",
      "\u{1F52F}",
      "\u{1F530}",
      "\u{1F531}",
      "\u{1F532}",
      "\u{1F533}",
      "\u{1F534}",
      "\u{1F535}",
      "\u{1F536}",
      "\u{1F537}",
      "\u{1F538}",
      "\u{1F539}",
      "\u{1F53A}",
      "\u{1F53B}",
      "\u{1F53C}",
      "\u{1F53D}",
      "\u{1F549}\uFE0F",
      "\u{1F54A}\uFE0F",
      "\u{1F54B}",
      "\u{1F54C}",
      "\u{1F54D}",
      "\u{1F54E}",
      "\u{1F550}",
      "\u{1F551}",
      "\u{1F552}",
      "\u{1F553}",
      "\u{1F554}",
      "\u{1F555}",
      "\u{1F556}",
      "\u{1F557}",
      "\u{1F558}",
      "\u{1F559}",
      "\u{1F55A}",
      "\u{1F55B}",
      "\u{1F55C}",
      "\u{1F55D}",
      "\u{1F55E}",
      "\u{1F55F}",
      "\u{1F560}",
      "\u{1F561}",
      "\u{1F562}",
      "\u{1F563}",
      "\u{1F564}",
      "\u{1F565}",
      "\u{1F566}",
      "\u{1F567}",
      "\u{1F56F}\uFE0F",
      "\u{1F570}\uFE0F",
      "\u{1F573}\uFE0F",
      "\u{1F574}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F574}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F574}\u{1F3FB}",
      "\u{1F574}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F574}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F574}\u{1F3FC}",
      "\u{1F574}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F574}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F574}\u{1F3FD}",
      "\u{1F574}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F574}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F574}\u{1F3FE}",
      "\u{1F574}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F574}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F574}\u{1F3FF}",
      "\u{1F574}\uFE0F\u200D\u2640\uFE0F",
      "\u{1F574}\uFE0F\u200D\u2642\uFE0F",
      "\u{1F574}\uFE0F",
      "\u{1F575}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F575}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F575}\u{1F3FB}",
      "\u{1F575}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F575}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F575}\u{1F3FC}",
      "\u{1F575}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F575}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F575}\u{1F3FD}",
      "\u{1F575}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F575}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F575}\u{1F3FE}",
      "\u{1F575}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F575}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F575}\u{1F3FF}",
      "\u{1F575}\uFE0F\u200D\u2640\uFE0F",
      "\u{1F575}\uFE0F\u200D\u2642\uFE0F",
      "\u{1F575}\uFE0F",
      "\u{1F576}\uFE0F",
      "\u{1F577}\uFE0F",
      "\u{1F578}\uFE0F",
      "\u{1F579}\uFE0F",
      "\u{1F57A}\u{1F3FB}",
      "\u{1F57A}\u{1F3FC}",
      "\u{1F57A}\u{1F3FD}",
      "\u{1F57A}\u{1F3FE}",
      "\u{1F57A}\u{1F3FF}",
      "\u{1F57A}",
      "\u{1F587}\uFE0F",
      "\u{1F58A}\uFE0F",
      "\u{1F58B}\uFE0F",
      "\u{1F58C}\uFE0F",
      "\u{1F58D}\uFE0F",
      "\u{1F590}\u{1F3FB}",
      "\u{1F590}\u{1F3FC}",
      "\u{1F590}\u{1F3FD}",
      "\u{1F590}\u{1F3FE}",
      "\u{1F590}\u{1F3FF}",
      "\u{1F590}\uFE0F",
      "\u{1F595}\u{1F3FB}",
      "\u{1F595}\u{1F3FC}",
      "\u{1F595}\u{1F3FD}",
      "\u{1F595}\u{1F3FE}",
      "\u{1F595}\u{1F3FF}",
      "\u{1F595}",
      "\u{1F596}\u{1F3FB}",
      "\u{1F596}\u{1F3FC}",
      "\u{1F596}\u{1F3FD}",
      "\u{1F596}\u{1F3FE}",
      "\u{1F596}\u{1F3FF}",
      "\u{1F596}",
      "\u{1F5A4}",
      "\u{1F5A5}\uFE0F",
      "\u{1F5A8}\uFE0F",
      "\u{1F5B1}\uFE0F",
      "\u{1F5B2}\uFE0F",
      "\u{1F5BC}\uFE0F",
      "\u{1F5C2}\uFE0F",
      "\u{1F5C3}\uFE0F",
      "\u{1F5C4}\uFE0F",
      "\u{1F5D1}\uFE0F",
      "\u{1F5D2}\uFE0F",
      "\u{1F5D3}\uFE0F",
      "\u{1F5DC}\uFE0F",
      "\u{1F5DD}\uFE0F",
      "\u{1F5DE}\uFE0F",
      "\u{1F5E1}\uFE0F",
      "\u{1F5E3}\uFE0F",
      "\u{1F5E8}\uFE0F",
      "\u{1F5EF}\uFE0F",
      "\u{1F5F3}\uFE0F",
      "\u{1F5FA}\uFE0F",
      "\u{1F5FB}",
      "\u{1F5FC}",
      "\u{1F5FD}",
      "\u{1F5FE}",
      "\u{1F5FF}",
      "\u{1F600}",
      "\u{1F601}",
      "\u{1F602}",
      "\u{1F603}",
      "\u{1F604}",
      "\u{1F605}",
      "\u{1F606}",
      "\u{1F607}",
      "\u{1F608}",
      "\u{1F609}",
      "\u{1F60A}",
      "\u{1F60B}",
      "\u{1F60C}",
      "\u{1F60D}",
      "\u{1F60E}",
      "\u{1F60F}",
      "\u{1F610}",
      "\u{1F611}",
      "\u{1F612}",
      "\u{1F613}",
      "\u{1F614}",
      "\u{1F615}",
      "\u{1F616}",
      "\u{1F617}",
      "\u{1F618}",
      "\u{1F619}",
      "\u{1F61A}",
      "\u{1F61B}",
      "\u{1F61C}",
      "\u{1F61D}",
      "\u{1F61E}",
      "\u{1F61F}",
      "\u{1F620}",
      "\u{1F621}",
      "\u{1F622}",
      "\u{1F623}",
      "\u{1F624}",
      "\u{1F625}",
      "\u{1F626}",
      "\u{1F627}",
      "\u{1F628}",
      "\u{1F629}",
      "\u{1F62A}",
      "\u{1F62B}",
      "\u{1F62C}",
      "\u{1F62D}",
      "\u{1F62E}",
      "\u{1F62F}",
      "\u{1F630}",
      "\u{1F631}",
      "\u{1F632}",
      "\u{1F633}",
      "\u{1F634}",
      "\u{1F635}",
      "\u{1F636}",
      "\u{1F637}",
      "\u{1F638}",
      "\u{1F639}",
      "\u{1F63A}",
      "\u{1F63B}",
      "\u{1F63C}",
      "\u{1F63D}",
      "\u{1F63E}",
      "\u{1F63F}",
      "\u{1F640}",
      "\u{1F641}",
      "\u{1F642}",
      "\u{1F643}",
      "\u{1F644}",
      "\u{1F645}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F645}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F645}\u{1F3FB}",
      "\u{1F645}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F645}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F645}\u{1F3FC}",
      "\u{1F645}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F645}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F645}\u{1F3FD}",
      "\u{1F645}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F645}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F645}\u{1F3FE}",
      "\u{1F645}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F645}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F645}\u{1F3FF}",
      "\u{1F645}\u200D\u2640\uFE0F",
      "\u{1F645}\u200D\u2642\uFE0F",
      "\u{1F645}",
      "\u{1F646}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F646}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F646}\u{1F3FB}",
      "\u{1F646}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F646}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F646}\u{1F3FC}",
      "\u{1F646}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F646}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F646}\u{1F3FD}",
      "\u{1F646}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F646}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F646}\u{1F3FE}",
      "\u{1F646}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F646}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F646}\u{1F3FF}",
      "\u{1F646}\u200D\u2640\uFE0F",
      "\u{1F646}\u200D\u2642\uFE0F",
      "\u{1F646}",
      "\u{1F647}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F647}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F647}\u{1F3FB}",
      "\u{1F647}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F647}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F647}\u{1F3FC}",
      "\u{1F647}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F647}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F647}\u{1F3FD}",
      "\u{1F647}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F647}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F647}\u{1F3FE}",
      "\u{1F647}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F647}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F647}\u{1F3FF}",
      "\u{1F647}\u200D\u2640\uFE0F",
      "\u{1F647}\u200D\u2642\uFE0F",
      "\u{1F647}",
      "\u{1F648}",
      "\u{1F649}",
      "\u{1F64A}",
      "\u{1F64B}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F64B}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F64B}\u{1F3FB}",
      "\u{1F64B}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F64B}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F64B}\u{1F3FC}",
      "\u{1F64B}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F64B}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F64B}\u{1F3FD}",
      "\u{1F64B}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F64B}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F64B}\u{1F3FE}",
      "\u{1F64B}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F64B}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F64B}\u{1F3FF}",
      "\u{1F64B}\u200D\u2640\uFE0F",
      "\u{1F64B}\u200D\u2642\uFE0F",
      "\u{1F64B}",
      "\u{1F64C}\u{1F3FB}",
      "\u{1F64C}\u{1F3FC}",
      "\u{1F64C}\u{1F3FD}",
      "\u{1F64C}\u{1F3FE}",
      "\u{1F64C}\u{1F3FF}",
      "\u{1F64C}",
      "\u{1F64D}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F64D}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F64D}\u{1F3FB}",
      "\u{1F64D}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F64D}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F64D}\u{1F3FC}",
      "\u{1F64D}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F64D}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F64D}\u{1F3FD}",
      "\u{1F64D}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F64D}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F64D}\u{1F3FE}",
      "\u{1F64D}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F64D}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F64D}\u{1F3FF}",
      "\u{1F64D}\u200D\u2640\uFE0F",
      "\u{1F64D}\u200D\u2642\uFE0F",
      "\u{1F64D}",
      "\u{1F64E}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F64E}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F64E}\u{1F3FB}",
      "\u{1F64E}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F64E}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F64E}\u{1F3FC}",
      "\u{1F64E}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F64E}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F64E}\u{1F3FD}",
      "\u{1F64E}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F64E}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F64E}\u{1F3FE}",
      "\u{1F64E}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F64E}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F64E}\u{1F3FF}",
      "\u{1F64E}\u200D\u2640\uFE0F",
      "\u{1F64E}\u200D\u2642\uFE0F",
      "\u{1F64E}",
      "\u{1F64F}\u{1F3FB}",
      "\u{1F64F}\u{1F3FC}",
      "\u{1F64F}\u{1F3FD}",
      "\u{1F64F}\u{1F3FE}",
      "\u{1F64F}\u{1F3FF}",
      "\u{1F64F}",
      "\u{1F680}",
      "\u{1F681}",
      "\u{1F682}",
      "\u{1F683}",
      "\u{1F684}",
      "\u{1F685}",
      "\u{1F686}",
      "\u{1F687}",
      "\u{1F688}",
      "\u{1F689}",
      "\u{1F68A}",
      "\u{1F68B}",
      "\u{1F68C}",
      "\u{1F68D}",
      "\u{1F68E}",
      "\u{1F68F}",
      "\u{1F690}",
      "\u{1F691}",
      "\u{1F692}",
      "\u{1F693}",
      "\u{1F694}",
      "\u{1F695}",
      "\u{1F696}",
      "\u{1F697}",
      "\u{1F698}",
      "\u{1F699}",
      "\u{1F69A}",
      "\u{1F69B}",
      "\u{1F69C}",
      "\u{1F69D}",
      "\u{1F69E}",
      "\u{1F69F}",
      "\u{1F6A0}",
      "\u{1F6A1}",
      "\u{1F6A2}",
      "\u{1F6A3}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F6A3}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F6A3}\u{1F3FB}",
      "\u{1F6A3}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F6A3}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F6A3}\u{1F3FC}",
      "\u{1F6A3}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F6A3}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F6A3}\u{1F3FD}",
      "\u{1F6A3}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F6A3}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F6A3}\u{1F3FE}",
      "\u{1F6A3}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F6A3}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F6A3}\u{1F3FF}",
      "\u{1F6A3}\u200D\u2640\uFE0F",
      "\u{1F6A3}\u200D\u2642\uFE0F",
      "\u{1F6A3}",
      "\u{1F6A4}",
      "\u{1F6A5}",
      "\u{1F6A6}",
      "\u{1F6A7}",
      "\u{1F6A8}",
      "\u{1F6A9}",
      "\u{1F6AA}",
      "\u{1F6AB}",
      "\u{1F6AC}",
      "\u{1F6AD}",
      "\u{1F6AE}",
      "\u{1F6AF}",
      "\u{1F6B0}",
      "\u{1F6B1}",
      "\u{1F6B2}",
      "\u{1F6B3}",
      "\u{1F6B4}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F6B4}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F6B4}\u{1F3FB}",
      "\u{1F6B4}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F6B4}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F6B4}\u{1F3FC}",
      "\u{1F6B4}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F6B4}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F6B4}\u{1F3FD}",
      "\u{1F6B4}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F6B4}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F6B4}\u{1F3FE}",
      "\u{1F6B4}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F6B4}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F6B4}\u{1F3FF}",
      "\u{1F6B4}\u200D\u2640\uFE0F",
      "\u{1F6B4}\u200D\u2642\uFE0F",
      "\u{1F6B4}",
      "\u{1F6B5}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F6B5}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F6B5}\u{1F3FB}",
      "\u{1F6B5}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F6B5}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F6B5}\u{1F3FC}",
      "\u{1F6B5}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F6B5}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F6B5}\u{1F3FD}",
      "\u{1F6B5}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F6B5}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F6B5}\u{1F3FE}",
      "\u{1F6B5}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F6B5}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F6B5}\u{1F3FF}",
      "\u{1F6B5}\u200D\u2640\uFE0F",
      "\u{1F6B5}\u200D\u2642\uFE0F",
      "\u{1F6B5}",
      "\u{1F6B6}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F6B6}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F6B6}\u{1F3FB}",
      "\u{1F6B6}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F6B6}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F6B6}\u{1F3FC}",
      "\u{1F6B6}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F6B6}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F6B6}\u{1F3FD}",
      "\u{1F6B6}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F6B6}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F6B6}\u{1F3FE}",
      "\u{1F6B6}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F6B6}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F6B6}\u{1F3FF}",
      "\u{1F6B6}\u200D\u2640\uFE0F",
      "\u{1F6B6}\u200D\u2642\uFE0F",
      "\u{1F6B6}",
      "\u{1F6B7}",
      "\u{1F6B8}",
      "\u{1F6B9}",
      "\u{1F6BA}",
      "\u{1F6BB}",
      "\u{1F6BC}",
      "\u{1F6BD}",
      "\u{1F6BE}",
      "\u{1F6BF}",
      "\u{1F6C0}\u{1F3FB}",
      "\u{1F6C0}\u{1F3FC}",
      "\u{1F6C0}\u{1F3FD}",
      "\u{1F6C0}\u{1F3FE}",
      "\u{1F6C0}\u{1F3FF}",
      "\u{1F6C0}",
      "\u{1F6C1}",
      "\u{1F6C2}",
      "\u{1F6C3}",
      "\u{1F6C4}",
      "\u{1F6C5}",
      "\u{1F6CB}\uFE0F",
      "\u{1F6CC}\u{1F3FB}",
      "\u{1F6CC}\u{1F3FC}",
      "\u{1F6CC}\u{1F3FD}",
      "\u{1F6CC}\u{1F3FE}",
      "\u{1F6CC}\u{1F3FF}",
      "\u{1F6CC}",
      "\u{1F6CD}\uFE0F",
      "\u{1F6CE}\uFE0F",
      "\u{1F6CF}\uFE0F",
      "\u{1F6D0}",
      "\u{1F6D1}",
      "\u{1F6D2}",
      "\u{1F6D5}",
      "\u{1F6E0}\uFE0F",
      "\u{1F6E1}\uFE0F",
      "\u{1F6E2}\uFE0F",
      "\u{1F6E3}\uFE0F",
      "\u{1F6E4}\uFE0F",
      "\u{1F6E5}\uFE0F",
      "\u{1F6E9}\uFE0F",
      "\u{1F6EB}",
      "\u{1F6EC}",
      "\u{1F6F0}\uFE0F",
      "\u{1F6F3}\uFE0F",
      "\u{1F6F4}",
      "\u{1F6F5}",
      "\u{1F6F6}",
      "\u{1F6F7}",
      "\u{1F6F8}",
      "\u{1F6F9}",
      "\u{1F6FA}",
      "\u{1F7E0}",
      "\u{1F7E1}",
      "\u{1F7E2}",
      "\u{1F7E3}",
      "\u{1F7E4}",
      "\u{1F7E5}",
      "\u{1F7E6}",
      "\u{1F7E7}",
      "\u{1F7E8}",
      "\u{1F7E9}",
      "\u{1F7EA}",
      "\u{1F7EB}",
      "\u{1F90D}",
      "\u{1F90E}",
      "\u{1F90F}\u{1F3FB}",
      "\u{1F90F}\u{1F3FC}",
      "\u{1F90F}\u{1F3FD}",
      "\u{1F90F}\u{1F3FE}",
      "\u{1F90F}\u{1F3FF}",
      "\u{1F90F}",
      "\u{1F910}",
      "\u{1F911}",
      "\u{1F912}",
      "\u{1F913}",
      "\u{1F914}",
      "\u{1F915}",
      "\u{1F916}",
      "\u{1F917}",
      "\u{1F918}\u{1F3FB}",
      "\u{1F918}\u{1F3FC}",
      "\u{1F918}\u{1F3FD}",
      "\u{1F918}\u{1F3FE}",
      "\u{1F918}\u{1F3FF}",
      "\u{1F918}",
      "\u{1F919}\u{1F3FB}",
      "\u{1F919}\u{1F3FC}",
      "\u{1F919}\u{1F3FD}",
      "\u{1F919}\u{1F3FE}",
      "\u{1F919}\u{1F3FF}",
      "\u{1F919}",
      "\u{1F91A}\u{1F3FB}",
      "\u{1F91A}\u{1F3FC}",
      "\u{1F91A}\u{1F3FD}",
      "\u{1F91A}\u{1F3FE}",
      "\u{1F91A}\u{1F3FF}",
      "\u{1F91A}",
      "\u{1F91B}\u{1F3FB}",
      "\u{1F91B}\u{1F3FC}",
      "\u{1F91B}\u{1F3FD}",
      "\u{1F91B}\u{1F3FE}",
      "\u{1F91B}\u{1F3FF}",
      "\u{1F91B}",
      "\u{1F91C}\u{1F3FB}",
      "\u{1F91C}\u{1F3FC}",
      "\u{1F91C}\u{1F3FD}",
      "\u{1F91C}\u{1F3FE}",
      "\u{1F91C}\u{1F3FF}",
      "\u{1F91C}",
      "\u{1F91D}",
      "\u{1F91E}\u{1F3FB}",
      "\u{1F91E}\u{1F3FC}",
      "\u{1F91E}\u{1F3FD}",
      "\u{1F91E}\u{1F3FE}",
      "\u{1F91E}\u{1F3FF}",
      "\u{1F91E}",
      "\u{1F91F}\u{1F3FB}",
      "\u{1F91F}\u{1F3FC}",
      "\u{1F91F}\u{1F3FD}",
      "\u{1F91F}\u{1F3FE}",
      "\u{1F91F}\u{1F3FF}",
      "\u{1F91F}",
      "\u{1F920}",
      "\u{1F921}",
      "\u{1F922}",
      "\u{1F923}",
      "\u{1F924}",
      "\u{1F925}",
      "\u{1F926}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F926}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F926}\u{1F3FB}",
      "\u{1F926}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F926}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F926}\u{1F3FC}",
      "\u{1F926}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F926}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F926}\u{1F3FD}",
      "\u{1F926}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F926}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F926}\u{1F3FE}",
      "\u{1F926}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F926}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F926}\u{1F3FF}",
      "\u{1F926}\u200D\u2640\uFE0F",
      "\u{1F926}\u200D\u2642\uFE0F",
      "\u{1F926}",
      "\u{1F927}",
      "\u{1F928}",
      "\u{1F929}",
      "\u{1F92A}",
      "\u{1F92B}",
      "\u{1F92C}",
      "\u{1F92D}",
      "\u{1F92E}",
      "\u{1F92F}",
      "\u{1F930}\u{1F3FB}",
      "\u{1F930}\u{1F3FC}",
      "\u{1F930}\u{1F3FD}",
      "\u{1F930}\u{1F3FE}",
      "\u{1F930}\u{1F3FF}",
      "\u{1F930}",
      "\u{1F931}\u{1F3FB}",
      "\u{1F931}\u{1F3FC}",
      "\u{1F931}\u{1F3FD}",
      "\u{1F931}\u{1F3FE}",
      "\u{1F931}\u{1F3FF}",
      "\u{1F931}",
      "\u{1F932}\u{1F3FB}",
      "\u{1F932}\u{1F3FC}",
      "\u{1F932}\u{1F3FD}",
      "\u{1F932}\u{1F3FE}",
      "\u{1F932}\u{1F3FF}",
      "\u{1F932}",
      "\u{1F933}\u{1F3FB}",
      "\u{1F933}\u{1F3FC}",
      "\u{1F933}\u{1F3FD}",
      "\u{1F933}\u{1F3FE}",
      "\u{1F933}\u{1F3FF}",
      "\u{1F933}",
      "\u{1F934}\u{1F3FB}",
      "\u{1F934}\u{1F3FC}",
      "\u{1F934}\u{1F3FD}",
      "\u{1F934}\u{1F3FE}",
      "\u{1F934}\u{1F3FF}",
      "\u{1F934}",
      "\u{1F935}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F935}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F935}\u{1F3FB}",
      "\u{1F935}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F935}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F935}\u{1F3FC}",
      "\u{1F935}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F935}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F935}\u{1F3FD}",
      "\u{1F935}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F935}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F935}\u{1F3FE}",
      "\u{1F935}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F935}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F935}\u{1F3FF}",
      "\u{1F935}\u200D\u2640\uFE0F",
      "\u{1F935}\u200D\u2642\uFE0F",
      "\u{1F935}",
      "\u{1F936}\u{1F3FB}",
      "\u{1F936}\u{1F3FC}",
      "\u{1F936}\u{1F3FD}",
      "\u{1F936}\u{1F3FE}",
      "\u{1F936}\u{1F3FF}",
      "\u{1F936}",
      "\u{1F937}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F937}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F937}\u{1F3FB}",
      "\u{1F937}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F937}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F937}\u{1F3FC}",
      "\u{1F937}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F937}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F937}\u{1F3FD}",
      "\u{1F937}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F937}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F937}\u{1F3FE}",
      "\u{1F937}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F937}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F937}\u{1F3FF}",
      "\u{1F937}\u200D\u2640\uFE0F",
      "\u{1F937}\u200D\u2642\uFE0F",
      "\u{1F937}",
      "\u{1F938}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F938}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F938}\u{1F3FB}",
      "\u{1F938}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F938}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F938}\u{1F3FC}",
      "\u{1F938}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F938}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F938}\u{1F3FD}",
      "\u{1F938}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F938}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F938}\u{1F3FE}",
      "\u{1F938}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F938}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F938}\u{1F3FF}",
      "\u{1F938}\u200D\u2640\uFE0F",
      "\u{1F938}\u200D\u2642\uFE0F",
      "\u{1F938}",
      "\u{1F939}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F939}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F939}\u{1F3FB}",
      "\u{1F939}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F939}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F939}\u{1F3FC}",
      "\u{1F939}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F939}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F939}\u{1F3FD}",
      "\u{1F939}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F939}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F939}\u{1F3FE}",
      "\u{1F939}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F939}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F939}\u{1F3FF}",
      "\u{1F939}\u200D\u2640\uFE0F",
      "\u{1F939}\u200D\u2642\uFE0F",
      "\u{1F939}",
      "\u{1F93A}",
      "\u{1F93C}\u200D\u2640\uFE0F",
      "\u{1F93C}\u200D\u2642\uFE0F",
      "\u{1F93C}",
      "\u{1F93D}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F93D}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F93D}\u{1F3FB}",
      "\u{1F93D}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F93D}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F93D}\u{1F3FC}",
      "\u{1F93D}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F93D}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F93D}\u{1F3FD}",
      "\u{1F93D}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F93D}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F93D}\u{1F3FE}",
      "\u{1F93D}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F93D}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F93D}\u{1F3FF}",
      "\u{1F93D}\u200D\u2640\uFE0F",
      "\u{1F93D}\u200D\u2642\uFE0F",
      "\u{1F93D}",
      "\u{1F93E}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F93E}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F93E}\u{1F3FB}",
      "\u{1F93E}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F93E}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F93E}\u{1F3FC}",
      "\u{1F93E}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F93E}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F93E}\u{1F3FD}",
      "\u{1F93E}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F93E}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F93E}\u{1F3FE}",
      "\u{1F93E}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F93E}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F93E}\u{1F3FF}",
      "\u{1F93E}\u200D\u2640\uFE0F",
      "\u{1F93E}\u200D\u2642\uFE0F",
      "\u{1F93E}",
      "\u{1F93F}",
      "\u{1F940}",
      "\u{1F941}",
      "\u{1F942}",
      "\u{1F943}",
      "\u{1F944}",
      "\u{1F945}",
      "\u{1F947}",
      "\u{1F948}",
      "\u{1F949}",
      "\u{1F94A}",
      "\u{1F94B}",
      "\u{1F94C}",
      "\u{1F94D}",
      "\u{1F94E}",
      "\u{1F94F}",
      "\u{1F950}",
      "\u{1F951}",
      "\u{1F952}",
      "\u{1F953}",
      "\u{1F954}",
      "\u{1F955}",
      "\u{1F956}",
      "\u{1F957}",
      "\u{1F958}",
      "\u{1F959}",
      "\u{1F95A}",
      "\u{1F95B}",
      "\u{1F95C}",
      "\u{1F95D}",
      "\u{1F95E}",
      "\u{1F95F}",
      "\u{1F960}",
      "\u{1F961}",
      "\u{1F962}",
      "\u{1F963}",
      "\u{1F964}",
      "\u{1F965}",
      "\u{1F966}",
      "\u{1F967}",
      "\u{1F968}",
      "\u{1F969}",
      "\u{1F96A}",
      "\u{1F96B}",
      "\u{1F96C}",
      "\u{1F96D}",
      "\u{1F96E}",
      "\u{1F96F}",
      "\u{1F970}",
      "\u{1F971}",
      "\u{1F973}",
      "\u{1F974}",
      "\u{1F975}",
      "\u{1F976}",
      "\u{1F97A}",
      "\u{1F97B}",
      "\u{1F97C}",
      "\u{1F97D}",
      "\u{1F97E}",
      "\u{1F97F}",
      "\u{1F980}",
      "\u{1F981}",
      "\u{1F982}",
      "\u{1F983}",
      "\u{1F984}",
      "\u{1F985}",
      "\u{1F986}",
      "\u{1F987}",
      "\u{1F988}",
      "\u{1F989}",
      "\u{1F98A}",
      "\u{1F98B}",
      "\u{1F98C}",
      "\u{1F98D}",
      "\u{1F98E}",
      "\u{1F98F}",
      "\u{1F990}",
      "\u{1F991}",
      "\u{1F992}",
      "\u{1F993}",
      "\u{1F994}",
      "\u{1F995}",
      "\u{1F996}",
      "\u{1F997}",
      "\u{1F998}",
      "\u{1F999}",
      "\u{1F99A}",
      "\u{1F99B}",
      "\u{1F99C}",
      "\u{1F99D}",
      "\u{1F99E}",
      "\u{1F99F}",
      "\u{1F9A0}",
      "\u{1F9A1}",
      "\u{1F9A2}",
      "\u{1F9A5}",
      "\u{1F9A6}",
      "\u{1F9A7}",
      "\u{1F9A8}",
      "\u{1F9A9}",
      "\u{1F9AA}",
      "\u{1F9AE}",
      "\u{1F9AF}",
      "\u{1F9B0}",
      "\u{1F9B1}",
      "\u{1F9B2}",
      "\u{1F9B3}",
      "\u{1F9B4}",
      "\u{1F9B5}\u{1F3FB}",
      "\u{1F9B5}\u{1F3FC}",
      "\u{1F9B5}\u{1F3FD}",
      "\u{1F9B5}\u{1F3FE}",
      "\u{1F9B5}\u{1F3FF}",
      "\u{1F9B5}",
      "\u{1F9B6}\u{1F3FB}",
      "\u{1F9B6}\u{1F3FC}",
      "\u{1F9B6}\u{1F3FD}",
      "\u{1F9B6}\u{1F3FE}",
      "\u{1F9B6}\u{1F3FF}",
      "\u{1F9B6}",
      "\u{1F9B7}",
      "\u{1F9B8}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9B8}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9B8}\u{1F3FB}",
      "\u{1F9B8}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9B8}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9B8}\u{1F3FC}",
      "\u{1F9B8}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9B8}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9B8}\u{1F3FD}",
      "\u{1F9B8}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9B8}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9B8}\u{1F3FE}",
      "\u{1F9B8}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9B8}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9B8}\u{1F3FF}",
      "\u{1F9B8}\u200D\u2640\uFE0F",
      "\u{1F9B8}\u200D\u2642\uFE0F",
      "\u{1F9B8}",
      "\u{1F9B9}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9B9}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9B9}\u{1F3FB}",
      "\u{1F9B9}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9B9}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9B9}\u{1F3FC}",
      "\u{1F9B9}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9B9}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9B9}\u{1F3FD}",
      "\u{1F9B9}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9B9}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9B9}\u{1F3FE}",
      "\u{1F9B9}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9B9}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9B9}\u{1F3FF}",
      "\u{1F9B9}\u200D\u2640\uFE0F",
      "\u{1F9B9}\u200D\u2642\uFE0F",
      "\u{1F9B9}",
      "\u{1F9BA}",
      "\u{1F9BB}\u{1F3FB}",
      "\u{1F9BB}\u{1F3FC}",
      "\u{1F9BB}\u{1F3FD}",
      "\u{1F9BB}\u{1F3FE}",
      "\u{1F9BB}\u{1F3FF}",
      "\u{1F9BB}",
      "\u{1F9BC}",
      "\u{1F9BD}",
      "\u{1F9BE}",
      "\u{1F9BF}",
      "\u{1F9C0}",
      "\u{1F9C1}",
      "\u{1F9C2}",
      "\u{1F9C3}",
      "\u{1F9C4}",
      "\u{1F9C5}",
      "\u{1F9C6}",
      "\u{1F9C7}",
      "\u{1F9C8}",
      "\u{1F9C9}",
      "\u{1F9CA}",
      "\u{1F9CD}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9CD}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9CD}\u{1F3FB}",
      "\u{1F9CD}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9CD}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9CD}\u{1F3FC}",
      "\u{1F9CD}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9CD}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9CD}\u{1F3FD}",
      "\u{1F9CD}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9CD}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9CD}\u{1F3FE}",
      "\u{1F9CD}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9CD}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9CD}\u{1F3FF}",
      "\u{1F9CD}\u200D\u2640\uFE0F",
      "\u{1F9CD}\u200D\u2642\uFE0F",
      "\u{1F9CD}",
      "\u{1F9CE}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9CE}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9CE}\u{1F3FB}",
      "\u{1F9CE}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9CE}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9CE}\u{1F3FC}",
      "\u{1F9CE}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9CE}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9CE}\u{1F3FD}",
      "\u{1F9CE}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9CE}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9CE}\u{1F3FE}",
      "\u{1F9CE}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9CE}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9CE}\u{1F3FF}",
      "\u{1F9CE}\u200D\u2640\uFE0F",
      "\u{1F9CE}\u200D\u2642\uFE0F",
      "\u{1F9CE}",
      "\u{1F9CF}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9CF}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9CF}\u{1F3FB}",
      "\u{1F9CF}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9CF}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9CF}\u{1F3FC}",
      "\u{1F9CF}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9CF}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9CF}\u{1F3FD}",
      "\u{1F9CF}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9CF}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9CF}\u{1F3FE}",
      "\u{1F9CF}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9CF}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9CF}\u{1F3FF}",
      "\u{1F9CF}\u200D\u2640\uFE0F",
      "\u{1F9CF}\u200D\u2642\uFE0F",
      "\u{1F9CF}",
      "\u{1F9D0}",
      "\u{1F9D1}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}",
      "\u{1F9D1}\u{1F3FB}",
      "\u{1F9D1}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}",
      "\u{1F9D1}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}",
      "\u{1F9D1}\u{1F3FC}",
      "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}",
      "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}",
      "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}",
      "\u{1F9D1}\u{1F3FD}",
      "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}",
      "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}",
      "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}",
      "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FE}",
      "\u{1F9D1}\u{1F3FE}",
      "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}",
      "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}",
      "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}",
      "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FE}",
      "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FF}",
      "\u{1F9D1}\u{1F3FF}",
      "\u{1F9D1}\u200D\u{1F91D}\u200D\u{1F9D1}",
      "\u{1F9D1}",
      "\u{1F9D2}\u{1F3FB}",
      "\u{1F9D2}\u{1F3FC}",
      "\u{1F9D2}\u{1F3FD}",
      "\u{1F9D2}\u{1F3FE}",
      "\u{1F9D2}\u{1F3FF}",
      "\u{1F9D2}",
      "\u{1F9D3}\u{1F3FB}",
      "\u{1F9D3}\u{1F3FC}",
      "\u{1F9D3}\u{1F3FD}",
      "\u{1F9D3}\u{1F3FE}",
      "\u{1F9D3}\u{1F3FF}",
      "\u{1F9D3}",
      "\u{1F9D4}\u{1F3FB}",
      "\u{1F9D4}\u{1F3FC}",
      "\u{1F9D4}\u{1F3FD}",
      "\u{1F9D4}\u{1F3FE}",
      "\u{1F9D4}\u{1F3FF}",
      "\u{1F9D4}",
      "\u{1F9D5}\u{1F3FB}",
      "\u{1F9D5}\u{1F3FC}",
      "\u{1F9D5}\u{1F3FD}",
      "\u{1F9D5}\u{1F3FE}",
      "\u{1F9D5}\u{1F3FF}",
      "\u{1F9D5}",
      "\u{1F9D6}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9D6}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9D6}\u{1F3FB}",
      "\u{1F9D6}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9D6}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9D6}\u{1F3FC}",
      "\u{1F9D6}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9D6}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9D6}\u{1F3FD}",
      "\u{1F9D6}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9D6}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9D6}\u{1F3FE}",
      "\u{1F9D6}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9D6}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9D6}\u{1F3FF}",
      "\u{1F9D6}\u200D\u2640\uFE0F",
      "\u{1F9D6}\u200D\u2642\uFE0F",
      "\u{1F9D6}",
      "\u{1F9D7}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9D7}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9D7}\u{1F3FB}",
      "\u{1F9D7}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9D7}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9D7}\u{1F3FC}",
      "\u{1F9D7}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9D7}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9D7}\u{1F3FD}",
      "\u{1F9D7}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9D7}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9D7}\u{1F3FE}",
      "\u{1F9D7}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9D7}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9D7}\u{1F3FF}",
      "\u{1F9D7}\u200D\u2640\uFE0F",
      "\u{1F9D7}\u200D\u2642\uFE0F",
      "\u{1F9D7}",
      "\u{1F9D8}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9D8}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9D8}\u{1F3FB}",
      "\u{1F9D8}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9D8}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9D8}\u{1F3FC}",
      "\u{1F9D8}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9D8}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9D8}\u{1F3FD}",
      "\u{1F9D8}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9D8}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9D8}\u{1F3FE}",
      "\u{1F9D8}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9D8}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9D8}\u{1F3FF}",
      "\u{1F9D8}\u200D\u2640\uFE0F",
      "\u{1F9D8}\u200D\u2642\uFE0F",
      "\u{1F9D8}",
      "\u{1F9D9}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9D9}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9D9}\u{1F3FB}",
      "\u{1F9D9}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9D9}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9D9}\u{1F3FC}",
      "\u{1F9D9}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9D9}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9D9}\u{1F3FD}",
      "\u{1F9D9}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9D9}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9D9}\u{1F3FE}",
      "\u{1F9D9}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9D9}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9D9}\u{1F3FF}",
      "\u{1F9D9}\u200D\u2640\uFE0F",
      "\u{1F9D9}\u200D\u2642\uFE0F",
      "\u{1F9D9}",
      "\u{1F9DA}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9DA}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9DA}\u{1F3FB}",
      "\u{1F9DA}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9DA}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9DA}\u{1F3FC}",
      "\u{1F9DA}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9DA}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9DA}\u{1F3FD}",
      "\u{1F9DA}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9DA}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9DA}\u{1F3FE}",
      "\u{1F9DA}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9DA}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9DA}\u{1F3FF}",
      "\u{1F9DA}\u200D\u2640\uFE0F",
      "\u{1F9DA}\u200D\u2642\uFE0F",
      "\u{1F9DA}",
      "\u{1F9DB}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9DB}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9DB}\u{1F3FB}",
      "\u{1F9DB}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9DB}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9DB}\u{1F3FC}",
      "\u{1F9DB}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9DB}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9DB}\u{1F3FD}",
      "\u{1F9DB}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9DB}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9DB}\u{1F3FE}",
      "\u{1F9DB}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9DB}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9DB}\u{1F3FF}",
      "\u{1F9DB}\u200D\u2640\uFE0F",
      "\u{1F9DB}\u200D\u2642\uFE0F",
      "\u{1F9DB}",
      "\u{1F9DC}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9DC}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9DC}\u{1F3FB}",
      "\u{1F9DC}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9DC}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9DC}\u{1F3FC}",
      "\u{1F9DC}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9DC}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9DC}\u{1F3FD}",
      "\u{1F9DC}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9DC}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9DC}\u{1F3FE}",
      "\u{1F9DC}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9DC}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9DC}\u{1F3FF}",
      "\u{1F9DC}\u200D\u2640\uFE0F",
      "\u{1F9DC}\u200D\u2642\uFE0F",
      "\u{1F9DC}",
      "\u{1F9DD}\u{1F3FB}\u200D\u2640\uFE0F",
      "\u{1F9DD}\u{1F3FB}\u200D\u2642\uFE0F",
      "\u{1F9DD}\u{1F3FB}",
      "\u{1F9DD}\u{1F3FC}\u200D\u2640\uFE0F",
      "\u{1F9DD}\u{1F3FC}\u200D\u2642\uFE0F",
      "\u{1F9DD}\u{1F3FC}",
      "\u{1F9DD}\u{1F3FD}\u200D\u2640\uFE0F",
      "\u{1F9DD}\u{1F3FD}\u200D\u2642\uFE0F",
      "\u{1F9DD}\u{1F3FD}",
      "\u{1F9DD}\u{1F3FE}\u200D\u2640\uFE0F",
      "\u{1F9DD}\u{1F3FE}\u200D\u2642\uFE0F",
      "\u{1F9DD}\u{1F3FE}",
      "\u{1F9DD}\u{1F3FF}\u200D\u2640\uFE0F",
      "\u{1F9DD}\u{1F3FF}\u200D\u2642\uFE0F",
      "\u{1F9DD}\u{1F3FF}",
      "\u{1F9DD}\u200D\u2640\uFE0F",
      "\u{1F9DD}\u200D\u2642\uFE0F",
      "\u{1F9DD}",
      "\u{1F9DE}\u200D\u2640\uFE0F",
      "\u{1F9DE}\u200D\u2642\uFE0F",
      "\u{1F9DE}",
      "\u{1F9DF}\u200D\u2640\uFE0F",
      "\u{1F9DF}\u200D\u2642\uFE0F",
      "\u{1F9DF}",
      "\u{1F9E0}",
      "\u{1F9E1}",
      "\u{1F9E2}",
      "\u{1F9E3}",
      "\u{1F9E4}",
      "\u{1F9E5}",
      "\u{1F9E6}",
      "\u{1F9E7}",
      "\u{1F9E8}",
      "\u{1F9E9}",
      "\u{1F9EA}",
      "\u{1F9EB}",
      "\u{1F9EC}",
      "\u{1F9ED}",
      "\u{1F9EE}",
      "\u{1F9EF}",
      "\u{1F9F0}",
      "\u{1F9F1}",
      "\u{1F9F2}",
      "\u{1F9F3}",
      "\u{1F9F4}",
      "\u{1F9F5}",
      "\u{1F9F6}",
      "\u{1F9F7}",
      "\u{1F9F8}",
      "\u{1F9F9}",
      "\u{1F9FA}",
      "\u{1F9FB}",
      "\u{1F9FC}",
      "\u{1F9FD}",
      "\u{1F9FE}",
      "\u{1F9FF}",
      "\u{1FA70}",
      "\u{1FA71}",
      "\u{1FA72}",
      "\u{1FA73}",
      "\u{1FA78}",
      "\u{1FA79}",
      "\u{1FA7A}",
      "\u{1FA80}",
      "\u{1FA81}",
      "\u{1FA82}",
      "\u{1FA90}",
      "\u{1FA91}",
      "\u{1FA92}",
      "\u{1FA93}",
      "\u{1FA94}",
      "\u{1FA95}",
      "\u203C\uFE0F",
      "\u2049\uFE0F",
      "\u2122\uFE0F",
      "\u2139\uFE0F",
      "\u2194\uFE0F",
      "\u2195\uFE0F",
      "\u2196\uFE0F",
      "\u2197\uFE0F",
      "\u2198\uFE0F",
      "\u2199\uFE0F",
      "\u21A9\uFE0F",
      "\u21AA\uFE0F",
      "#\u20E3",
      "\u231A\uFE0F",
      "\u231B\uFE0F",
      "\u2328\uFE0F",
      "\u23CF\uFE0F",
      "\u23E9",
      "\u23EA",
      "\u23EB",
      "\u23EC",
      "\u23ED\uFE0F",
      "\u23EE\uFE0F",
      "\u23EF\uFE0F",
      "\u23F0",
      "\u23F1\uFE0F",
      "\u23F2\uFE0F",
      "\u23F3",
      "\u23F8\uFE0F",
      "\u23F9\uFE0F",
      "\u23FA\uFE0F",
      "\u24C2\uFE0F",
      "\u25AA\uFE0F",
      "\u25AB\uFE0F",
      "\u25B6\uFE0F",
      "\u25C0\uFE0F",
      "\u25FB\uFE0F",
      "\u25FC\uFE0F",
      "\u25FD\uFE0F",
      "\u25FE\uFE0F",
      "\u2600\uFE0F",
      "\u2601\uFE0F",
      "\u2602\uFE0F",
      "\u2603\uFE0F",
      "\u2604\uFE0F",
      "\u260E\uFE0F",
      "\u2611\uFE0F",
      "\u2614\uFE0F",
      "\u2615\uFE0F",
      "\u2618\uFE0F",
      "\u261D\u{1F3FB}",
      "\u261D\u{1F3FC}",
      "\u261D\u{1F3FD}",
      "\u261D\u{1F3FE}",
      "\u261D\u{1F3FF}",
      "\u261D\uFE0F",
      "\u2620\uFE0F",
      "\u2622\uFE0F",
      "\u2623\uFE0F",
      "\u2626\uFE0F",
      "\u262A\uFE0F",
      "\u262E\uFE0F",
      "\u262F\uFE0F",
      "\u2638\uFE0F",
      "\u2639\uFE0F",
      "\u263A\uFE0F",
      "\u2640\uFE0F",
      "\u2642\uFE0F",
      "\u2648\uFE0F",
      "\u2649\uFE0F",
      "\u264A\uFE0F",
      "\u264B\uFE0F",
      "\u264C\uFE0F",
      "\u264D\uFE0F",
      "\u264E\uFE0F",
      "\u264F\uFE0F",
      "\u2650\uFE0F",
      "\u2651\uFE0F",
      "\u2652\uFE0F",
      "\u2653\uFE0F",
      "\u265F\uFE0F",
      "\u2660\uFE0F",
      "\u2663\uFE0F",
      "\u2665\uFE0F",
      "\u2666\uFE0F",
      "\u2668\uFE0F",
      "\u267B\uFE0F",
      "\u267E",
      "\u267F\uFE0F",
      "\u2692\uFE0F",
      "\u2693\uFE0F",
      "\u2694\uFE0F",
      "\u2695\uFE0F",
      "\u2696\uFE0F",
      "\u2697\uFE0F",
      "\u2699\uFE0F",
      "\u269B\uFE0F",
      "\u269C\uFE0F",
      "\u26A0\uFE0F",
      "\u26A1\uFE0F",
      "\u26AA\uFE0F",
      "\u26AB\uFE0F",
      "\u26B0\uFE0F",
      "\u26B1\uFE0F",
      "\u26BD\uFE0F",
      "\u26BE\uFE0F",
      "\u26C4\uFE0F",
      "\u26C5\uFE0F",
      "\u26C8\uFE0F",
      "\u26CE",
      "\u26CF\uFE0F",
      "\u26D1\uFE0F",
      "\u26D3\uFE0F",
      "\u26D4\uFE0F",
      "\u26E9\uFE0F",
      "\u26EA\uFE0F",
      "\u26F0\uFE0F",
      "\u26F1\uFE0F",
      "\u26F2\uFE0F",
      "\u26F3\uFE0F",
      "\u26F4\uFE0F",
      "\u26F5\uFE0F",
      "\u26F7\u{1F3FB}",
      "\u26F7\u{1F3FC}",
      "\u26F7\u{1F3FD}",
      "\u26F7\u{1F3FE}",
      "\u26F7\u{1F3FF}",
      "\u26F7\uFE0F",
      "\u26F8\uFE0F",
      "\u26F9\u{1F3FB}\u200D\u2640\uFE0F",
      "\u26F9\u{1F3FB}\u200D\u2642\uFE0F",
      "\u26F9\u{1F3FB}",
      "\u26F9\u{1F3FC}\u200D\u2640\uFE0F",
      "\u26F9\u{1F3FC}\u200D\u2642\uFE0F",
      "\u26F9\u{1F3FC}",
      "\u26F9\u{1F3FD}\u200D\u2640\uFE0F",
      "\u26F9\u{1F3FD}\u200D\u2642\uFE0F",
      "\u26F9\u{1F3FD}",
      "\u26F9\u{1F3FE}\u200D\u2640\uFE0F",
      "\u26F9\u{1F3FE}\u200D\u2642\uFE0F",
      "\u26F9\u{1F3FE}",
      "\u26F9\u{1F3FF}\u200D\u2640\uFE0F",
      "\u26F9\u{1F3FF}\u200D\u2642\uFE0F",
      "\u26F9\u{1F3FF}",
      "\u26F9\uFE0F\u200D\u2640\uFE0F",
      "\u26F9\uFE0F\u200D\u2642\uFE0F",
      "\u26F9\uFE0F",
      "\u26FA\uFE0F",
      "\u26FD\uFE0F",
      "\u2702\uFE0F",
      "\u2705",
      "\u2708\uFE0F",
      "\u2709\uFE0F",
      "\u270A\u{1F3FB}",
      "\u270A\u{1F3FC}",
      "\u270A\u{1F3FD}",
      "\u270A\u{1F3FE}",
      "\u270A\u{1F3FF}",
      "\u270A",
      "\u270B\u{1F3FB}",
      "\u270B\u{1F3FC}",
      "\u270B\u{1F3FD}",
      "\u270B\u{1F3FE}",
      "\u270B\u{1F3FF}",
      "\u270B",
      "\u270C\u{1F3FB}",
      "\u270C\u{1F3FC}",
      "\u270C\u{1F3FD}",
      "\u270C\u{1F3FE}",
      "\u270C\u{1F3FF}",
      "\u270C\uFE0F",
      "\u270D\u{1F3FB}",
      "\u270D\u{1F3FC}",
      "\u270D\u{1F3FD}",
      "\u270D\u{1F3FE}",
      "\u270D\u{1F3FF}",
      "\u270D\uFE0F",
      "\u270F\uFE0F",
      "\u2712\uFE0F",
      "\u2714\uFE0F",
      "\u2716\uFE0F",
      "\u271D\uFE0F",
      "\u2721\uFE0F",
      "\u2728",
      "\u2733\uFE0F",
      "\u2734\uFE0F",
      "\u2744\uFE0F",
      "\u2747\uFE0F",
      "\u274C",
      "\u274E",
      "\u2753",
      "\u2754",
      "\u2755",
      "\u2757\uFE0F",
      "\u2763\uFE0F",
      "\u2764\uFE0F",
      "\u2795",
      "\u2796",
      "\u2797",
      "\u27A1\uFE0F",
      "\u27B0",
      "\u27BF",
      "\u2934\uFE0F",
      "\u2935\uFE0F",
      "*\u20E3",
      "\u2B05\uFE0F",
      "\u2B06\uFE0F",
      "\u2B07\uFE0F",
      "\u2B1B\uFE0F",
      "\u2B1C\uFE0F",
      "\u2B50\uFE0F",
      "\u2B55\uFE0F",
      "0\u20E3",
      "\u3030\uFE0F",
      "\u303D\uFE0F",
      "1\u20E3",
      "2\u20E3",
      "\u3297\uFE0F",
      "\u3299\uFE0F",
      "3\u20E3",
      "4\u20E3",
      "5\u20E3",
      "6\u20E3",
      "7\u20E3",
      "8\u20E3",
      "9\u20E3",
      "\xA9\uFE0F",
      "\xAE\uFE0F",
      "\uE50A"
    ];
    var path$12 = path__default2;
    var emojisList = emojisList$1;
    var getHashDigest$1 = getHashDigest_1;
    var emojiRegex = /[\uD800-\uDFFF]./;
    var emojiList = emojisList.filter((emoji) => emojiRegex.test(emoji));
    var emojiCache = {};
    function encodeStringToEmoji(content2, length) {
      if (emojiCache[content2]) {
        return emojiCache[content2];
      }
      length = length || 1;
      const emojis = [];
      do {
        if (!emojiList.length) {
          throw new Error("Ran out of emoji");
        }
        const index3 = Math.floor(Math.random() * emojiList.length);
        emojis.push(emojiList[index3]);
        emojiList.splice(index3, 1);
      } while (--length > 0);
      const emojiEncoding = emojis.join("");
      emojiCache[content2] = emojiEncoding;
      return emojiEncoding;
    }
    function interpolateName$2(loaderContext, name, options2) {
      let filename2;
      const hasQuery = loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;
      if (typeof name === "function") {
        filename2 = name(loaderContext.resourcePath, hasQuery ? loaderContext.resourceQuery : void 0);
      } else {
        filename2 = name || "[hash].[ext]";
      }
      const context2 = options2.context;
      const content2 = options2.content;
      const regExp = options2.regExp;
      let ext2 = "bin";
      let basename = "file";
      let directory = "";
      let folder = "";
      let query = "";
      if (loaderContext.resourcePath) {
        const parsed = path$12.parse(loaderContext.resourcePath);
        let resourcePath = loaderContext.resourcePath;
        if (parsed.ext) {
          ext2 = parsed.ext.substr(1);
        }
        if (parsed.dir) {
          basename = parsed.name;
          resourcePath = parsed.dir + path$12.sep;
        }
        if (typeof context2 !== "undefined") {
          directory = path$12.relative(context2, resourcePath + "_").replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1");
          directory = directory.substr(0, directory.length - 1);
        } else {
          directory = resourcePath.replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1");
        }
        if (directory.length === 1) {
          directory = "";
        } else if (directory.length > 1) {
          folder = path$12.basename(directory);
        }
      }
      if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {
        query = loaderContext.resourceQuery;
        const hashIdx = query.indexOf("#");
        if (hashIdx >= 0) {
          query = query.substr(0, hashIdx);
        }
      }
      let url2 = filename2;
      if (content2) {
        url2 = url2.replace(/\[(?:([^:\]]+):)?(?:hash|contenthash)(?::([a-z]+\d*))?(?::(\d+))?\]/gi, (all, hashType, digestType, maxLength) => getHashDigest$1(content2, hashType, digestType, parseInt(maxLength, 10))).replace(/\[emoji(?::(\d+))?\]/gi, (all, length) => encodeStringToEmoji(content2, parseInt(length, 10)));
      }
      url2 = url2.replace(/\[ext\]/gi, () => ext2).replace(/\[name\]/gi, () => basename).replace(/\[path\]/gi, () => directory).replace(/\[folder\]/gi, () => folder).replace(/\[query\]/gi, () => query);
      if (regExp && loaderContext.resourcePath) {
        const match2 = loaderContext.resourcePath.match(new RegExp(regExp));
        match2 && match2.forEach((matched, i2) => {
          url2 = url2.replace(new RegExp("\\[" + i2 + "\\]", "ig"), matched);
        });
      }
      if (typeof loaderContext.options === "object" && typeof loaderContext.options.customInterpolateName === "function") {
        url2 = loaderContext.options.customInterpolateName.call(loaderContext, url2, name, options2);
      }
      return url2;
    }
    var interpolateName_1 = interpolateName$2;
    var getOptions2 = getOptions_1;
    var parseQuery = parseQuery_1;
    var stringifyRequest = stringifyRequest_1;
    var getRemainingRequest = getRemainingRequest_1;
    var getCurrentRequest = getCurrentRequest_1;
    var isUrlRequest = isUrlRequest_1;
    var urlToRequest = urlToRequest_1;
    var parseString = parseString_1;
    var getHashDigest = getHashDigest_1;
    var interpolateName$1 = interpolateName_1;
    lib$2.getOptions = getOptions2;
    lib$2.parseQuery = parseQuery;
    lib$2.stringifyRequest = stringifyRequest;
    lib$2.getRemainingRequest = getRemainingRequest;
    lib$2.getCurrentRequest = getCurrentRequest;
    lib$2.isUrlRequest = isUrlRequest;
    lib$2.urlToRequest = urlToRequest;
    lib$2.parseString = parseString;
    lib$2.getHashDigest = getHashDigest;
    lib$2.interpolateName = interpolateName$1;
    var interpolateName = lib$2.interpolateName;
    var path2 = path__default2;
    var genericNames = function createGenerator(pattern2, options2) {
      options2 = options2 || {};
      var context2 = options2 && typeof options2.context === "string" ? options2.context : process.cwd();
      var hashPrefix = options2 && typeof options2.hashPrefix === "string" ? options2.hashPrefix : "";
      return function generate2(localName, filepath) {
        var name = pattern2.replace(/\[local\]/gi, localName);
        var loaderContext = {
          resourcePath: filepath
        };
        var loaderOptions = {
          content: hashPrefix + path2.relative(context2, filepath).replace(/\\/g, "/") + "+" + localName,
          context: context2
        };
        var genericName = interpolateName(loaderContext, name, loaderOptions);
        return genericName.replace(new RegExp("[^a-zA-Z0-9\\-_\xA0-\uFFFF]", "g"), "-").replace(/^((-?[0-9])|--)/, "_$1");
      };
    };
    var unquote$1 = {};
    Object.defineProperty(unquote$1, "__esModule", {
      value: true
    });
    unquote$1.default = unquote;
    var reg = /['"]/;
    function unquote(str2) {
      if (!str2) {
        return "";
      }
      if (reg.test(str2.charAt(0))) {
        str2 = str2.substr(1);
      }
      if (reg.test(str2.charAt(str2.length - 1))) {
        str2 = str2.substr(0, str2.length - 1);
      }
      return str2;
    }
    var parser$1 = {};
    var lib2 = {};
    Object.defineProperty(lib2, "__esModule", {
      value: true
    });
    lib2.replaceAll = replaceAll;
    var matchConstName = /[$#]?[\w-\.]+/g;
    function replaceAll(replacements, text) {
      var matches2 = void 0;
      while (matches2 = matchConstName.exec(text)) {
        var replacement2 = replacements[matches2[0]];
        if (replacement2) {
          text = text.slice(0, matches2.index) + replacement2 + text.slice(matchConstName.lastIndex);
          matchConstName.lastIndex -= matches2[0].length - replacement2.length;
        }
      }
      return text;
    }
    lib2.default = function(css, translations) {
      css.walkDecls(function(decl) {
        return decl.value = replaceAll(translations, decl.value);
      });
      css.walkAtRules("media", function(atRule) {
        return atRule.params = replaceAll(translations, atRule.params);
      });
    };
    Object.defineProperty(parser$1, "__esModule", {
      value: true
    });
    var _icssReplaceSymbols = lib2;
    var _icssReplaceSymbols2 = _interopRequireDefault$6(_icssReplaceSymbols);
    function _interopRequireDefault$6(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var importRegexp = /^:import\((.+)\)$/;
    var Parser2 = class {
      constructor(pathFetcher, trace) {
        this.pathFetcher = pathFetcher;
        this.plugin = this.plugin.bind(this);
        this.exportTokens = {};
        this.translations = {};
        this.trace = trace;
      }
      plugin() {
        const parser3 = this;
        return {
          postcssPlugin: "css-modules-parser",
          OnceExit(css) {
            return Promise.all(parser3.fetchAllImports(css)).then(() => parser3.linkImportedSymbols(css)).then(() => parser3.extractExports(css));
          }
        };
      }
      fetchAllImports(css) {
        let imports = [];
        css.each((node3) => {
          if (node3.type == "rule" && node3.selector.match(importRegexp)) {
            imports.push(this.fetchImport(node3, css.source.input.from, imports.length));
          }
        });
        return imports;
      }
      linkImportedSymbols(css) {
        (0, _icssReplaceSymbols2.default)(css, this.translations);
      }
      extractExports(css) {
        css.each((node3) => {
          if (node3.type == "rule" && node3.selector == ":export")
            this.handleExport(node3);
        });
      }
      handleExport(exportNode) {
        exportNode.each((decl) => {
          if (decl.type == "decl") {
            Object.keys(this.translations).forEach((translation) => {
              decl.value = decl.value.replace(translation, this.translations[translation]);
            });
            this.exportTokens[decl.prop] = decl.value;
          }
        });
        exportNode.remove();
      }
      fetchImport(importNode, relativeTo, depNr) {
        let file = importNode.selector.match(importRegexp)[1], depTrace = this.trace + String.fromCharCode(depNr);
        return this.pathFetcher(file, relativeTo, depTrace).then((exports3) => {
          importNode.each((decl) => {
            if (decl.type == "decl") {
              this.translations[decl.prop] = exports3[decl.value];
            }
          });
          importNode.remove();
        }, (err) => console.log(err));
      }
    };
    parser$1.default = Parser2;
    var loader = {};
    Object.defineProperty(loader, "__esModule", {
      value: true
    });
    var _postcss$1 = require$$0__default2;
    var _postcss2$1 = _interopRequireDefault$5(_postcss$1);
    var _fs$1 = fs__default2;
    var _fs2 = _interopRequireDefault$5(_fs$1);
    var _path = path__default2;
    var _path2 = _interopRequireDefault$5(_path);
    var _parser$1 = parser$1;
    var _parser2$1 = _interopRequireDefault$5(_parser$1);
    function _interopRequireDefault$5(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Core = class {
      constructor(plugins2) {
        this.plugins = plugins2 || Core.defaultPlugins;
      }
      load(sourceString, sourcePath, trace, pathFetcher) {
        let parser3 = new _parser2$1.default(pathFetcher, trace);
        return (0, _postcss2$1.default)(this.plugins.concat([parser3.plugin()])).process(sourceString, { from: "/" + sourcePath }).then((result2) => {
          return {
            injectableSource: result2.css,
            exportTokens: parser3.exportTokens
          };
        });
      }
    };
    var traceKeySorter = (a2, b2) => {
      if (a2.length < b2.length) {
        return a2 < b2.substring(0, a2.length) ? -1 : 1;
      } else if (a2.length > b2.length) {
        return a2.substring(0, b2.length) <= b2 ? -1 : 1;
      } else {
        return a2 < b2 ? -1 : 1;
      }
    };
    var FileSystemLoader = class {
      constructor(root2, plugins2) {
        this.root = root2;
        this.sources = {};
        this.traces = {};
        this.importNr = 0;
        this.core = new Core(plugins2);
        this.tokensByFile = {};
      }
      fetch(_newPath, relativeTo, _trace) {
        let newPath = _newPath.replace(/^["']|["']$/g, ""), trace = _trace || String.fromCharCode(this.importNr++);
        return new Promise((resolve2, reject) => {
          let relativeDir = _path2.default.dirname(relativeTo), rootRelativePath = _path2.default.resolve(relativeDir, newPath), fileRelativePath = _path2.default.resolve(_path2.default.join(this.root, relativeDir), newPath);
          if (newPath[0] !== "." && newPath[0] !== "/") {
            try {
              fileRelativePath = __require.resolve(newPath);
            } catch (e2) {
            }
          }
          const tokens = this.tokensByFile[fileRelativePath];
          if (tokens) {
            return resolve2(tokens);
          }
          _fs2.default.readFile(fileRelativePath, "utf-8", (err, source2) => {
            if (err)
              reject(err);
            this.core.load(source2, rootRelativePath, trace, this.fetch.bind(this)).then(({ injectableSource, exportTokens }) => {
              this.sources[fileRelativePath] = injectableSource;
              this.traces[trace] = fileRelativePath;
              this.tokensByFile[fileRelativePath] = exportTokens;
              resolve2(exportTokens);
            }, reject);
          });
        });
      }
      get finalSource() {
        const traces = this.traces;
        const sources = this.sources;
        let written = new Set();
        return Object.keys(traces).sort(traceKeySorter).map((key) => {
          const filename2 = traces[key];
          if (written.has(filename2)) {
            return null;
          }
          written.add(filename2);
          return sources[filename2];
        }).join("");
      }
    };
    loader.default = FileSystemLoader;
    var generateScopedName$1 = {};
    function hash(str2) {
      var hash2 = 5381, i2 = str2.length;
      while (i2) {
        hash2 = hash2 * 33 ^ str2.charCodeAt(--i2);
      }
      return hash2 >>> 0;
    }
    var stringHash = hash;
    Object.defineProperty(generateScopedName$1, "__esModule", {
      value: true
    });
    generateScopedName$1.default = generateScopedName;
    var _stringHash = stringHash;
    var _stringHash2 = _interopRequireDefault$4(_stringHash);
    function _interopRequireDefault$4(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function generateScopedName(name, filename2, css) {
      const i2 = css.indexOf(`.${name}`);
      const lineNumber = css.substr(0, i2).split(/[\r\n]/).length;
      const hash2 = (0, _stringHash2.default)(css).toString(36).substr(0, 5);
      return `_${name}_${hash2}_${lineNumber}`;
    }
    var saveJSON$1 = {};
    Object.defineProperty(saveJSON$1, "__esModule", {
      value: true
    });
    saveJSON$1.default = saveJSON;
    var _fs = fs__default2;
    function saveJSON(cssFile, json2) {
      return new Promise((resolve2, reject) => {
        (0, _fs.writeFile)(`${cssFile}.json`, JSON.stringify(json2), (e2) => e2 ? reject(e2) : resolve2(json2));
      });
    }
    var behaviours$1 = {};
    var src$4 = { exports: {} };
    var dist2 = { exports: {} };
    var processor = { exports: {} };
    var parser2 = { exports: {} };
    var root$1 = { exports: {} };
    var container = { exports: {} };
    var node$12 = { exports: {} };
    var util2 = {};
    var unesc = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = unesc2;
      function gobbleHex(str2) {
        var lower = str2.toLowerCase();
        var hex = "";
        var spaceTerminated = false;
        for (var i2 = 0; i2 < 6 && lower[i2] !== void 0; i2++) {
          var code = lower.charCodeAt(i2);
          var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57;
          spaceTerminated = code === 32;
          if (!valid) {
            break;
          }
          hex += lower[i2];
        }
        if (hex.length === 0) {
          return void 0;
        }
        var codePoint = parseInt(hex, 16);
        var isSurrogate = codePoint >= 55296 && codePoint <= 57343;
        if (isSurrogate || codePoint === 0 || codePoint > 1114111) {
          return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
        }
        return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
      }
      var CONTAINS_ESCAPE = /\\/;
      function unesc2(str2) {
        var needToProcess = CONTAINS_ESCAPE.test(str2);
        if (!needToProcess) {
          return str2;
        }
        var ret = "";
        for (var i2 = 0; i2 < str2.length; i2++) {
          if (str2[i2] === "\\") {
            var gobbled = gobbleHex(str2.slice(i2 + 1, i2 + 7));
            if (gobbled !== void 0) {
              ret += gobbled[0];
              i2 += gobbled[1];
              continue;
            }
            if (str2[i2 + 1] === "\\") {
              ret += "\\";
              i2++;
              continue;
            }
            if (str2.length === i2 + 1) {
              ret += str2[i2];
            }
            continue;
          }
          ret += str2[i2];
        }
        return ret;
      }
      module3.exports = exports3.default;
    })(unesc, unesc.exports);
    var getProp = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = getProp2;
      function getProp2(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }
        while (props.length > 0) {
          var prop = props.shift();
          if (!obj[prop]) {
            return void 0;
          }
          obj = obj[prop];
        }
        return obj;
      }
      module3.exports = exports3.default;
    })(getProp, getProp.exports);
    var ensureObject = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = ensureObject2;
      function ensureObject2(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }
        while (props.length > 0) {
          var prop = props.shift();
          if (!obj[prop]) {
            obj[prop] = {};
          }
          obj = obj[prop];
        }
      }
      module3.exports = exports3.default;
    })(ensureObject, ensureObject.exports);
    var stripComments = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = stripComments2;
      function stripComments2(str2) {
        var s2 = "";
        var commentStart = str2.indexOf("/*");
        var lastEnd = 0;
        while (commentStart >= 0) {
          s2 = s2 + str2.slice(lastEnd, commentStart);
          var commentEnd = str2.indexOf("*/", commentStart + 2);
          if (commentEnd < 0) {
            return s2;
          }
          lastEnd = commentEnd + 2;
          commentStart = str2.indexOf("/*", lastEnd);
        }
        s2 = s2 + str2.slice(lastEnd);
        return s2;
      }
      module3.exports = exports3.default;
    })(stripComments, stripComments.exports);
    util2.__esModule = true;
    util2.stripComments = util2.ensureObject = util2.getProp = util2.unesc = void 0;
    var _unesc = _interopRequireDefault$3(unesc.exports);
    util2.unesc = _unesc["default"];
    var _getProp = _interopRequireDefault$3(getProp.exports);
    util2.getProp = _getProp["default"];
    var _ensureObject = _interopRequireDefault$3(ensureObject.exports);
    util2.ensureObject = _ensureObject["default"];
    var _stripComments = _interopRequireDefault$3(stripComments.exports);
    util2.stripComments = _stripComments["default"];
    function _interopRequireDefault$3(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _util = util2;
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var cloneNode = function cloneNode2(obj, parent) {
        if (typeof obj !== "object" || obj === null) {
          return obj;
        }
        var cloned = new obj.constructor();
        for (var i2 in obj) {
          if (!obj.hasOwnProperty(i2)) {
            continue;
          }
          var value = obj[i2];
          var type = typeof value;
          if (i2 === "parent" && type === "object") {
            if (parent) {
              cloned[i2] = parent;
            }
          } else if (value instanceof Array) {
            cloned[i2] = value.map(function(j2) {
              return cloneNode2(j2, cloned);
            });
          } else {
            cloned[i2] = cloneNode2(value, cloned);
          }
        }
        return cloned;
      };
      var Node2 = function() {
        function Node3(opts) {
          if (opts === void 0) {
            opts = {};
          }
          Object.assign(this, opts);
          this.spaces = this.spaces || {};
          this.spaces.before = this.spaces.before || "";
          this.spaces.after = this.spaces.after || "";
        }
        var _proto = Node3.prototype;
        _proto.remove = function remove2() {
          if (this.parent) {
            this.parent.removeChild(this);
          }
          this.parent = void 0;
          return this;
        };
        _proto.replaceWith = function replaceWith() {
          if (this.parent) {
            for (var index3 in arguments) {
              this.parent.insertBefore(this, arguments[index3]);
            }
            this.remove();
          }
          return this;
        };
        _proto.next = function next() {
          return this.parent.at(this.parent.index(this) + 1);
        };
        _proto.prev = function prev() {
          return this.parent.at(this.parent.index(this) - 1);
        };
        _proto.clone = function clone(overrides) {
          if (overrides === void 0) {
            overrides = {};
          }
          var cloned = cloneNode(this);
          for (var name in overrides) {
            cloned[name] = overrides[name];
          }
          return cloned;
        };
        _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }
          var originalValue = this[name];
          var originalEscaped = this.raws[name];
          this[name] = originalValue + value;
          if (originalEscaped || valueEscaped !== value) {
            this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
          } else {
            delete this.raws[name];
          }
        };
        _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }
          this[name] = value;
          this.raws[name] = valueEscaped;
        };
        _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
          this[name] = value;
          if (this.raws) {
            delete this.raws[name];
          }
        };
        _proto.isAtPosition = function isAtPosition(line, column) {
          if (this.source && this.source.start && this.source.end) {
            if (this.source.start.line > line) {
              return false;
            }
            if (this.source.end.line < line) {
              return false;
            }
            if (this.source.start.line === line && this.source.start.column > column) {
              return false;
            }
            if (this.source.end.line === line && this.source.end.column < column) {
              return false;
            }
            return true;
          }
          return void 0;
        };
        _proto.stringifyProperty = function stringifyProperty(name) {
          return this.raws && this.raws[name] || this[name];
        };
        _proto.valueToString = function valueToString() {
          return String(this.stringifyProperty("value"));
        };
        _proto.toString = function toString3() {
          return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
        };
        _createClass(Node3, [{
          key: "rawSpaceBefore",
          get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
            if (rawSpace === void 0) {
              rawSpace = this.spaces && this.spaces.before;
            }
            return rawSpace || "";
          },
          set: function set2(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.before = raw;
          }
        }, {
          key: "rawSpaceAfter",
          get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
            if (rawSpace === void 0) {
              rawSpace = this.spaces.after;
            }
            return rawSpace || "";
          },
          set: function set2(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.after = raw;
          }
        }]);
        return Node3;
      }();
      exports3["default"] = Node2;
      module3.exports = exports3.default;
    })(node$12, node$12.exports);
    var types2 = {};
    types2.__esModule = true;
    types2.UNIVERSAL = types2.ATTRIBUTE = types2.CLASS = types2.COMBINATOR = types2.COMMENT = types2.ID = types2.NESTING = types2.PSEUDO = types2.ROOT = types2.SELECTOR = types2.STRING = types2.TAG = void 0;
    var TAG = "tag";
    types2.TAG = TAG;
    var STRING = "string";
    types2.STRING = STRING;
    var SELECTOR = "selector";
    types2.SELECTOR = SELECTOR;
    var ROOT = "root";
    types2.ROOT = ROOT;
    var PSEUDO = "pseudo";
    types2.PSEUDO = PSEUDO;
    var NESTING = "nesting";
    types2.NESTING = NESTING;
    var ID = "id";
    types2.ID = ID;
    var COMMENT = "comment";
    types2.COMMENT = COMMENT;
    var COMBINATOR = "combinator";
    types2.COMBINATOR = COMBINATOR;
    var CLASS = "class";
    types2.CLASS = CLASS;
    var ATTRIBUTE = "attribute";
    types2.ATTRIBUTE = ATTRIBUTE;
    var UNIVERSAL = "universal";
    types2.UNIVERSAL = UNIVERSAL;
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _node = _interopRequireDefault2(node$12.exports);
      var types$12 = _interopRequireWildcard2(types2);
      function _getRequireWildcardCache() {
        if (typeof WeakMap !== "function")
          return null;
        var cache2 = new WeakMap();
        _getRequireWildcardCache = function _getRequireWildcardCache2() {
          return cache2;
        };
        return cache2;
      }
      function _interopRequireWildcard2(obj) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache();
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _createForOfIteratorHelperLoose(o2, allowArrayLike) {
        var it2;
        if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
          if (Array.isArray(o2) || (it2 = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
            if (it2)
              o2 = it2;
            var i2 = 0;
            return function() {
              if (i2 >= o2.length)
                return { done: true };
              return { done: false, value: o2[i2++] };
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        it2 = o2[Symbol.iterator]();
        return it2.next.bind(it2);
      }
      function _unsupportedIterableToArray(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray(o2, minLen);
        var n3 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n3 === "Object" && o2.constructor)
          n3 = o2.constructor.name;
        if (n3 === "Map" || n3 === "Set")
          return Array.from(o2);
        if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
          return _arrayLikeToArray(o2, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
          arr2[i2] = arr[i2];
        }
        return arr2;
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Container = function(_Node) {
        _inheritsLoose(Container2, _Node);
        function Container2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          if (!_this.nodes) {
            _this.nodes = [];
          }
          return _this;
        }
        var _proto = Container2.prototype;
        _proto.append = function append2(selector2) {
          selector2.parent = this;
          this.nodes.push(selector2);
          return this;
        };
        _proto.prepend = function prepend(selector2) {
          selector2.parent = this;
          this.nodes.unshift(selector2);
          return this;
        };
        _proto.at = function at3(index3) {
          return this.nodes[index3];
        };
        _proto.index = function index3(child) {
          if (typeof child === "number") {
            return child;
          }
          return this.nodes.indexOf(child);
        };
        _proto.removeChild = function removeChild(child) {
          child = this.index(child);
          this.at(child).parent = void 0;
          this.nodes.splice(child, 1);
          var index3;
          for (var id2 in this.indexes) {
            index3 = this.indexes[id2];
            if (index3 >= child) {
              this.indexes[id2] = index3 - 1;
            }
          }
          return this;
        };
        _proto.removeAll = function removeAll() {
          for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done; ) {
            var node3 = _step.value;
            node3.parent = void 0;
          }
          this.nodes = [];
          return this;
        };
        _proto.empty = function empty2() {
          return this.removeAll();
        };
        _proto.insertAfter = function insertAfter(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex + 1, 0, newNode);
          newNode.parent = this;
          var index3;
          for (var id2 in this.indexes) {
            index3 = this.indexes[id2];
            if (oldIndex <= index3) {
              this.indexes[id2] = index3 + 1;
            }
          }
          return this;
        };
        _proto.insertBefore = function insertBefore(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex, 0, newNode);
          newNode.parent = this;
          var index3;
          for (var id2 in this.indexes) {
            index3 = this.indexes[id2];
            if (index3 <= oldIndex) {
              this.indexes[id2] = index3 + 1;
            }
          }
          return this;
        };
        _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
          var found = void 0;
          this.each(function(node3) {
            if (node3.atPosition) {
              var foundChild = node3.atPosition(line, col);
              if (foundChild) {
                found = foundChild;
                return false;
              }
            } else if (node3.isAtPosition(line, col)) {
              found = node3;
              return false;
            }
          });
          return found;
        };
        _proto.atPosition = function atPosition(line, col) {
          if (this.isAtPosition(line, col)) {
            return this._findChildAtPosition(line, col) || this;
          } else {
            return void 0;
          }
        };
        _proto._inferEndPosition = function _inferEndPosition() {
          if (this.last && this.last.source && this.last.source.end) {
            this.source = this.source || {};
            this.source.end = this.source.end || {};
            Object.assign(this.source.end, this.last.source.end);
          }
        };
        _proto.each = function each(callback) {
          if (!this.lastEach) {
            this.lastEach = 0;
          }
          if (!this.indexes) {
            this.indexes = {};
          }
          this.lastEach++;
          var id2 = this.lastEach;
          this.indexes[id2] = 0;
          if (!this.length) {
            return void 0;
          }
          var index3, result2;
          while (this.indexes[id2] < this.length) {
            index3 = this.indexes[id2];
            result2 = callback(this.at(index3), index3);
            if (result2 === false) {
              break;
            }
            this.indexes[id2] += 1;
          }
          delete this.indexes[id2];
          if (result2 === false) {
            return false;
          }
        };
        _proto.walk = function walk2(callback) {
          return this.each(function(node3, i2) {
            var result2 = callback(node3, i2);
            if (result2 !== false && node3.length) {
              result2 = node3.walk(callback);
            }
            if (result2 === false) {
              return false;
            }
          });
        };
        _proto.walkAttributes = function walkAttributes(callback) {
          var _this2 = this;
          return this.walk(function(selector2) {
            if (selector2.type === types$12.ATTRIBUTE) {
              return callback.call(_this2, selector2);
            }
          });
        };
        _proto.walkClasses = function walkClasses(callback) {
          var _this3 = this;
          return this.walk(function(selector2) {
            if (selector2.type === types$12.CLASS) {
              return callback.call(_this3, selector2);
            }
          });
        };
        _proto.walkCombinators = function walkCombinators(callback) {
          var _this4 = this;
          return this.walk(function(selector2) {
            if (selector2.type === types$12.COMBINATOR) {
              return callback.call(_this4, selector2);
            }
          });
        };
        _proto.walkComments = function walkComments(callback) {
          var _this5 = this;
          return this.walk(function(selector2) {
            if (selector2.type === types$12.COMMENT) {
              return callback.call(_this5, selector2);
            }
          });
        };
        _proto.walkIds = function walkIds(callback) {
          var _this6 = this;
          return this.walk(function(selector2) {
            if (selector2.type === types$12.ID) {
              return callback.call(_this6, selector2);
            }
          });
        };
        _proto.walkNesting = function walkNesting(callback) {
          var _this7 = this;
          return this.walk(function(selector2) {
            if (selector2.type === types$12.NESTING) {
              return callback.call(_this7, selector2);
            }
          });
        };
        _proto.walkPseudos = function walkPseudos(callback) {
          var _this8 = this;
          return this.walk(function(selector2) {
            if (selector2.type === types$12.PSEUDO) {
              return callback.call(_this8, selector2);
            }
          });
        };
        _proto.walkTags = function walkTags(callback) {
          var _this9 = this;
          return this.walk(function(selector2) {
            if (selector2.type === types$12.TAG) {
              return callback.call(_this9, selector2);
            }
          });
        };
        _proto.walkUniversals = function walkUniversals(callback) {
          var _this10 = this;
          return this.walk(function(selector2) {
            if (selector2.type === types$12.UNIVERSAL) {
              return callback.call(_this10, selector2);
            }
          });
        };
        _proto.split = function split2(callback) {
          var _this11 = this;
          var current = [];
          return this.reduce(function(memo, node3, index3) {
            var split3 = callback.call(_this11, node3);
            current.push(node3);
            if (split3) {
              memo.push(current);
              current = [];
            } else if (index3 === _this11.length - 1) {
              memo.push(current);
            }
            return memo;
          }, []);
        };
        _proto.map = function map2(callback) {
          return this.nodes.map(callback);
        };
        _proto.reduce = function reduce(callback, memo) {
          return this.nodes.reduce(callback, memo);
        };
        _proto.every = function every(callback) {
          return this.nodes.every(callback);
        };
        _proto.some = function some(callback) {
          return this.nodes.some(callback);
        };
        _proto.filter = function filter2(callback) {
          return this.nodes.filter(callback);
        };
        _proto.sort = function sort(callback) {
          return this.nodes.sort(callback);
        };
        _proto.toString = function toString3() {
          return this.map(String).join("");
        };
        _createClass(Container2, [{
          key: "first",
          get: function get() {
            return this.at(0);
          }
        }, {
          key: "last",
          get: function get() {
            return this.at(this.length - 1);
          }
        }, {
          key: "length",
          get: function get() {
            return this.nodes.length;
          }
        }]);
        return Container2;
      }(_node["default"]);
      exports3["default"] = Container;
      module3.exports = exports3.default;
    })(container, container.exports);
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _container = _interopRequireDefault2(container.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Root = function(_Container) {
        _inheritsLoose(Root2, _Container);
        function Root2(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types2.ROOT;
          return _this;
        }
        var _proto = Root2.prototype;
        _proto.toString = function toString3() {
          var str2 = this.reduce(function(memo, selector2) {
            memo.push(String(selector2));
            return memo;
          }, []).join(",");
          return this.trailingComma ? str2 + "," : str2;
        };
        _proto.error = function error2(message, options2) {
          if (this._error) {
            return this._error(message, options2);
          } else {
            return new Error(message);
          }
        };
        _createClass(Root2, [{
          key: "errorGenerator",
          set: function set2(handler) {
            this._error = handler;
          }
        }]);
        return Root2;
      }(_container["default"]);
      exports3["default"] = Root;
      module3.exports = exports3.default;
    })(root$1, root$1.exports);
    var selector$1 = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _container = _interopRequireDefault2(container.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Selector = function(_Container) {
        _inheritsLoose(Selector2, _Container);
        function Selector2(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types2.SELECTOR;
          return _this;
        }
        return Selector2;
      }(_container["default"]);
      exports3["default"] = Selector;
      module3.exports = exports3.default;
    })(selector$1, selector$1.exports);
    var className$1 = { exports: {} };
    var object = {};
    var hasOwnProperty$12 = object.hasOwnProperty;
    var merge3 = function merge4(options2, defaults2) {
      if (!options2) {
        return defaults2;
      }
      var result2 = {};
      for (var key in defaults2) {
        result2[key] = hasOwnProperty$12.call(options2, key) ? options2[key] : defaults2[key];
      }
      return result2;
    };
    var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
    var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
    var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
    var cssesc = function cssesc2(string3, options2) {
      options2 = merge3(options2, cssesc2.options);
      if (options2.quotes != "single" && options2.quotes != "double") {
        options2.quotes = "single";
      }
      var quote = options2.quotes == "double" ? '"' : "'";
      var isIdentifier2 = options2.isIdentifier;
      var firstChar = string3.charAt(0);
      var output = "";
      var counter = 0;
      var length = string3.length;
      while (counter < length) {
        var character = string3.charAt(counter++);
        var codePoint = character.charCodeAt();
        var value = void 0;
        if (codePoint < 32 || codePoint > 126) {
          if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
            var extra = string3.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
            } else {
              counter--;
            }
          }
          value = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else {
          if (options2.escapeEverything) {
            if (regexAnySingleEscape.test(character)) {
              value = "\\" + character;
            } else {
              value = "\\" + codePoint.toString(16).toUpperCase() + " ";
            }
          } else if (/[\t\n\f\r\x0B]/.test(character)) {
            value = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else if (character == "\\" || !isIdentifier2 && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier2 && regexSingleEscape.test(character)) {
            value = "\\" + character;
          } else {
            value = character;
          }
        }
        output += value;
      }
      if (isIdentifier2) {
        if (/^-[-\d]/.test(output)) {
          output = "\\-" + output.slice(1);
        } else if (/\d/.test(firstChar)) {
          output = "\\3" + firstChar + " " + output.slice(1);
        }
      }
      output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
        if ($1 && $1.length % 2) {
          return $0;
        }
        return ($1 || "") + $2;
      });
      if (!isIdentifier2 && options2.wrap) {
        return quote + output + quote;
      }
      return output;
    };
    cssesc.options = {
      "escapeEverything": false,
      "isIdentifier": false,
      "quotes": "single",
      "wrap": false
    };
    cssesc.version = "3.0.0";
    var cssesc_1 = cssesc;
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _cssesc = _interopRequireDefault2(cssesc_1);
      var _util = util2;
      var _node = _interopRequireDefault2(node$12.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var ClassName = function(_Node) {
        _inheritsLoose(ClassName2, _Node);
        function ClassName2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.CLASS;
          _this._constructed = true;
          return _this;
        }
        var _proto = ClassName2.prototype;
        _proto.valueToString = function valueToString() {
          return "." + _Node.prototype.valueToString.call(this);
        };
        _createClass(ClassName2, [{
          key: "value",
          get: function get() {
            return this._value;
          },
          set: function set2(v2) {
            if (this._constructed) {
              var escaped2 = (0, _cssesc["default"])(v2, {
                isIdentifier: true
              });
              if (escaped2 !== v2) {
                (0, _util.ensureObject)(this, "raws");
                this.raws.value = escaped2;
              } else if (this.raws) {
                delete this.raws.value;
              }
            }
            this._value = v2;
          }
        }]);
        return ClassName2;
      }(_node["default"]);
      exports3["default"] = ClassName;
      module3.exports = exports3.default;
    })(className$1, className$1.exports);
    var comment$2 = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _node = _interopRequireDefault2(node$12.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Comment2 = function(_Node) {
        _inheritsLoose(Comment3, _Node);
        function Comment3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.COMMENT;
          return _this;
        }
        return Comment3;
      }(_node["default"]);
      exports3["default"] = Comment2;
      module3.exports = exports3.default;
    })(comment$2, comment$2.exports);
    var id$1 = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _node = _interopRequireDefault2(node$12.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var ID2 = function(_Node) {
        _inheritsLoose(ID3, _Node);
        function ID3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.ID;
          return _this;
        }
        var _proto = ID3.prototype;
        _proto.valueToString = function valueToString() {
          return "#" + _Node.prototype.valueToString.call(this);
        };
        return ID3;
      }(_node["default"]);
      exports3["default"] = ID2;
      module3.exports = exports3.default;
    })(id$1, id$1.exports);
    var tag$1 = { exports: {} };
    var namespace = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _cssesc = _interopRequireDefault2(cssesc_1);
      var _util = util2;
      var _node = _interopRequireDefault2(node$12.exports);
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Namespace = function(_Node) {
        _inheritsLoose(Namespace2, _Node);
        function Namespace2() {
          return _Node.apply(this, arguments) || this;
        }
        var _proto = Namespace2.prototype;
        _proto.qualifiedName = function qualifiedName(value) {
          if (this.namespace) {
            return this.namespaceString + "|" + value;
          } else {
            return value;
          }
        };
        _proto.valueToString = function valueToString() {
          return this.qualifiedName(_Node.prototype.valueToString.call(this));
        };
        _createClass(Namespace2, [{
          key: "namespace",
          get: function get() {
            return this._namespace;
          },
          set: function set2(namespace2) {
            if (namespace2 === true || namespace2 === "*" || namespace2 === "&") {
              this._namespace = namespace2;
              if (this.raws) {
                delete this.raws.namespace;
              }
              return;
            }
            var escaped2 = (0, _cssesc["default"])(namespace2, {
              isIdentifier: true
            });
            this._namespace = namespace2;
            if (escaped2 !== namespace2) {
              (0, _util.ensureObject)(this, "raws");
              this.raws.namespace = escaped2;
            } else if (this.raws) {
              delete this.raws.namespace;
            }
          }
        }, {
          key: "ns",
          get: function get() {
            return this._namespace;
          },
          set: function set2(namespace2) {
            this.namespace = namespace2;
          }
        }, {
          key: "namespaceString",
          get: function get() {
            if (this.namespace) {
              var ns2 = this.stringifyProperty("namespace");
              if (ns2 === true) {
                return "";
              } else {
                return ns2;
              }
            } else {
              return "";
            }
          }
        }]);
        return Namespace2;
      }(_node["default"]);
      exports3["default"] = Namespace;
      module3.exports = exports3.default;
    })(namespace, namespace.exports);
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _namespace = _interopRequireDefault2(namespace.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Tag = function(_Namespace) {
        _inheritsLoose(Tag2, _Namespace);
        function Tag2(opts) {
          var _this;
          _this = _Namespace.call(this, opts) || this;
          _this.type = _types2.TAG;
          return _this;
        }
        return Tag2;
      }(_namespace["default"]);
      exports3["default"] = Tag;
      module3.exports = exports3.default;
    })(tag$1, tag$1.exports);
    var string$12 = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _node = _interopRequireDefault2(node$12.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var String2 = function(_Node) {
        _inheritsLoose(String3, _Node);
        function String3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.STRING;
          return _this;
        }
        return String3;
      }(_node["default"]);
      exports3["default"] = String2;
      module3.exports = exports3.default;
    })(string$12, string$12.exports);
    var pseudo$1 = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _container = _interopRequireDefault2(container.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Pseudo = function(_Container) {
        _inheritsLoose(Pseudo2, _Container);
        function Pseudo2(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types2.PSEUDO;
          return _this;
        }
        var _proto = Pseudo2.prototype;
        _proto.toString = function toString3() {
          var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
          return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join("");
        };
        return Pseudo2;
      }(_container["default"]);
      exports3["default"] = Pseudo;
      module3.exports = exports3.default;
    })(pseudo$1, pseudo$1.exports);
    var attribute$1 = {};
    var node2 = require$$0__default$12.deprecate;
    (function(exports3) {
      exports3.__esModule = true;
      exports3.unescapeValue = unescapeValue;
      exports3["default"] = void 0;
      var _cssesc = _interopRequireDefault2(cssesc_1);
      var _unesc2 = _interopRequireDefault2(unesc.exports);
      var _namespace = _interopRequireDefault2(namespace.exports);
      var _types2 = types2;
      var _CSSESC_QUOTE_OPTIONS;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var deprecate = node2;
      var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
      var warnOfDeprecatedValueAssignment = deprecate(function() {
      }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead.");
      var warnOfDeprecatedQuotedAssignment = deprecate(function() {
      }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
      var warnOfDeprecatedConstructor = deprecate(function() {
      }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
      function unescapeValue(value) {
        var deprecatedUsage = false;
        var quoteMark = null;
        var unescaped = value;
        var m3 = unescaped.match(WRAPPED_IN_QUOTES);
        if (m3) {
          quoteMark = m3[1];
          unescaped = m3[2];
        }
        unescaped = (0, _unesc2["default"])(unescaped);
        if (unescaped !== value) {
          deprecatedUsage = true;
        }
        return {
          deprecatedUsage,
          unescaped,
          quoteMark
        };
      }
      function handleDeprecatedContructorOpts(opts) {
        if (opts.quoteMark !== void 0) {
          return opts;
        }
        if (opts.value === void 0) {
          return opts;
        }
        warnOfDeprecatedConstructor();
        var _unescapeValue = unescapeValue(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
        if (!opts.raws) {
          opts.raws = {};
        }
        if (opts.raws.value === void 0) {
          opts.raws.value = opts.value;
        }
        opts.value = unescaped;
        opts.quoteMark = quoteMark;
        return opts;
      }
      var Attribute = function(_Namespace) {
        _inheritsLoose(Attribute2, _Namespace);
        function Attribute2(opts) {
          var _this;
          if (opts === void 0) {
            opts = {};
          }
          _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
          _this.type = _types2.ATTRIBUTE;
          _this.raws = _this.raws || {};
          Object.defineProperty(_this.raws, "unquoted", {
            get: deprecate(function() {
              return _this.value;
            }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
            set: deprecate(function() {
              return _this.value;
            }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
          });
          _this._constructed = true;
          return _this;
        }
        var _proto = Attribute2.prototype;
        _proto.getQuotedValue = function getQuotedValue(options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var quoteMark = this._determineQuoteMark(options2);
          var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
          var escaped2 = (0, _cssesc["default"])(this._value, cssescopts);
          return escaped2;
        };
        _proto._determineQuoteMark = function _determineQuoteMark(options2) {
          return options2.smart ? this.smartQuoteMark(options2) : this.preferredQuoteMark(options2);
        };
        _proto.setValue = function setValue(value, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          this._value = value;
          this._quoteMark = this._determineQuoteMark(options2);
          this._syncRawValue();
        };
        _proto.smartQuoteMark = function smartQuoteMark(options2) {
          var v2 = this.value;
          var numSingleQuotes = v2.replace(/[^']/g, "").length;
          var numDoubleQuotes = v2.replace(/[^"]/g, "").length;
          if (numSingleQuotes + numDoubleQuotes === 0) {
            var escaped2 = (0, _cssesc["default"])(v2, {
              isIdentifier: true
            });
            if (escaped2 === v2) {
              return Attribute2.NO_QUOTE;
            } else {
              var pref = this.preferredQuoteMark(options2);
              if (pref === Attribute2.NO_QUOTE) {
                var quote = this.quoteMark || options2.quoteMark || Attribute2.DOUBLE_QUOTE;
                var opts = CSSESC_QUOTE_OPTIONS[quote];
                var quoteValue = (0, _cssesc["default"])(v2, opts);
                if (quoteValue.length < escaped2.length) {
                  return quote;
                }
              }
              return pref;
            }
          } else if (numDoubleQuotes === numSingleQuotes) {
            return this.preferredQuoteMark(options2);
          } else if (numDoubleQuotes < numSingleQuotes) {
            return Attribute2.DOUBLE_QUOTE;
          } else {
            return Attribute2.SINGLE_QUOTE;
          }
        };
        _proto.preferredQuoteMark = function preferredQuoteMark(options2) {
          var quoteMark = options2.preferCurrentQuoteMark ? this.quoteMark : options2.quoteMark;
          if (quoteMark === void 0) {
            quoteMark = options2.preferCurrentQuoteMark ? options2.quoteMark : this.quoteMark;
          }
          if (quoteMark === void 0) {
            quoteMark = Attribute2.DOUBLE_QUOTE;
          }
          return quoteMark;
        };
        _proto._syncRawValue = function _syncRawValue() {
          var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
          if (rawValue === this._value) {
            if (this.raws) {
              delete this.raws.value;
            }
          } else {
            this.raws.value = rawValue;
          }
        };
        _proto._handleEscapes = function _handleEscapes(prop, value) {
          if (this._constructed) {
            var escaped2 = (0, _cssesc["default"])(value, {
              isIdentifier: true
            });
            if (escaped2 !== value) {
              this.raws[prop] = escaped2;
            } else {
              delete this.raws[prop];
            }
          }
        };
        _proto._spacesFor = function _spacesFor(name) {
          var attrSpaces = {
            before: "",
            after: ""
          };
          var spaces = this.spaces[name] || {};
          var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
          return Object.assign(attrSpaces, spaces, rawSpaces);
        };
        _proto._stringFor = function _stringFor(name, spaceName, concat2) {
          if (spaceName === void 0) {
            spaceName = name;
          }
          if (concat2 === void 0) {
            concat2 = defaultAttrConcat;
          }
          var attrSpaces = this._spacesFor(spaceName);
          return concat2(this.stringifyProperty(name), attrSpaces);
        };
        _proto.offsetOf = function offsetOf(name) {
          var count = 1;
          var attributeSpaces = this._spacesFor("attribute");
          count += attributeSpaces.before.length;
          if (name === "namespace" || name === "ns") {
            return this.namespace ? count : -1;
          }
          if (name === "attributeNS") {
            return count;
          }
          count += this.namespaceString.length;
          if (this.namespace) {
            count += 1;
          }
          if (name === "attribute") {
            return count;
          }
          count += this.stringifyProperty("attribute").length;
          count += attributeSpaces.after.length;
          var operatorSpaces = this._spacesFor("operator");
          count += operatorSpaces.before.length;
          var operator = this.stringifyProperty("operator");
          if (name === "operator") {
            return operator ? count : -1;
          }
          count += operator.length;
          count += operatorSpaces.after.length;
          var valueSpaces = this._spacesFor("value");
          count += valueSpaces.before.length;
          var value = this.stringifyProperty("value");
          if (name === "value") {
            return value ? count : -1;
          }
          count += value.length;
          count += valueSpaces.after.length;
          var insensitiveSpaces = this._spacesFor("insensitive");
          count += insensitiveSpaces.before.length;
          if (name === "insensitive") {
            return this.insensitive ? count : -1;
          }
          return -1;
        };
        _proto.toString = function toString3() {
          var _this2 = this;
          var selector2 = [this.rawSpaceBefore, "["];
          selector2.push(this._stringFor("qualifiedAttribute", "attribute"));
          if (this.operator && (this.value || this.value === "")) {
            selector2.push(this._stringFor("operator"));
            selector2.push(this._stringFor("value"));
            selector2.push(this._stringFor("insensitiveFlag", "insensitive", function(attrValue, attrSpaces) {
              if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
                attrSpaces.before = " ";
              }
              return defaultAttrConcat(attrValue, attrSpaces);
            }));
          }
          selector2.push("]");
          selector2.push(this.rawSpaceAfter);
          return selector2.join("");
        };
        _createClass(Attribute2, [{
          key: "quoted",
          get: function get() {
            var qm = this.quoteMark;
            return qm === "'" || qm === '"';
          },
          set: function set2(value) {
            warnOfDeprecatedQuotedAssignment();
          }
        }, {
          key: "quoteMark",
          get: function get() {
            return this._quoteMark;
          },
          set: function set2(quoteMark) {
            if (!this._constructed) {
              this._quoteMark = quoteMark;
              return;
            }
            if (this._quoteMark !== quoteMark) {
              this._quoteMark = quoteMark;
              this._syncRawValue();
            }
          }
        }, {
          key: "qualifiedAttribute",
          get: function get() {
            return this.qualifiedName(this.raws.attribute || this.attribute);
          }
        }, {
          key: "insensitiveFlag",
          get: function get() {
            return this.insensitive ? "i" : "";
          }
        }, {
          key: "value",
          get: function get() {
            return this._value;
          },
          set: function set2(v2) {
            if (this._constructed) {
              var _unescapeValue2 = unescapeValue(v2), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
              if (deprecatedUsage) {
                warnOfDeprecatedValueAssignment();
              }
              if (unescaped === this._value && quoteMark === this._quoteMark) {
                return;
              }
              this._value = unescaped;
              this._quoteMark = quoteMark;
              this._syncRawValue();
            } else {
              this._value = v2;
            }
          }
        }, {
          key: "attribute",
          get: function get() {
            return this._attribute;
          },
          set: function set2(name) {
            this._handleEscapes("attribute", name);
            this._attribute = name;
          }
        }]);
        return Attribute2;
      }(_namespace["default"]);
      exports3["default"] = Attribute;
      Attribute.NO_QUOTE = null;
      Attribute.SINGLE_QUOTE = "'";
      Attribute.DOUBLE_QUOTE = '"';
      var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
        "'": {
          quotes: "single",
          wrap: true
        },
        '"': {
          quotes: "double",
          wrap: true
        }
      }, _CSSESC_QUOTE_OPTIONS[null] = {
        isIdentifier: true
      }, _CSSESC_QUOTE_OPTIONS);
      function defaultAttrConcat(attrValue, attrSpaces) {
        return "" + attrSpaces.before + attrValue + attrSpaces.after;
      }
    })(attribute$1);
    var universal$1 = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _namespace = _interopRequireDefault2(namespace.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Universal = function(_Namespace) {
        _inheritsLoose(Universal2, _Namespace);
        function Universal2(opts) {
          var _this;
          _this = _Namespace.call(this, opts) || this;
          _this.type = _types2.UNIVERSAL;
          _this.value = "*";
          return _this;
        }
        return Universal2;
      }(_namespace["default"]);
      exports3["default"] = Universal;
      module3.exports = exports3.default;
    })(universal$1, universal$1.exports);
    var combinator$2 = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _node = _interopRequireDefault2(node$12.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Combinator = function(_Node) {
        _inheritsLoose(Combinator2, _Node);
        function Combinator2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.COMBINATOR;
          return _this;
        }
        return Combinator2;
      }(_node["default"]);
      exports3["default"] = Combinator;
      module3.exports = exports3.default;
    })(combinator$2, combinator$2.exports);
    var nesting$1 = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _node = _interopRequireDefault2(node$12.exports);
      var _types2 = types2;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      var Nesting = function(_Node) {
        _inheritsLoose(Nesting2, _Node);
        function Nesting2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.NESTING;
          _this.value = "&";
          return _this;
        }
        return Nesting2;
      }(_node["default"]);
      exports3["default"] = Nesting;
      module3.exports = exports3.default;
    })(nesting$1, nesting$1.exports);
    var sortAscending = { exports: {} };
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = sortAscending2;
      function sortAscending2(list2) {
        return list2.sort(function(a2, b2) {
          return a2 - b2;
        });
      }
      module3.exports = exports3.default;
    })(sortAscending, sortAscending.exports);
    var tokenize = {};
    var tokenTypes = {};
    tokenTypes.__esModule = true;
    tokenTypes.combinator = tokenTypes.word = tokenTypes.comment = tokenTypes.str = tokenTypes.tab = tokenTypes.newline = tokenTypes.feed = tokenTypes.cr = tokenTypes.backslash = tokenTypes.bang = tokenTypes.slash = tokenTypes.doubleQuote = tokenTypes.singleQuote = tokenTypes.space = tokenTypes.greaterThan = tokenTypes.pipe = tokenTypes.equals = tokenTypes.plus = tokenTypes.caret = tokenTypes.tilde = tokenTypes.dollar = tokenTypes.closeSquare = tokenTypes.openSquare = tokenTypes.closeParenthesis = tokenTypes.openParenthesis = tokenTypes.semicolon = tokenTypes.colon = tokenTypes.comma = tokenTypes.at = tokenTypes.asterisk = tokenTypes.ampersand = void 0;
    var ampersand = 38;
    tokenTypes.ampersand = ampersand;
    var asterisk = 42;
    tokenTypes.asterisk = asterisk;
    var at2 = 64;
    tokenTypes.at = at2;
    var comma = 44;
    tokenTypes.comma = comma;
    var colon = 58;
    tokenTypes.colon = colon;
    var semicolon = 59;
    tokenTypes.semicolon = semicolon;
    var openParenthesis = 40;
    tokenTypes.openParenthesis = openParenthesis;
    var closeParenthesis = 41;
    tokenTypes.closeParenthesis = closeParenthesis;
    var openSquare = 91;
    tokenTypes.openSquare = openSquare;
    var closeSquare = 93;
    tokenTypes.closeSquare = closeSquare;
    var dollar = 36;
    tokenTypes.dollar = dollar;
    var tilde = 126;
    tokenTypes.tilde = tilde;
    var caret = 94;
    tokenTypes.caret = caret;
    var plus = 43;
    tokenTypes.plus = plus;
    var equals2 = 61;
    tokenTypes.equals = equals2;
    var pipe = 124;
    tokenTypes.pipe = pipe;
    var greaterThan = 62;
    tokenTypes.greaterThan = greaterThan;
    var space = 32;
    tokenTypes.space = space;
    var singleQuote = 39;
    tokenTypes.singleQuote = singleQuote;
    var doubleQuote = 34;
    tokenTypes.doubleQuote = doubleQuote;
    var slash2 = 47;
    tokenTypes.slash = slash2;
    var bang = 33;
    tokenTypes.bang = bang;
    var backslash2 = 92;
    tokenTypes.backslash = backslash2;
    var cr2 = 13;
    tokenTypes.cr = cr2;
    var feed = 12;
    tokenTypes.feed = feed;
    var newline = 10;
    tokenTypes.newline = newline;
    var tab = 9;
    tokenTypes.tab = tab;
    var str = singleQuote;
    tokenTypes.str = str;
    var comment$1 = -1;
    tokenTypes.comment = comment$1;
    var word = -2;
    tokenTypes.word = word;
    var combinator$1 = -3;
    tokenTypes.combinator = combinator$1;
    (function(exports3) {
      exports3.__esModule = true;
      exports3["default"] = tokenize2;
      exports3.FIELDS = void 0;
      var t = _interopRequireWildcard2(tokenTypes);
      var _unescapable, _wordDelimiters;
      function _getRequireWildcardCache() {
        if (typeof WeakMap !== "function")
          return null;
        var cache2 = new WeakMap();
        _getRequireWildcardCache = function _getRequireWildcardCache2() {
          return cache2;
        };
        return cache2;
      }
      function _interopRequireWildcard2(obj) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache();
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
      var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
      var hex = {};
      var hexChars = "0123456789abcdefABCDEF";
      for (var i2 = 0; i2 < hexChars.length; i2++) {
        hex[hexChars.charCodeAt(i2)] = true;
      }
      function consumeWord(css, start) {
        var next = start;
        var code;
        do {
          code = css.charCodeAt(next);
          if (wordDelimiters[code]) {
            return next - 1;
          } else if (code === t.backslash) {
            next = consumeEscape(css, next) + 1;
          } else {
            next++;
          }
        } while (next < css.length);
        return next - 1;
      }
      function consumeEscape(css, start) {
        var next = start;
        var code = css.charCodeAt(next + 1);
        if (unescapable[code])
          ;
        else if (hex[code]) {
          var hexDigits = 0;
          do {
            next++;
            hexDigits++;
            code = css.charCodeAt(next + 1);
          } while (hex[code] && hexDigits < 6);
          if (hexDigits < 6 && code === t.space) {
            next++;
          }
        } else {
          next++;
        }
        return next;
      }
      var FIELDS = {
        TYPE: 0,
        START_LINE: 1,
        START_COL: 2,
        END_LINE: 3,
        END_COL: 4,
        START_POS: 5,
        END_POS: 6
      };
      exports3.FIELDS = FIELDS;
      function tokenize2(input) {
        var tokens = [];
        var css = input.css.valueOf();
        var _css = css, length = _css.length;
        var offset2 = -1;
        var line = 1;
        var start = 0;
        var end = 0;
        var code, content2, endColumn, endLine, escaped2, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;
        function unclosed(what, fix) {
          if (input.safe) {
            css += fix;
            next = css.length - 1;
          } else {
            throw input.error("Unclosed " + what, line, start - offset2, start);
          }
        }
        while (start < length) {
          code = css.charCodeAt(start);
          if (code === t.newline) {
            offset2 = start;
            line += 1;
          }
          switch (code) {
            case t.space:
            case t.tab:
            case t.newline:
            case t.cr:
            case t.feed:
              next = start;
              do {
                next += 1;
                code = css.charCodeAt(next);
                if (code === t.newline) {
                  offset2 = next;
                  line += 1;
                }
              } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);
              tokenType = t.space;
              endLine = line;
              endColumn = next - offset2 - 1;
              end = next;
              break;
            case t.plus:
            case t.greaterThan:
            case t.tilde:
            case t.pipe:
              next = start;
              do {
                next += 1;
                code = css.charCodeAt(next);
              } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);
              tokenType = t.combinator;
              endLine = line;
              endColumn = start - offset2;
              end = next;
              break;
            case t.asterisk:
            case t.ampersand:
            case t.bang:
            case t.comma:
            case t.equals:
            case t.dollar:
            case t.caret:
            case t.openSquare:
            case t.closeSquare:
            case t.colon:
            case t.semicolon:
            case t.openParenthesis:
            case t.closeParenthesis:
              next = start;
              tokenType = code;
              endLine = line;
              endColumn = start - offset2;
              end = next + 1;
              break;
            case t.singleQuote:
            case t.doubleQuote:
              quote = code === t.singleQuote ? "'" : '"';
              next = start;
              do {
                escaped2 = false;
                next = css.indexOf(quote, next + 1);
                if (next === -1) {
                  unclosed("quote", quote);
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === t.backslash) {
                  escapePos -= 1;
                  escaped2 = !escaped2;
                }
              } while (escaped2);
              tokenType = t.str;
              endLine = line;
              endColumn = start - offset2;
              end = next + 1;
              break;
            default:
              if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
                next = css.indexOf("*/", start + 2) + 1;
                if (next === 0) {
                  unclosed("comment", "*/");
                }
                content2 = css.slice(start, next + 1);
                lines = content2.split("\n");
                last = lines.length - 1;
                if (last > 0) {
                  nextLine = line + last;
                  nextOffset = next - lines[last].length;
                } else {
                  nextLine = line;
                  nextOffset = offset2;
                }
                tokenType = t.comment;
                line = nextLine;
                endLine = nextLine;
                endColumn = next - nextOffset;
              } else if (code === t.slash) {
                next = start;
                tokenType = code;
                endLine = line;
                endColumn = start - offset2;
                end = next + 1;
              } else {
                next = consumeWord(css, start);
                tokenType = t.word;
                endLine = line;
                endColumn = next - offset2;
              }
              end = next + 1;
              break;
          }
          tokens.push([
            tokenType,
            line,
            start - offset2,
            endLine,
            endColumn,
            start,
            end
          ]);
          if (nextOffset) {
            offset2 = nextOffset;
            nextOffset = null;
          }
          start = end;
        }
        return tokens;
      }
    })(tokenize);
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _root2 = _interopRequireDefault2(root$1.exports);
      var _selector2 = _interopRequireDefault2(selector$1.exports);
      var _className2 = _interopRequireDefault2(className$1.exports);
      var _comment2 = _interopRequireDefault2(comment$2.exports);
      var _id2 = _interopRequireDefault2(id$1.exports);
      var _tag2 = _interopRequireDefault2(tag$1.exports);
      var _string2 = _interopRequireDefault2(string$12.exports);
      var _pseudo2 = _interopRequireDefault2(pseudo$1.exports);
      var _attribute2 = _interopRequireWildcard2(attribute$1);
      var _universal2 = _interopRequireDefault2(universal$1.exports);
      var _combinator2 = _interopRequireDefault2(combinator$2.exports);
      var _nesting2 = _interopRequireDefault2(nesting$1.exports);
      var _sortAscending = _interopRequireDefault2(sortAscending.exports);
      var _tokenize = _interopRequireWildcard2(tokenize);
      var tokens = _interopRequireWildcard2(tokenTypes);
      var types$12 = _interopRequireWildcard2(types2);
      var _util = util2;
      var _WHITESPACE_TOKENS, _Object$assign;
      function _getRequireWildcardCache() {
        if (typeof WeakMap !== "function")
          return null;
        var cache2 = new WeakMap();
        _getRequireWildcardCache = function _getRequireWildcardCache2() {
          return cache2;
        };
        return cache2;
      }
      function _interopRequireWildcard2(obj) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache();
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
      var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
      function tokenStart(token) {
        return {
          line: token[_tokenize.FIELDS.START_LINE],
          column: token[_tokenize.FIELDS.START_COL]
        };
      }
      function tokenEnd(token) {
        return {
          line: token[_tokenize.FIELDS.END_LINE],
          column: token[_tokenize.FIELDS.END_COL]
        };
      }
      function getSource2(startLine, startColumn, endLine, endColumn) {
        return {
          start: {
            line: startLine,
            column: startColumn
          },
          end: {
            line: endLine,
            column: endColumn
          }
        };
      }
      function getTokenSource(token) {
        return getSource2(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
      }
      function getTokenSourceSpan(startToken, endToken) {
        if (!startToken) {
          return void 0;
        }
        return getSource2(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
      }
      function unescapeProp(node3, prop) {
        var value = node3[prop];
        if (typeof value !== "string") {
          return;
        }
        if (value.indexOf("\\") !== -1) {
          (0, _util.ensureObject)(node3, "raws");
          node3[prop] = (0, _util.unesc)(value);
          if (node3.raws[prop] === void 0) {
            node3.raws[prop] = value;
          }
        }
        return node3;
      }
      function indexesOf(array2, item) {
        var i2 = -1;
        var indexes = [];
        while ((i2 = array2.indexOf(item, i2 + 1)) !== -1) {
          indexes.push(i2);
        }
        return indexes;
      }
      function uniqs() {
        var list2 = Array.prototype.concat.apply([], arguments);
        return list2.filter(function(item, i2) {
          return i2 === list2.indexOf(item);
        });
      }
      var Parser3 = function() {
        function Parser4(rule, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          this.rule = rule;
          this.options = Object.assign({
            lossy: false,
            safe: false
          }, options2);
          this.position = 0;
          this.css = typeof this.rule === "string" ? this.rule : this.rule.selector;
          this.tokens = (0, _tokenize["default"])({
            css: this.css,
            error: this._errorGenerator(),
            safe: this.options.safe
          });
          var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
          this.root = new _root2["default"]({
            source: rootSource
          });
          this.root.errorGenerator = this._errorGenerator();
          var selector2 = new _selector2["default"]({
            source: {
              start: {
                line: 1,
                column: 1
              }
            }
          });
          this.root.append(selector2);
          this.current = selector2;
          this.loop();
        }
        var _proto = Parser4.prototype;
        _proto._errorGenerator = function _errorGenerator() {
          var _this = this;
          return function(message, errorOptions) {
            if (typeof _this.rule === "string") {
              return new Error(message);
            }
            return _this.rule.error(message, errorOptions);
          };
        };
        _proto.attribute = function attribute2() {
          var attr = [];
          var startingToken = this.currToken;
          this.position++;
          while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            attr.push(this.currToken);
            this.position++;
          }
          if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
          }
          var len = attr.length;
          var node3 = {
            source: getSource2(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
            sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
          };
          if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
            return this.expected("attribute", attr[0][_tokenize.FIELDS.START_POS]);
          }
          var pos = 0;
          var spaceBefore = "";
          var commentBefore = "";
          var lastAdded = null;
          var spaceAfterMeaningfulToken = false;
          while (pos < len) {
            var token = attr[pos];
            var content2 = this.content(token);
            var next = attr[pos + 1];
            switch (token[_tokenize.FIELDS.TYPE]) {
              case tokens.space:
                spaceAfterMeaningfulToken = true;
                if (this.options.lossy) {
                  break;
                }
                if (lastAdded) {
                  (0, _util.ensureObject)(node3, "spaces", lastAdded);
                  var prevContent = node3.spaces[lastAdded].after || "";
                  node3.spaces[lastAdded].after = prevContent + content2;
                  var existingComment = (0, _util.getProp)(node3, "raws", "spaces", lastAdded, "after") || null;
                  if (existingComment) {
                    node3.raws.spaces[lastAdded].after = existingComment + content2;
                  }
                } else {
                  spaceBefore = spaceBefore + content2;
                  commentBefore = commentBefore + content2;
                }
                break;
              case tokens.asterisk:
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node3.operator = content2;
                  lastAdded = "operator";
                } else if ((!node3.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node3, "spaces", "attribute");
                    node3.spaces.attribute.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node3, "raws", "spaces", "attribute");
                    node3.raws.spaces.attribute.before = spaceBefore;
                    commentBefore = "";
                  }
                  node3.namespace = (node3.namespace || "") + content2;
                  var rawValue = (0, _util.getProp)(node3, "raws", "namespace") || null;
                  if (rawValue) {
                    node3.raws.namespace += content2;
                  }
                  lastAdded = "namespace";
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.dollar:
                if (lastAdded === "value") {
                  var oldRawValue = (0, _util.getProp)(node3, "raws", "value");
                  node3.value += "$";
                  if (oldRawValue) {
                    node3.raws.value = oldRawValue + "$";
                  }
                  break;
                }
              case tokens.caret:
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node3.operator = content2;
                  lastAdded = "operator";
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.combinator:
                if (content2 === "~" && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node3.operator = content2;
                  lastAdded = "operator";
                }
                if (content2 !== "|") {
                  spaceAfterMeaningfulToken = false;
                  break;
                }
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node3.operator = content2;
                  lastAdded = "operator";
                } else if (!node3.namespace && !node3.attribute) {
                  node3.namespace = true;
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.word:
                if (next && this.content(next) === "|" && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && !node3.operator && !node3.namespace) {
                  node3.namespace = content2;
                  lastAdded = "namespace";
                } else if (!node3.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node3, "spaces", "attribute");
                    node3.spaces.attribute.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node3, "raws", "spaces", "attribute");
                    node3.raws.spaces.attribute.before = commentBefore;
                    commentBefore = "";
                  }
                  node3.attribute = (node3.attribute || "") + content2;
                  var _rawValue = (0, _util.getProp)(node3, "raws", "attribute") || null;
                  if (_rawValue) {
                    node3.raws.attribute += content2;
                  }
                  lastAdded = "attribute";
                } else if (!node3.value && node3.value !== "" || lastAdded === "value" && !spaceAfterMeaningfulToken) {
                  var _unescaped = (0, _util.unesc)(content2);
                  var _oldRawValue = (0, _util.getProp)(node3, "raws", "value") || "";
                  var oldValue = node3.value || "";
                  node3.value = oldValue + _unescaped;
                  node3.quoteMark = null;
                  if (_unescaped !== content2 || _oldRawValue) {
                    (0, _util.ensureObject)(node3, "raws");
                    node3.raws.value = (_oldRawValue || oldValue) + content2;
                  }
                  lastAdded = "value";
                } else {
                  var insensitive = content2 === "i" || content2 === "I";
                  if ((node3.value || node3.value === "") && (node3.quoteMark || spaceAfterMeaningfulToken)) {
                    node3.insensitive = insensitive;
                    if (!insensitive || content2 === "I") {
                      (0, _util.ensureObject)(node3, "raws");
                      node3.raws.insensitiveFlag = content2;
                    }
                    lastAdded = "insensitive";
                    if (spaceBefore) {
                      (0, _util.ensureObject)(node3, "spaces", "insensitive");
                      node3.spaces.insensitive.before = spaceBefore;
                      spaceBefore = "";
                    }
                    if (commentBefore) {
                      (0, _util.ensureObject)(node3, "raws", "spaces", "insensitive");
                      node3.raws.spaces.insensitive.before = commentBefore;
                      commentBefore = "";
                    }
                  } else if (node3.value || node3.value === "") {
                    lastAdded = "value";
                    node3.value += content2;
                    if (node3.raws.value) {
                      node3.raws.value += content2;
                    }
                  }
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.str:
                if (!node3.attribute || !node3.operator) {
                  return this.error("Expected an attribute followed by an operator preceding the string.", {
                    index: token[_tokenize.FIELDS.START_POS]
                  });
                }
                var _unescapeValue = (0, _attribute2.unescapeValue)(content2), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
                node3.value = unescaped;
                node3.quoteMark = quoteMark;
                lastAdded = "value";
                (0, _util.ensureObject)(node3, "raws");
                node3.raws.value = content2;
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.equals:
                if (!node3.attribute) {
                  return this.expected("attribute", token[_tokenize.FIELDS.START_POS], content2);
                }
                if (node3.value) {
                  return this.error('Unexpected "=" found; an operator was already defined.', {
                    index: token[_tokenize.FIELDS.START_POS]
                  });
                }
                node3.operator = node3.operator ? node3.operator + content2 : content2;
                lastAdded = "operator";
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.comment:
                if (lastAdded) {
                  if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === "insensitive") {
                    var lastComment = (0, _util.getProp)(node3, "spaces", lastAdded, "after") || "";
                    var rawLastComment = (0, _util.getProp)(node3, "raws", "spaces", lastAdded, "after") || lastComment;
                    (0, _util.ensureObject)(node3, "raws", "spaces", lastAdded);
                    node3.raws.spaces[lastAdded].after = rawLastComment + content2;
                  } else {
                    var lastValue = node3[lastAdded] || "";
                    var rawLastValue = (0, _util.getProp)(node3, "raws", lastAdded) || lastValue;
                    (0, _util.ensureObject)(node3, "raws");
                    node3.raws[lastAdded] = rawLastValue + content2;
                  }
                } else {
                  commentBefore = commentBefore + content2;
                }
                break;
              default:
                return this.error('Unexpected "' + content2 + '" found.', {
                  index: token[_tokenize.FIELDS.START_POS]
                });
            }
            pos++;
          }
          unescapeProp(node3, "attribute");
          unescapeProp(node3, "namespace");
          this.newNode(new _attribute2["default"](node3));
          this.position++;
        };
        _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
          if (stopPosition < 0) {
            stopPosition = this.tokens.length;
          }
          var startPosition = this.position;
          var nodes = [];
          var space2 = "";
          var lastComment = void 0;
          do {
            if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
              if (!this.options.lossy) {
                space2 += this.content();
              }
            } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
              var spaces = {};
              if (space2) {
                spaces.before = space2;
                space2 = "";
              }
              lastComment = new _comment2["default"]({
                value: this.content(),
                source: getTokenSource(this.currToken),
                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
                spaces
              });
              nodes.push(lastComment);
            }
          } while (++this.position < stopPosition);
          if (space2) {
            if (lastComment) {
              lastComment.spaces.after = space2;
            } else if (!this.options.lossy) {
              var firstToken = this.tokens[startPosition];
              var lastToken = this.tokens[this.position - 1];
              nodes.push(new _string2["default"]({
                value: "",
                source: getSource2(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
                sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
                spaces: {
                  before: space2,
                  after: ""
                }
              }));
            }
          }
          return nodes;
        };
        _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
          var _this2 = this;
          if (requiredSpace === void 0) {
            requiredSpace = false;
          }
          var space2 = "";
          var rawSpace = "";
          nodes.forEach(function(n3) {
            var spaceBefore = _this2.lossySpace(n3.spaces.before, requiredSpace);
            var rawSpaceBefore = _this2.lossySpace(n3.rawSpaceBefore, requiredSpace);
            space2 += spaceBefore + _this2.lossySpace(n3.spaces.after, requiredSpace && spaceBefore.length === 0);
            rawSpace += spaceBefore + n3.value + _this2.lossySpace(n3.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
          });
          if (rawSpace === space2) {
            rawSpace = void 0;
          }
          var result2 = {
            space: space2,
            rawSpace
          };
          return result2;
        };
        _proto.isNamedCombinator = function isNamedCombinator(position) {
          if (position === void 0) {
            position = this.position;
          }
          return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
        };
        _proto.namedCombinator = function namedCombinator() {
          if (this.isNamedCombinator()) {
            var nameRaw = this.content(this.tokens[this.position + 1]);
            var name = (0, _util.unesc)(nameRaw).toLowerCase();
            var raws = {};
            if (name !== nameRaw) {
              raws.value = "/" + nameRaw + "/";
            }
            var node3 = new _combinator2["default"]({
              value: "/" + name + "/",
              source: getSource2(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
              raws
            });
            this.position = this.position + 3;
            return node3;
          } else {
            this.unexpected();
          }
        };
        _proto.combinator = function combinator2() {
          var _this3 = this;
          if (this.content() === "|") {
            return this.namespace();
          }
          var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
          if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
            var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
            if (nodes.length > 0) {
              var last = this.current.last;
              if (last) {
                var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space2 = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
                if (rawSpace !== void 0) {
                  last.rawSpaceAfter += rawSpace;
                }
                last.spaces.after += space2;
              } else {
                nodes.forEach(function(n3) {
                  return _this3.newNode(n3);
                });
              }
            }
            return;
          }
          var firstToken = this.currToken;
          var spaceOrDescendantSelectorNodes = void 0;
          if (nextSigTokenPos > this.position) {
            spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
          }
          var node3;
          if (this.isNamedCombinator()) {
            node3 = this.namedCombinator();
          } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
            node3 = new _combinator2["default"]({
              value: this.content(),
              source: getTokenSource(this.currToken),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
            });
            this.position++;
          } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]])
            ;
          else if (!spaceOrDescendantSelectorNodes) {
            this.unexpected();
          }
          if (node3) {
            if (spaceOrDescendantSelectorNodes) {
              var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
              node3.spaces.before = _space;
              node3.rawSpaceBefore = _rawSpace;
            }
          } else {
            var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
            if (!_rawSpace2) {
              _rawSpace2 = _space2;
            }
            var spaces = {};
            var raws = {
              spaces: {}
            };
            if (_space2.endsWith(" ") && _rawSpace2.endsWith(" ")) {
              spaces.before = _space2.slice(0, _space2.length - 1);
              raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
            } else if (_space2.startsWith(" ") && _rawSpace2.startsWith(" ")) {
              spaces.after = _space2.slice(1);
              raws.spaces.after = _rawSpace2.slice(1);
            } else {
              raws.value = _rawSpace2;
            }
            node3 = new _combinator2["default"]({
              value: " ",
              source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
              sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
              spaces,
              raws
            });
          }
          if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
            node3.spaces.after = this.optionalSpace(this.content());
            this.position++;
          }
          return this.newNode(node3);
        };
        _proto.comma = function comma2() {
          if (this.position === this.tokens.length - 1) {
            this.root.trailingComma = true;
            this.position++;
            return;
          }
          this.current._inferEndPosition();
          var selector2 = new _selector2["default"]({
            source: {
              start: tokenStart(this.tokens[this.position + 1])
            }
          });
          this.current.parent.append(selector2);
          this.current = selector2;
          this.position++;
        };
        _proto.comment = function comment2() {
          var current = this.currToken;
          this.newNode(new _comment2["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.error = function error2(message, opts) {
          throw this.root.error(message, opts);
        };
        _proto.missingBackslash = function missingBackslash() {
          return this.error("Expected a backslash preceding the semicolon.", {
            index: this.currToken[_tokenize.FIELDS.START_POS]
          });
        };
        _proto.missingParenthesis = function missingParenthesis() {
          return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.missingSquareBracket = function missingSquareBracket() {
          return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.unexpected = function unexpected() {
          return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.namespace = function namespace2() {
          var before = this.prevToken && this.content(this.prevToken) || true;
          if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.position++;
            return this.word(before);
          } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
            this.position++;
            return this.universal(before);
          }
        };
        _proto.nesting = function nesting2() {
          if (this.nextToken) {
            var nextContent = this.content(this.nextToken);
            if (nextContent === "|") {
              this.position++;
              return;
            }
          }
          var current = this.currToken;
          this.newNode(new _nesting2["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.parentheses = function parentheses() {
          var last = this.current.last;
          var unbalanced = 1;
          this.position++;
          if (last && last.type === types$12.PSEUDO) {
            var selector2 = new _selector2["default"]({
              source: {
                start: tokenStart(this.tokens[this.position - 1])
              }
            });
            var cache2 = this.current;
            last.append(selector2);
            this.current = selector2;
            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }
              if (unbalanced) {
                this.parse();
              } else {
                this.current.source.end = tokenEnd(this.currToken);
                this.current.parent.source.end = tokenEnd(this.currToken);
                this.position++;
              }
            }
            this.current = cache2;
          } else {
            var parenStart = this.currToken;
            var parenValue = "(";
            var parenEnd;
            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }
              parenEnd = this.currToken;
              parenValue += this.parseParenthesisToken(this.currToken);
              this.position++;
            }
            if (last) {
              last.appendToPropertyAndEscape("value", parenValue, parenValue);
            } else {
              this.newNode(new _string2["default"]({
                value: parenValue,
                source: getSource2(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
                sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
              }));
            }
          }
          if (unbalanced) {
            return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };
        _proto.pseudo = function pseudo2() {
          var _this4 = this;
          var pseudoStr = "";
          var startingToken = this.currToken;
          while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
            pseudoStr += this.content();
            this.position++;
          }
          if (!this.currToken) {
            return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
          }
          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.splitWord(false, function(first2, length) {
              pseudoStr += first2;
              _this4.newNode(new _pseudo2["default"]({
                value: pseudoStr,
                source: getTokenSourceSpan(startingToken, _this4.currToken),
                sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
              }));
              if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                _this4.error("Misplaced parenthesis.", {
                  index: _this4.nextToken[_tokenize.FIELDS.START_POS]
                });
              }
            });
          } else {
            return this.expected(["pseudo-class", "pseudo-element"], this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };
        _proto.space = function space2() {
          var content2 = this.content();
          if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function(node3) {
            return node3.type === "comment";
          })) {
            this.spaces = this.optionalSpace(content2);
            this.position++;
          } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            this.current.last.spaces.after = this.optionalSpace(content2);
            this.position++;
          } else {
            this.combinator();
          }
        };
        _proto.string = function string3() {
          var current = this.currToken;
          this.newNode(new _string2["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.universal = function universal2(namespace2) {
          var nextToken = this.nextToken;
          if (nextToken && this.content(nextToken) === "|") {
            this.position++;
            return this.namespace();
          }
          var current = this.currToken;
          this.newNode(new _universal2["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }), namespace2);
          this.position++;
        };
        _proto.splitWord = function splitWord(namespace2, firstCallback) {
          var _this5 = this;
          var nextToken = this.nextToken;
          var word2 = this.content();
          while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
            this.position++;
            var current = this.content();
            word2 += current;
            if (current.lastIndexOf("\\") === current.length - 1) {
              var next = this.nextToken;
              if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
                word2 += this.requiredSpace(this.content(next));
                this.position++;
              }
            }
            nextToken = this.nextToken;
          }
          var hasClass = indexesOf(word2, ".").filter(function(i2) {
            return word2[i2 - 1] !== "\\";
          });
          var hasId = indexesOf(word2, "#").filter(function(i2) {
            return word2[i2 - 1] !== "\\";
          });
          var interpolations = indexesOf(word2, "#{");
          if (interpolations.length) {
            hasId = hasId.filter(function(hashIndex) {
              return !~interpolations.indexOf(hashIndex);
            });
          }
          var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
          indices.forEach(function(ind, i2) {
            var index3 = indices[i2 + 1] || word2.length;
            var value = word2.slice(ind, index3);
            if (i2 === 0 && firstCallback) {
              return firstCallback.call(_this5, value, indices.length);
            }
            var node3;
            var current2 = _this5.currToken;
            var sourceIndex = current2[_tokenize.FIELDS.START_POS] + indices[i2];
            var source2 = getSource2(current2[1], current2[2] + ind, current2[3], current2[2] + (index3 - 1));
            if (~hasClass.indexOf(ind)) {
              var classNameOpts = {
                value: value.slice(1),
                source: source2,
                sourceIndex
              };
              node3 = new _className2["default"](unescapeProp(classNameOpts, "value"));
            } else if (~hasId.indexOf(ind)) {
              var idOpts = {
                value: value.slice(1),
                source: source2,
                sourceIndex
              };
              node3 = new _id2["default"](unescapeProp(idOpts, "value"));
            } else {
              var tagOpts = {
                value,
                source: source2,
                sourceIndex
              };
              unescapeProp(tagOpts, "value");
              node3 = new _tag2["default"](tagOpts);
            }
            _this5.newNode(node3, namespace2);
            namespace2 = null;
          });
          this.position++;
        };
        _proto.word = function word2(namespace2) {
          var nextToken = this.nextToken;
          if (nextToken && this.content(nextToken) === "|") {
            this.position++;
            return this.namespace();
          }
          return this.splitWord(namespace2);
        };
        _proto.loop = function loop2() {
          while (this.position < this.tokens.length) {
            this.parse(true);
          }
          this.current._inferEndPosition();
          return this.root;
        };
        _proto.parse = function parse3(throwOnParenthesis) {
          switch (this.currToken[_tokenize.FIELDS.TYPE]) {
            case tokens.space:
              this.space();
              break;
            case tokens.comment:
              this.comment();
              break;
            case tokens.openParenthesis:
              this.parentheses();
              break;
            case tokens.closeParenthesis:
              if (throwOnParenthesis) {
                this.missingParenthesis();
              }
              break;
            case tokens.openSquare:
              this.attribute();
              break;
            case tokens.dollar:
            case tokens.caret:
            case tokens.equals:
            case tokens.word:
              this.word();
              break;
            case tokens.colon:
              this.pseudo();
              break;
            case tokens.comma:
              this.comma();
              break;
            case tokens.asterisk:
              this.universal();
              break;
            case tokens.ampersand:
              this.nesting();
              break;
            case tokens.slash:
            case tokens.combinator:
              this.combinator();
              break;
            case tokens.str:
              this.string();
              break;
            case tokens.closeSquare:
              this.missingSquareBracket();
            case tokens.semicolon:
              this.missingBackslash();
            default:
              this.unexpected();
          }
        };
        _proto.expected = function expected(description, index3, found) {
          if (Array.isArray(description)) {
            var last = description.pop();
            description = description.join(", ") + " or " + last;
          }
          var an2 = /^[aeiou]/.test(description[0]) ? "an" : "a";
          if (!found) {
            return this.error("Expected " + an2 + " " + description + ".", {
              index: index3
            });
          }
          return this.error("Expected " + an2 + " " + description + ', found "' + found + '" instead.', {
            index: index3
          });
        };
        _proto.requiredSpace = function requiredSpace(space2) {
          return this.options.lossy ? " " : space2;
        };
        _proto.optionalSpace = function optionalSpace(space2) {
          return this.options.lossy ? "" : space2;
        };
        _proto.lossySpace = function lossySpace(space2, required) {
          if (this.options.lossy) {
            return required ? " " : "";
          } else {
            return space2;
          }
        };
        _proto.parseParenthesisToken = function parseParenthesisToken(token) {
          var content2 = this.content(token);
          if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
            return this.requiredSpace(content2);
          } else {
            return content2;
          }
        };
        _proto.newNode = function newNode(node3, namespace2) {
          if (namespace2) {
            if (/^ +$/.test(namespace2)) {
              if (!this.options.lossy) {
                this.spaces = (this.spaces || "") + namespace2;
              }
              namespace2 = true;
            }
            node3.namespace = namespace2;
            unescapeProp(node3, "namespace");
          }
          if (this.spaces) {
            node3.spaces.before = this.spaces;
            this.spaces = "";
          }
          return this.current.append(node3);
        };
        _proto.content = function content2(token) {
          if (token === void 0) {
            token = this.currToken;
          }
          return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
        };
        _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
          if (startPosition === void 0) {
            startPosition = this.position + 1;
          }
          var searchPosition = startPosition;
          while (searchPosition < this.tokens.length) {
            if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
              searchPosition++;
              continue;
            } else {
              return searchPosition;
            }
          }
          return -1;
        };
        _createClass(Parser4, [{
          key: "currToken",
          get: function get() {
            return this.tokens[this.position];
          }
        }, {
          key: "nextToken",
          get: function get() {
            return this.tokens[this.position + 1];
          }
        }, {
          key: "prevToken",
          get: function get() {
            return this.tokens[this.position - 1];
          }
        }]);
        return Parser4;
      }();
      exports3["default"] = Parser3;
      module3.exports = exports3.default;
    })(parser2, parser2.exports);
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _parser3 = _interopRequireDefault2(parser2.exports);
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var Processor = function() {
        function Processor2(func, options2) {
          this.func = func || function noop2() {
          };
          this.funcRes = null;
          this.options = options2;
        }
        var _proto = Processor2.prototype;
        _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var merged = Object.assign({}, this.options, options2);
          if (merged.updateSelector === false) {
            return false;
          } else {
            return typeof rule !== "string";
          }
        };
        _proto._isLossy = function _isLossy(options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var merged = Object.assign({}, this.options, options2);
          if (merged.lossless === false) {
            return true;
          } else {
            return false;
          }
        };
        _proto._root = function _root2(rule, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var parser3 = new _parser3["default"](rule, this._parseOptions(options2));
          return parser3.root;
        };
        _proto._parseOptions = function _parseOptions(options2) {
          return {
            lossy: this._isLossy(options2)
          };
        };
        _proto._run = function _run(rule, options2) {
          var _this = this;
          if (options2 === void 0) {
            options2 = {};
          }
          return new Promise(function(resolve2, reject) {
            try {
              var root2 = _this._root(rule, options2);
              Promise.resolve(_this.func(root2)).then(function(transform2) {
                var string3 = void 0;
                if (_this._shouldUpdateSelector(rule, options2)) {
                  string3 = root2.toString();
                  rule.selector = string3;
                }
                return {
                  transform: transform2,
                  root: root2,
                  string: string3
                };
              }).then(resolve2, reject);
            } catch (e2) {
              reject(e2);
              return;
            }
          });
        };
        _proto._runSync = function _runSync(rule, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var root2 = this._root(rule, options2);
          var transform2 = this.func(root2);
          if (transform2 && typeof transform2.then === "function") {
            throw new Error("Selector processor returned a promise to a synchronous call.");
          }
          var string3 = void 0;
          if (options2.updateSelector && typeof rule !== "string") {
            string3 = root2.toString();
            rule.selector = string3;
          }
          return {
            transform: transform2,
            root: root2,
            string: string3
          };
        };
        _proto.ast = function ast(rule, options2) {
          return this._run(rule, options2).then(function(result2) {
            return result2.root;
          });
        };
        _proto.astSync = function astSync(rule, options2) {
          return this._runSync(rule, options2).root;
        };
        _proto.transform = function transform2(rule, options2) {
          return this._run(rule, options2).then(function(result2) {
            return result2.transform;
          });
        };
        _proto.transformSync = function transformSync(rule, options2) {
          return this._runSync(rule, options2).transform;
        };
        _proto.process = function process2(rule, options2) {
          return this._run(rule, options2).then(function(result2) {
            return result2.string || result2.root.toString();
          });
        };
        _proto.processSync = function processSync(rule, options2) {
          var result2 = this._runSync(rule, options2);
          return result2.string || result2.root.toString();
        };
        return Processor2;
      }();
      exports3["default"] = Processor;
      module3.exports = exports3.default;
    })(processor, processor.exports);
    var selectors = {};
    var constructors = {};
    constructors.__esModule = true;
    constructors.universal = constructors.tag = constructors.string = constructors.selector = constructors.root = constructors.pseudo = constructors.nesting = constructors.id = constructors.comment = constructors.combinator = constructors.className = constructors.attribute = void 0;
    var _attribute = _interopRequireDefault$2(attribute$1);
    var _className = _interopRequireDefault$2(className$1.exports);
    var _combinator = _interopRequireDefault$2(combinator$2.exports);
    var _comment = _interopRequireDefault$2(comment$2.exports);
    var _id = _interopRequireDefault$2(id$1.exports);
    var _nesting = _interopRequireDefault$2(nesting$1.exports);
    var _pseudo = _interopRequireDefault$2(pseudo$1.exports);
    var _root = _interopRequireDefault$2(root$1.exports);
    var _selector = _interopRequireDefault$2(selector$1.exports);
    var _string = _interopRequireDefault$2(string$12.exports);
    var _tag = _interopRequireDefault$2(tag$1.exports);
    var _universal = _interopRequireDefault$2(universal$1.exports);
    function _interopRequireDefault$2(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var attribute = function attribute2(opts) {
      return new _attribute["default"](opts);
    };
    constructors.attribute = attribute;
    var className = function className2(opts) {
      return new _className["default"](opts);
    };
    constructors.className = className;
    var combinator = function combinator2(opts) {
      return new _combinator["default"](opts);
    };
    constructors.combinator = combinator;
    var comment = function comment2(opts) {
      return new _comment["default"](opts);
    };
    constructors.comment = comment;
    var id = function id2(opts) {
      return new _id["default"](opts);
    };
    constructors.id = id;
    var nesting = function nesting2(opts) {
      return new _nesting["default"](opts);
    };
    constructors.nesting = nesting;
    var pseudo = function pseudo2(opts) {
      return new _pseudo["default"](opts);
    };
    constructors.pseudo = pseudo;
    var root = function root2(opts) {
      return new _root["default"](opts);
    };
    constructors.root = root;
    var selector = function selector2(opts) {
      return new _selector["default"](opts);
    };
    constructors.selector = selector;
    var string2 = function string3(opts) {
      return new _string["default"](opts);
    };
    constructors.string = string2;
    var tag = function tag2(opts) {
      return new _tag["default"](opts);
    };
    constructors.tag = tag;
    var universal = function universal2(opts) {
      return new _universal["default"](opts);
    };
    constructors.universal = universal;
    var guards = {};
    guards.__esModule = true;
    guards.isNode = isNode;
    guards.isPseudoElement = isPseudoElement;
    guards.isPseudoClass = isPseudoClass;
    guards.isContainer = isContainer;
    guards.isNamespace = isNamespace;
    guards.isUniversal = guards.isTag = guards.isString = guards.isSelector = guards.isRoot = guards.isPseudo = guards.isNesting = guards.isIdentifier = guards.isComment = guards.isCombinator = guards.isClassName = guards.isAttribute = void 0;
    var _types = types2;
    var _IS_TYPE;
    var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
    function isNode(node3) {
      return typeof node3 === "object" && IS_TYPE[node3.type];
    }
    function isNodeType(type, node3) {
      return isNode(node3) && node3.type === type;
    }
    var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
    guards.isAttribute = isAttribute;
    var isClassName = isNodeType.bind(null, _types.CLASS);
    guards.isClassName = isClassName;
    var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
    guards.isCombinator = isCombinator;
    var isComment = isNodeType.bind(null, _types.COMMENT);
    guards.isComment = isComment;
    var isIdentifier = isNodeType.bind(null, _types.ID);
    guards.isIdentifier = isIdentifier;
    var isNesting = isNodeType.bind(null, _types.NESTING);
    guards.isNesting = isNesting;
    var isPseudo = isNodeType.bind(null, _types.PSEUDO);
    guards.isPseudo = isPseudo;
    var isRoot = isNodeType.bind(null, _types.ROOT);
    guards.isRoot = isRoot;
    var isSelector = isNodeType.bind(null, _types.SELECTOR);
    guards.isSelector = isSelector;
    var isString2 = isNodeType.bind(null, _types.STRING);
    guards.isString = isString2;
    var isTag = isNodeType.bind(null, _types.TAG);
    guards.isTag = isTag;
    var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
    guards.isUniversal = isUniversal;
    function isPseudoElement(node3) {
      return isPseudo(node3) && node3.value && (node3.value.startsWith("::") || node3.value.toLowerCase() === ":before" || node3.value.toLowerCase() === ":after");
    }
    function isPseudoClass(node3) {
      return isPseudo(node3) && !isPseudoElement(node3);
    }
    function isContainer(node3) {
      return !!(isNode(node3) && node3.walk);
    }
    function isNamespace(node3) {
      return isAttribute(node3) || isTag(node3);
    }
    (function(exports3) {
      exports3.__esModule = true;
      var _types2 = types2;
      Object.keys(_types2).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports3 && exports3[key] === _types2[key])
          return;
        exports3[key] = _types2[key];
      });
      var _constructors = constructors;
      Object.keys(_constructors).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports3 && exports3[key] === _constructors[key])
          return;
        exports3[key] = _constructors[key];
      });
      var _guards = guards;
      Object.keys(_guards).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (key in exports3 && exports3[key] === _guards[key])
          return;
        exports3[key] = _guards[key];
      });
    })(selectors);
    (function(module3, exports3) {
      exports3.__esModule = true;
      exports3["default"] = void 0;
      var _processor = _interopRequireDefault2(processor.exports);
      var selectors$1 = _interopRequireWildcard2(selectors);
      function _getRequireWildcardCache() {
        if (typeof WeakMap !== "function")
          return null;
        var cache2 = new WeakMap();
        _getRequireWildcardCache = function _getRequireWildcardCache2() {
          return cache2;
        };
        return cache2;
      }
      function _interopRequireWildcard2(obj) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache();
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var parser3 = function parser4(processor2) {
        return new _processor["default"](processor2);
      };
      Object.assign(parser3, selectors$1);
      delete parser3.__esModule;
      var _default = parser3;
      exports3["default"] = _default;
      module3.exports = exports3.default;
    })(dist2, dist2.exports);
    var matchValueName = /[$]?[\w-]+/g;
    var replaceValueSymbols$2 = (value, replacements) => {
      let matches2;
      while (matches2 = matchValueName.exec(value)) {
        const replacement2 = replacements[matches2[0]];
        if (replacement2) {
          value = value.slice(0, matches2.index) + replacement2 + value.slice(matchValueName.lastIndex);
          matchValueName.lastIndex -= matches2[0].length - replacement2.length;
        }
      }
      return value;
    };
    var replaceValueSymbols_1 = replaceValueSymbols$2;
    var replaceValueSymbols$1 = replaceValueSymbols_1;
    var replaceSymbols$1 = (css, replacements) => {
      css.walk((node3) => {
        if (node3.type === "decl" && node3.value) {
          node3.value = replaceValueSymbols$1(node3.value.toString(), replacements);
        } else if (node3.type === "rule" && node3.selector) {
          node3.selector = replaceValueSymbols$1(node3.selector.toString(), replacements);
        } else if (node3.type === "atrule" && node3.params) {
          node3.params = replaceValueSymbols$1(node3.params.toString(), replacements);
        }
      });
    };
    var replaceSymbols_1 = replaceSymbols$1;
    var importPattern = /^:import\(("[^"]*"|'[^']*'|[^"']+)\)$/;
    var balancedQuotes = /^("[^"]*"|'[^']*'|[^"']+)$/;
    var getDeclsObject = (rule) => {
      const object2 = {};
      rule.walkDecls((decl) => {
        const before = decl.raws.before ? decl.raws.before.trim() : "";
        object2[before + decl.prop] = decl.value;
      });
      return object2;
    };
    var extractICSS$2 = (css, removeRules = true, mode2 = "auto") => {
      const icssImports = {};
      const icssExports = {};
      function addImports(node3, path3) {
        const unquoted = path3.replace(/'|"/g, "");
        icssImports[unquoted] = Object.assign(icssImports[unquoted] || {}, getDeclsObject(node3));
        if (removeRules) {
          node3.remove();
        }
      }
      function addExports(node3) {
        Object.assign(icssExports, getDeclsObject(node3));
        if (removeRules) {
          node3.remove();
        }
      }
      css.each((node3) => {
        if (node3.type === "rule" && mode2 !== "at-rule") {
          if (node3.selector.slice(0, 7) === ":import") {
            const matches2 = importPattern.exec(node3.selector);
            if (matches2) {
              addImports(node3, matches2[1]);
            }
          }
          if (node3.selector === ":export") {
            addExports(node3);
          }
        }
        if (node3.type === "atrule" && mode2 !== "rule") {
          if (node3.name === "icss-import") {
            const matches2 = balancedQuotes.exec(node3.params);
            if (matches2) {
              addImports(node3, matches2[1]);
            }
          }
          if (node3.name === "icss-export") {
            addExports(node3);
          }
        }
      });
      return { icssImports, icssExports };
    };
    var extractICSS_1 = extractICSS$2;
    var createImports = (imports, postcss3, mode2 = "rule") => {
      return Object.keys(imports).map((path3) => {
        const aliases2 = imports[path3];
        const declarations = Object.keys(aliases2).map((key) => postcss3.decl({
          prop: key,
          value: aliases2[key],
          raws: { before: "\n  " }
        }));
        const hasDeclarations = declarations.length > 0;
        const rule = mode2 === "rule" ? postcss3.rule({
          selector: `:import('${path3}')`,
          raws: { after: hasDeclarations ? "\n" : "" }
        }) : postcss3.atRule({
          name: "icss-import",
          params: `'${path3}'`,
          raws: { after: hasDeclarations ? "\n" : "" }
        });
        if (hasDeclarations) {
          rule.append(declarations);
        }
        return rule;
      });
    };
    var createExports = (exports3, postcss3, mode2 = "rule") => {
      const declarations = Object.keys(exports3).map((key) => postcss3.decl({
        prop: key,
        value: exports3[key],
        raws: { before: "\n  " }
      }));
      if (declarations.length === 0) {
        return [];
      }
      const rule = mode2 === "rule" ? postcss3.rule({
        selector: `:export`,
        raws: { after: "\n" }
      }) : postcss3.atRule({
        name: "icss-export",
        raws: { after: "\n" }
      });
      rule.append(declarations);
      return [rule];
    };
    var createICSSRules$1 = (imports, exports3, postcss3, mode2) => [
      ...createImports(imports, postcss3, mode2),
      ...createExports(exports3, postcss3, mode2)
    ];
    var createICSSRules_1 = createICSSRules$1;
    var replaceValueSymbols = replaceValueSymbols_1;
    var replaceSymbols = replaceSymbols_1;
    var extractICSS$1 = extractICSS_1;
    var createICSSRules = createICSSRules_1;
    var src$3 = {
      replaceValueSymbols,
      replaceSymbols,
      extractICSS: extractICSS$1,
      createICSSRules
    };
    var selectorParser$1 = dist2.exports;
    var valueParser2 = index$12.lib;
    var { extractICSS } = src$3;
    var isSpacing = (node3) => node3.type === "combinator" && node3.value === " ";
    function normalizeNodeArray(nodes) {
      const array2 = [];
      nodes.forEach((x2) => {
        if (Array.isArray(x2)) {
          normalizeNodeArray(x2).forEach((item) => {
            array2.push(item);
          });
        } else if (x2) {
          array2.push(x2);
        }
      });
      if (array2.length > 0 && isSpacing(array2[array2.length - 1])) {
        array2.pop();
      }
      return array2;
    }
    function localizeNode(rule, mode2, localAliasMap) {
      const transform2 = (node3, context2) => {
        if (context2.ignoreNextSpacing && !isSpacing(node3)) {
          throw new Error("Missing whitespace after " + context2.ignoreNextSpacing);
        }
        if (context2.enforceNoSpacing && isSpacing(node3)) {
          throw new Error("Missing whitespace before " + context2.enforceNoSpacing);
        }
        let newNodes;
        switch (node3.type) {
          case "root": {
            let resultingGlobal;
            context2.hasPureGlobals = false;
            newNodes = node3.nodes.map((n3) => {
              const nContext = {
                global: context2.global,
                lastWasSpacing: true,
                hasLocals: false,
                explicit: false
              };
              n3 = transform2(n3, nContext);
              if (typeof resultingGlobal === "undefined") {
                resultingGlobal = nContext.global;
              } else if (resultingGlobal !== nContext.global) {
                throw new Error('Inconsistent rule global/local result in rule "' + node3 + '" (multiple selectors must result in the same mode for the rule)');
              }
              if (!nContext.hasLocals) {
                context2.hasPureGlobals = true;
              }
              return n3;
            });
            context2.global = resultingGlobal;
            node3.nodes = normalizeNodeArray(newNodes);
            break;
          }
          case "selector": {
            newNodes = node3.map((childNode) => transform2(childNode, context2));
            node3 = node3.clone();
            node3.nodes = normalizeNodeArray(newNodes);
            break;
          }
          case "combinator": {
            if (isSpacing(node3)) {
              if (context2.ignoreNextSpacing) {
                context2.ignoreNextSpacing = false;
                context2.lastWasSpacing = false;
                context2.enforceNoSpacing = false;
                return null;
              }
              context2.lastWasSpacing = true;
              return node3;
            }
            break;
          }
          case "pseudo": {
            let childContext;
            const isNested = !!node3.length;
            const isScoped = node3.value === ":local" || node3.value === ":global";
            const isImportExport = node3.value === ":import" || node3.value === ":export";
            if (isImportExport) {
              context2.hasLocals = true;
            } else if (isNested) {
              if (isScoped) {
                if (node3.nodes.length === 0) {
                  throw new Error(`${node3.value}() can't be empty`);
                }
                if (context2.inside) {
                  throw new Error(`A ${node3.value} is not allowed inside of a ${context2.inside}(...)`);
                }
                childContext = {
                  global: node3.value === ":global",
                  inside: node3.value,
                  hasLocals: false,
                  explicit: true
                };
                newNodes = node3.map((childNode) => transform2(childNode, childContext)).reduce((acc, next) => acc.concat(next.nodes), []);
                if (newNodes.length) {
                  const { before, after } = node3.spaces;
                  const first2 = newNodes[0];
                  const last = newNodes[newNodes.length - 1];
                  first2.spaces = { before, after: first2.spaces.after };
                  last.spaces = { before: last.spaces.before, after };
                }
                node3 = newNodes;
                break;
              } else {
                childContext = {
                  global: context2.global,
                  inside: context2.inside,
                  lastWasSpacing: true,
                  hasLocals: false,
                  explicit: context2.explicit
                };
                newNodes = node3.map((childNode) => transform2(childNode, childContext));
                node3 = node3.clone();
                node3.nodes = normalizeNodeArray(newNodes);
                if (childContext.hasLocals) {
                  context2.hasLocals = true;
                }
              }
              break;
            } else if (isScoped) {
              if (context2.inside) {
                throw new Error(`A ${node3.value} is not allowed inside of a ${context2.inside}(...)`);
              }
              const addBackSpacing = !!node3.spaces.before;
              context2.ignoreNextSpacing = context2.lastWasSpacing ? node3.value : false;
              context2.enforceNoSpacing = context2.lastWasSpacing ? false : node3.value;
              context2.global = node3.value === ":global";
              context2.explicit = true;
              return addBackSpacing ? selectorParser$1.combinator({ value: " " }) : null;
            }
            break;
          }
          case "id":
          case "class": {
            if (!node3.value) {
              throw new Error("Invalid class or id selector syntax");
            }
            if (context2.global) {
              break;
            }
            const isImportedValue = localAliasMap.has(node3.value);
            const isImportedWithExplicitScope = isImportedValue && context2.explicit;
            if (!isImportedValue || isImportedWithExplicitScope) {
              const innerNode = node3.clone();
              innerNode.spaces = { before: "", after: "" };
              node3 = selectorParser$1.pseudo({
                value: ":local",
                nodes: [innerNode],
                spaces: node3.spaces
              });
              context2.hasLocals = true;
            }
            break;
          }
        }
        context2.lastWasSpacing = false;
        context2.ignoreNextSpacing = false;
        context2.enforceNoSpacing = false;
        return node3;
      };
      const rootContext = {
        global: mode2 === "global",
        hasPureGlobals: false
      };
      rootContext.selector = selectorParser$1((root2) => {
        transform2(root2, rootContext);
      }).processSync(rule, { updateSelector: false, lossless: true });
      return rootContext;
    }
    function localizeDeclNode(node3, context2) {
      switch (node3.type) {
        case "word":
          if (context2.localizeNextItem) {
            if (!context2.localAliasMap.has(node3.value)) {
              node3.value = ":local(" + node3.value + ")";
              context2.localizeNextItem = false;
            }
          }
          break;
        case "function":
          if (context2.options && context2.options.rewriteUrl && node3.value.toLowerCase() === "url") {
            node3.nodes.map((nestedNode) => {
              if (nestedNode.type !== "string" && nestedNode.type !== "word") {
                return;
              }
              let newUrl = context2.options.rewriteUrl(context2.global, nestedNode.value);
              switch (nestedNode.type) {
                case "string":
                  if (nestedNode.quote === "'") {
                    newUrl = newUrl.replace(/(\\)/g, "\\$1").replace(/'/g, "\\'");
                  }
                  if (nestedNode.quote === '"') {
                    newUrl = newUrl.replace(/(\\)/g, "\\$1").replace(/"/g, '\\"');
                  }
                  break;
                case "word":
                  newUrl = newUrl.replace(/("|'|\)|\\)/g, "\\$1");
                  break;
              }
              nestedNode.value = newUrl;
            });
          }
          break;
      }
      return node3;
    }
    function isWordAFunctionArgument(wordNode, functionNode) {
      return functionNode ? functionNode.nodes.some((functionNodeChild) => functionNodeChild.sourceIndex === wordNode.sourceIndex) : false;
    }
    function localizeDeclarationValues(localize, declaration, context2) {
      const valueNodes = valueParser2(declaration.value);
      valueNodes.walk((node3, index3, nodes) => {
        const subContext = {
          options: context2.options,
          global: context2.global,
          localizeNextItem: localize && !context2.global,
          localAliasMap: context2.localAliasMap
        };
        nodes[index3] = localizeDeclNode(node3, subContext);
      });
      declaration.value = valueNodes.toString();
    }
    function localizeDeclaration(declaration, context2) {
      const isAnimation = /animation$/i.test(declaration.prop);
      if (isAnimation) {
        const validIdent = /^-?[_a-z][_a-z0-9-]*$/i;
        const animationKeywords = {
          $alternate: 1,
          "$alternate-reverse": 1,
          $backwards: 1,
          $both: 1,
          $ease: 1,
          "$ease-in": 1,
          "$ease-in-out": 1,
          "$ease-out": 1,
          $forwards: 1,
          $infinite: 1,
          $linear: 1,
          $none: Infinity,
          $normal: 1,
          $paused: 1,
          $reverse: 1,
          $running: 1,
          "$step-end": 1,
          "$step-start": 1,
          $initial: Infinity,
          $inherit: Infinity,
          $unset: Infinity
        };
        let parsedAnimationKeywords = {};
        let stepsFunctionNode = null;
        const valueNodes = valueParser2(declaration.value).walk((node3) => {
          if (node3.type === "div") {
            parsedAnimationKeywords = {};
          }
          if (node3.type === "function" && node3.value.toLowerCase() === "steps") {
            stepsFunctionNode = node3;
          }
          const value = node3.type === "word" && !isWordAFunctionArgument(node3, stepsFunctionNode) ? node3.value.toLowerCase() : null;
          let shouldParseAnimationName = false;
          if (value && validIdent.test(value)) {
            if ("$" + value in animationKeywords) {
              parsedAnimationKeywords["$" + value] = "$" + value in parsedAnimationKeywords ? parsedAnimationKeywords["$" + value] + 1 : 0;
              shouldParseAnimationName = parsedAnimationKeywords["$" + value] >= animationKeywords["$" + value];
            } else {
              shouldParseAnimationName = true;
            }
          }
          const subContext = {
            options: context2.options,
            global: context2.global,
            localizeNextItem: shouldParseAnimationName && !context2.global,
            localAliasMap: context2.localAliasMap
          };
          return localizeDeclNode(node3, subContext);
        });
        declaration.value = valueNodes.toString();
        return;
      }
      const isAnimationName = /animation(-name)?$/i.test(declaration.prop);
      if (isAnimationName) {
        return localizeDeclarationValues(true, declaration, context2);
      }
      const hasUrl = /url\(/i.test(declaration.value);
      if (hasUrl) {
        return localizeDeclarationValues(false, declaration, context2);
      }
    }
    src$4.exports = (options2 = {}) => {
      if (options2 && options2.mode && options2.mode !== "global" && options2.mode !== "local" && options2.mode !== "pure") {
        throw new Error('options.mode must be either "global", "local" or "pure" (default "local")');
      }
      const pureMode = options2 && options2.mode === "pure";
      const globalMode = options2 && options2.mode === "global";
      return {
        postcssPlugin: "postcss-modules-local-by-default",
        prepare() {
          const localAliasMap = new Map();
          return {
            Once(root2) {
              const { icssImports } = extractICSS(root2, false);
              Object.keys(icssImports).forEach((key) => {
                Object.keys(icssImports[key]).forEach((prop) => {
                  localAliasMap.set(prop, icssImports[key][prop]);
                });
              });
              root2.walkAtRules((atRule) => {
                if (/keyframes$/i.test(atRule.name)) {
                  const globalMatch = /^\s*:global\s*\((.+)\)\s*$/.exec(atRule.params);
                  const localMatch = /^\s*:local\s*\((.+)\)\s*$/.exec(atRule.params);
                  let globalKeyframes = globalMode;
                  if (globalMatch) {
                    if (pureMode) {
                      throw atRule.error("@keyframes :global(...) is not allowed in pure mode");
                    }
                    atRule.params = globalMatch[1];
                    globalKeyframes = true;
                  } else if (localMatch) {
                    atRule.params = localMatch[0];
                    globalKeyframes = false;
                  } else if (!globalMode) {
                    if (atRule.params && !localAliasMap.has(atRule.params)) {
                      atRule.params = ":local(" + atRule.params + ")";
                    }
                  }
                  atRule.walkDecls((declaration) => {
                    localizeDeclaration(declaration, {
                      localAliasMap,
                      options: options2,
                      global: globalKeyframes
                    });
                  });
                } else if (atRule.nodes) {
                  atRule.nodes.forEach((declaration) => {
                    if (declaration.type === "decl") {
                      localizeDeclaration(declaration, {
                        localAliasMap,
                        options: options2,
                        global: globalMode
                      });
                    }
                  });
                }
              });
              root2.walkRules((rule) => {
                if (rule.parent && rule.parent.type === "atrule" && /keyframes$/i.test(rule.parent.name)) {
                  return;
                }
                const context2 = localizeNode(rule, options2.mode, localAliasMap);
                context2.options = options2;
                context2.localAliasMap = localAliasMap;
                if (pureMode && context2.hasPureGlobals) {
                  throw rule.error('Selector "' + rule.selector + '" is not pure (pure selectors must contain at least one local class or id)');
                }
                rule.selector = context2.selector;
                if (rule.nodes) {
                  rule.nodes.forEach((declaration) => localizeDeclaration(declaration, context2));
                }
              });
            }
          };
        }
      };
    };
    src$4.exports.postcss = true;
    var src$22 = { exports: {} };
    var PERMANENT_MARKER = 2;
    var TEMPORARY_MARKER = 1;
    function createError(node3, graph) {
      const er2 = new Error("Nondeterministic import's order");
      const related = graph[node3];
      const relatedNode = related.find((relatedNode2) => graph[relatedNode2].indexOf(node3) > -1);
      er2.nodes = [node3, relatedNode];
      return er2;
    }
    function walkGraph(node3, graph, state, result2, strict) {
      if (state[node3] === PERMANENT_MARKER) {
        return;
      }
      if (state[node3] === TEMPORARY_MARKER) {
        if (strict) {
          return createError(node3, graph);
        }
        return;
      }
      state[node3] = TEMPORARY_MARKER;
      const children = graph[node3];
      const length = children.length;
      for (let i2 = 0; i2 < length; ++i2) {
        const error2 = walkGraph(children[i2], graph, state, result2, strict);
        if (error2 instanceof Error) {
          return error2;
        }
      }
      state[node3] = PERMANENT_MARKER;
      result2.push(node3);
    }
    function topologicalSort$1(graph, strict) {
      const result2 = [];
      const state = {};
      const nodes = Object.keys(graph);
      const length = nodes.length;
      for (let i2 = 0; i2 < length; ++i2) {
        const er2 = walkGraph(nodes[i2], graph, state, result2, strict);
        if (er2 instanceof Error) {
          return er2;
        }
      }
      return result2;
    }
    var topologicalSort_1 = topologicalSort$1;
    var topologicalSort = topologicalSort_1;
    var matchImports$1 = /^(.+?)\s+from\s+(?:"([^"]+)"|'([^']+)'|(global))$/;
    var icssImport = /^:import\((?:"([^"]+)"|'([^']+)')\)/;
    var VISITED_MARKER = 1;
    function addImportToGraph(importId, parentId, graph, visited) {
      const siblingsId = parentId + "_siblings";
      const visitedId = parentId + "_" + importId;
      if (visited[visitedId] !== VISITED_MARKER) {
        if (!Array.isArray(visited[siblingsId])) {
          visited[siblingsId] = [];
        }
        const siblings = visited[siblingsId];
        if (Array.isArray(graph[importId])) {
          graph[importId] = graph[importId].concat(siblings);
        } else {
          graph[importId] = siblings.slice();
        }
        visited[visitedId] = VISITED_MARKER;
        siblings.push(importId);
      }
    }
    src$22.exports = (options2 = {}) => {
      let importIndex = 0;
      const createImportedName = typeof options2.createImportedName !== "function" ? (importName) => `i__imported_${importName.replace(/\W/g, "_")}_${importIndex++}` : options2.createImportedName;
      const failOnWrongOrder = options2.failOnWrongOrder;
      return {
        postcssPlugin: "postcss-modules-extract-imports",
        prepare() {
          const graph = {};
          const visited = {};
          const existingImports = {};
          const importDecls = {};
          const imports = {};
          return {
            Once(root2, postcss3) {
              root2.walkRules((rule) => {
                const matches2 = icssImport.exec(rule.selector);
                if (matches2) {
                  const [, doubleQuotePath, singleQuotePath] = matches2;
                  const importPath = doubleQuotePath || singleQuotePath;
                  addImportToGraph(importPath, "root", graph, visited);
                  existingImports[importPath] = rule;
                }
              });
              root2.walkDecls(/^composes$/, (declaration) => {
                const matches2 = declaration.value.match(matchImports$1);
                if (!matches2) {
                  return;
                }
                let tmpSymbols;
                let [
                  ,
                  symbols,
                  doubleQuotePath,
                  singleQuotePath,
                  global2
                ] = matches2;
                if (global2) {
                  tmpSymbols = symbols.split(/\s+/).map((s2) => `global(${s2})`);
                } else {
                  const importPath = doubleQuotePath || singleQuotePath;
                  let parent = declaration.parent;
                  let parentIndexes = "";
                  while (parent.type !== "root") {
                    parentIndexes = parent.parent.index(parent) + "_" + parentIndexes;
                    parent = parent.parent;
                  }
                  const { selector: selector2 } = declaration.parent;
                  const parentRule = `_${parentIndexes}${selector2}`;
                  addImportToGraph(importPath, parentRule, graph, visited);
                  importDecls[importPath] = declaration;
                  imports[importPath] = imports[importPath] || {};
                  tmpSymbols = symbols.split(/\s+/).map((s2) => {
                    if (!imports[importPath][s2]) {
                      imports[importPath][s2] = createImportedName(s2, importPath);
                    }
                    return imports[importPath][s2];
                  });
                }
                declaration.value = tmpSymbols.join(" ");
              });
              const importsOrder = topologicalSort(graph, failOnWrongOrder);
              if (importsOrder instanceof Error) {
                const importPath = importsOrder.nodes.find((importPath2) => importDecls.hasOwnProperty(importPath2));
                const decl = importDecls[importPath];
                throw decl.error("Failed to resolve order of composed modules " + importsOrder.nodes.map((importPath2) => "`" + importPath2 + "`").join(", ") + ".", {
                  plugin: "postcss-modules-extract-imports",
                  word: "composes"
                });
              }
              let lastImportRule;
              importsOrder.forEach((path3) => {
                const importedSymbols = imports[path3];
                let rule = existingImports[path3];
                if (!rule && importedSymbols) {
                  rule = postcss3.rule({
                    selector: `:import("${path3}")`,
                    raws: { after: "\n" }
                  });
                  if (lastImportRule) {
                    root2.insertAfter(lastImportRule, rule);
                  } else {
                    root2.prepend(rule);
                  }
                }
                lastImportRule = rule;
                if (!importedSymbols) {
                  return;
                }
                Object.keys(importedSymbols).forEach((importedSymbol) => {
                  rule.append(postcss3.decl({
                    value: importedSymbol,
                    prop: importedSymbols[importedSymbol],
                    raws: { before: "\n  " }
                  }));
                });
              });
            }
          };
        }
      };
    };
    src$22.exports.postcss = true;
    var selectorParser = dist2.exports;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function getSingleLocalNamesForComposes(root2) {
      return root2.nodes.map((node3) => {
        if (node3.type !== "selector" || node3.nodes.length !== 1) {
          throw new Error(`composition is only allowed when selector is single :local class name not in "${root2}"`);
        }
        node3 = node3.nodes[0];
        if (node3.type !== "pseudo" || node3.value !== ":local" || node3.nodes.length !== 1) {
          throw new Error('composition is only allowed when selector is single :local class name not in "' + root2 + '", "' + node3 + '" is weird');
        }
        node3 = node3.first;
        if (node3.type !== "selector" || node3.length !== 1) {
          throw new Error('composition is only allowed when selector is single :local class name not in "' + root2 + '", "' + node3 + '" is weird');
        }
        node3 = node3.first;
        if (node3.type !== "class") {
          throw new Error('composition is only allowed when selector is single :local class name not in "' + root2 + '", "' + node3 + '" is weird');
        }
        return node3.value;
      });
    }
    var whitespace = "[\\x20\\t\\r\\n\\f]";
    var unescapeRegExp = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig");
    function unescape2(str2) {
      return str2.replace(unescapeRegExp, (_2, escaped2, escapedWhitespace) => {
        const high = "0x" + escaped2 - 65536;
        return high !== high || escapedWhitespace ? escaped2 : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
      });
    }
    var plugin = (options2 = {}) => {
      const generateScopedName2 = options2 && options2.generateScopedName || plugin.generateScopedName;
      const generateExportEntry = options2 && options2.generateExportEntry || plugin.generateExportEntry;
      const exportGlobals = options2 && options2.exportGlobals;
      return {
        postcssPlugin: "postcss-modules-scope",
        Once(root2, { rule }) {
          const exports3 = Object.create(null);
          function exportScopedName(name, rawName) {
            const scopedName = generateScopedName2(rawName ? rawName : name, root2.source.input.from, root2.source.input.css);
            const exportEntry = generateExportEntry(rawName ? rawName : name, scopedName, root2.source.input.from, root2.source.input.css);
            const { key, value } = exportEntry;
            exports3[key] = exports3[key] || [];
            if (exports3[key].indexOf(value) < 0) {
              exports3[key].push(value);
            }
            return scopedName;
          }
          function localizeNode2(node3) {
            switch (node3.type) {
              case "selector":
                node3.nodes = node3.map(localizeNode2);
                return node3;
              case "class":
                return selectorParser.className({
                  value: exportScopedName(node3.value, node3.raws && node3.raws.value ? node3.raws.value : null)
                });
              case "id": {
                return selectorParser.id({
                  value: exportScopedName(node3.value, node3.raws && node3.raws.value ? node3.raws.value : null)
                });
              }
            }
            throw new Error(`${node3.type} ("${node3}") is not allowed in a :local block`);
          }
          function traverseNode(node3) {
            switch (node3.type) {
              case "pseudo":
                if (node3.value === ":local") {
                  if (node3.nodes.length !== 1) {
                    throw new Error('Unexpected comma (",") in :local block');
                  }
                  const selector2 = localizeNode2(node3.first);
                  selector2.first.spaces = node3.spaces;
                  const nextNode = node3.next();
                  if (nextNode && nextNode.type === "combinator" && nextNode.value === " " && /\\[A-F0-9]{1,6}$/.test(selector2.last.value)) {
                    selector2.last.spaces.after = " ";
                  }
                  node3.replaceWith(selector2);
                  return;
                }
              case "root":
              case "selector": {
                node3.each(traverseNode);
                break;
              }
              case "id":
              case "class":
                if (exportGlobals) {
                  exports3[node3.value] = [node3.value];
                }
                break;
            }
            return node3;
          }
          const importedNames = {};
          root2.walkRules(/^:import\(.+\)$/, (rule2) => {
            rule2.walkDecls((decl) => {
              importedNames[decl.prop] = true;
            });
          });
          root2.walkRules((rule2) => {
            let parsedSelector = selectorParser().astSync(rule2);
            rule2.selector = traverseNode(parsedSelector.clone()).toString();
            rule2.walkDecls(/composes|compose-with/i, (decl) => {
              const localNames = getSingleLocalNamesForComposes(parsedSelector);
              const classes = decl.value.split(/\s+/);
              classes.forEach((className2) => {
                const global2 = /^global\(([^)]+)\)$/.exec(className2);
                if (global2) {
                  localNames.forEach((exportedName) => {
                    exports3[exportedName].push(global2[1]);
                  });
                } else if (hasOwnProperty2.call(importedNames, className2)) {
                  localNames.forEach((exportedName) => {
                    exports3[exportedName].push(className2);
                  });
                } else if (hasOwnProperty2.call(exports3, className2)) {
                  localNames.forEach((exportedName) => {
                    exports3[className2].forEach((item) => {
                      exports3[exportedName].push(item);
                    });
                  });
                } else {
                  throw decl.error(`referenced class name "${className2}" in ${decl.prop} not found`);
                }
              });
              decl.remove();
            });
            rule2.walkDecls((decl) => {
              if (!/:local\s*\((.+?)\)/.test(decl.value)) {
                return;
              }
              let tokens = decl.value.split(/(,|'[^']*'|"[^"]*")/);
              tokens = tokens.map((token, idx) => {
                if (idx === 0 || tokens[idx - 1] === ",") {
                  let result2 = token;
                  const localMatch = /:local\s*\((.+?)\)/.exec(token);
                  if (localMatch) {
                    const input = localMatch.input;
                    const matchPattern = localMatch[0];
                    const matchVal = localMatch[1];
                    const newVal = exportScopedName(matchVal);
                    result2 = input.replace(matchPattern, newVal);
                  } else {
                    return token;
                  }
                  return result2;
                } else {
                  return token;
                }
              });
              decl.value = tokens.join("");
            });
          });
          root2.walkAtRules(/keyframes$/i, (atRule) => {
            const localMatch = /^\s*:local\s*\((.+?)\)\s*$/.exec(atRule.params);
            if (!localMatch) {
              return;
            }
            atRule.params = exportScopedName(localMatch[1]);
          });
          const exportedNames = Object.keys(exports3);
          if (exportedNames.length > 0) {
            const exportRule = rule({ selector: ":export" });
            exportedNames.forEach((exportedName) => exportRule.append({
              prop: exportedName,
              value: exports3[exportedName].join(" "),
              raws: { before: "\n  " }
            }));
            root2.append(exportRule);
          }
        }
      };
    };
    plugin.postcss = true;
    plugin.generateScopedName = function(name, path3) {
      const sanitisedPath = path3.replace(/\.[^./\\]+$/, "").replace(/[\W_]+/g, "_").replace(/^_|_$/g, "");
      return `_${sanitisedPath}__${name}`.trim();
    };
    plugin.generateExportEntry = function(name, scopedName) {
      return {
        key: unescape2(name),
        value: unescape2(scopedName)
      };
    };
    var src$12 = plugin;
    var src2 = { exports: {} };
    var ICSSUtils = src$3;
    var matchImports = /^(.+?|\([\s\S]+?\))\s+from\s+("[^"]*"|'[^']*'|[\w-]+)$/;
    var matchValueDefinition = /(?:\s+|^)([\w-]+):?(.*?)$/;
    var matchImport = /^([\w-]+)(?:\s+as\s+([\w-]+))?/;
    src2.exports = (options2) => {
      let importIndex = 0;
      const createImportedName = options2 && options2.createImportedName || ((importName) => `i__const_${importName.replace(/\W/g, "_")}_${importIndex++}`);
      return {
        postcssPlugin: "postcss-modules-values",
        prepare(result2) {
          const importAliases = [];
          const definitions = {};
          return {
            Once(root2, postcss3) {
              root2.walkAtRules(/value/i, (atRule) => {
                const matches2 = atRule.params.match(matchImports);
                if (matches2) {
                  let [, aliases2, path3] = matches2;
                  if (definitions[path3]) {
                    path3 = definitions[path3];
                  }
                  const imports = aliases2.replace(/^\(\s*([\s\S]+)\s*\)$/, "$1").split(/\s*,\s*/).map((alias2) => {
                    const tokens = matchImport.exec(alias2);
                    if (tokens) {
                      const [, theirName, myName = theirName] = tokens;
                      const importedName = createImportedName(myName);
                      definitions[myName] = importedName;
                      return { theirName, importedName };
                    } else {
                      throw new Error(`@import statement "${alias2}" is invalid!`);
                    }
                  });
                  importAliases.push({ path: path3, imports });
                  atRule.remove();
                  return;
                }
                if (atRule.params.indexOf("@value") !== -1) {
                  result2.warn("Invalid value definition: " + atRule.params);
                }
                let [, key, value] = `${atRule.params}${atRule.raws.between}`.match(matchValueDefinition);
                const normalizedValue = value.replace(/\/\*((?!\*\/).*?)\*\//g, "");
                if (normalizedValue.length === 0) {
                  result2.warn("Invalid value definition: " + atRule.params);
                  atRule.remove();
                  return;
                }
                let isOnlySpace = /^\s+$/.test(normalizedValue);
                if (!isOnlySpace) {
                  value = value.trim();
                }
                definitions[key] = ICSSUtils.replaceValueSymbols(value, definitions);
                atRule.remove();
              });
              if (!Object.keys(definitions).length) {
                return;
              }
              ICSSUtils.replaceSymbols(root2, definitions);
              const exportDeclarations = Object.keys(definitions).map((key) => postcss3.decl({
                value: definitions[key],
                prop: key,
                raws: { before: "\n  " }
              }));
              if (exportDeclarations.length > 0) {
                const exportRule = postcss3.rule({
                  selector: ":export",
                  raws: { after: "\n" }
                });
                exportRule.append(exportDeclarations);
                root2.prepend(exportRule);
              }
              importAliases.reverse().forEach(({ path: path3, imports }) => {
                const importRule = postcss3.rule({
                  selector: `:import(${path3})`,
                  raws: { after: "\n" }
                });
                imports.forEach(({ theirName, importedName }) => {
                  importRule.append({
                    value: theirName,
                    prop: importedName,
                    raws: { before: "\n  " }
                  });
                });
                root2.prepend(importRule);
              });
            }
          };
        }
      };
    };
    src2.exports.postcss = true;
    Object.defineProperty(behaviours$1, "__esModule", {
      value: true
    });
    behaviours$1.behaviours = void 0;
    behaviours$1.getDefaultPlugins = getDefaultPlugins;
    behaviours$1.isValidBehaviour = isValidBehaviour;
    var _postcssModulesLocalByDefault = src$4.exports;
    var _postcssModulesLocalByDefault2 = _interopRequireDefault$1(_postcssModulesLocalByDefault);
    var _postcssModulesExtractImports = src$22.exports;
    var _postcssModulesExtractImports2 = _interopRequireDefault$1(_postcssModulesExtractImports);
    var _postcssModulesScope = src$12;
    var _postcssModulesScope2 = _interopRequireDefault$1(_postcssModulesScope);
    var _postcssModulesValues = src2.exports;
    var _postcssModulesValues2 = _interopRequireDefault$1(_postcssModulesValues);
    function _interopRequireDefault$1(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var behaviours = behaviours$1.behaviours = {
      LOCAL: "local",
      GLOBAL: "global"
    };
    function getDefaultPlugins({
      behaviour,
      generateScopedName: generateScopedName2,
      exportGlobals
    }) {
      const scope = (0, _postcssModulesScope2.default)({ generateScopedName: generateScopedName2, exportGlobals });
      const plugins2 = {
        [behaviours.LOCAL]: [_postcssModulesValues2.default, _postcssModulesLocalByDefault2.default, _postcssModulesExtractImports2.default, scope],
        [behaviours.GLOBAL]: [_postcssModulesValues2.default, _postcssModulesExtractImports2.default, scope]
      };
      return plugins2[behaviour];
    }
    function isValidBehaviour(behaviour) {
      return Object.keys(behaviours).map((key) => behaviours[key]).indexOf(behaviour) > -1;
    }
    var _postcss = require$$0__default2;
    var _postcss2 = _interopRequireDefault(_postcss);
    var _lodash = lodash_camelcase;
    var _lodash2 = _interopRequireDefault(_lodash);
    var _genericNames = genericNames;
    var _genericNames2 = _interopRequireDefault(_genericNames);
    var _unquote = unquote$1;
    var _unquote2 = _interopRequireDefault(_unquote);
    var _parser = parser$1;
    var _parser2 = _interopRequireDefault(_parser);
    var _loader = loader;
    var _loader2 = _interopRequireDefault(_loader);
    var _generateScopedName = generateScopedName$1;
    var _generateScopedName2 = _interopRequireDefault(_generateScopedName);
    var _saveJSON = saveJSON$1;
    var _saveJSON2 = _interopRequireDefault(_saveJSON);
    var _behaviours = behaviours$1;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _asyncToGenerator(fn2) {
      return function() {
        var gen = fn2.apply(this, arguments);
        return new Promise(function(resolve2, reject) {
          function step(key, arg) {
            try {
              var info = gen[key](arg);
              var value = info.value;
            } catch (error2) {
              reject(error2);
              return;
            }
            if (info.done) {
              resolve2(value);
            } else {
              return Promise.resolve(value).then(function(value2) {
                step("next", value2);
              }, function(err) {
                step("throw", err);
              });
            }
          }
          return step("next");
        });
      };
    }
    var PLUGIN_NAME = "postcss-modules";
    function getDefaultScopeBehaviour(opts) {
      if (opts.scopeBehaviour && (0, _behaviours.isValidBehaviour)(opts.scopeBehaviour)) {
        return opts.scopeBehaviour;
      }
      return _behaviours.behaviours.LOCAL;
    }
    function getScopedNameGenerator(opts) {
      const scopedNameGenerator = opts.generateScopedName || _generateScopedName2.default;
      if (typeof scopedNameGenerator === "function")
        return scopedNameGenerator;
      return (0, _genericNames2.default)(scopedNameGenerator, {
        context: process.cwd(),
        hashPrefix: opts.hashPrefix
      });
    }
    function getLoader(opts, plugins2) {
      const root2 = typeof opts.root === "undefined" ? "/" : opts.root;
      return typeof opts.Loader === "function" ? new opts.Loader(root2, plugins2) : new _loader2.default(root2, plugins2);
    }
    function isGlobalModule(globalModules, inputFile) {
      return globalModules.some((regex) => inputFile.match(regex));
    }
    function getDefaultPluginsList(opts, inputFile) {
      const globalModulesList = opts.globalModulePaths || null;
      const exportGlobals = opts.exportGlobals || false;
      const defaultBehaviour = getDefaultScopeBehaviour(opts);
      const generateScopedName2 = getScopedNameGenerator(opts);
      if (globalModulesList && isGlobalModule(globalModulesList, inputFile)) {
        return (0, _behaviours.getDefaultPlugins)({
          behaviour: _behaviours.behaviours.GLOBAL,
          generateScopedName: generateScopedName2,
          exportGlobals
        });
      }
      return (0, _behaviours.getDefaultPlugins)({
        behaviour: defaultBehaviour,
        generateScopedName: generateScopedName2,
        exportGlobals
      });
    }
    function isOurPlugin(plugin2) {
      return plugin2.postcssPlugin === PLUGIN_NAME;
    }
    function dashesCamelCase(string3) {
      return string3.replace(/-+(\w)/g, (_2, firstLetter) => firstLetter.toUpperCase());
    }
    build$12.exports = (opts = {}) => {
      return {
        postcssPlugin: PLUGIN_NAME,
        OnceExit(css, { result: result2 }) {
          return _asyncToGenerator(function* () {
            const getJSON = opts.getJSON || _saveJSON2.default;
            const inputFile = css.source.input.file;
            const pluginList = getDefaultPluginsList(opts, inputFile);
            const resultPluginIndex = result2.processor.plugins.findIndex(function(plugin2) {
              return isOurPlugin(plugin2);
            });
            if (resultPluginIndex === -1) {
              throw new Error("Plugin missing from options.");
            }
            const earlierPlugins = result2.processor.plugins.slice(0, resultPluginIndex);
            const loaderPlugins = [...earlierPlugins, ...pluginList];
            const loader2 = getLoader(opts, loaderPlugins);
            const fetcher = function fetcher2(file, relativeTo, depTrace) {
              const unquoteFile = (0, _unquote2.default)(file);
              const resolvedResult = typeof opts.resolve === "function" && opts.resolve(unquoteFile);
              const resolvedFile = resolvedResult instanceof Promise ? resolvedResult : Promise.resolve(resolvedResult);
              return resolvedFile.then(function(f2) {
                return loader2.fetch.call(loader2, `"${f2 || unquoteFile}"`, relativeTo, depTrace);
              });
            };
            const parser3 = new _parser2.default(fetcher);
            yield (0, _postcss2.default)([...pluginList, parser3.plugin()]).process(css, {
              from: inputFile
            });
            const out2 = loader2.finalSource;
            if (out2)
              css.prepend(out2);
            if (opts.localsConvention) {
              const isFunc = typeof opts.localsConvention === "function";
              parser3.exportTokens = Object.entries(parser3.exportTokens).reduce(function(tokens, [className2, value]) {
                if (isFunc) {
                  tokens[opts.localsConvention(className2, value, inputFile)] = value;
                  return tokens;
                }
                switch (opts.localsConvention) {
                  case "camelCase":
                    tokens[className2] = value;
                    tokens[(0, _lodash2.default)(className2)] = value;
                    break;
                  case "camelCaseOnly":
                    tokens[(0, _lodash2.default)(className2)] = value;
                    break;
                  case "dashes":
                    tokens[className2] = value;
                    tokens[dashesCamelCase(className2)] = value;
                    break;
                  case "dashesOnly":
                    tokens[dashesCamelCase(className2)] = value;
                    break;
                }
                return tokens;
              }, {});
            }
            result2.messages.push({
              type: "export",
              plugin: "postcss-modules",
              exportTokens: parser3.exportTokens
            });
            return getJSON(css.source.input.file, parser3.exportTokens, result2.opts.to);
          })();
        }
      };
    };
    var postcss2 = build$12.exports.postcss = true;
    var build2 = build$12.exports;
    var index2 = _mergeNamespaces2({
      __proto__: null,
      "default": build2,
      postcss: postcss2
    }, [build$12.exports]);
    exports2.index = index2;
  }
});

// node_modules/vite/dist/node/chunks/dep-6899098c.js
var require_dep_6899098c = __commonJS({
  "node_modules/vite/dist/node/chunks/dep-6899098c.js"(exports2) {
    "use strict";
    var build2 = require_dep_76613303();
    function _mergeNamespaces2(n3, m3) {
      for (var i2 = 0; i2 < m3.length; i2++) {
        var e2 = m3[i2];
        if (typeof e2 !== "string" && !Array.isArray(e2)) {
          for (var k2 in e2) {
            if (k2 !== "default" && !(k2 in n3)) {
              n3[k2] = e2[k2];
            }
          }
        }
      }
      return n3;
    }
    var compilerDom_cjs$2 = {};
    function makeMap(str, expectsLowerCase) {
      const map2 = Object.create(null);
      const list2 = str.split(",");
      for (let i2 = 0; i2 < list2.length; i2++) {
        map2[list2[i2]] = true;
      }
      return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
    }
    var PatchFlagNames = {
      [1]: `TEXT`,
      [2]: `CLASS`,
      [4]: `STYLE`,
      [8]: `PROPS`,
      [16]: `FULL_PROPS`,
      [32]: `HYDRATE_EVENTS`,
      [64]: `STABLE_FRAGMENT`,
      [128]: `KEYED_FRAGMENT`,
      [256]: `UNKEYED_FRAGMENT`,
      [512]: `NEED_PATCH`,
      [1024]: `DYNAMIC_SLOTS`,
      [2048]: `DEV_ROOT_FRAGMENT`,
      [-1]: `HOISTED`,
      [-2]: `BAIL`
    };
    var slotFlagsText = {
      [1]: "STABLE",
      [2]: "DYNAMIC",
      [3]: "FORWARDED"
    };
    var GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
    var isGloballyWhitelisted = makeMap(GLOBALS_WHITE_LISTED);
    var range2 = 2;
    function generateCodeFrame2(source2, start = 0, end = source2.length) {
      let lines = source2.split(/(\r?\n)/);
      const newlineSequences = lines.filter((_2, idx) => idx % 2 === 1);
      lines = lines.filter((_2, idx) => idx % 2 === 0);
      let count = 0;
      const res = [];
      for (let i2 = 0; i2 < lines.length; i2++) {
        count += lines[i2].length + (newlineSequences[i2] && newlineSequences[i2].length || 0);
        if (count >= start) {
          for (let j2 = i2 - range2; j2 <= i2 + range2 || end > count; j2++) {
            if (j2 < 0 || j2 >= lines.length)
              continue;
            const line = j2 + 1;
            res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j2]}`);
            const lineLength = lines[j2].length;
            const newLineSeqLength = newlineSequences[j2] && newlineSequences[j2].length || 0;
            if (j2 === i2) {
              const pad2 = start - (count - (lineLength + newLineSeqLength));
              const length = Math.max(1, end > count ? lineLength - pad2 : end - start);
              res.push(`   |  ` + " ".repeat(pad2) + "^".repeat(length));
            } else if (j2 > i2) {
              if (end > count) {
                const length = Math.max(Math.min(end - count, lineLength), 1);
                res.push(`   |  ` + "^".repeat(length));
              }
              count += lineLength + newLineSeqLength;
            }
          }
          break;
        }
      }
      return res.join("\n");
    }
    var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    var isSpecialBooleanAttr = makeMap(specialBooleanAttrs);
    var isBooleanAttr = makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    var unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
    var attrValidationCache = {};
    function isSSRSafeAttrName(name) {
      if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
      }
      const isUnsafe = unsafeAttrCharRE.test(name);
      if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
      }
      return attrValidationCache[name] = !isUnsafe;
    }
    var propsToAttrMap = {
      acceptCharset: "accept-charset",
      className: "class",
      htmlFor: "for",
      httpEquiv: "http-equiv"
    };
    var isNoUnitNumericStyleProp = makeMap(`animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width`);
    var isKnownHtmlAttr = makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
    var isKnownSvgAttr = makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
    function normalizeStyle(value) {
      if (isArray2(value)) {
        const res = {};
        for (let i2 = 0; i2 < value.length; i2++) {
          const item = value[i2];
          const normalized = isString2(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString2(value)) {
        return value;
      } else if (isObject2(value)) {
        return value;
      }
    }
    var listDelimiterRE = /;(?![^(]*\))/g;
    var propertyDelimiterRE = /:(.+)/;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function stringifyStyle(styles2) {
      let ret = "";
      if (!styles2 || isString2(styles2)) {
        return ret;
      }
      for (const key in styles2) {
        const value = styles2[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString2(value) || typeof value === "number" && isNoUnitNumericStyleProp(normalizedKey)) {
          ret += `${normalizedKey}:${value};`;
        }
      }
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString2(value)) {
        res = value;
      } else if (isArray2(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          const normalized = normalizeClass(value[i2]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject2(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props)
        return null;
      let { class: klass, style } = props;
      if (klass && !isString2(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style) {
        props.style = normalizeStyle(style);
      }
      return props;
    }
    var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
    var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
    var VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
    var isHTMLTag = makeMap(HTML_TAGS);
    var isSVGTag = makeMap(SVG_TAGS);
    var isVoidTag = makeMap(VOID_TAGS);
    var escapeRE = /["'&<>]/;
    function escapeHtml2(string2) {
      const str = "" + string2;
      const match2 = escapeRE.exec(str);
      if (!match2) {
        return str;
      }
      let html = "";
      let escaped2;
      let index2;
      let lastIndex = 0;
      for (index2 = match2.index; index2 < str.length; index2++) {
        switch (str.charCodeAt(index2)) {
          case 34:
            escaped2 = "&quot;";
            break;
          case 38:
            escaped2 = "&amp;";
            break;
          case 39:
            escaped2 = "&#39;";
            break;
          case 60:
            escaped2 = "&lt;";
            break;
          case 62:
            escaped2 = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index2) {
          html += str.slice(lastIndex, index2);
        }
        lastIndex = index2 + 1;
        html += escaped2;
      }
      return lastIndex !== index2 ? html + str.slice(lastIndex, index2) : html;
    }
    var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
    function escapeHtmlComment(src2) {
      return src2.replace(commentStripRE, "");
    }
    function looseCompareArrays(a2, b2) {
      if (a2.length !== b2.length)
        return false;
      let equal = true;
      for (let i2 = 0; equal && i2 < a2.length; i2++) {
        equal = looseEqual(a2[i2], b2[i2]);
      }
      return equal;
    }
    function looseEqual(a2, b2) {
      if (a2 === b2)
        return true;
      let aValidType = isDate(a2);
      let bValidType = isDate(b2);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
      }
      aValidType = isArray2(a2);
      bValidType = isArray2(b2);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
      }
      aValidType = isObject2(a2);
      bValidType = isObject2(b2);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a2).length;
        const bKeysCount = Object.keys(b2).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a2) {
          const aHasKey = a2.hasOwnProperty(key);
          const bHasKey = b2.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key], b2[key])) {
            return false;
          }
        }
      }
      return String(a2) === String(b2);
    }
    function looseIndexOf(arr, val) {
      return arr.findIndex((item) => looseEqual(item, val));
    }
    var toDisplayString = (val) => {
      return val == null ? "" : isArray2(val) || isObject2(val) && (val.toString === objectToString || !isFunction2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
    };
    var replacer = (_key, val) => {
      if (val && val.__v_isRef) {
        return replacer(_key, val.value);
      } else if (isMap(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
            entries[`${key} =>`] = val2;
            return entries;
          }, {})
        };
      } else if (isSet(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()]
        };
      } else if (isObject2(val) && !isArray2(val) && !isPlainObject(val)) {
        return String(val);
      }
      return val;
    };
    var EMPTY_OBJ = true ? Object.freeze({}) : {};
    var EMPTY_ARR = true ? Object.freeze([]) : [];
    var NOOP2 = () => {
    };
    var NO = () => false;
    var onRE = /^on[^a-z]/;
    var isOn = (key) => onRE.test(key);
    var isModelListener = (key) => key.startsWith("onUpdate:");
    var extend2 = Object.assign;
    var remove2 = (arr, el) => {
      const i2 = arr.indexOf(el);
      if (i2 > -1) {
        arr.splice(i2, 1);
      }
    };
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var hasOwn2 = (val, key) => hasOwnProperty2.call(val, key);
    var isArray2 = Array.isArray;
    var isMap = (val) => toTypeString(val) === "[object Map]";
    var isSet = (val) => toTypeString(val) === "[object Set]";
    var isDate = (val) => val instanceof Date;
    var isFunction2 = (val) => typeof val === "function";
    var isString2 = (val) => typeof val === "string";
    var isSymbol = (val) => typeof val === "symbol";
    var isObject2 = (val) => val !== null && typeof val === "object";
    var isPromise = (val) => {
      return isObject2(val) && isFunction2(val.then) && isFunction2(val.catch);
    };
    var objectToString = Object.prototype.toString;
    var toTypeString = (value) => objectToString.call(value);
    var toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    var isPlainObject = (val) => toTypeString(val) === "[object Object]";
    var isIntegerKey = (key) => isString2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    var isReservedProp = makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
    var cacheStringFunction$1 = (fn2) => {
      const cache2 = Object.create(null);
      return (str) => {
        const hit = cache2[str];
        return hit || (cache2[str] = fn2(str));
      };
    };
    var camelizeRE$1 = /-(\w)/g;
    var camelize$1 = cacheStringFunction$1((str) => {
      return str.replace(camelizeRE$1, (_2, c2) => c2 ? c2.toUpperCase() : "");
    });
    var hyphenateRE = /\B([A-Z])/g;
    var hyphenate = cacheStringFunction$1((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
    var capitalize = cacheStringFunction$1((str) => str.charAt(0).toUpperCase() + str.slice(1));
    var toHandlerKey = cacheStringFunction$1((str) => str ? `on${capitalize(str)}` : ``);
    var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    var invokeArrayFns = (fns, arg) => {
      for (let i2 = 0; i2 < fns.length; i2++) {
        fns[i2](arg);
      }
    };
    var def = (obj, key, value) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
      });
    };
    var toNumber = (val) => {
      const n3 = parseFloat(val);
      return isNaN(n3) ? val : n3;
    };
    var _globalThis;
    var getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    var shared_esmBundler = {
      __proto__: null,
      EMPTY_ARR,
      EMPTY_OBJ,
      NO,
      NOOP: NOOP2,
      PatchFlagNames,
      camelize: camelize$1,
      capitalize,
      def,
      escapeHtml: escapeHtml2,
      escapeHtmlComment,
      extend: extend2,
      generateCodeFrame: generateCodeFrame2,
      getGlobalThis,
      hasChanged,
      hasOwn: hasOwn2,
      hyphenate,
      includeBooleanAttr,
      invokeArrayFns,
      isArray: isArray2,
      isBooleanAttr,
      isDate,
      isFunction: isFunction2,
      isGloballyWhitelisted,
      isHTMLTag,
      isIntegerKey,
      isKnownHtmlAttr,
      isKnownSvgAttr,
      isMap,
      isModelListener,
      isNoUnitNumericStyleProp,
      isObject: isObject2,
      isOn,
      isPlainObject,
      isPromise,
      isReservedProp,
      isSSRSafeAttrName,
      isSVGTag,
      isSet,
      isSpecialBooleanAttr,
      isString: isString2,
      isSymbol,
      isVoidTag,
      looseEqual,
      looseIndexOf,
      makeMap,
      normalizeClass,
      normalizeProps,
      normalizeStyle,
      objectToString,
      parseStringStyle,
      propsToAttrMap,
      remove: remove2,
      slotFlagsText,
      stringifyStyle,
      toDisplayString,
      toHandlerKey,
      toNumber,
      toRawType,
      toTypeString
    };
    function defaultOnError(error2) {
      throw error2;
    }
    function defaultOnWarn(msg) {
      console.warn(`[Vue warn] ${msg.message}`);
    }
    function createCompilerError(code, loc, messages, additionalMessage) {
      const msg = true ? (messages || errorMessages)[code] + (additionalMessage || ``) : code;
      const error2 = new SyntaxError(String(msg));
      error2.code = code;
      error2.loc = loc;
      return error2;
    }
    var errorMessages = {
      [0]: "Illegal comment.",
      [1]: "CDATA section is allowed only in XML context.",
      [2]: "Duplicate attribute.",
      [3]: "End tag cannot have attributes.",
      [4]: "Illegal '/' in tags.",
      [5]: "Unexpected EOF in tag.",
      [6]: "Unexpected EOF in CDATA section.",
      [7]: "Unexpected EOF in comment.",
      [8]: "Unexpected EOF in script.",
      [9]: "Unexpected EOF in tag.",
      [10]: "Incorrectly closed comment.",
      [11]: "Incorrectly opened comment.",
      [12]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13]: "Attribute value was expected.",
      [14]: "End tag name was expected.",
      [15]: "Whitespace was expected.",
      [16]: "Unexpected '<!--' in comment.",
      [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
      [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
      [19]: "Attribute name cannot start with '='.",
      [21]: "'<?' is allowed only in XML context.",
      [20]: `Unexpected null character.`,
      [22]: "Illegal '/' in tags.",
      [23]: "Invalid end tag.",
      [24]: "Element is missing end tag.",
      [25]: "Interpolation end sign was not found.",
      [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
      [26]: "Legal directive name was expected.",
      [28]: `v-if/v-else-if is missing expression.`,
      [29]: `v-if/else branches must use unique keys.`,
      [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
      [31]: `v-for is missing expression.`,
      [32]: `v-for has invalid expression.`,
      [33]: `<template v-for> key should be placed on the <template> tag.`,
      [34]: `v-bind is missing expression.`,
      [35]: `v-on is missing expression.`,
      [36]: `Unexpected custom directive on <slot> outlet.`,
      [37]: `Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
      [38]: `Duplicate slot names found. `,
      [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
      [40]: `v-slot can only be used on components or <template> tags.`,
      [41]: `v-model is missing expression.`,
      [42]: `v-model value must be a valid JavaScript member expression.`,
      [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [44]: `Error parsing JavaScript expression: `,
      [45]: `<KeepAlive> expects exactly one child component.`,
      [46]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [47]: `ES module mode is not supported in this build of compiler.`,
      [48]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [49]: `"scopeId" option is only supported in module mode.`,
      [50]: ``
    };
    var FRAGMENT = Symbol(true ? `Fragment` : ``);
    var TELEPORT = Symbol(true ? `Teleport` : ``);
    var SUSPENSE = Symbol(true ? `Suspense` : ``);
    var KEEP_ALIVE = Symbol(true ? `KeepAlive` : ``);
    var BASE_TRANSITION = Symbol(true ? `BaseTransition` : ``);
    var OPEN_BLOCK = Symbol(true ? `openBlock` : ``);
    var CREATE_BLOCK = Symbol(true ? `createBlock` : ``);
    var CREATE_ELEMENT_BLOCK = Symbol(true ? `createElementBlock` : ``);
    var CREATE_VNODE = Symbol(true ? `createVNode` : ``);
    var CREATE_ELEMENT_VNODE = Symbol(true ? `createElementVNode` : ``);
    var CREATE_COMMENT = Symbol(true ? `createCommentVNode` : ``);
    var CREATE_TEXT = Symbol(true ? `createTextVNode` : ``);
    var CREATE_STATIC = Symbol(true ? `createStaticVNode` : ``);
    var RESOLVE_COMPONENT = Symbol(true ? `resolveComponent` : ``);
    var RESOLVE_DYNAMIC_COMPONENT = Symbol(true ? `resolveDynamicComponent` : ``);
    var RESOLVE_DIRECTIVE = Symbol(true ? `resolveDirective` : ``);
    var RESOLVE_FILTER = Symbol(true ? `resolveFilter` : ``);
    var WITH_DIRECTIVES = Symbol(true ? `withDirectives` : ``);
    var RENDER_LIST = Symbol(true ? `renderList` : ``);
    var RENDER_SLOT = Symbol(true ? `renderSlot` : ``);
    var CREATE_SLOTS = Symbol(true ? `createSlots` : ``);
    var TO_DISPLAY_STRING = Symbol(true ? `toDisplayString` : ``);
    var MERGE_PROPS = Symbol(true ? `mergeProps` : ``);
    var NORMALIZE_CLASS = Symbol(true ? `normalizeClass` : ``);
    var NORMALIZE_STYLE = Symbol(true ? `normalizeStyle` : ``);
    var NORMALIZE_PROPS = Symbol(true ? `normalizeProps` : ``);
    var GUARD_REACTIVE_PROPS = Symbol(true ? `guardReactiveProps` : ``);
    var TO_HANDLERS = Symbol(true ? `toHandlers` : ``);
    var CAMELIZE = Symbol(true ? `camelize` : ``);
    var CAPITALIZE = Symbol(true ? `capitalize` : ``);
    var TO_HANDLER_KEY = Symbol(true ? `toHandlerKey` : ``);
    var SET_BLOCK_TRACKING = Symbol(true ? `setBlockTracking` : ``);
    var PUSH_SCOPE_ID = Symbol(true ? `pushScopeId` : ``);
    var POP_SCOPE_ID = Symbol(true ? `popScopeId` : ``);
    var WITH_CTX = Symbol(true ? `withCtx` : ``);
    var UNREF = Symbol(true ? `unref` : ``);
    var IS_REF = Symbol(true ? `isRef` : ``);
    var WITH_MEMO = Symbol(true ? `withMemo` : ``);
    var IS_MEMO_SAME = Symbol(true ? `isMemoSame` : ``);
    var helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_ELEMENT_VNODE]: `createElementVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [NORMALIZE_CLASS]: `normalizeClass`,
      [NORMALIZE_STYLE]: `normalizeStyle`,
      [NORMALIZE_PROPS]: `normalizeProps`,
      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`,
      [WITH_MEMO]: `withMemo`,
      [IS_MEMO_SAME]: `isMemoSame`
    };
    function registerRuntimeHelpers(helpers) {
      Object.getOwnPropertySymbols(helpers).forEach((s2) => {
        helperNameMap[s2] = helpers[s2];
      });
    }
    var locStub = {
      source: "",
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 }
    };
    function createRoot(children, loc = locStub) {
      return {
        type: 0,
        children,
        helpers: [],
        components: [],
        directives: [],
        hoists: [],
        imports: [],
        cached: 0,
        temps: 0,
        codegenNode: void 0,
        loc
      };
    }
    function createVNodeCall(context2, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
      if (context2) {
        if (isBlock) {
          context2.helper(OPEN_BLOCK);
          context2.helper(getVNodeBlockHelper(context2.inSSR, isComponent2));
        } else {
          context2.helper(getVNodeHelper(context2.inSSR, isComponent2));
        }
        if (directives) {
          context2.helper(WITH_DIRECTIVES);
        }
      }
      return {
        type: 13,
        tag,
        props,
        children,
        patchFlag,
        dynamicProps,
        directives,
        isBlock,
        disableTracking,
        isComponent: isComponent2,
        loc
      };
    }
    function createArrayExpression(elements, loc = locStub) {
      return {
        type: 17,
        loc,
        elements
      };
    }
    function createObjectExpression(properties, loc = locStub) {
      return {
        type: 15,
        loc,
        properties
      };
    }
    function createObjectProperty(key, value) {
      return {
        type: 16,
        loc: locStub,
        key: isString2(key) ? createSimpleExpression(key, true) : key,
        value
      };
    }
    function createSimpleExpression(content2, isStatic = false, loc = locStub, constType = 0) {
      return {
        type: 4,
        loc,
        content: content2,
        isStatic,
        constType: isStatic ? 3 : constType
      };
    }
    function createInterpolation(content2, loc) {
      return {
        type: 5,
        loc,
        content: isString2(content2) ? createSimpleExpression(content2, false, loc) : content2
      };
    }
    function createCompoundExpression(children, loc = locStub) {
      return {
        type: 8,
        loc,
        children
      };
    }
    function createCallExpression(callee, args = [], loc = locStub) {
      return {
        type: 14,
        loc,
        callee,
        arguments: args
      };
    }
    function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
      return {
        type: 18,
        params,
        returns,
        newline,
        isSlot,
        loc
      };
    }
    function createConditionalExpression(test, consequent, alternate, newline = true) {
      return {
        type: 19,
        test,
        consequent,
        alternate,
        newline,
        loc: locStub
      };
    }
    function createCacheExpression(index2, value, isVNode = false) {
      return {
        type: 20,
        index: index2,
        value,
        isVNode,
        loc: locStub
      };
    }
    function createBlockStatement(body) {
      return {
        type: 21,
        body,
        loc: locStub
      };
    }
    function createTemplateLiteral(elements) {
      return {
        type: 22,
        elements,
        loc: locStub
      };
    }
    function createIfStatement(test, consequent, alternate) {
      return {
        type: 23,
        test,
        consequent,
        alternate,
        loc: locStub
      };
    }
    function createAssignmentExpression(left, right) {
      return {
        type: 24,
        left,
        right,
        loc: locStub
      };
    }
    function createSequenceExpression(expressions) {
      return {
        type: 25,
        expressions,
        loc: locStub
      };
    }
    function createReturnStatement(returns) {
      return {
        type: 26,
        returns,
        loc: locStub
      };
    }
    var isStaticExp = (p2) => p2.type === 4 && p2.isStatic;
    var isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);
    function isCoreComponent(tag) {
      if (isBuiltInType(tag, "Teleport")) {
        return TELEPORT;
      } else if (isBuiltInType(tag, "Suspense")) {
        return SUSPENSE;
      } else if (isBuiltInType(tag, "KeepAlive")) {
        return KEEP_ALIVE;
      } else if (isBuiltInType(tag, "BaseTransition")) {
        return BASE_TRANSITION;
      }
    }
    var nonIdentifierRE = /^\d|[^\$\w]/;
    var isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
    var validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
    var validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
    var whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
    var isMemberExpressionBrowser = (path2) => {
      path2 = path2.trim().replace(whitespaceRE, (s2) => s2.trim());
      let state = 0;
      let stateStack = [];
      let currentOpenBracketCount = 0;
      let currentOpenParensCount = 0;
      let currentStringType = null;
      for (let i2 = 0; i2 < path2.length; i2++) {
        const char = path2.charAt(i2);
        switch (state) {
          case 0:
            if (char === "[") {
              stateStack.push(state);
              state = 1;
              currentOpenBracketCount++;
            } else if (char === "(") {
              stateStack.push(state);
              state = 2;
              currentOpenParensCount++;
            } else if (!(i2 === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
              return false;
            }
            break;
          case 1:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `[`) {
              currentOpenBracketCount++;
            } else if (char === `]`) {
              if (!--currentOpenBracketCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 2:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `(`) {
              currentOpenParensCount++;
            } else if (char === `)`) {
              if (i2 === path2.length - 1) {
                return false;
              }
              if (!--currentOpenParensCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 3:
            if (char === currentStringType) {
              state = stateStack.pop();
              currentStringType = null;
            }
            break;
        }
      }
      return !currentOpenBracketCount && !currentOpenParensCount;
    };
    var isMemberExpressionNode = NOOP2;
    var isMemberExpression = isMemberExpressionBrowser;
    function getInnerRange(loc, offset2, length) {
      const source2 = loc.source.slice(offset2, offset2 + length);
      const newLoc = {
        source: source2,
        start: advancePositionWithClone(loc.start, loc.source, offset2),
        end: loc.end
      };
      if (length != null) {
        newLoc.end = advancePositionWithClone(loc.start, loc.source, offset2 + length);
      }
      return newLoc;
    }
    function advancePositionWithClone(pos, source2, numberOfCharacters = source2.length) {
      return advancePositionWithMutation(extend2({}, pos), source2, numberOfCharacters);
    }
    function advancePositionWithMutation(pos, source2, numberOfCharacters = source2.length) {
      let linesCount = 0;
      let lastNewLinePos = -1;
      for (let i2 = 0; i2 < numberOfCharacters; i2++) {
        if (source2.charCodeAt(i2) === 10) {
          linesCount++;
          lastNewLinePos = i2;
        }
      }
      pos.offset += numberOfCharacters;
      pos.line += linesCount;
      pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
      return pos;
    }
    function assert2(condition, msg) {
      if (!condition) {
        throw new Error(msg || `unexpected compiler condition`);
      }
    }
    function findDir(node2, name, allowEmpty = false) {
      for (let i2 = 0; i2 < node2.props.length; i2++) {
        const p2 = node2.props[i2];
        if (p2.type === 7 && (allowEmpty || p2.exp) && (isString2(name) ? p2.name === name : name.test(p2.name))) {
          return p2;
        }
      }
    }
    function findProp(node2, name, dynamicOnly = false, allowEmpty = false) {
      for (let i2 = 0; i2 < node2.props.length; i2++) {
        const p2 = node2.props[i2];
        if (p2.type === 6) {
          if (dynamicOnly)
            continue;
          if (p2.name === name && (p2.value || allowEmpty)) {
            return p2;
          }
        } else if (p2.name === "bind" && (p2.exp || allowEmpty) && isStaticArgOf(p2.arg, name)) {
          return p2;
        }
      }
    }
    function isStaticArgOf(arg, name) {
      return !!(arg && isStaticExp(arg) && arg.content === name);
    }
    function hasDynamicKeyVBind(node2) {
      return node2.props.some((p2) => p2.type === 7 && p2.name === "bind" && (!p2.arg || p2.arg.type !== 4 || !p2.arg.isStatic));
    }
    function isText(node2) {
      return node2.type === 5 || node2.type === 2;
    }
    function isVSlot(p2) {
      return p2.type === 7 && p2.name === "slot";
    }
    function isTemplateNode(node2) {
      return node2.type === 1 && node2.tagType === 3;
    }
    function isSlotOutlet(node2) {
      return node2.type === 1 && node2.tagType === 2;
    }
    function getVNodeHelper(ssr, isComponent2) {
      return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
    }
    function getVNodeBlockHelper(ssr, isComponent2) {
      return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
    }
    var propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
    function getUnnormalizedProps(props, callPath = []) {
      if (props && !isString2(props) && props.type === 14) {
        const callee = props.callee;
        if (!isString2(callee) && propsHelperSet.has(callee)) {
          return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
        }
      }
      return [props, callPath];
    }
    function injectProp(node2, prop, context2) {
      let propsWithInjection;
      let props = node2.type === 13 ? node2.props : node2.arguments[2];
      let callPath = [];
      let parentCall;
      if (props && !isString2(props) && props.type === 14) {
        const ret = getUnnormalizedProps(props);
        props = ret[0];
        callPath = ret[1];
        parentCall = callPath[callPath.length - 1];
      }
      if (props == null || isString2(props)) {
        propsWithInjection = createObjectExpression([prop]);
      } else if (props.type === 14) {
        const first2 = props.arguments[0];
        if (!isString2(first2) && first2.type === 15) {
          first2.properties.unshift(prop);
        } else {
          if (props.callee === TO_HANDLERS) {
            propsWithInjection = createCallExpression(context2.helper(MERGE_PROPS), [
              createObjectExpression([prop]),
              props
            ]);
          } else {
            props.arguments.unshift(createObjectExpression([prop]));
          }
        }
        !propsWithInjection && (propsWithInjection = props);
      } else if (props.type === 15) {
        let alreadyExists = false;
        if (prop.key.type === 4) {
          const propKeyName = prop.key.content;
          alreadyExists = props.properties.some((p2) => p2.key.type === 4 && p2.key.content === propKeyName);
        }
        if (!alreadyExists) {
          props.properties.unshift(prop);
        }
        propsWithInjection = props;
      } else {
        propsWithInjection = createCallExpression(context2.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
        if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
          parentCall = callPath[callPath.length - 2];
        }
      }
      if (node2.type === 13) {
        if (parentCall) {
          parentCall.arguments[0] = propsWithInjection;
        } else {
          node2.props = propsWithInjection;
        }
      } else {
        if (parentCall) {
          parentCall.arguments[0] = propsWithInjection;
        } else {
          node2.arguments[2] = propsWithInjection;
        }
      }
    }
    function toValidAssetId(name, type) {
      return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
        return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
      })}`;
    }
    function hasScopeRef(node2, ids) {
      if (!node2 || Object.keys(ids).length === 0) {
        return false;
      }
      switch (node2.type) {
        case 1:
          for (let i2 = 0; i2 < node2.props.length; i2++) {
            const p2 = node2.props[i2];
            if (p2.type === 7 && (hasScopeRef(p2.arg, ids) || hasScopeRef(p2.exp, ids))) {
              return true;
            }
          }
          return node2.children.some((c2) => hasScopeRef(c2, ids));
        case 11:
          if (hasScopeRef(node2.source, ids)) {
            return true;
          }
          return node2.children.some((c2) => hasScopeRef(c2, ids));
        case 9:
          return node2.branches.some((b2) => hasScopeRef(b2, ids));
        case 10:
          if (hasScopeRef(node2.condition, ids)) {
            return true;
          }
          return node2.children.some((c2) => hasScopeRef(c2, ids));
        case 4:
          return !node2.isStatic && isSimpleIdentifier(node2.content) && !!ids[node2.content];
        case 8:
          return node2.children.some((c2) => isObject2(c2) && hasScopeRef(c2, ids));
        case 5:
        case 12:
          return hasScopeRef(node2.content, ids);
        case 2:
        case 3:
          return false;
        default:
          if (true)
            ;
          return false;
      }
    }
    function getMemoedVNodeCall(node2) {
      if (node2.type === 14 && node2.callee === WITH_MEMO) {
        return node2.arguments[1].returns;
      } else {
        return node2;
      }
    }
    function makeBlock(node2, { helper, removeHelper, inSSR }) {
      if (!node2.isBlock) {
        node2.isBlock = true;
        removeHelper(getVNodeHelper(inSSR, node2.isComponent));
        helper(OPEN_BLOCK);
        helper(getVNodeBlockHelper(inSSR, node2.isComponent));
      }
    }
    var deprecationData = {
      ["COMPILER_IS_ON_ELEMENT"]: {
        message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
        link: `https://v3.vuejs.org/guide/migration/custom-elements-interop.html`
      },
      ["COMPILER_V_BIND_SYNC"]: {
        message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
        link: `https://v3.vuejs.org/guide/migration/v-model.html`
      },
      ["COMPILER_V_BIND_PROP"]: {
        message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`
      },
      ["COMPILER_V_BIND_OBJECT_ORDER"]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
        link: `https://v3.vuejs.org/guide/migration/v-bind.html`
      },
      ["COMPILER_V_ON_NATIVE"]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3.vuejs.org/guide/migration/v-on-native-modifier-removed.html`
      },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
        message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
        link: `https://v3.vuejs.org/guide/migration/v-if-v-for.html`
      },
      ["COMPILER_NATIVE_TEMPLATE"]: {
        message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
      },
      ["COMPILER_INLINE_TEMPLATE"]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3.vuejs.org/guide/migration/inline-template-attribute.html`
      },
      ["COMPILER_FILTER"]: {
        message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
        link: `https://v3.vuejs.org/guide/migration/filters.html`
      }
    };
    function getCompatValue(key, context2) {
      const config2 = context2.options ? context2.options.compatConfig : context2.compatConfig;
      const value = config2 && config2[key];
      if (key === "MODE") {
        return value || 3;
      } else {
        return value;
      }
    }
    function isCompatEnabled(key, context2) {
      const mode2 = getCompatValue("MODE", context2);
      const value = getCompatValue(key, context2);
      return mode2 === 3 ? value === true : value !== false;
    }
    function checkCompatEnabled(key, context2, loc, ...args) {
      const enabled = isCompatEnabled(key, context2);
      if (enabled) {
        warnDeprecation(key, context2, loc, ...args);
      }
      return enabled;
    }
    function warnDeprecation(key, context2, loc, ...args) {
      const val = getCompatValue(key, context2);
      if (val === "suppress-warning") {
        return;
      }
      const { message, link: link2 } = deprecationData[key];
      const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link2 ? `
  Details: ${link2}` : ``}`;
      const err = new SyntaxError(msg);
      err.code = key;
      if (loc)
        err.loc = loc;
      context2.onWarn(err);
    }
    var decodeRE = /&(gt|lt|amp|apos|quot);/g;
    var decodeMap = {
      gt: ">",
      lt: "<",
      amp: "&",
      apos: "'",
      quot: '"'
    };
    var defaultParserOptions = {
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0,
      getTextMode: () => 0,
      isVoidTag: NO,
      isPreTag: NO,
      isCustomElement: NO,
      decodeEntities: (rawText) => rawText.replace(decodeRE, (_2, p1) => decodeMap[p1]),
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: true
    };
    function baseParse(content2, options2 = {}) {
      const context2 = createParserContext(content2, options2);
      const start = getCursor(context2);
      return createRoot(parseChildren(context2, 0, []), getSelection(context2, start));
    }
    function createParserContext(content2, rawOptions) {
      const options2 = extend2({}, defaultParserOptions);
      let key;
      for (key in rawOptions) {
        options2[key] = rawOptions[key] === void 0 ? defaultParserOptions[key] : rawOptions[key];
      }
      return {
        options: options2,
        column: 1,
        line: 1,
        offset: 0,
        originalSource: content2,
        source: content2,
        inPre: false,
        inVPre: false,
        onWarn: options2.onWarn
      };
    }
    function parseChildren(context2, mode2, ancestors) {
      const parent = last(ancestors);
      const ns2 = parent ? parent.ns : 0;
      const nodes = [];
      while (!isEnd(context2, mode2, ancestors)) {
        const s2 = context2.source;
        let node2 = void 0;
        if (mode2 === 0 || mode2 === 1) {
          if (!context2.inVPre && startsWith(s2, context2.options.delimiters[0])) {
            node2 = parseInterpolation(context2, mode2);
          } else if (mode2 === 0 && s2[0] === "<") {
            if (s2.length === 1) {
              emitError(context2, 5, 1);
            } else if (s2[1] === "!") {
              if (startsWith(s2, "<!--")) {
                node2 = parseComment(context2);
              } else if (startsWith(s2, "<!DOCTYPE")) {
                node2 = parseBogusComment(context2);
              } else if (startsWith(s2, "<![CDATA[")) {
                if (ns2 !== 0) {
                  node2 = parseCDATA(context2, ancestors);
                } else {
                  emitError(context2, 1);
                  node2 = parseBogusComment(context2);
                }
              } else {
                emitError(context2, 11);
                node2 = parseBogusComment(context2);
              }
            } else if (s2[1] === "/") {
              if (s2.length === 2) {
                emitError(context2, 5, 2);
              } else if (s2[2] === ">") {
                emitError(context2, 14, 2);
                advanceBy(context2, 3);
                continue;
              } else if (/[a-z]/i.test(s2[2])) {
                emitError(context2, 23);
                parseTag(context2, 1, parent);
                continue;
              } else {
                emitError(context2, 12, 2);
                node2 = parseBogusComment(context2);
              }
            } else if (/[a-z]/i.test(s2[1])) {
              node2 = parseElement(context2, ancestors);
              if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE", context2) && node2 && node2.tag === "template" && !node2.props.some((p2) => p2.type === 7 && isSpecialTemplateDirective(p2.name))) {
                warnDeprecation("COMPILER_NATIVE_TEMPLATE", context2, node2.loc);
                node2 = node2.children;
              }
            } else if (s2[1] === "?") {
              emitError(context2, 21, 1);
              node2 = parseBogusComment(context2);
            } else {
              emitError(context2, 12, 1);
            }
          }
        }
        if (!node2) {
          node2 = parseText(context2, mode2);
        }
        if (isArray2(node2)) {
          for (let i2 = 0; i2 < node2.length; i2++) {
            pushNode(nodes, node2[i2]);
          }
        } else {
          pushNode(nodes, node2);
        }
      }
      let removedWhitespace = false;
      if (mode2 !== 2 && mode2 !== 1) {
        const shouldCondense = context2.options.whitespace !== "preserve";
        for (let i2 = 0; i2 < nodes.length; i2++) {
          const node2 = nodes[i2];
          if (!context2.inPre && node2.type === 2) {
            if (!/[^\t\r\n\f ]/.test(node2.content)) {
              const prev = nodes[i2 - 1];
              const next = nodes[i2 + 1];
              if (!prev || !next || shouldCondense && (prev.type === 3 || next.type === 3 || prev.type === 1 && next.type === 1 && /[\r\n]/.test(node2.content))) {
                removedWhitespace = true;
                nodes[i2] = null;
              } else {
                node2.content = " ";
              }
            } else if (shouldCondense) {
              node2.content = node2.content.replace(/[\t\r\n\f ]+/g, " ");
            }
          } else if (node2.type === 3 && !context2.options.comments) {
            removedWhitespace = true;
            nodes[i2] = null;
          }
        }
        if (context2.inPre && parent && context2.options.isPreTag(parent.tag)) {
          const first2 = nodes[0];
          if (first2 && first2.type === 2) {
            first2.content = first2.content.replace(/^\r?\n/, "");
          }
        }
      }
      return removedWhitespace ? nodes.filter(Boolean) : nodes;
    }
    function pushNode(nodes, node2) {
      if (node2.type === 2) {
        const prev = last(nodes);
        if (prev && prev.type === 2 && prev.loc.end.offset === node2.loc.start.offset) {
          prev.content += node2.content;
          prev.loc.end = node2.loc.end;
          prev.loc.source += node2.loc.source;
          return;
        }
      }
      nodes.push(node2);
    }
    function parseCDATA(context2, ancestors) {
      advanceBy(context2, 9);
      const nodes = parseChildren(context2, 3, ancestors);
      if (context2.source.length === 0) {
        emitError(context2, 6);
      } else {
        advanceBy(context2, 3);
      }
      return nodes;
    }
    function parseComment(context2) {
      const start = getCursor(context2);
      let content2;
      const match2 = /--(\!)?>/.exec(context2.source);
      if (!match2) {
        content2 = context2.source.slice(4);
        advanceBy(context2, context2.source.length);
        emitError(context2, 7);
      } else {
        if (match2.index <= 3) {
          emitError(context2, 0);
        }
        if (match2[1]) {
          emitError(context2, 10);
        }
        content2 = context2.source.slice(4, match2.index);
        const s2 = context2.source.slice(0, match2.index);
        let prevIndex = 1, nestedIndex = 0;
        while ((nestedIndex = s2.indexOf("<!--", prevIndex)) !== -1) {
          advanceBy(context2, nestedIndex - prevIndex + 1);
          if (nestedIndex + 4 < s2.length) {
            emitError(context2, 16);
          }
          prevIndex = nestedIndex + 1;
        }
        advanceBy(context2, match2.index + match2[0].length - prevIndex + 1);
      }
      return {
        type: 3,
        content: content2,
        loc: getSelection(context2, start)
      };
    }
    function parseBogusComment(context2) {
      const start = getCursor(context2);
      const contentStart = context2.source[1] === "?" ? 1 : 2;
      let content2;
      const closeIndex = context2.source.indexOf(">");
      if (closeIndex === -1) {
        content2 = context2.source.slice(contentStart);
        advanceBy(context2, context2.source.length);
      } else {
        content2 = context2.source.slice(contentStart, closeIndex);
        advanceBy(context2, closeIndex + 1);
      }
      return {
        type: 3,
        content: content2,
        loc: getSelection(context2, start)
      };
    }
    function parseElement(context2, ancestors) {
      const wasInPre = context2.inPre;
      const wasInVPre = context2.inVPre;
      const parent = last(ancestors);
      const element = parseTag(context2, 0, parent);
      const isPreBoundary = context2.inPre && !wasInPre;
      const isVPreBoundary = context2.inVPre && !wasInVPre;
      if (element.isSelfClosing || context2.options.isVoidTag(element.tag)) {
        if (isPreBoundary) {
          context2.inPre = false;
        }
        if (isVPreBoundary) {
          context2.inVPre = false;
        }
        return element;
      }
      ancestors.push(element);
      const mode2 = context2.options.getTextMode(element, parent);
      const children = parseChildren(context2, mode2, ancestors);
      ancestors.pop();
      {
        const inlineTemplateProp = element.props.find((p2) => p2.type === 6 && p2.name === "inline-template");
        if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", context2, inlineTemplateProp.loc)) {
          const loc = getSelection(context2, element.loc.end);
          inlineTemplateProp.value = {
            type: 2,
            content: loc.source,
            loc
          };
        }
      }
      element.children = children;
      if (startsWithEndTagOpen(context2.source, element.tag)) {
        parseTag(context2, 1, parent);
      } else {
        emitError(context2, 24, 0, element.loc.start);
        if (context2.source.length === 0 && element.tag.toLowerCase() === "script") {
          const first2 = children[0];
          if (first2 && startsWith(first2.loc.source, "<!--")) {
            emitError(context2, 8);
          }
        }
      }
      element.loc = getSelection(context2, element.loc.start);
      if (isPreBoundary) {
        context2.inPre = false;
      }
      if (isVPreBoundary) {
        context2.inVPre = false;
      }
      return element;
    }
    var isSpecialTemplateDirective = makeMap(`if,else,else-if,for,slot`);
    function parseTag(context2, type, parent) {
      const start = getCursor(context2);
      const match2 = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context2.source);
      const tag = match2[1];
      const ns2 = context2.options.getNamespace(tag, parent);
      advanceBy(context2, match2[0].length);
      advanceSpaces(context2);
      const cursor = getCursor(context2);
      const currentSource = context2.source;
      if (context2.options.isPreTag(tag)) {
        context2.inPre = true;
      }
      let props = parseAttributes(context2, type);
      if (type === 0 && !context2.inVPre && props.some((p2) => p2.type === 7 && p2.name === "pre")) {
        context2.inVPre = true;
        extend2(context2, cursor);
        context2.source = currentSource;
        props = parseAttributes(context2, type).filter((p2) => p2.name !== "v-pre");
      }
      let isSelfClosing = false;
      if (context2.source.length === 0) {
        emitError(context2, 9);
      } else {
        isSelfClosing = startsWith(context2.source, "/>");
        if (type === 1 && isSelfClosing) {
          emitError(context2, 4);
        }
        advanceBy(context2, isSelfClosing ? 2 : 1);
      }
      if (type === 1) {
        return;
      }
      if (isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE", context2)) {
        let hasIf = false;
        let hasFor = false;
        for (let i2 = 0; i2 < props.length; i2++) {
          const p2 = props[i2];
          if (p2.type === 7) {
            if (p2.name === "if") {
              hasIf = true;
            } else if (p2.name === "for") {
              hasFor = true;
            }
          }
          if (hasIf && hasFor) {
            warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE", context2, getSelection(context2, start));
            break;
          }
        }
      }
      let tagType = 0;
      if (!context2.inVPre) {
        if (tag === "slot") {
          tagType = 2;
        } else if (tag === "template") {
          if (props.some((p2) => p2.type === 7 && isSpecialTemplateDirective(p2.name))) {
            tagType = 3;
          }
        } else if (isComponent(tag, props, context2)) {
          tagType = 1;
        }
      }
      return {
        type: 1,
        ns: ns2,
        tag,
        tagType,
        props,
        isSelfClosing,
        children: [],
        loc: getSelection(context2, start),
        codegenNode: void 0
      };
    }
    function isComponent(tag, props, context2) {
      const options2 = context2.options;
      if (options2.isCustomElement(tag)) {
        return false;
      }
      if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options2.isBuiltInComponent && options2.isBuiltInComponent(tag) || options2.isNativeTag && !options2.isNativeTag(tag)) {
        return true;
      }
      for (let i2 = 0; i2 < props.length; i2++) {
        const p2 = props[i2];
        if (p2.type === 6) {
          if (p2.name === "is" && p2.value) {
            if (p2.value.content.startsWith("vue:")) {
              return true;
            } else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context2, p2.loc)) {
              return true;
            }
          }
        } else {
          if (p2.name === "is") {
            return true;
          } else if (p2.name === "bind" && isStaticArgOf(p2.arg, "is") && true && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context2, p2.loc)) {
            return true;
          }
        }
      }
    }
    function parseAttributes(context2, type) {
      const props = [];
      const attributeNames = new Set();
      while (context2.source.length > 0 && !startsWith(context2.source, ">") && !startsWith(context2.source, "/>")) {
        if (startsWith(context2.source, "/")) {
          emitError(context2, 22);
          advanceBy(context2, 1);
          advanceSpaces(context2);
          continue;
        }
        if (type === 1) {
          emitError(context2, 3);
        }
        const attr = parseAttribute(context2, attributeNames);
        if (attr.type === 6 && attr.value && attr.name === "class") {
          attr.value.content = attr.value.content.replace(/\s+/g, " ").trim();
        }
        if (type === 0) {
          props.push(attr);
        }
        if (/^[^\t\r\n\f />]/.test(context2.source)) {
          emitError(context2, 15);
        }
        advanceSpaces(context2);
      }
      return props;
    }
    function parseAttribute(context2, nameSet) {
      const start = getCursor(context2);
      const match2 = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context2.source);
      const name = match2[0];
      if (nameSet.has(name)) {
        emitError(context2, 2);
      }
      nameSet.add(name);
      if (name[0] === "=") {
        emitError(context2, 19);
      }
      {
        const pattern2 = /["'<]/g;
        let m3;
        while (m3 = pattern2.exec(name)) {
          emitError(context2, 17, m3.index);
        }
      }
      advanceBy(context2, name.length);
      let value = void 0;
      if (/^[\t\r\n\f ]*=/.test(context2.source)) {
        advanceSpaces(context2);
        advanceBy(context2, 1);
        advanceSpaces(context2);
        value = parseAttributeValue(context2);
        if (!value) {
          emitError(context2, 13);
        }
      }
      const loc = getSelection(context2, start);
      if (!context2.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
        const match3 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
        let isPropShorthand = startsWith(name, ".");
        let dirName = match3[1] || (isPropShorthand || startsWith(name, ":") ? "bind" : startsWith(name, "@") ? "on" : "slot");
        let arg;
        if (match3[2]) {
          const isSlot = dirName === "slot";
          const startOffset = name.lastIndexOf(match3[2]);
          const loc2 = getSelection(context2, getNewPosition(context2, start, startOffset), getNewPosition(context2, start, startOffset + match3[2].length + (isSlot && match3[3] || "").length));
          let content2 = match3[2];
          let isStatic = true;
          if (content2.startsWith("[")) {
            isStatic = false;
            if (!content2.endsWith("]")) {
              emitError(context2, 27);
              content2 = content2.slice(1);
            } else {
              content2 = content2.slice(1, content2.length - 1);
            }
          } else if (isSlot) {
            content2 += match3[3] || "";
          }
          arg = {
            type: 4,
            content: content2,
            isStatic,
            constType: isStatic ? 3 : 0,
            loc: loc2
          };
        }
        if (value && value.isQuoted) {
          const valueLoc = value.loc;
          valueLoc.start.offset++;
          valueLoc.start.column++;
          valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
          valueLoc.source = valueLoc.source.slice(1, -1);
        }
        const modifiers = match3[3] ? match3[3].slice(1).split(".") : [];
        if (isPropShorthand)
          modifiers.push("prop");
        if (dirName === "bind" && arg) {
          if (modifiers.includes("sync") && checkCompatEnabled("COMPILER_V_BIND_SYNC", context2, loc, arg.loc.source)) {
            dirName = "model";
            modifiers.splice(modifiers.indexOf("sync"), 1);
          }
          if (modifiers.includes("prop")) {
            checkCompatEnabled("COMPILER_V_BIND_PROP", context2, loc);
          }
        }
        return {
          type: 7,
          name: dirName,
          exp: value && {
            type: 4,
            content: value.content,
            isStatic: false,
            constType: 0,
            loc: value.loc
          },
          arg,
          modifiers,
          loc
        };
      }
      if (!context2.inVPre && startsWith(name, "v-")) {
        emitError(context2, 26);
      }
      return {
        type: 6,
        name,
        value: value && {
          type: 2,
          content: value.content,
          loc: value.loc
        },
        loc
      };
    }
    function parseAttributeValue(context2) {
      const start = getCursor(context2);
      let content2;
      const quote = context2.source[0];
      const isQuoted = quote === `"` || quote === `'`;
      if (isQuoted) {
        advanceBy(context2, 1);
        const endIndex = context2.source.indexOf(quote);
        if (endIndex === -1) {
          content2 = parseTextData(context2, context2.source.length, 4);
        } else {
          content2 = parseTextData(context2, endIndex, 4);
          advanceBy(context2, 1);
        }
      } else {
        const match2 = /^[^\t\r\n\f >]+/.exec(context2.source);
        if (!match2) {
          return void 0;
        }
        const unexpectedChars = /["'<=`]/g;
        let m3;
        while (m3 = unexpectedChars.exec(match2[0])) {
          emitError(context2, 18, m3.index);
        }
        content2 = parseTextData(context2, match2[0].length, 4);
      }
      return { content: content2, isQuoted, loc: getSelection(context2, start) };
    }
    function parseInterpolation(context2, mode2) {
      const [open2, close2] = context2.options.delimiters;
      const closeIndex = context2.source.indexOf(close2, open2.length);
      if (closeIndex === -1) {
        emitError(context2, 25);
        return void 0;
      }
      const start = getCursor(context2);
      advanceBy(context2, open2.length);
      const innerStart = getCursor(context2);
      const innerEnd = getCursor(context2);
      const rawContentLength = closeIndex - open2.length;
      const rawContent = context2.source.slice(0, rawContentLength);
      const preTrimContent = parseTextData(context2, rawContentLength, mode2);
      const content2 = preTrimContent.trim();
      const startOffset = preTrimContent.indexOf(content2);
      if (startOffset > 0) {
        advancePositionWithMutation(innerStart, rawContent, startOffset);
      }
      const endOffset = rawContentLength - (preTrimContent.length - content2.length - startOffset);
      advancePositionWithMutation(innerEnd, rawContent, endOffset);
      advanceBy(context2, close2.length);
      return {
        type: 5,
        content: {
          type: 4,
          isStatic: false,
          constType: 0,
          content: content2,
          loc: getSelection(context2, innerStart, innerEnd)
        },
        loc: getSelection(context2, start)
      };
    }
    function parseText(context2, mode2) {
      const endTokens = mode2 === 3 ? ["]]>"] : ["<", context2.options.delimiters[0]];
      let endIndex = context2.source.length;
      for (let i2 = 0; i2 < endTokens.length; i2++) {
        const index2 = context2.source.indexOf(endTokens[i2], 1);
        if (index2 !== -1 && endIndex > index2) {
          endIndex = index2;
        }
      }
      const start = getCursor(context2);
      const content2 = parseTextData(context2, endIndex, mode2);
      return {
        type: 2,
        content: content2,
        loc: getSelection(context2, start)
      };
    }
    function parseTextData(context2, length, mode2) {
      const rawText = context2.source.slice(0, length);
      advanceBy(context2, length);
      if (mode2 === 2 || mode2 === 3 || rawText.indexOf("&") === -1) {
        return rawText;
      } else {
        return context2.options.decodeEntities(rawText, mode2 === 4);
      }
    }
    function getCursor(context2) {
      const { column, line, offset: offset2 } = context2;
      return { column, line, offset: offset2 };
    }
    function getSelection(context2, start, end) {
      end = end || getCursor(context2);
      return {
        start,
        end,
        source: context2.originalSource.slice(start.offset, end.offset)
      };
    }
    function last(xs2) {
      return xs2[xs2.length - 1];
    }
    function startsWith(source2, searchString) {
      return source2.startsWith(searchString);
    }
    function advanceBy(context2, numberOfCharacters) {
      const { source: source2 } = context2;
      advancePositionWithMutation(context2, source2, numberOfCharacters);
      context2.source = source2.slice(numberOfCharacters);
    }
    function advanceSpaces(context2) {
      const match2 = /^[\t\r\n\f ]+/.exec(context2.source);
      if (match2) {
        advanceBy(context2, match2[0].length);
      }
    }
    function getNewPosition(context2, start, numberOfCharacters) {
      return advancePositionWithClone(start, context2.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
    }
    function emitError(context2, code, offset2, loc = getCursor(context2)) {
      if (offset2) {
        loc.offset += offset2;
        loc.column += offset2;
      }
      context2.options.onError(createCompilerError(code, {
        start: loc,
        end: loc,
        source: ""
      }));
    }
    function isEnd(context2, mode2, ancestors) {
      const s2 = context2.source;
      switch (mode2) {
        case 0:
          if (startsWith(s2, "</")) {
            for (let i2 = ancestors.length - 1; i2 >= 0; --i2) {
              if (startsWithEndTagOpen(s2, ancestors[i2].tag)) {
                return true;
              }
            }
          }
          break;
        case 1:
        case 2: {
          const parent = last(ancestors);
          if (parent && startsWithEndTagOpen(s2, parent.tag)) {
            return true;
          }
          break;
        }
        case 3:
          if (startsWith(s2, "]]>")) {
            return true;
          }
          break;
      }
      return !s2;
    }
    function startsWithEndTagOpen(source2, tag) {
      return startsWith(source2, "</") && source2.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source2[2 + tag.length] || ">");
    }
    function hoistStatic(root, context2) {
      walk2(root, context2, isSingleElementRoot(root, root.children[0]));
    }
    function isSingleElementRoot(root, child) {
      const { children } = root;
      return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
    }
    function walk2(node2, context2, doNotHoistNode = false) {
      const { children } = node2;
      const originalCount = children.length;
      let hoistedCount = 0;
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (child.type === 1 && child.tagType === 0) {
          const constantType = doNotHoistNode ? 0 : getConstantType(child, context2);
          if (constantType > 0) {
            if (constantType >= 2) {
              child.codegenNode.patchFlag = -1 + (true ? ` /* HOISTED */` : ``);
              child.codegenNode = context2.hoist(child.codegenNode);
              hoistedCount++;
              continue;
            }
          } else {
            const codegenNode = child.codegenNode;
            if (codegenNode.type === 13) {
              const flag = getPatchFlag(codegenNode);
              if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context2) >= 2) {
                const props = getNodeProps(child);
                if (props) {
                  codegenNode.props = context2.hoist(props);
                }
              }
              if (codegenNode.dynamicProps) {
                codegenNode.dynamicProps = context2.hoist(codegenNode.dynamicProps);
              }
            }
          }
        } else if (child.type === 12 && getConstantType(child.content, context2) >= 2) {
          child.codegenNode = context2.hoist(child.codegenNode);
          hoistedCount++;
        }
        if (child.type === 1) {
          const isComponent2 = child.tagType === 1;
          if (isComponent2) {
            context2.scopes.vSlot++;
          }
          walk2(child, context2);
          if (isComponent2) {
            context2.scopes.vSlot--;
          }
        } else if (child.type === 11) {
          walk2(child, context2, child.children.length === 1);
        } else if (child.type === 9) {
          for (let i3 = 0; i3 < child.branches.length; i3++) {
            walk2(child.branches[i3], context2, child.branches[i3].children.length === 1);
          }
        }
      }
      if (hoistedCount && context2.transformHoist) {
        context2.transformHoist(children, context2, node2);
      }
      if (hoistedCount && hoistedCount === originalCount && node2.type === 1 && node2.tagType === 0 && node2.codegenNode && node2.codegenNode.type === 13 && isArray2(node2.codegenNode.children)) {
        node2.codegenNode.children = context2.hoist(createArrayExpression(node2.codegenNode.children));
      }
    }
    function getConstantType(node2, context2) {
      const { constantCache } = context2;
      switch (node2.type) {
        case 1:
          if (node2.tagType !== 0) {
            return 0;
          }
          const cached = constantCache.get(node2);
          if (cached !== void 0) {
            return cached;
          }
          const codegenNode = node2.codegenNode;
          if (codegenNode.type !== 13) {
            return 0;
          }
          if (codegenNode.isBlock && node2.tag !== "svg" && node2.tag !== "foreignObject") {
            return 0;
          }
          const flag = getPatchFlag(codegenNode);
          if (!flag) {
            let returnType2 = 3;
            const generatedPropsType = getGeneratedPropsConstantType(node2, context2);
            if (generatedPropsType === 0) {
              constantCache.set(node2, 0);
              return 0;
            }
            if (generatedPropsType < returnType2) {
              returnType2 = generatedPropsType;
            }
            for (let i2 = 0; i2 < node2.children.length; i2++) {
              const childType = getConstantType(node2.children[i2], context2);
              if (childType === 0) {
                constantCache.set(node2, 0);
                return 0;
              }
              if (childType < returnType2) {
                returnType2 = childType;
              }
            }
            if (returnType2 > 1) {
              for (let i2 = 0; i2 < node2.props.length; i2++) {
                const p2 = node2.props[i2];
                if (p2.type === 7 && p2.name === "bind" && p2.exp) {
                  const expType = getConstantType(p2.exp, context2);
                  if (expType === 0) {
                    constantCache.set(node2, 0);
                    return 0;
                  }
                  if (expType < returnType2) {
                    returnType2 = expType;
                  }
                }
              }
            }
            if (codegenNode.isBlock) {
              context2.removeHelper(OPEN_BLOCK);
              context2.removeHelper(getVNodeBlockHelper(context2.inSSR, codegenNode.isComponent));
              codegenNode.isBlock = false;
              context2.helper(getVNodeHelper(context2.inSSR, codegenNode.isComponent));
            }
            constantCache.set(node2, returnType2);
            return returnType2;
          } else {
            constantCache.set(node2, 0);
            return 0;
          }
        case 2:
        case 3:
          return 3;
        case 9:
        case 11:
        case 10:
          return 0;
        case 5:
        case 12:
          return getConstantType(node2.content, context2);
        case 4:
          return node2.constType;
        case 8:
          let returnType = 3;
          for (let i2 = 0; i2 < node2.children.length; i2++) {
            const child = node2.children[i2];
            if (isString2(child) || isSymbol(child)) {
              continue;
            }
            const childType = getConstantType(child, context2);
            if (childType === 0) {
              return 0;
            } else if (childType < returnType) {
              returnType = childType;
            }
          }
          return returnType;
        default:
          if (true)
            ;
          return 0;
      }
    }
    var allowHoistedHelperSet = new Set([
      NORMALIZE_CLASS,
      NORMALIZE_STYLE,
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS
    ]);
    function getConstantTypeOfHelperCall(value, context2) {
      if (value.type === 14 && !isString2(value.callee) && allowHoistedHelperSet.has(value.callee)) {
        const arg = value.arguments[0];
        if (arg.type === 4) {
          return getConstantType(arg, context2);
        } else if (arg.type === 14) {
          return getConstantTypeOfHelperCall(arg, context2);
        }
      }
      return 0;
    }
    function getGeneratedPropsConstantType(node2, context2) {
      let returnType = 3;
      const props = getNodeProps(node2);
      if (props && props.type === 15) {
        const { properties } = props;
        for (let i2 = 0; i2 < properties.length; i2++) {
          const { key, value } = properties[i2];
          const keyType = getConstantType(key, context2);
          if (keyType === 0) {
            return keyType;
          }
          if (keyType < returnType) {
            returnType = keyType;
          }
          let valueType;
          if (value.type === 4) {
            valueType = getConstantType(value, context2);
          } else if (value.type === 14) {
            valueType = getConstantTypeOfHelperCall(value, context2);
          } else {
            valueType = 0;
          }
          if (valueType === 0) {
            return valueType;
          }
          if (valueType < returnType) {
            returnType = valueType;
          }
        }
      }
      return returnType;
    }
    function getNodeProps(node2) {
      const codegenNode = node2.codegenNode;
      if (codegenNode.type === 13) {
        return codegenNode.props;
      }
    }
    function getPatchFlag(node2) {
      const flag = node2.patchFlag;
      return flag ? parseInt(flag, 10) : void 0;
    }
    function createTransformContext(root, { filename: filename2 = "", prefixIdentifiers = false, hoistStatic: hoistStatic2 = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP2, isCustomElement = NOOP2, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
      const nameMatch = filename2.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
      const context2 = {
        selfName: nameMatch && capitalize(camelize$1(nameMatch[1])),
        prefixIdentifiers,
        hoistStatic: hoistStatic2,
        cacheHandlers,
        nodeTransforms,
        directiveTransforms,
        transformHoist,
        isBuiltInComponent,
        isCustomElement,
        expressionPlugins,
        scopeId,
        slotted,
        ssr,
        inSSR,
        ssrCssVars,
        bindingMetadata,
        inline,
        isTS,
        onError,
        onWarn,
        compatConfig,
        root,
        helpers: new Map(),
        components: new Set(),
        directives: new Set(),
        hoists: [],
        imports: [],
        constantCache: new Map(),
        temps: 0,
        cached: 0,
        identifiers: Object.create(null),
        scopes: {
          vFor: 0,
          vSlot: 0,
          vPre: 0,
          vOnce: 0
        },
        parent: null,
        currentNode: root,
        childIndex: 0,
        inVOnce: false,
        helper(name) {
          const count = context2.helpers.get(name) || 0;
          context2.helpers.set(name, count + 1);
          return name;
        },
        removeHelper(name) {
          const count = context2.helpers.get(name);
          if (count) {
            const currentCount = count - 1;
            if (!currentCount) {
              context2.helpers.delete(name);
            } else {
              context2.helpers.set(name, currentCount);
            }
          }
        },
        helperString(name) {
          return `_${helperNameMap[context2.helper(name)]}`;
        },
        replaceNode(node2) {
          if (true) {
            if (!context2.currentNode) {
              throw new Error(`Node being replaced is already removed.`);
            }
            if (!context2.parent) {
              throw new Error(`Cannot replace root node.`);
            }
          }
          context2.parent.children[context2.childIndex] = context2.currentNode = node2;
        },
        removeNode(node2) {
          if (!context2.parent) {
            throw new Error(`Cannot remove root node.`);
          }
          const list2 = context2.parent.children;
          const removalIndex = node2 ? list2.indexOf(node2) : context2.currentNode ? context2.childIndex : -1;
          if (removalIndex < 0) {
            throw new Error(`node being removed is not a child of current parent`);
          }
          if (!node2 || node2 === context2.currentNode) {
            context2.currentNode = null;
            context2.onNodeRemoved();
          } else {
            if (context2.childIndex > removalIndex) {
              context2.childIndex--;
              context2.onNodeRemoved();
            }
          }
          context2.parent.children.splice(removalIndex, 1);
        },
        onNodeRemoved: () => {
        },
        addIdentifiers(exp) {
        },
        removeIdentifiers(exp) {
        },
        hoist(exp) {
          if (isString2(exp))
            exp = createSimpleExpression(exp);
          context2.hoists.push(exp);
          const identifier = createSimpleExpression(`_hoisted_${context2.hoists.length}`, false, exp.loc, 2);
          identifier.hoisted = exp;
          return identifier;
        },
        cache(exp, isVNode = false) {
          return createCacheExpression(context2.cached++, exp, isVNode);
        }
      };
      {
        context2.filters = new Set();
      }
      return context2;
    }
    function transform2(root, options2) {
      const context2 = createTransformContext(root, options2);
      traverseNode(root, context2);
      if (options2.hoistStatic) {
        hoistStatic(root, context2);
      }
      if (!options2.ssr) {
        createRootCodegen(root, context2);
      }
      root.helpers = [...context2.helpers.keys()];
      root.components = [...context2.components];
      root.directives = [...context2.directives];
      root.imports = context2.imports;
      root.hoists = context2.hoists;
      root.temps = context2.temps;
      root.cached = context2.cached;
      {
        root.filters = [...context2.filters];
      }
    }
    function createRootCodegen(root, context2) {
      const { helper } = context2;
      const { children } = root;
      if (children.length === 1) {
        const child = children[0];
        if (isSingleElementRoot(root, child) && child.codegenNode) {
          const codegenNode = child.codegenNode;
          if (codegenNode.type === 13) {
            makeBlock(codegenNode, context2);
          }
          root.codegenNode = codegenNode;
        } else {
          root.codegenNode = child;
        }
      } else if (children.length > 1) {
        let patchFlag = 64;
        let patchFlagText = PatchFlagNames[64];
        if (children.filter((c2) => c2.type !== 3).length === 1) {
          patchFlag |= 2048;
          patchFlagText += `, ${PatchFlagNames[2048]}`;
        }
        root.codegenNode = createVNodeCall(context2, helper(FRAGMENT), void 0, root.children, patchFlag + (true ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, void 0, false);
      } else
        ;
    }
    function traverseChildren(parent, context2) {
      let i2 = 0;
      const nodeRemoved = () => {
        i2--;
      };
      for (; i2 < parent.children.length; i2++) {
        const child = parent.children[i2];
        if (isString2(child))
          continue;
        context2.parent = parent;
        context2.childIndex = i2;
        context2.onNodeRemoved = nodeRemoved;
        traverseNode(child, context2);
      }
    }
    function traverseNode(node2, context2) {
      context2.currentNode = node2;
      const { nodeTransforms } = context2;
      const exitFns = [];
      for (let i3 = 0; i3 < nodeTransforms.length; i3++) {
        const onExit2 = nodeTransforms[i3](node2, context2);
        if (onExit2) {
          if (isArray2(onExit2)) {
            exitFns.push(...onExit2);
          } else {
            exitFns.push(onExit2);
          }
        }
        if (!context2.currentNode) {
          return;
        } else {
          node2 = context2.currentNode;
        }
      }
      switch (node2.type) {
        case 3:
          if (!context2.ssr) {
            context2.helper(CREATE_COMMENT);
          }
          break;
        case 5:
          if (!context2.ssr) {
            context2.helper(TO_DISPLAY_STRING);
          }
          break;
        case 9:
          for (let i3 = 0; i3 < node2.branches.length; i3++) {
            traverseNode(node2.branches[i3], context2);
          }
          break;
        case 10:
        case 11:
        case 1:
        case 0:
          traverseChildren(node2, context2);
          break;
      }
      context2.currentNode = node2;
      let i2 = exitFns.length;
      while (i2--) {
        exitFns[i2]();
      }
    }
    function createStructuralDirectiveTransform(name, fn2) {
      const matches2 = isString2(name) ? (n3) => n3 === name : (n3) => name.test(n3);
      return (node2, context2) => {
        if (node2.type === 1) {
          const { props } = node2;
          if (node2.tagType === 3 && props.some(isVSlot)) {
            return;
          }
          const exitFns = [];
          for (let i2 = 0; i2 < props.length; i2++) {
            const prop = props[i2];
            if (prop.type === 7 && matches2(prop.name)) {
              props.splice(i2, 1);
              i2--;
              const onExit2 = fn2(node2, prop, context2);
              if (onExit2)
                exitFns.push(onExit2);
            }
          }
          return exitFns;
        }
      };
    }
    var PURE_ANNOTATION = `/*#__PURE__*/`;
    function createCodegenContext(ast, { mode: mode2 = "function", prefixIdentifiers = mode2 === "module", sourceMap = false, filename: filename2 = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = "vue/server-renderer", ssr = false, isTS = false, inSSR = false }) {
      const context2 = {
        mode: mode2,
        prefixIdentifiers,
        sourceMap,
        filename: filename2,
        scopeId,
        optimizeImports,
        runtimeGlobalName,
        runtimeModuleName,
        ssrRuntimeModuleName,
        ssr,
        isTS,
        inSSR,
        source: ast.loc.source,
        code: ``,
        column: 1,
        line: 1,
        offset: 0,
        indentLevel: 0,
        pure: false,
        map: void 0,
        helper(key) {
          return `_${helperNameMap[key]}`;
        },
        push(code, node2) {
          context2.code += code;
        },
        indent() {
          newline(++context2.indentLevel);
        },
        deindent(withoutNewLine = false) {
          if (withoutNewLine) {
            --context2.indentLevel;
          } else {
            newline(--context2.indentLevel);
          }
        },
        newline() {
          newline(context2.indentLevel);
        }
      };
      function newline(n3) {
        context2.push("\n" + `  `.repeat(n3));
      }
      return context2;
    }
    function generate2(ast, options2 = {}) {
      const context2 = createCodegenContext(ast, options2);
      if (options2.onContextCreated)
        options2.onContextCreated(context2);
      const { mode: mode2, push: push2, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context2;
      const hasHelpers = ast.helpers.length > 0;
      const useWithBlock = !prefixIdentifiers && mode2 !== "module";
      const preambleContext = context2;
      {
        genFunctionPreamble(ast, preambleContext);
      }
      const functionName = ssr ? `ssrRender` : `render`;
      const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
      const signature = args.join(", ");
      {
        push2(`function ${functionName}(${signature}) {`);
      }
      indent();
      if (useWithBlock) {
        push2(`with (_ctx) {`);
        indent();
        if (hasHelpers) {
          push2(`const { ${ast.helpers.map((s2) => `${helperNameMap[s2]}: _${helperNameMap[s2]}`).join(", ")} } = _Vue`);
          push2(`
`);
          newline();
        }
      }
      if (ast.components.length) {
        genAssets(ast.components, "component", context2);
        if (ast.directives.length || ast.temps > 0) {
          newline();
        }
      }
      if (ast.directives.length) {
        genAssets(ast.directives, "directive", context2);
        if (ast.temps > 0) {
          newline();
        }
      }
      if (ast.filters && ast.filters.length) {
        newline();
        genAssets(ast.filters, "filter", context2);
        newline();
      }
      if (ast.temps > 0) {
        push2(`let `);
        for (let i2 = 0; i2 < ast.temps; i2++) {
          push2(`${i2 > 0 ? `, ` : ``}_temp${i2}`);
        }
      }
      if (ast.components.length || ast.directives.length || ast.temps) {
        push2(`
`);
        newline();
      }
      if (!ssr) {
        push2(`return `);
      }
      if (ast.codegenNode) {
        genNode(ast.codegenNode, context2);
      } else {
        push2(`null`);
      }
      if (useWithBlock) {
        deindent();
        push2(`}`);
      }
      deindent();
      push2(`}`);
      return {
        ast,
        code: context2.code,
        preamble: ``,
        map: context2.map ? context2.map.toJSON() : void 0
      };
    }
    function genFunctionPreamble(ast, context2) {
      const { ssr, prefixIdentifiers, push: push2, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context2;
      const VueBinding = runtimeGlobalName;
      const aliasHelper = (s2) => `${helperNameMap[s2]}: _${helperNameMap[s2]}`;
      if (ast.helpers.length > 0) {
        {
          push2(`const _Vue = ${VueBinding}
`);
          if (ast.hoists.length) {
            const staticHelpers = [
              CREATE_VNODE,
              CREATE_ELEMENT_VNODE,
              CREATE_COMMENT,
              CREATE_TEXT,
              CREATE_STATIC
            ].filter((helper) => ast.helpers.includes(helper)).map(aliasHelper).join(", ");
            push2(`const { ${staticHelpers} } = _Vue
`);
          }
        }
      }
      genHoists(ast.hoists, context2);
      newline();
      push2(`return `);
    }
    function genAssets(assets, type, { helper, push: push2, newline, isTS }) {
      const resolver = helper(type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
      for (let i2 = 0; i2 < assets.length; i2++) {
        let id = assets[i2];
        const maybeSelfReference = id.endsWith("__self");
        if (maybeSelfReference) {
          id = id.slice(0, -6);
        }
        push2(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
        if (i2 < assets.length - 1) {
          newline();
        }
      }
    }
    function genHoists(hoists, context2) {
      if (!hoists.length) {
        return;
      }
      context2.pure = true;
      const { push: push2, newline, helper, scopeId, mode: mode2 } = context2;
      newline();
      for (let i2 = 0; i2 < hoists.length; i2++) {
        const exp = hoists[i2];
        if (exp) {
          push2(`const _hoisted_${i2 + 1} = ${``}`);
          genNode(exp, context2);
          newline();
        }
      }
      context2.pure = false;
    }
    function isText$1(n3) {
      return isString2(n3) || n3.type === 4 || n3.type === 2 || n3.type === 5 || n3.type === 8;
    }
    function genNodeListAsArray(nodes, context2) {
      const multilines = nodes.length > 3 || nodes.some((n3) => isArray2(n3) || !isText$1(n3));
      context2.push(`[`);
      multilines && context2.indent();
      genNodeList(nodes, context2, multilines);
      multilines && context2.deindent();
      context2.push(`]`);
    }
    function genNodeList(nodes, context2, multilines = false, comma = true) {
      const { push: push2, newline } = context2;
      for (let i2 = 0; i2 < nodes.length; i2++) {
        const node2 = nodes[i2];
        if (isString2(node2)) {
          push2(node2);
        } else if (isArray2(node2)) {
          genNodeListAsArray(node2, context2);
        } else {
          genNode(node2, context2);
        }
        if (i2 < nodes.length - 1) {
          if (multilines) {
            comma && push2(",");
            newline();
          } else {
            comma && push2(", ");
          }
        }
      }
    }
    function genNode(node2, context2) {
      if (isString2(node2)) {
        context2.push(node2);
        return;
      }
      if (isSymbol(node2)) {
        context2.push(context2.helper(node2));
        return;
      }
      switch (node2.type) {
        case 1:
        case 9:
        case 11:
          assert2(node2.codegenNode != null, `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`);
          genNode(node2.codegenNode, context2);
          break;
        case 2:
          genText(node2, context2);
          break;
        case 4:
          genExpression(node2, context2);
          break;
        case 5:
          genInterpolation(node2, context2);
          break;
        case 12:
          genNode(node2.codegenNode, context2);
          break;
        case 8:
          genCompoundExpression(node2, context2);
          break;
        case 3:
          genComment(node2, context2);
          break;
        case 13:
          genVNodeCall(node2, context2);
          break;
        case 14:
          genCallExpression(node2, context2);
          break;
        case 15:
          genObjectExpression(node2, context2);
          break;
        case 17:
          genArrayExpression(node2, context2);
          break;
        case 18:
          genFunctionExpression(node2, context2);
          break;
        case 19:
          genConditionalExpression(node2, context2);
          break;
        case 20:
          genCacheExpression(node2, context2);
          break;
        case 21:
          genNodeList(node2.body, context2, true, false);
          break;
        case 22:
          break;
        case 23:
          break;
        case 24:
          break;
        case 25:
          break;
        case 26:
          break;
        case 10:
          break;
        default:
          if (true) {
            assert2(false, `unhandled codegen node type: ${node2.type}`);
            const exhaustiveCheck = node2;
            return exhaustiveCheck;
          }
      }
    }
    function genText(node2, context2) {
      context2.push(JSON.stringify(node2.content), node2);
    }
    function genExpression(node2, context2) {
      const { content: content2, isStatic } = node2;
      context2.push(isStatic ? JSON.stringify(content2) : content2, node2);
    }
    function genInterpolation(node2, context2) {
      const { push: push2, helper, pure } = context2;
      if (pure)
        push2(PURE_ANNOTATION);
      push2(`${helper(TO_DISPLAY_STRING)}(`);
      genNode(node2.content, context2);
      push2(`)`);
    }
    function genCompoundExpression(node2, context2) {
      for (let i2 = 0; i2 < node2.children.length; i2++) {
        const child = node2.children[i2];
        if (isString2(child)) {
          context2.push(child);
        } else {
          genNode(child, context2);
        }
      }
    }
    function genExpressionAsPropertyKey(node2, context2) {
      const { push: push2 } = context2;
      if (node2.type === 8) {
        push2(`[`);
        genCompoundExpression(node2, context2);
        push2(`]`);
      } else if (node2.isStatic) {
        const text = isSimpleIdentifier(node2.content) ? node2.content : JSON.stringify(node2.content);
        push2(text, node2);
      } else {
        push2(`[${node2.content}]`, node2);
      }
    }
    function genComment(node2, context2) {
      const { push: push2, helper, pure } = context2;
      if (pure) {
        push2(PURE_ANNOTATION);
      }
      push2(`${helper(CREATE_COMMENT)}(${JSON.stringify(node2.content)})`, node2);
    }
    function genVNodeCall(node2, context2) {
      const { push: push2, helper, pure } = context2;
      const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent: isComponent2 } = node2;
      if (directives) {
        push2(helper(WITH_DIRECTIVES) + `(`);
      }
      if (isBlock) {
        push2(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
      }
      if (pure) {
        push2(PURE_ANNOTATION);
      }
      const callHelper = isBlock ? getVNodeBlockHelper(context2.inSSR, isComponent2) : getVNodeHelper(context2.inSSR, isComponent2);
      push2(helper(callHelper) + `(`, node2);
      genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context2);
      push2(`)`);
      if (isBlock) {
        push2(`)`);
      }
      if (directives) {
        push2(`, `);
        genNode(directives, context2);
        push2(`)`);
      }
    }
    function genNullableArgs(args) {
      let i2 = args.length;
      while (i2--) {
        if (args[i2] != null)
          break;
      }
      return args.slice(0, i2 + 1).map((arg) => arg || `null`);
    }
    function genCallExpression(node2, context2) {
      const { push: push2, helper, pure } = context2;
      const callee = isString2(node2.callee) ? node2.callee : helper(node2.callee);
      if (pure) {
        push2(PURE_ANNOTATION);
      }
      push2(callee + `(`, node2);
      genNodeList(node2.arguments, context2);
      push2(`)`);
    }
    function genObjectExpression(node2, context2) {
      const { push: push2, indent, deindent, newline } = context2;
      const { properties } = node2;
      if (!properties.length) {
        push2(`{}`, node2);
        return;
      }
      const multilines = properties.length > 1 || properties.some((p2) => p2.value.type !== 4);
      push2(multilines ? `{` : `{ `);
      multilines && indent();
      for (let i2 = 0; i2 < properties.length; i2++) {
        const { key, value } = properties[i2];
        genExpressionAsPropertyKey(key, context2);
        push2(`: `);
        genNode(value, context2);
        if (i2 < properties.length - 1) {
          push2(`,`);
          newline();
        }
      }
      multilines && deindent();
      push2(multilines ? `}` : ` }`);
    }
    function genArrayExpression(node2, context2) {
      genNodeListAsArray(node2.elements, context2);
    }
    function genFunctionExpression(node2, context2) {
      const { push: push2, indent, deindent } = context2;
      const { params, returns, body, newline, isSlot } = node2;
      if (isSlot) {
        push2(`_${helperNameMap[WITH_CTX]}(`);
      }
      push2(`(`, node2);
      if (isArray2(params)) {
        genNodeList(params, context2);
      } else if (params) {
        genNode(params, context2);
      }
      push2(`) => `);
      if (newline || body) {
        push2(`{`);
        indent();
      }
      if (returns) {
        if (newline) {
          push2(`return `);
        }
        if (isArray2(returns)) {
          genNodeListAsArray(returns, context2);
        } else {
          genNode(returns, context2);
        }
      } else if (body) {
        genNode(body, context2);
      }
      if (newline || body) {
        deindent();
        push2(`}`);
      }
      if (isSlot) {
        if (node2.isNonScopedSlot) {
          push2(`, undefined, true`);
        }
        push2(`)`);
      }
    }
    function genConditionalExpression(node2, context2) {
      const { test, consequent, alternate, newline: needNewline } = node2;
      const { push: push2, indent, deindent, newline } = context2;
      if (test.type === 4) {
        const needsParens = !isSimpleIdentifier(test.content);
        needsParens && push2(`(`);
        genExpression(test, context2);
        needsParens && push2(`)`);
      } else {
        push2(`(`);
        genNode(test, context2);
        push2(`)`);
      }
      needNewline && indent();
      context2.indentLevel++;
      needNewline || push2(` `);
      push2(`? `);
      genNode(consequent, context2);
      context2.indentLevel--;
      needNewline && newline();
      needNewline || push2(` `);
      push2(`: `);
      const isNested = alternate.type === 19;
      if (!isNested) {
        context2.indentLevel++;
      }
      genNode(alternate, context2);
      if (!isNested) {
        context2.indentLevel--;
      }
      needNewline && deindent(true);
    }
    function genCacheExpression(node2, context2) {
      const { push: push2, helper, indent, deindent, newline } = context2;
      push2(`_cache[${node2.index}] || (`);
      if (node2.isVNode) {
        indent();
        push2(`${helper(SET_BLOCK_TRACKING)}(-1),`);
        newline();
      }
      push2(`_cache[${node2.index}] = `);
      genNode(node2.value, context2);
      if (node2.isVNode) {
        push2(`,`);
        newline();
        push2(`${helper(SET_BLOCK_TRACKING)}(1),`);
        newline();
        push2(`_cache[${node2.index}]`);
        deindent();
      }
      push2(`)`);
    }
    function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = Object.create(null)) {
      {
        return;
      }
    }
    function isReferencedIdentifier(id, parent, parentStack) {
      {
        return false;
      }
    }
    function isInDestructureAssignment(parent, parentStack) {
      if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
        let i2 = parentStack.length;
        while (i2--) {
          const p2 = parentStack[i2];
          if (p2.type === "AssignmentExpression") {
            return true;
          } else if (p2.type !== "ObjectProperty" && !p2.type.endsWith("Pattern")) {
            break;
          }
        }
      }
      return false;
    }
    function walkFunctionParams(node2, onIdent) {
      for (const p2 of node2.params) {
        for (const id of extractIdentifiers(p2)) {
          onIdent(id);
        }
      }
    }
    function walkBlockDeclarations(block, onIdent) {
      for (const stmt of block.body) {
        if (stmt.type === "VariableDeclaration") {
          if (stmt.declare)
            continue;
          for (const decl of stmt.declarations) {
            for (const id of extractIdentifiers(decl.id)) {
              onIdent(id);
            }
          }
        } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
          if (stmt.declare || !stmt.id)
            continue;
          onIdent(stmt.id);
        }
      }
    }
    function extractIdentifiers(param, nodes = []) {
      switch (param.type) {
        case "Identifier":
          nodes.push(param);
          break;
        case "MemberExpression":
          let object = param;
          while (object.type === "MemberExpression") {
            object = object.object;
          }
          nodes.push(object);
          break;
        case "ObjectPattern":
          for (const prop of param.properties) {
            if (prop.type === "RestElement") {
              extractIdentifiers(prop.argument, nodes);
            } else {
              extractIdentifiers(prop.value, nodes);
            }
          }
          break;
        case "ArrayPattern":
          param.elements.forEach((element) => {
            if (element)
              extractIdentifiers(element, nodes);
          });
          break;
        case "RestElement":
          extractIdentifiers(param.argument, nodes);
          break;
        case "AssignmentPattern":
          extractIdentifiers(param.left, nodes);
          break;
      }
      return nodes;
    }
    var isFunctionType = (node2) => {
      return /Function(?:Expression|Declaration)$|Method$/.test(node2.type);
    };
    var isStaticProperty2 = (node2) => node2 && (node2.type === "ObjectProperty" || node2.type === "ObjectMethod") && !node2.computed;
    var isStaticPropertyKey2 = (node2, parent) => isStaticProperty2(parent) && parent.key === node2;
    var prohibitedKeywordRE = new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments,typeof,void".split(",").join("\\b|\\b") + "\\b");
    var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
    function validateBrowserExpression(node2, context2, asParams = false, asRawStatements = false) {
      const exp = node2.content;
      if (!exp.trim()) {
        return;
      }
      try {
        new Function(asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
      } catch (e2) {
        let message = e2.message;
        const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
        if (keywordMatch) {
          message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
        }
        context2.onError(createCompilerError(44, node2.loc, void 0, message));
      }
    }
    var transformExpression = (node2, context2) => {
      if (node2.type === 5) {
        node2.content = processExpression(node2.content, context2);
      } else if (node2.type === 1) {
        for (let i2 = 0; i2 < node2.props.length; i2++) {
          const dir = node2.props[i2];
          if (dir.type === 7 && dir.name !== "for") {
            const exp = dir.exp;
            const arg = dir.arg;
            if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
              dir.exp = processExpression(exp, context2, dir.name === "slot");
            }
            if (arg && arg.type === 4 && !arg.isStatic) {
              dir.arg = processExpression(arg, context2);
            }
          }
        }
      }
    };
    function processExpression(node2, context2, asParams = false, asRawStatements = false, localVars = Object.create(context2.identifiers)) {
      {
        if (true) {
          validateBrowserExpression(node2, context2, asParams, asRawStatements);
        }
        return node2;
      }
    }
    var transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node2, dir, context2) => {
      return processIf(node2, dir, context2, (ifNode, branch, isRoot) => {
        const siblings = context2.parent.children;
        let i2 = siblings.indexOf(ifNode);
        let key = 0;
        while (i2-- >= 0) {
          const sibling = siblings[i2];
          if (sibling && sibling.type === 9) {
            key += sibling.branches.length;
          }
        }
        return () => {
          if (isRoot) {
            ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context2);
          } else {
            const parentCondition = getParentCondition(ifNode.codegenNode);
            parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context2);
          }
        };
      });
    });
    function processIf(node2, dir, context2, processCodegen) {
      if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
        const loc = dir.exp ? dir.exp.loc : node2.loc;
        context2.onError(createCompilerError(28, dir.loc));
        dir.exp = createSimpleExpression(`true`, false, loc);
      }
      if (dir.exp) {
        validateBrowserExpression(dir.exp, context2);
      }
      if (dir.name === "if") {
        const branch = createIfBranch(node2, dir);
        const ifNode = {
          type: 9,
          loc: node2.loc,
          branches: [branch]
        };
        context2.replaceNode(ifNode);
        if (processCodegen) {
          return processCodegen(ifNode, branch, true);
        }
      } else {
        const siblings = context2.parent.children;
        const comments = [];
        let i2 = siblings.indexOf(node2);
        while (i2-- >= -1) {
          const sibling = siblings[i2];
          if (sibling && sibling.type === 3) {
            context2.removeNode(sibling);
            comments.unshift(sibling);
            continue;
          }
          if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
            context2.removeNode(sibling);
            continue;
          }
          if (sibling && sibling.type === 9) {
            if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
              context2.onError(createCompilerError(30, node2.loc));
            }
            context2.removeNode();
            const branch = createIfBranch(node2, dir);
            if (comments.length && !(context2.parent && context2.parent.type === 1 && isBuiltInType(context2.parent.tag, "transition"))) {
              branch.children = [...comments, ...branch.children];
            }
            if (true) {
              const key = branch.userKey;
              if (key) {
                sibling.branches.forEach(({ userKey }) => {
                  if (isSameKey(userKey, key)) {
                    context2.onError(createCompilerError(29, branch.userKey.loc));
                  }
                });
              }
            }
            sibling.branches.push(branch);
            const onExit2 = processCodegen && processCodegen(sibling, branch, false);
            traverseNode(branch, context2);
            if (onExit2)
              onExit2();
            context2.currentNode = null;
          } else {
            context2.onError(createCompilerError(30, node2.loc));
          }
          break;
        }
      }
    }
    function createIfBranch(node2, dir) {
      return {
        type: 10,
        loc: node2.loc,
        condition: dir.name === "else" ? void 0 : dir.exp,
        children: node2.tagType === 3 && !findDir(node2, "for") ? node2.children : [node2],
        userKey: findProp(node2, `key`)
      };
    }
    function createCodegenNodeForBranch(branch, keyIndex, context2) {
      if (branch.condition) {
        return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context2), createCallExpression(context2.helper(CREATE_COMMENT), [
          true ? '"v-if"' : '""',
          "true"
        ]));
      } else {
        return createChildrenCodegenNode(branch, keyIndex, context2);
      }
    }
    function createChildrenCodegenNode(branch, keyIndex, context2) {
      const { helper } = context2;
      const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2));
      const { children } = branch;
      const firstChild = children[0];
      const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
      if (needFragmentWrapper) {
        if (children.length === 1 && firstChild.type === 11) {
          const vnodeCall = firstChild.codegenNode;
          injectProp(vnodeCall, keyProperty, context2);
          return vnodeCall;
        } else {
          let patchFlag = 64;
          let patchFlagText = PatchFlagNames[64];
          if (children.filter((c2) => c2.type !== 3).length === 1) {
            patchFlag |= 2048;
            patchFlagText += `, ${PatchFlagNames[2048]}`;
          }
          return createVNodeCall(context2, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (true ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, false, false, branch.loc);
        }
      } else {
        const ret = firstChild.codegenNode;
        const vnodeCall = getMemoedVNodeCall(ret);
        if (vnodeCall.type === 13) {
          makeBlock(vnodeCall, context2);
        }
        injectProp(vnodeCall, keyProperty, context2);
        return ret;
      }
    }
    function isSameKey(a2, b2) {
      if (!a2 || a2.type !== b2.type) {
        return false;
      }
      if (a2.type === 6) {
        if (a2.value.content !== b2.value.content) {
          return false;
        }
      } else {
        const exp = a2.exp;
        const branchExp = b2.exp;
        if (exp.type !== branchExp.type) {
          return false;
        }
        if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
          return false;
        }
      }
      return true;
    }
    function getParentCondition(node2) {
      while (true) {
        if (node2.type === 19) {
          if (node2.alternate.type === 19) {
            node2 = node2.alternate;
          } else {
            return node2;
          }
        } else if (node2.type === 20) {
          node2 = node2.value;
        }
      }
    }
    var transformFor = createStructuralDirectiveTransform("for", (node2, dir, context2) => {
      const { helper, removeHelper } = context2;
      return processFor(node2, dir, context2, (forNode) => {
        const renderExp = createCallExpression(helper(RENDER_LIST), [
          forNode.source
        ]);
        const memo = findDir(node2, "memo");
        const keyProp = findProp(node2, `key`);
        const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
        const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
        const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
        const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
        forNode.codegenNode = createVNodeCall(context2, helper(FRAGMENT), void 0, renderExp, fragmentFlag + (true ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``), void 0, void 0, true, !isStableFragment, false, node2.loc);
        return () => {
          let childBlock;
          const isTemplate = isTemplateNode(node2);
          const { children } = forNode;
          if (isTemplate) {
            node2.children.some((c2) => {
              if (c2.type === 1) {
                const key = findProp(c2, "key");
                if (key) {
                  context2.onError(createCompilerError(33, key.loc));
                  return true;
                }
              }
            });
          }
          const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
          const slotOutlet = isSlotOutlet(node2) ? node2 : isTemplate && node2.children.length === 1 && isSlotOutlet(node2.children[0]) ? node2.children[0] : null;
          if (slotOutlet) {
            childBlock = slotOutlet.codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context2);
            }
          } else if (needFragmentWrapper) {
            childBlock = createVNodeCall(context2, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : void 0, node2.children, 64 + (true ? ` /* ${PatchFlagNames[64]} */` : ``), void 0, void 0, true, void 0, false);
          } else {
            childBlock = children[0].codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context2);
            }
            if (childBlock.isBlock !== !isStableFragment) {
              if (childBlock.isBlock) {
                removeHelper(OPEN_BLOCK);
                removeHelper(getVNodeBlockHelper(context2.inSSR, childBlock.isComponent));
              } else {
                removeHelper(getVNodeHelper(context2.inSSR, childBlock.isComponent));
              }
            }
            childBlock.isBlock = !isStableFragment;
            if (childBlock.isBlock) {
              helper(OPEN_BLOCK);
              helper(getVNodeBlockHelper(context2.inSSR, childBlock.isComponent));
            } else {
              helper(getVNodeHelper(context2.inSSR, childBlock.isComponent));
            }
          }
          if (memo) {
            const loop2 = createFunctionExpression(createForLoopParams(forNode.parseResult, [
              createSimpleExpression(`_cached`)
            ]));
            loop2.body = createBlockStatement([
              createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
              createCompoundExpression([
                `if (_cached`,
                ...keyExp ? [` && _cached.key === `, keyExp] : [],
                ` && ${context2.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
              ]),
              createCompoundExpression([`const _item = `, childBlock]),
              createSimpleExpression(`_item.memo = _memo`),
              createSimpleExpression(`return _item`)
            ]);
            renderExp.arguments.push(loop2, createSimpleExpression(`_cache`), createSimpleExpression(String(context2.cached++)));
          } else {
            renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true));
          }
        };
      });
    });
    function processFor(node2, dir, context2, processCodegen) {
      if (!dir.exp) {
        context2.onError(createCompilerError(31, dir.loc));
        return;
      }
      const parseResult = parseForExpression(dir.exp, context2);
      if (!parseResult) {
        context2.onError(createCompilerError(32, dir.loc));
        return;
      }
      const { addIdentifiers, removeIdentifiers, scopes } = context2;
      const { source: source2, value, key, index: index2 } = parseResult;
      const forNode = {
        type: 11,
        loc: dir.loc,
        source: source2,
        valueAlias: value,
        keyAlias: key,
        objectIndexAlias: index2,
        parseResult,
        children: isTemplateNode(node2) ? node2.children : [node2]
      };
      context2.replaceNode(forNode);
      scopes.vFor++;
      const onExit2 = processCodegen && processCodegen(forNode);
      return () => {
        scopes.vFor--;
        if (onExit2)
          onExit2();
      };
    }
    var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    var stripParensRE = /^\(|\)$/g;
    function parseForExpression(input, context2) {
      const loc = input.loc;
      const exp = input.content;
      const inMatch = exp.match(forAliasRE);
      if (!inMatch)
        return;
      const [, LHS, RHS] = inMatch;
      const result2 = {
        source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
        value: void 0,
        key: void 0,
        index: void 0
      };
      if (true) {
        validateBrowserExpression(result2.source, context2);
      }
      let valueContent = LHS.trim().replace(stripParensRE, "").trim();
      const trimmedOffset = LHS.indexOf(valueContent);
      const iteratorMatch = valueContent.match(forIteratorRE);
      if (iteratorMatch) {
        valueContent = valueContent.replace(forIteratorRE, "").trim();
        const keyContent = iteratorMatch[1].trim();
        let keyOffset;
        if (keyContent) {
          keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
          result2.key = createAliasExpression(loc, keyContent, keyOffset);
          if (true) {
            validateBrowserExpression(result2.key, context2, true);
          }
        }
        if (iteratorMatch[2]) {
          const indexContent = iteratorMatch[2].trim();
          if (indexContent) {
            result2.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result2.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));
            if (true) {
              validateBrowserExpression(result2.index, context2, true);
            }
          }
        }
      }
      if (valueContent) {
        result2.value = createAliasExpression(loc, valueContent, trimmedOffset);
        if (true) {
          validateBrowserExpression(result2.value, context2, true);
        }
      }
      return result2;
    }
    function createAliasExpression(range3, content2, offset2) {
      return createSimpleExpression(content2, false, getInnerRange(range3, offset2, content2.length));
    }
    function createForLoopParams({ value, key, index: index2 }, memoArgs = []) {
      return createParamsList([value, key, index2, ...memoArgs]);
    }
    function createParamsList(args) {
      let i2 = args.length;
      while (i2--) {
        if (args[i2])
          break;
      }
      return args.slice(0, i2 + 1).map((arg, i3) => arg || createSimpleExpression(`_`.repeat(i3 + 1), false));
    }
    var defaultFallback = createSimpleExpression(`undefined`, false);
    var trackSlotScopes = (node2, context2) => {
      if (node2.type === 1 && (node2.tagType === 1 || node2.tagType === 3)) {
        const vSlot = findDir(node2, "slot");
        if (vSlot) {
          context2.scopes.vSlot++;
          return () => {
            context2.scopes.vSlot--;
          };
        }
      }
    };
    var trackVForSlotScopes = (node2, context2) => {
      let vFor;
      if (isTemplateNode(node2) && node2.props.some(isVSlot) && (vFor = findDir(node2, "for"))) {
        const result2 = vFor.parseResult = parseForExpression(vFor.exp, context2);
        if (result2) {
          const { value, key, index: index2 } = result2;
          const { addIdentifiers, removeIdentifiers } = context2;
          value && addIdentifiers(value);
          key && addIdentifiers(key);
          index2 && addIdentifiers(index2);
          return () => {
            value && removeIdentifiers(value);
            key && removeIdentifiers(key);
            index2 && removeIdentifiers(index2);
          };
        }
      }
    };
    var buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false, true, children.length ? children[0].loc : loc);
    function buildSlots(node2, context2, buildSlotFn = buildClientSlotFn) {
      context2.helper(WITH_CTX);
      const { children, loc } = node2;
      const slotsProperties = [];
      const dynamicSlots = [];
      let hasDynamicSlots = context2.scopes.vSlot > 0 || context2.scopes.vFor > 0;
      const onComponentSlot = findDir(node2, "slot", true);
      if (onComponentSlot) {
        const { arg, exp } = onComponentSlot;
        if (arg && !isStaticExp(arg)) {
          hasDynamicSlots = true;
        }
        slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, children, loc)));
      }
      let hasTemplateSlots = false;
      let hasNamedDefaultSlot = false;
      const implicitDefaultChildren = [];
      const seenSlotNames = new Set();
      for (let i2 = 0; i2 < children.length; i2++) {
        const slotElement = children[i2];
        let slotDir;
        if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
          if (slotElement.type !== 3) {
            implicitDefaultChildren.push(slotElement);
          }
          continue;
        }
        if (onComponentSlot) {
          context2.onError(createCompilerError(37, slotDir.loc));
          break;
        }
        hasTemplateSlots = true;
        const { children: slotChildren, loc: slotLoc } = slotElement;
        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
        let staticSlotName;
        if (isStaticExp(slotName)) {
          staticSlotName = slotName ? slotName.content : `default`;
        } else {
          hasDynamicSlots = true;
        }
        const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
        let vIf;
        let vElse;
        let vFor;
        if (vIf = findDir(slotElement, "if")) {
          hasDynamicSlots = true;
          dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
        } else if (vElse = findDir(slotElement, /^else(-if)?$/, true)) {
          let j2 = i2;
          let prev;
          while (j2--) {
            prev = children[j2];
            if (prev.type !== 3) {
              break;
            }
          }
          if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
            children.splice(i2, 1);
            i2--;
            let conditional = dynamicSlots[dynamicSlots.length - 1];
            while (conditional.alternate.type === 19) {
              conditional = conditional.alternate;
            }
            conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback) : buildDynamicSlot(slotName, slotFunction);
          } else {
            context2.onError(createCompilerError(30, vElse.loc));
          }
        } else if (vFor = findDir(slotElement, "for")) {
          hasDynamicSlots = true;
          const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context2);
          if (parseResult) {
            dynamicSlots.push(createCallExpression(context2.helper(RENDER_LIST), [
              parseResult.source,
              createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true)
            ]));
          } else {
            context2.onError(createCompilerError(32, vFor.loc));
          }
        } else {
          if (staticSlotName) {
            if (seenSlotNames.has(staticSlotName)) {
              context2.onError(createCompilerError(38, dirLoc));
              continue;
            }
            seenSlotNames.add(staticSlotName);
            if (staticSlotName === "default") {
              hasNamedDefaultSlot = true;
            }
          }
          slotsProperties.push(createObjectProperty(slotName, slotFunction));
        }
      }
      if (!onComponentSlot) {
        const buildDefaultSlotProperty = (props, children2) => {
          const fn2 = buildSlotFn(props, children2, loc);
          if (context2.compatConfig) {
            fn2.isNonScopedSlot = true;
          }
          return createObjectProperty(`default`, fn2);
        };
        if (!hasTemplateSlots) {
          slotsProperties.push(buildDefaultSlotProperty(void 0, children));
        } else if (implicitDefaultChildren.length && implicitDefaultChildren.some((node3) => isNonWhitespaceContent(node3))) {
          if (hasNamedDefaultSlot) {
            context2.onError(createCompilerError(39, implicitDefaultChildren[0].loc));
          } else {
            slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
          }
        }
      }
      const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node2.children) ? 3 : 1;
      let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, createSimpleExpression(slotFlag + (true ? ` /* ${slotFlagsText[slotFlag]} */` : ``), false))), loc);
      if (dynamicSlots.length) {
        slots = createCallExpression(context2.helper(CREATE_SLOTS), [
          slots,
          createArrayExpression(dynamicSlots)
        ]);
      }
      return {
        slots,
        hasDynamicSlots
      };
    }
    function buildDynamicSlot(name, fn2) {
      return createObjectExpression([
        createObjectProperty(`name`, name),
        createObjectProperty(`fn`, fn2)
      ]);
    }
    function hasForwardedSlots(children) {
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        switch (child.type) {
          case 1:
            if (child.tagType === 2 || hasForwardedSlots(child.children)) {
              return true;
            }
            break;
          case 9:
            if (hasForwardedSlots(child.branches))
              return true;
            break;
          case 10:
          case 11:
            if (hasForwardedSlots(child.children))
              return true;
            break;
        }
      }
      return false;
    }
    function isNonWhitespaceContent(node2) {
      if (node2.type !== 2 && node2.type !== 12)
        return true;
      return node2.type === 2 ? !!node2.content.trim() : isNonWhitespaceContent(node2.content);
    }
    var directiveImportMap = new WeakMap();
    var transformElement = (node2, context2) => {
      return function postTransformElement() {
        node2 = context2.currentNode;
        if (!(node2.type === 1 && (node2.tagType === 0 || node2.tagType === 1))) {
          return;
        }
        const { tag, props } = node2;
        const isComponent2 = node2.tagType === 1;
        let vnodeTag = isComponent2 ? resolveComponentType(node2, context2) : `"${tag}"`;
        const isDynamicComponent = isObject2(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && (tag === "svg" || tag === "foreignObject");
        if (props.length > 0) {
          const propsBuildResult = buildProps(node2, context2);
          vnodeProps = propsBuildResult.props;
          patchFlag = propsBuildResult.patchFlag;
          dynamicPropNames = propsBuildResult.dynamicPropNames;
          const directives = propsBuildResult.directives;
          vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map((dir) => buildDirectiveArgs(dir, context2))) : void 0;
          if (propsBuildResult.shouldUseBlock) {
            shouldUseBlock = true;
          }
        }
        if (node2.children.length > 0) {
          if (vnodeTag === KEEP_ALIVE) {
            shouldUseBlock = true;
            patchFlag |= 1024;
            if (node2.children.length > 1) {
              context2.onError(createCompilerError(45, {
                start: node2.children[0].loc.start,
                end: node2.children[node2.children.length - 1].loc.end,
                source: ""
              }));
            }
          }
          const shouldBuildAsSlots = isComponent2 && vnodeTag !== TELEPORT && vnodeTag !== KEEP_ALIVE;
          if (shouldBuildAsSlots) {
            const { slots, hasDynamicSlots } = buildSlots(node2, context2);
            vnodeChildren = slots;
            if (hasDynamicSlots) {
              patchFlag |= 1024;
            }
          } else if (node2.children.length === 1 && vnodeTag !== TELEPORT) {
            const child = node2.children[0];
            const type = child.type;
            const hasDynamicTextChild = type === 5 || type === 8;
            if (hasDynamicTextChild && getConstantType(child, context2) === 0) {
              patchFlag |= 1;
            }
            if (hasDynamicTextChild || type === 2) {
              vnodeChildren = child;
            } else {
              vnodeChildren = node2.children;
            }
          } else {
            vnodeChildren = node2.children;
          }
        }
        if (patchFlag !== 0) {
          if (true) {
            if (patchFlag < 0) {
              vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
            } else {
              const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n3) => n3 > 0 && patchFlag & n3).map((n3) => PatchFlagNames[n3]).join(`, `);
              vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
            }
          } else {
            vnodePatchFlag = String(patchFlag);
          }
          if (dynamicPropNames && dynamicPropNames.length) {
            vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
          }
        }
        node2.codegenNode = createVNodeCall(context2, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent2, node2.loc);
      };
    };
    function resolveComponentType(node2, context2, ssr = false) {
      let { tag } = node2;
      const isExplicitDynamic = isComponentTag(tag);
      const isProp = findProp(node2, "is");
      if (isProp) {
        if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context2)) {
          const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
          if (exp) {
            return createCallExpression(context2.helper(RESOLVE_DYNAMIC_COMPONENT), [
              exp
            ]);
          }
        } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
          tag = isProp.value.content.slice(4);
        }
      }
      const isDir = !isExplicitDynamic && findDir(node2, "is");
      if (isDir && isDir.exp) {
        return createCallExpression(context2.helper(RESOLVE_DYNAMIC_COMPONENT), [
          isDir.exp
        ]);
      }
      const builtIn = isCoreComponent(tag) || context2.isBuiltInComponent(tag);
      if (builtIn) {
        if (!ssr)
          context2.helper(builtIn);
        return builtIn;
      }
      context2.helper(RESOLVE_COMPONENT);
      context2.components.add(tag);
      return toValidAssetId(tag, `component`);
    }
    function buildProps(node2, context2, props = node2.props, ssr = false) {
      const { tag, loc: elementLoc, children } = node2;
      const isComponent2 = node2.tagType === 1;
      let properties = [];
      const mergeArgs = [];
      const runtimeDirectives = [];
      const hasChildren = children.length > 0;
      let shouldUseBlock = false;
      let patchFlag = 0;
      let hasRef = false;
      let hasClassBinding = false;
      let hasStyleBinding = false;
      let hasHydrationEventBinding = false;
      let hasDynamicKeys = false;
      let hasVnodeHook = false;
      const dynamicPropNames = [];
      const analyzePatchFlag = ({ key, value }) => {
        if (isStaticExp(key)) {
          const name = key.content;
          const isEventHandler = isOn(name);
          if (!isComponent2 && isEventHandler && name.toLowerCase() !== "onclick" && name !== "onUpdate:modelValue" && !isReservedProp(name)) {
            hasHydrationEventBinding = true;
          }
          if (isEventHandler && isReservedProp(name)) {
            hasVnodeHook = true;
          }
          if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context2) > 0) {
            return;
          }
          if (name === "ref") {
            hasRef = true;
          } else if (name === "class") {
            hasClassBinding = true;
          } else if (name === "style") {
            hasStyleBinding = true;
          } else if (name !== "key" && !dynamicPropNames.includes(name)) {
            dynamicPropNames.push(name);
          }
          if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
            dynamicPropNames.push(name);
          }
        } else {
          hasDynamicKeys = true;
        }
      };
      for (let i2 = 0; i2 < props.length; i2++) {
        const prop = props[i2];
        if (prop.type === 6) {
          const { loc, name, value } = prop;
          let isStatic = true;
          if (name === "ref") {
            hasRef = true;
            if (context2.scopes.vFor > 0) {
              properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
            }
          }
          if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context2))) {
            continue;
          }
          properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
        } else {
          const { name, arg, exp, loc } = prop;
          const isVBind = name === "bind";
          const isVOn = name === "on";
          if (name === "slot") {
            if (!isComponent2) {
              context2.onError(createCompilerError(40, loc));
            }
            continue;
          }
          if (name === "once" || name === "memo") {
            continue;
          }
          if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context2))) {
            continue;
          }
          if (isVOn && ssr) {
            continue;
          }
          if (isVBind && isStaticArgOf(arg, "key") || isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")) {
            shouldUseBlock = true;
          }
          if (isVBind && isStaticArgOf(arg, "ref") && context2.scopes.vFor > 0) {
            properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
          }
          if (!arg && (isVBind || isVOn)) {
            hasDynamicKeys = true;
            if (exp) {
              if (properties.length) {
                mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
                properties = [];
              }
              if (isVBind) {
                {
                  if (true) {
                    const hasOverridableKeys = mergeArgs.some((arg2) => {
                      if (arg2.type === 15) {
                        return arg2.properties.some(({ key }) => {
                          if (key.type !== 4 || !key.isStatic) {
                            return true;
                          }
                          return key.content !== "class" && key.content !== "style" && !isOn(key.content);
                        });
                      } else {
                        return true;
                      }
                    });
                    if (hasOverridableKeys) {
                      checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context2, loc);
                    }
                  }
                  if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context2)) {
                    mergeArgs.unshift(exp);
                    continue;
                  }
                }
                mergeArgs.push(exp);
              } else {
                mergeArgs.push({
                  type: 14,
                  loc,
                  callee: context2.helper(TO_HANDLERS),
                  arguments: [exp]
                });
              }
            } else {
              context2.onError(createCompilerError(isVBind ? 34 : 35, loc));
            }
            continue;
          }
          const directiveTransform = context2.directiveTransforms[name];
          if (directiveTransform) {
            const { props: props2, needRuntime } = directiveTransform(prop, node2, context2);
            !ssr && props2.forEach(analyzePatchFlag);
            properties.push(...props2);
            if (needRuntime) {
              runtimeDirectives.push(prop);
              if (isSymbol(needRuntime)) {
                directiveImportMap.set(prop, needRuntime);
              }
            }
          } else {
            runtimeDirectives.push(prop);
            if (hasChildren) {
              shouldUseBlock = true;
            }
          }
        }
      }
      let propsExpression = void 0;
      if (mergeArgs.length) {
        if (properties.length) {
          mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
        }
        if (mergeArgs.length > 1) {
          propsExpression = createCallExpression(context2.helper(MERGE_PROPS), mergeArgs, elementLoc);
        } else {
          propsExpression = mergeArgs[0];
        }
      } else if (properties.length) {
        propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
      }
      if (hasDynamicKeys) {
        patchFlag |= 16;
      } else {
        if (hasClassBinding && !isComponent2) {
          patchFlag |= 2;
        }
        if (hasStyleBinding && !isComponent2) {
          patchFlag |= 4;
        }
        if (dynamicPropNames.length) {
          patchFlag |= 8;
        }
        if (hasHydrationEventBinding) {
          patchFlag |= 32;
        }
      }
      if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
        patchFlag |= 512;
      }
      if (!context2.inSSR && propsExpression) {
        switch (propsExpression.type) {
          case 15:
            let classKeyIndex = -1;
            let styleKeyIndex = -1;
            let hasDynamicKey = false;
            for (let i2 = 0; i2 < propsExpression.properties.length; i2++) {
              const key = propsExpression.properties[i2].key;
              if (isStaticExp(key)) {
                if (key.content === "class") {
                  classKeyIndex = i2;
                } else if (key.content === "style") {
                  styleKeyIndex = i2;
                }
              } else if (!key.isHandlerKey) {
                hasDynamicKey = true;
              }
            }
            const classProp = propsExpression.properties[classKeyIndex];
            const styleProp = propsExpression.properties[styleKeyIndex];
            if (!hasDynamicKey) {
              if (classProp && !isStaticExp(classProp.value)) {
                classProp.value = createCallExpression(context2.helper(NORMALIZE_CLASS), [classProp.value]);
              }
              if (styleProp && !isStaticExp(styleProp.value) && (hasStyleBinding || styleProp.value.type === 17)) {
                styleProp.value = createCallExpression(context2.helper(NORMALIZE_STYLE), [styleProp.value]);
              }
            } else {
              propsExpression = createCallExpression(context2.helper(NORMALIZE_PROPS), [propsExpression]);
            }
            break;
          case 14:
            break;
          default:
            propsExpression = createCallExpression(context2.helper(NORMALIZE_PROPS), [
              createCallExpression(context2.helper(GUARD_REACTIVE_PROPS), [
                propsExpression
              ])
            ]);
            break;
        }
      }
      return {
        props: propsExpression,
        directives: runtimeDirectives,
        patchFlag,
        dynamicPropNames,
        shouldUseBlock
      };
    }
    function dedupeProperties(properties) {
      const knownProps = new Map();
      const deduped = [];
      for (let i2 = 0; i2 < properties.length; i2++) {
        const prop = properties[i2];
        if (prop.key.type === 8 || !prop.key.isStatic) {
          deduped.push(prop);
          continue;
        }
        const name = prop.key.content;
        const existing = knownProps.get(name);
        if (existing) {
          if (name === "style" || name === "class" || isOn(name)) {
            mergeAsArray(existing, prop);
          }
        } else {
          knownProps.set(name, prop);
          deduped.push(prop);
        }
      }
      return deduped;
    }
    function mergeAsArray(existing, incoming) {
      if (existing.value.type === 17) {
        existing.value.elements.push(incoming.value);
      } else {
        existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
      }
    }
    function buildDirectiveArgs(dir, context2) {
      const dirArgs = [];
      const runtime = directiveImportMap.get(dir);
      if (runtime) {
        dirArgs.push(context2.helperString(runtime));
      } else {
        {
          context2.helper(RESOLVE_DIRECTIVE);
          context2.directives.add(dir.name);
          dirArgs.push(toValidAssetId(dir.name, `directive`));
        }
      }
      const { loc } = dir;
      if (dir.exp)
        dirArgs.push(dir.exp);
      if (dir.arg) {
        if (!dir.exp) {
          dirArgs.push(`void 0`);
        }
        dirArgs.push(dir.arg);
      }
      if (Object.keys(dir.modifiers).length) {
        if (!dir.arg) {
          if (!dir.exp) {
            dirArgs.push(`void 0`);
          }
          dirArgs.push(`void 0`);
        }
        const trueExpression = createSimpleExpression(`true`, false, loc);
        dirArgs.push(createObjectExpression(dir.modifiers.map((modifier) => createObjectProperty(modifier, trueExpression)), loc));
      }
      return createArrayExpression(dirArgs, dir.loc);
    }
    function stringifyDynamicPropNames(props) {
      let propsNamesString = `[`;
      for (let i2 = 0, l2 = props.length; i2 < l2; i2++) {
        propsNamesString += JSON.stringify(props[i2]);
        if (i2 < l2 - 1)
          propsNamesString += ", ";
      }
      return propsNamesString + `]`;
    }
    function isComponentTag(tag) {
      return tag === "component" || tag === "Component";
    }
    true ? Object.freeze({}) : {};
    true ? Object.freeze([]) : [];
    var cacheStringFunction = (fn2) => {
      const cache2 = Object.create(null);
      return (str) => {
        const hit = cache2[str];
        return hit || (cache2[str] = fn2(str));
      };
    };
    var camelizeRE = /-(\w)/g;
    var camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
    });
    var transformSlotOutlet = (node2, context2) => {
      if (isSlotOutlet(node2)) {
        const { children, loc } = node2;
        const { slotName, slotProps } = processSlotOutlet(node2, context2);
        const slotArgs = [
          context2.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
          slotName,
          "{}",
          "undefined",
          "true"
        ];
        let expectedLen = 2;
        if (slotProps) {
          slotArgs[2] = slotProps;
          expectedLen = 3;
        }
        if (children.length) {
          slotArgs[3] = createFunctionExpression([], children, false, false, loc);
          expectedLen = 4;
        }
        if (context2.scopeId && !context2.slotted) {
          expectedLen = 5;
        }
        slotArgs.splice(expectedLen);
        node2.codegenNode = createCallExpression(context2.helper(RENDER_SLOT), slotArgs, loc);
      }
    };
    function processSlotOutlet(node2, context2) {
      let slotName = `"default"`;
      let slotProps = void 0;
      const nonNameProps = [];
      for (let i2 = 0; i2 < node2.props.length; i2++) {
        const p2 = node2.props[i2];
        if (p2.type === 6) {
          if (p2.value) {
            if (p2.name === "name") {
              slotName = JSON.stringify(p2.value.content);
            } else {
              p2.name = camelize(p2.name);
              nonNameProps.push(p2);
            }
          }
        } else {
          if (p2.name === "bind" && isStaticArgOf(p2.arg, "name")) {
            if (p2.exp)
              slotName = p2.exp;
          } else {
            if (p2.name === "bind" && p2.arg && isStaticExp(p2.arg)) {
              p2.arg.content = camelize(p2.arg.content);
            }
            nonNameProps.push(p2);
          }
        }
      }
      if (nonNameProps.length > 0) {
        const { props, directives } = buildProps(node2, context2, nonNameProps);
        slotProps = props;
        if (directives.length) {
          context2.onError(createCompilerError(36, directives[0].loc));
        }
      }
      return {
        slotName,
        slotProps
      };
    }
    var fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
    var transformOn = (dir, node2, context2, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
        context2.onError(createCompilerError(35, loc));
      }
      let eventName;
      if (arg.type === 4) {
        if (arg.isStatic) {
          let rawName = arg.content;
          if (rawName.startsWith("vue:")) {
            rawName = `vnode-${rawName.slice(4)}`;
          }
          eventName = createSimpleExpression(toHandlerKey(camelize$1(rawName)), true, arg.loc);
        } else {
          eventName = createCompoundExpression([
            `${context2.helperString(TO_HANDLER_KEY)}(`,
            arg,
            `)`
          ]);
        }
      } else {
        eventName = arg;
        eventName.children.unshift(`${context2.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
      }
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
        exp = void 0;
      }
      let shouldCache = context2.cacheHandlers && !exp && !context2.inVOnce;
      if (exp) {
        const isMemberExp = isMemberExpression(exp.content);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (true) {
          validateBrowserExpression(exp, context2, false, hasMultipleStatements);
        }
        if (isInlineStatement || shouldCache && isMemberExp) {
          exp = createCompoundExpression([
            `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
            exp,
            hasMultipleStatements ? `}` : `)`
          ]);
        }
      }
      let ret = {
        props: [
          createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
        ]
      };
      if (augmentor) {
        ret = augmentor(ret);
      }
      if (shouldCache) {
        ret.props[0].value = context2.cache(ret.props[0].value);
      }
      ret.props.forEach((p2) => p2.key.isHandlerKey = true);
      return ret;
    };
    var transformBind = (dir, _node, context2) => {
      const { exp, modifiers, loc } = dir;
      const arg = dir.arg;
      if (arg.type !== 4) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
      } else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
      }
      if (modifiers.includes("camel")) {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = camelize$1(arg.content);
          } else {
            arg.content = `${context2.helperString(CAMELIZE)}(${arg.content})`;
          }
        } else {
          arg.children.unshift(`${context2.helperString(CAMELIZE)}(`);
          arg.children.push(`)`);
        }
      }
      if (!context2.inSSR) {
        if (modifiers.includes("prop")) {
          injectPrefix(arg, ".");
        }
        if (modifiers.includes("attr")) {
          injectPrefix(arg, "^");
        }
      }
      if (!exp || exp.type === 4 && !exp.content.trim()) {
        context2.onError(createCompilerError(34, loc));
        return {
          props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
        };
      }
      return {
        props: [createObjectProperty(arg, exp)]
      };
    };
    var injectPrefix = (arg, prefix) => {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = prefix + arg.content;
        } else {
          arg.content = `\`${prefix}\${${arg.content}}\``;
        }
      } else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
      }
    };
    var transformText = (node2, context2) => {
      if (node2.type === 0 || node2.type === 1 || node2.type === 11 || node2.type === 10) {
        return () => {
          const children = node2.children;
          let currentContainer = void 0;
          let hasText = false;
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (isText(child)) {
              hasText = true;
              for (let j2 = i2 + 1; j2 < children.length; j2++) {
                const next = children[j2];
                if (isText(next)) {
                  if (!currentContainer) {
                    currentContainer = children[i2] = {
                      type: 8,
                      loc: child.loc,
                      children: [child]
                    };
                  }
                  currentContainer.children.push(` + `, next);
                  children.splice(j2, 1);
                  j2--;
                } else {
                  currentContainer = void 0;
                  break;
                }
              }
            }
          }
          if (!hasText || children.length === 1 && (node2.type === 0 || node2.type === 1 && node2.tagType === 0 && !node2.props.find((p2) => p2.type === 7 && !context2.directiveTransforms[p2.name]) && !(node2.tag === "template"))) {
            return;
          }
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (isText(child) || child.type === 8) {
              const callArgs = [];
              if (child.type !== 2 || child.content !== " ") {
                callArgs.push(child);
              }
              if (!context2.ssr && getConstantType(child, context2) === 0) {
                callArgs.push(1 + (true ? ` /* ${PatchFlagNames[1]} */` : ``));
              }
              children[i2] = {
                type: 12,
                content: child,
                loc: child.loc,
                codegenNode: createCallExpression(context2.helper(CREATE_TEXT), callArgs)
              };
            }
          }
        };
      }
    };
    var seen2 = new WeakSet();
    var transformOnce = (node2, context2) => {
      if (node2.type === 1 && findDir(node2, "once", true)) {
        if (seen2.has(node2) || context2.inVOnce) {
          return;
        }
        seen2.add(node2);
        context2.inVOnce = true;
        context2.helper(SET_BLOCK_TRACKING);
        return () => {
          context2.inVOnce = false;
          const cur = context2.currentNode;
          if (cur.codegenNode) {
            cur.codegenNode = context2.cache(cur.codegenNode, true);
          }
        };
      }
    };
    var transformModel = (dir, node2, context2) => {
      const { exp, arg } = dir;
      if (!exp) {
        context2.onError(createCompilerError(41, dir.loc));
        return createTransformProps();
      }
      const rawExp = exp.loc.source;
      const expString = exp.type === 4 ? exp.content : rawExp;
      const maybeRef = false;
      if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
        context2.onError(createCompilerError(42, exp.loc));
        return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression("modelValue", true);
      const eventName = arg ? isStaticExp(arg) ? `onUpdate:${arg.content}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
      let assignmentExp;
      const eventArg = context2.isTS ? `($event: any)` : `$event`;
      {
        assignmentExp = createCompoundExpression([
          `${eventArg} => ((`,
          exp,
          `) = $event)`
        ]);
      }
      const props = [
        createObjectProperty(propName, dir.exp),
        createObjectProperty(eventName, assignmentExp)
      ];
      if (dir.modifiers.length && node2.tagType === 1) {
        const modifiers = dir.modifiers.map((m3) => (isSimpleIdentifier(m3) ? m3 : JSON.stringify(m3)) + `: true`).join(`, `);
        const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2)));
      }
      return createTransformProps(props);
    };
    function createTransformProps(props = []) {
      return { props };
    }
    var validDivisionCharRE = /[\w).+\-_$\]]/;
    var transformFilter = (node2, context2) => {
      if (!isCompatEnabled("COMPILER_FILTER", context2)) {
        return;
      }
      if (node2.type === 5) {
        rewriteFilter(node2.content, context2);
      }
      if (node2.type === 1) {
        node2.props.forEach((prop) => {
          if (prop.type === 7 && prop.name !== "for" && prop.exp) {
            rewriteFilter(prop.exp, context2);
          }
        });
      }
    };
    function rewriteFilter(node2, context2) {
      if (node2.type === 4) {
        parseFilter(node2, context2);
      } else {
        for (let i2 = 0; i2 < node2.children.length; i2++) {
          const child = node2.children[i2];
          if (typeof child !== "object")
            continue;
          if (child.type === 4) {
            parseFilter(child, context2);
          } else if (child.type === 8) {
            rewriteFilter(node2, context2);
          } else if (child.type === 5) {
            rewriteFilter(child.content, context2);
          }
        }
      }
    }
    function parseFilter(node2, context2) {
      const exp = node2.content;
      let inSingle = false;
      let inDouble = false;
      let inTemplateString = false;
      let inRegex = false;
      let curly = 0;
      let square = 0;
      let paren = 0;
      let lastFilterIndex = 0;
      let c2, prev, i2, expression, filters = [];
      for (i2 = 0; i2 < exp.length; i2++) {
        prev = c2;
        c2 = exp.charCodeAt(i2);
        if (inSingle) {
          if (c2 === 39 && prev !== 92)
            inSingle = false;
        } else if (inDouble) {
          if (c2 === 34 && prev !== 92)
            inDouble = false;
        } else if (inTemplateString) {
          if (c2 === 96 && prev !== 92)
            inTemplateString = false;
        } else if (inRegex) {
          if (c2 === 47 && prev !== 92)
            inRegex = false;
        } else if (c2 === 124 && exp.charCodeAt(i2 + 1) !== 124 && exp.charCodeAt(i2 - 1) !== 124 && !curly && !square && !paren) {
          if (expression === void 0) {
            lastFilterIndex = i2 + 1;
            expression = exp.slice(0, i2).trim();
          } else {
            pushFilter();
          }
        } else {
          switch (c2) {
            case 34:
              inDouble = true;
              break;
            case 39:
              inSingle = true;
              break;
            case 96:
              inTemplateString = true;
              break;
            case 40:
              paren++;
              break;
            case 41:
              paren--;
              break;
            case 91:
              square++;
              break;
            case 93:
              square--;
              break;
            case 123:
              curly++;
              break;
            case 125:
              curly--;
              break;
          }
          if (c2 === 47) {
            let j2 = i2 - 1;
            let p2;
            for (; j2 >= 0; j2--) {
              p2 = exp.charAt(j2);
              if (p2 !== " ")
                break;
            }
            if (!p2 || !validDivisionCharRE.test(p2)) {
              inRegex = true;
            }
          }
        }
      }
      if (expression === void 0) {
        expression = exp.slice(0, i2).trim();
      } else if (lastFilterIndex !== 0) {
        pushFilter();
      }
      function pushFilter() {
        filters.push(exp.slice(lastFilterIndex, i2).trim());
        lastFilterIndex = i2 + 1;
      }
      if (filters.length) {
        warnDeprecation("COMPILER_FILTER", context2, node2.loc);
        for (i2 = 0; i2 < filters.length; i2++) {
          expression = wrapFilter(expression, filters[i2], context2);
        }
        node2.content = expression;
      }
    }
    function wrapFilter(exp, filter2, context2) {
      context2.helper(RESOLVE_FILTER);
      const i2 = filter2.indexOf("(");
      if (i2 < 0) {
        context2.filters.add(filter2);
        return `${toValidAssetId(filter2, "filter")}(${exp})`;
      } else {
        const name = filter2.slice(0, i2);
        const args = filter2.slice(i2 + 1);
        context2.filters.add(name);
        return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
      }
    }
    var seen$1 = new WeakSet();
    var transformMemo = (node2, context2) => {
      if (node2.type === 1) {
        const dir = findDir(node2, "memo");
        if (!dir || seen$1.has(node2)) {
          return;
        }
        seen$1.add(node2);
        return () => {
          const codegenNode = node2.codegenNode || context2.currentNode.codegenNode;
          if (codegenNode && codegenNode.type === 13) {
            if (node2.tagType !== 1) {
              makeBlock(codegenNode, context2);
            }
            node2.codegenNode = createCallExpression(context2.helper(WITH_MEMO), [
              dir.exp,
              createFunctionExpression(void 0, codegenNode),
              `_cache`,
              String(context2.cached++)
            ]);
          }
        };
      }
    };
    function getBaseTransformPreset(prefixIdentifiers) {
      return [
        [
          transformOnce,
          transformIf,
          transformMemo,
          transformFor,
          ...[transformFilter],
          ...true ? [transformExpression] : [],
          transformSlotOutlet,
          transformElement,
          trackSlotScopes,
          transformText
        ],
        {
          on: transformOn,
          bind: transformBind,
          model: transformModel
        }
      ];
    }
    function baseCompile(template2, options2 = {}) {
      const onError = options2.onError || defaultOnError;
      const isModuleMode = options2.mode === "module";
      {
        if (options2.prefixIdentifiers === true) {
          onError(createCompilerError(46));
        } else if (isModuleMode) {
          onError(createCompilerError(47));
        }
      }
      const prefixIdentifiers = false;
      if (options2.cacheHandlers) {
        onError(createCompilerError(48));
      }
      if (options2.scopeId && !isModuleMode) {
        onError(createCompilerError(49));
      }
      const ast = isString2(template2) ? baseParse(template2, options2) : template2;
      const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
      transform2(ast, extend2({}, options2, {
        prefixIdentifiers,
        nodeTransforms: [
          ...nodeTransforms,
          ...options2.nodeTransforms || []
        ],
        directiveTransforms: extend2({}, directiveTransforms, options2.directiveTransforms || {})
      }));
      return generate2(ast, extend2({}, options2, {
        prefixIdentifiers
      }));
    }
    var noopDirectiveTransform = () => ({ props: [] });
    var compilerCore_esmBundler = {
      __proto__: null,
      BASE_TRANSITION,
      CAMELIZE,
      CAPITALIZE,
      CREATE_BLOCK,
      CREATE_COMMENT,
      CREATE_ELEMENT_BLOCK,
      CREATE_ELEMENT_VNODE,
      CREATE_SLOTS,
      CREATE_STATIC,
      CREATE_TEXT,
      CREATE_VNODE,
      FRAGMENT,
      GUARD_REACTIVE_PROPS,
      IS_MEMO_SAME,
      IS_REF,
      KEEP_ALIVE,
      MERGE_PROPS,
      NORMALIZE_CLASS,
      NORMALIZE_PROPS,
      NORMALIZE_STYLE,
      OPEN_BLOCK,
      POP_SCOPE_ID,
      PUSH_SCOPE_ID,
      RENDER_LIST,
      RENDER_SLOT,
      RESOLVE_COMPONENT,
      RESOLVE_DIRECTIVE,
      RESOLVE_DYNAMIC_COMPONENT,
      RESOLVE_FILTER,
      SET_BLOCK_TRACKING,
      SUSPENSE,
      TELEPORT,
      TO_DISPLAY_STRING,
      TO_HANDLERS,
      TO_HANDLER_KEY,
      UNREF,
      WITH_CTX,
      WITH_DIRECTIVES,
      WITH_MEMO,
      advancePositionWithClone,
      advancePositionWithMutation,
      assert: assert2,
      baseCompile,
      baseParse,
      buildProps,
      buildSlots,
      checkCompatEnabled,
      createArrayExpression,
      createAssignmentExpression,
      createBlockStatement,
      createCacheExpression,
      createCallExpression,
      createCompilerError,
      createCompoundExpression,
      createConditionalExpression,
      createForLoopParams,
      createFunctionExpression,
      createIfStatement,
      createInterpolation,
      createObjectExpression,
      createObjectProperty,
      createReturnStatement,
      createRoot,
      createSequenceExpression,
      createSimpleExpression,
      createStructuralDirectiveTransform,
      createTemplateLiteral,
      createTransformContext,
      createVNodeCall,
      extractIdentifiers,
      findDir,
      findProp,
      generate: generate2,
      getBaseTransformPreset,
      getInnerRange,
      getMemoedVNodeCall,
      getVNodeBlockHelper,
      getVNodeHelper,
      hasDynamicKeyVBind,
      hasScopeRef,
      helperNameMap,
      injectProp,
      isBuiltInType,
      isCoreComponent,
      isFunctionType,
      isInDestructureAssignment,
      isMemberExpression,
      isMemberExpressionBrowser,
      isMemberExpressionNode,
      isReferencedIdentifier,
      isSimpleIdentifier,
      isSlotOutlet,
      isStaticArgOf,
      isStaticExp,
      isStaticProperty: isStaticProperty2,
      isStaticPropertyKey: isStaticPropertyKey2,
      isTemplateNode,
      isText,
      isVSlot,
      locStub,
      makeBlock,
      noopDirectiveTransform,
      processExpression,
      processFor,
      processIf,
      processSlotOutlet,
      registerRuntimeHelpers,
      resolveComponentType,
      toValidAssetId,
      trackSlotScopes,
      trackVForSlotScopes,
      transform: transform2,
      transformBind,
      transformElement,
      transformExpression,
      transformModel,
      transformOn,
      traverseNode,
      walkBlockDeclarations,
      walkFunctionParams,
      walkIdentifiers,
      warnDeprecation,
      generateCodeFrame: generateCodeFrame2
    };
    var require$$02 = build2.getAugmentedNamespace(compilerCore_esmBundler);
    var require$$12 = build2.getAugmentedNamespace(shared_esmBundler);
    (function(exports3) {
      Object.defineProperty(exports3, "__esModule", { value: true });
      var compilerCore = require$$02;
      var shared = require$$12;
      const V_MODEL_RADIO = Symbol(`vModelRadio`);
      const V_MODEL_CHECKBOX = Symbol(`vModelCheckbox`);
      const V_MODEL_TEXT = Symbol(`vModelText`);
      const V_MODEL_SELECT = Symbol(`vModelSelect`);
      const V_MODEL_DYNAMIC = Symbol(`vModelDynamic`);
      const V_ON_WITH_MODIFIERS = Symbol(`vOnModifiersGuard`);
      const V_ON_WITH_KEYS = Symbol(`vOnKeysGuard`);
      const V_SHOW = Symbol(`vShow`);
      const TRANSITION = Symbol(`Transition`);
      const TRANSITION_GROUP = Symbol(`TransitionGroup`);
      compilerCore.registerRuntimeHelpers({
        [V_MODEL_RADIO]: `vModelRadio`,
        [V_MODEL_CHECKBOX]: `vModelCheckbox`,
        [V_MODEL_TEXT]: `vModelText`,
        [V_MODEL_SELECT]: `vModelSelect`,
        [V_MODEL_DYNAMIC]: `vModelDynamic`,
        [V_ON_WITH_MODIFIERS]: `withModifiers`,
        [V_ON_WITH_KEYS]: `withKeys`,
        [V_SHOW]: `vShow`,
        [TRANSITION]: `Transition`,
        [TRANSITION_GROUP]: `TransitionGroup`
      });
      var namedCharacterReferences = {
        GT: ">",
        gt: ">",
        LT: "<",
        lt: "<",
        "ac;": "\u223E",
        "af;": "\u2061",
        AMP: "&",
        amp: "&",
        "ap;": "\u2248",
        "DD;": "\u2145",
        "dd;": "\u2146",
        deg: "\xB0",
        "ee;": "\u2147",
        "eg;": "\u2A9A",
        "el;": "\u2A99",
        ETH: "\xD0",
        eth: "\xF0",
        "gE;": "\u2267",
        "ge;": "\u2265",
        "Gg;": "\u22D9",
        "gg;": "\u226B",
        "gl;": "\u2277",
        "GT;": ">",
        "Gt;": "\u226B",
        "gt;": ">",
        "ic;": "\u2063",
        "ii;": "\u2148",
        "Im;": "\u2111",
        "in;": "\u2208",
        "it;": "\u2062",
        "lE;": "\u2266",
        "le;": "\u2264",
        "lg;": "\u2276",
        "Ll;": "\u22D8",
        "ll;": "\u226A",
        "LT;": "<",
        "Lt;": "\u226A",
        "lt;": "<",
        "mp;": "\u2213",
        "Mu;": "\u039C",
        "mu;": "\u03BC",
        "ne;": "\u2260",
        "ni;": "\u220B",
        not: "\xAC",
        "Nu;": "\u039D",
        "nu;": "\u03BD",
        "Or;": "\u2A54",
        "or;": "\u2228",
        "oS;": "\u24C8",
        "Pi;": "\u03A0",
        "pi;": "\u03C0",
        "pm;": "\xB1",
        "Pr;": "\u2ABB",
        "pr;": "\u227A",
        "Re;": "\u211C",
        REG: "\xAE",
        reg: "\xAE",
        "rx;": "\u211E",
        "Sc;": "\u2ABC",
        "sc;": "\u227B",
        shy: "\xAD",
        uml: "\xA8",
        "wp;": "\u2118",
        "wr;": "\u2240",
        "Xi;": "\u039E",
        "xi;": "\u03BE",
        yen: "\xA5",
        "acd;": "\u223F",
        "acE;": "\u223E\u0333",
        "Acy;": "\u0410",
        "acy;": "\u0430",
        "Afr;": "\u{1D504}",
        "afr;": "\u{1D51E}",
        "AMP;": "&",
        "amp;": "&",
        "And;": "\u2A53",
        "and;": "\u2227",
        "ang;": "\u2220",
        "apE;": "\u2A70",
        "ape;": "\u224A",
        "ast;": "*",
        Auml: "\xC4",
        auml: "\xE4",
        "Bcy;": "\u0411",
        "bcy;": "\u0431",
        "Bfr;": "\u{1D505}",
        "bfr;": "\u{1D51F}",
        "bne;": "=\u20E5",
        "bot;": "\u22A5",
        "Cap;": "\u22D2",
        "cap;": "\u2229",
        cent: "\xA2",
        "Cfr;": "\u212D",
        "cfr;": "\u{1D520}",
        "Chi;": "\u03A7",
        "chi;": "\u03C7",
        "cir;": "\u25CB",
        COPY: "\xA9",
        copy: "\xA9",
        "Cup;": "\u22D3",
        "cup;": "\u222A",
        "Dcy;": "\u0414",
        "dcy;": "\u0434",
        "deg;": "\xB0",
        "Del;": "\u2207",
        "Dfr;": "\u{1D507}",
        "dfr;": "\u{1D521}",
        "die;": "\xA8",
        "div;": "\xF7",
        "Dot;": "\xA8",
        "dot;": "\u02D9",
        "Ecy;": "\u042D",
        "ecy;": "\u044D",
        "Efr;": "\u{1D508}",
        "efr;": "\u{1D522}",
        "egs;": "\u2A96",
        "ell;": "\u2113",
        "els;": "\u2A95",
        "ENG;": "\u014A",
        "eng;": "\u014B",
        "Eta;": "\u0397",
        "eta;": "\u03B7",
        "ETH;": "\xD0",
        "eth;": "\xF0",
        Euml: "\xCB",
        euml: "\xEB",
        "Fcy;": "\u0424",
        "fcy;": "\u0444",
        "Ffr;": "\u{1D509}",
        "ffr;": "\u{1D523}",
        "gap;": "\u2A86",
        "Gcy;": "\u0413",
        "gcy;": "\u0433",
        "gEl;": "\u2A8C",
        "gel;": "\u22DB",
        "geq;": "\u2265",
        "ges;": "\u2A7E",
        "Gfr;": "\u{1D50A}",
        "gfr;": "\u{1D524}",
        "ggg;": "\u22D9",
        "gla;": "\u2AA5",
        "glE;": "\u2A92",
        "glj;": "\u2AA4",
        "gnE;": "\u2269",
        "gne;": "\u2A88",
        "Hat;": "^",
        "Hfr;": "\u210C",
        "hfr;": "\u{1D525}",
        "Icy;": "\u0418",
        "icy;": "\u0438",
        "iff;": "\u21D4",
        "Ifr;": "\u2111",
        "ifr;": "\u{1D526}",
        "Int;": "\u222C",
        "int;": "\u222B",
        Iuml: "\xCF",
        iuml: "\xEF",
        "Jcy;": "\u0419",
        "jcy;": "\u0439",
        "Jfr;": "\u{1D50D}",
        "jfr;": "\u{1D527}",
        "Kcy;": "\u041A",
        "kcy;": "\u043A",
        "Kfr;": "\u{1D50E}",
        "kfr;": "\u{1D528}",
        "lap;": "\u2A85",
        "lat;": "\u2AAB",
        "Lcy;": "\u041B",
        "lcy;": "\u043B",
        "lEg;": "\u2A8B",
        "leg;": "\u22DA",
        "leq;": "\u2264",
        "les;": "\u2A7D",
        "Lfr;": "\u{1D50F}",
        "lfr;": "\u{1D529}",
        "lgE;": "\u2A91",
        "lnE;": "\u2268",
        "lne;": "\u2A87",
        "loz;": "\u25CA",
        "lrm;": "\u200E",
        "Lsh;": "\u21B0",
        "lsh;": "\u21B0",
        macr: "\xAF",
        "Map;": "\u2905",
        "map;": "\u21A6",
        "Mcy;": "\u041C",
        "mcy;": "\u043C",
        "Mfr;": "\u{1D510}",
        "mfr;": "\u{1D52A}",
        "mho;": "\u2127",
        "mid;": "\u2223",
        "nap;": "\u2249",
        nbsp: "\xA0",
        "Ncy;": "\u041D",
        "ncy;": "\u043D",
        "Nfr;": "\u{1D511}",
        "nfr;": "\u{1D52B}",
        "ngE;": "\u2267\u0338",
        "nge;": "\u2271",
        "nGg;": "\u22D9\u0338",
        "nGt;": "\u226B\u20D2",
        "ngt;": "\u226F",
        "nis;": "\u22FC",
        "niv;": "\u220B",
        "nlE;": "\u2266\u0338",
        "nle;": "\u2270",
        "nLl;": "\u22D8\u0338",
        "nLt;": "\u226A\u20D2",
        "nlt;": "\u226E",
        "Not;": "\u2AEC",
        "not;": "\xAC",
        "npr;": "\u2280",
        "nsc;": "\u2281",
        "num;": "#",
        "Ocy;": "\u041E",
        "ocy;": "\u043E",
        "Ofr;": "\u{1D512}",
        "ofr;": "\u{1D52C}",
        "ogt;": "\u29C1",
        "ohm;": "\u03A9",
        "olt;": "\u29C0",
        "ord;": "\u2A5D",
        ordf: "\xAA",
        ordm: "\xBA",
        "orv;": "\u2A5B",
        Ouml: "\xD6",
        ouml: "\xF6",
        "par;": "\u2225",
        para: "\xB6",
        "Pcy;": "\u041F",
        "pcy;": "\u043F",
        "Pfr;": "\u{1D513}",
        "pfr;": "\u{1D52D}",
        "Phi;": "\u03A6",
        "phi;": "\u03C6",
        "piv;": "\u03D6",
        "prE;": "\u2AB3",
        "pre;": "\u2AAF",
        "Psi;": "\u03A8",
        "psi;": "\u03C8",
        "Qfr;": "\u{1D514}",
        "qfr;": "\u{1D52E}",
        QUOT: '"',
        quot: '"',
        "Rcy;": "\u0420",
        "rcy;": "\u0440",
        "REG;": "\xAE",
        "reg;": "\xAE",
        "Rfr;": "\u211C",
        "rfr;": "\u{1D52F}",
        "Rho;": "\u03A1",
        "rho;": "\u03C1",
        "rlm;": "\u200F",
        "Rsh;": "\u21B1",
        "rsh;": "\u21B1",
        "scE;": "\u2AB4",
        "sce;": "\u2AB0",
        "Scy;": "\u0421",
        "scy;": "\u0441",
        sect: "\xA7",
        "Sfr;": "\u{1D516}",
        "sfr;": "\u{1D530}",
        "shy;": "\xAD",
        "sim;": "\u223C",
        "smt;": "\u2AAA",
        "sol;": "/",
        "squ;": "\u25A1",
        "Sub;": "\u22D0",
        "sub;": "\u2282",
        "Sum;": "\u2211",
        "sum;": "\u2211",
        "Sup;": "\u22D1",
        "sup;": "\u2283",
        sup1: "\xB9",
        sup2: "\xB2",
        sup3: "\xB3",
        "Tab;": "	",
        "Tau;": "\u03A4",
        "tau;": "\u03C4",
        "Tcy;": "\u0422",
        "tcy;": "\u0442",
        "Tfr;": "\u{1D517}",
        "tfr;": "\u{1D531}",
        "top;": "\u22A4",
        "Ucy;": "\u0423",
        "ucy;": "\u0443",
        "Ufr;": "\u{1D518}",
        "ufr;": "\u{1D532}",
        "uml;": "\xA8",
        Uuml: "\xDC",
        uuml: "\xFC",
        "Vcy;": "\u0412",
        "vcy;": "\u0432",
        "Vee;": "\u22C1",
        "vee;": "\u2228",
        "Vfr;": "\u{1D519}",
        "vfr;": "\u{1D533}",
        "Wfr;": "\u{1D51A}",
        "wfr;": "\u{1D534}",
        "Xfr;": "\u{1D51B}",
        "xfr;": "\u{1D535}",
        "Ycy;": "\u042B",
        "ycy;": "\u044B",
        "yen;": "\xA5",
        "Yfr;": "\u{1D51C}",
        "yfr;": "\u{1D536}",
        yuml: "\xFF",
        "Zcy;": "\u0417",
        "zcy;": "\u0437",
        "Zfr;": "\u2128",
        "zfr;": "\u{1D537}",
        "zwj;": "\u200D",
        Acirc: "\xC2",
        acirc: "\xE2",
        acute: "\xB4",
        AElig: "\xC6",
        aelig: "\xE6",
        "andd;": "\u2A5C",
        "andv;": "\u2A5A",
        "ange;": "\u29A4",
        "Aopf;": "\u{1D538}",
        "aopf;": "\u{1D552}",
        "apid;": "\u224B",
        "apos;": "'",
        Aring: "\xC5",
        aring: "\xE5",
        "Ascr;": "\u{1D49C}",
        "ascr;": "\u{1D4B6}",
        "Auml;": "\xC4",
        "auml;": "\xE4",
        "Barv;": "\u2AE7",
        "bbrk;": "\u23B5",
        "Beta;": "\u0392",
        "beta;": "\u03B2",
        "beth;": "\u2136",
        "bNot;": "\u2AED",
        "bnot;": "\u2310",
        "Bopf;": "\u{1D539}",
        "bopf;": "\u{1D553}",
        "boxH;": "\u2550",
        "boxh;": "\u2500",
        "boxV;": "\u2551",
        "boxv;": "\u2502",
        "Bscr;": "\u212C",
        "bscr;": "\u{1D4B7}",
        "bsim;": "\u223D",
        "bsol;": "\\",
        "bull;": "\u2022",
        "bump;": "\u224E",
        "caps;": "\u2229\uFE00",
        "Cdot;": "\u010A",
        "cdot;": "\u010B",
        cedil: "\xB8",
        "cent;": "\xA2",
        "CHcy;": "\u0427",
        "chcy;": "\u0447",
        "circ;": "\u02C6",
        "cirE;": "\u29C3",
        "cire;": "\u2257",
        "comp;": "\u2201",
        "cong;": "\u2245",
        "Copf;": "\u2102",
        "copf;": "\u{1D554}",
        "COPY;": "\xA9",
        "copy;": "\xA9",
        "Cscr;": "\u{1D49E}",
        "cscr;": "\u{1D4B8}",
        "csub;": "\u2ACF",
        "csup;": "\u2AD0",
        "cups;": "\u222A\uFE00",
        "Darr;": "\u21A1",
        "dArr;": "\u21D3",
        "darr;": "\u2193",
        "dash;": "\u2010",
        "dHar;": "\u2965",
        "diam;": "\u22C4",
        "DJcy;": "\u0402",
        "djcy;": "\u0452",
        "Dopf;": "\u{1D53B}",
        "dopf;": "\u{1D555}",
        "Dscr;": "\u{1D49F}",
        "dscr;": "\u{1D4B9}",
        "DScy;": "\u0405",
        "dscy;": "\u0455",
        "dsol;": "\u29F6",
        "dtri;": "\u25BF",
        "DZcy;": "\u040F",
        "dzcy;": "\u045F",
        "ecir;": "\u2256",
        Ecirc: "\xCA",
        ecirc: "\xEA",
        "Edot;": "\u0116",
        "eDot;": "\u2251",
        "edot;": "\u0117",
        "emsp;": "\u2003",
        "ensp;": "\u2002",
        "Eopf;": "\u{1D53C}",
        "eopf;": "\u{1D556}",
        "epar;": "\u22D5",
        "epsi;": "\u03B5",
        "Escr;": "\u2130",
        "escr;": "\u212F",
        "Esim;": "\u2A73",
        "esim;": "\u2242",
        "Euml;": "\xCB",
        "euml;": "\xEB",
        "euro;": "\u20AC",
        "excl;": "!",
        "flat;": "\u266D",
        "fnof;": "\u0192",
        "Fopf;": "\u{1D53D}",
        "fopf;": "\u{1D557}",
        "fork;": "\u22D4",
        "Fscr;": "\u2131",
        "fscr;": "\u{1D4BB}",
        "Gdot;": "\u0120",
        "gdot;": "\u0121",
        "geqq;": "\u2267",
        "gesl;": "\u22DB\uFE00",
        "GJcy;": "\u0403",
        "gjcy;": "\u0453",
        "gnap;": "\u2A8A",
        "gneq;": "\u2A88",
        "Gopf;": "\u{1D53E}",
        "gopf;": "\u{1D558}",
        "Gscr;": "\u{1D4A2}",
        "gscr;": "\u210A",
        "gsim;": "\u2273",
        "gtcc;": "\u2AA7",
        "gvnE;": "\u2269\uFE00",
        "half;": "\xBD",
        "hArr;": "\u21D4",
        "harr;": "\u2194",
        "hbar;": "\u210F",
        "Hopf;": "\u210D",
        "hopf;": "\u{1D559}",
        "Hscr;": "\u210B",
        "hscr;": "\u{1D4BD}",
        Icirc: "\xCE",
        icirc: "\xEE",
        "Idot;": "\u0130",
        "IEcy;": "\u0415",
        "iecy;": "\u0435",
        iexcl: "\xA1",
        "imof;": "\u22B7",
        "IOcy;": "\u0401",
        "iocy;": "\u0451",
        "Iopf;": "\u{1D540}",
        "iopf;": "\u{1D55A}",
        "Iota;": "\u0399",
        "iota;": "\u03B9",
        "Iscr;": "\u2110",
        "iscr;": "\u{1D4BE}",
        "isin;": "\u2208",
        "Iuml;": "\xCF",
        "iuml;": "\xEF",
        "Jopf;": "\u{1D541}",
        "jopf;": "\u{1D55B}",
        "Jscr;": "\u{1D4A5}",
        "jscr;": "\u{1D4BF}",
        "KHcy;": "\u0425",
        "khcy;": "\u0445",
        "KJcy;": "\u040C",
        "kjcy;": "\u045C",
        "Kopf;": "\u{1D542}",
        "kopf;": "\u{1D55C}",
        "Kscr;": "\u{1D4A6}",
        "kscr;": "\u{1D4C0}",
        "Lang;": "\u27EA",
        "lang;": "\u27E8",
        laquo: "\xAB",
        "Larr;": "\u219E",
        "lArr;": "\u21D0",
        "larr;": "\u2190",
        "late;": "\u2AAD",
        "lcub;": "{",
        "ldca;": "\u2936",
        "ldsh;": "\u21B2",
        "leqq;": "\u2266",
        "lesg;": "\u22DA\uFE00",
        "lHar;": "\u2962",
        "LJcy;": "\u0409",
        "ljcy;": "\u0459",
        "lnap;": "\u2A89",
        "lneq;": "\u2A87",
        "Lopf;": "\u{1D543}",
        "lopf;": "\u{1D55D}",
        "lozf;": "\u29EB",
        "lpar;": "(",
        "Lscr;": "\u2112",
        "lscr;": "\u{1D4C1}",
        "lsim;": "\u2272",
        "lsqb;": "[",
        "ltcc;": "\u2AA6",
        "ltri;": "\u25C3",
        "lvnE;": "\u2268\uFE00",
        "macr;": "\xAF",
        "male;": "\u2642",
        "malt;": "\u2720",
        micro: "\xB5",
        "mlcp;": "\u2ADB",
        "mldr;": "\u2026",
        "Mopf;": "\u{1D544}",
        "mopf;": "\u{1D55E}",
        "Mscr;": "\u2133",
        "mscr;": "\u{1D4C2}",
        "nang;": "\u2220\u20D2",
        "napE;": "\u2A70\u0338",
        "nbsp;": "\xA0",
        "ncap;": "\u2A43",
        "ncup;": "\u2A42",
        "ngeq;": "\u2271",
        "nges;": "\u2A7E\u0338",
        "ngtr;": "\u226F",
        "nGtv;": "\u226B\u0338",
        "nisd;": "\u22FA",
        "NJcy;": "\u040A",
        "njcy;": "\u045A",
        "nldr;": "\u2025",
        "nleq;": "\u2270",
        "nles;": "\u2A7D\u0338",
        "nLtv;": "\u226A\u0338",
        "nmid;": "\u2224",
        "Nopf;": "\u2115",
        "nopf;": "\u{1D55F}",
        "npar;": "\u2226",
        "npre;": "\u2AAF\u0338",
        "nsce;": "\u2AB0\u0338",
        "Nscr;": "\u{1D4A9}",
        "nscr;": "\u{1D4C3}",
        "nsim;": "\u2241",
        "nsub;": "\u2284",
        "nsup;": "\u2285",
        "ntgl;": "\u2279",
        "ntlg;": "\u2278",
        "nvap;": "\u224D\u20D2",
        "nvge;": "\u2265\u20D2",
        "nvgt;": ">\u20D2",
        "nvle;": "\u2264\u20D2",
        "nvlt;": "<\u20D2",
        "oast;": "\u229B",
        "ocir;": "\u229A",
        Ocirc: "\xD4",
        ocirc: "\xF4",
        "odiv;": "\u2A38",
        "odot;": "\u2299",
        "ogon;": "\u02DB",
        "oint;": "\u222E",
        "omid;": "\u29B6",
        "Oopf;": "\u{1D546}",
        "oopf;": "\u{1D560}",
        "opar;": "\u29B7",
        "ordf;": "\xAA",
        "ordm;": "\xBA",
        "oror;": "\u2A56",
        "Oscr;": "\u{1D4AA}",
        "oscr;": "\u2134",
        "osol;": "\u2298",
        "Ouml;": "\xD6",
        "ouml;": "\xF6",
        "para;": "\xB6",
        "part;": "\u2202",
        "perp;": "\u22A5",
        "phiv;": "\u03D5",
        "plus;": "+",
        "Popf;": "\u2119",
        "popf;": "\u{1D561}",
        pound: "\xA3",
        "prap;": "\u2AB7",
        "prec;": "\u227A",
        "prnE;": "\u2AB5",
        "prod;": "\u220F",
        "prop;": "\u221D",
        "Pscr;": "\u{1D4AB}",
        "pscr;": "\u{1D4C5}",
        "qint;": "\u2A0C",
        "Qopf;": "\u211A",
        "qopf;": "\u{1D562}",
        "Qscr;": "\u{1D4AC}",
        "qscr;": "\u{1D4C6}",
        "QUOT;": '"',
        "quot;": '"',
        "race;": "\u223D\u0331",
        "Rang;": "\u27EB",
        "rang;": "\u27E9",
        raquo: "\xBB",
        "Rarr;": "\u21A0",
        "rArr;": "\u21D2",
        "rarr;": "\u2192",
        "rcub;": "}",
        "rdca;": "\u2937",
        "rdsh;": "\u21B3",
        "real;": "\u211C",
        "rect;": "\u25AD",
        "rHar;": "\u2964",
        "rhov;": "\u03F1",
        "ring;": "\u02DA",
        "Ropf;": "\u211D",
        "ropf;": "\u{1D563}",
        "rpar;": ")",
        "Rscr;": "\u211B",
        "rscr;": "\u{1D4C7}",
        "rsqb;": "]",
        "rtri;": "\u25B9",
        "scap;": "\u2AB8",
        "scnE;": "\u2AB6",
        "sdot;": "\u22C5",
        "sect;": "\xA7",
        "semi;": ";",
        "sext;": "\u2736",
        "SHcy;": "\u0428",
        "shcy;": "\u0448",
        "sime;": "\u2243",
        "simg;": "\u2A9E",
        "siml;": "\u2A9D",
        "smid;": "\u2223",
        "smte;": "\u2AAC",
        "solb;": "\u29C4",
        "Sopf;": "\u{1D54A}",
        "sopf;": "\u{1D564}",
        "spar;": "\u2225",
        "Sqrt;": "\u221A",
        "squf;": "\u25AA",
        "Sscr;": "\u{1D4AE}",
        "sscr;": "\u{1D4C8}",
        "Star;": "\u22C6",
        "star;": "\u2606",
        "subE;": "\u2AC5",
        "sube;": "\u2286",
        "succ;": "\u227B",
        "sung;": "\u266A",
        "sup1;": "\xB9",
        "sup2;": "\xB2",
        "sup3;": "\xB3",
        "supE;": "\u2AC6",
        "supe;": "\u2287",
        szlig: "\xDF",
        "tbrk;": "\u23B4",
        "tdot;": "\u20DB",
        THORN: "\xDE",
        thorn: "\xFE",
        times: "\xD7",
        "tint;": "\u222D",
        "toea;": "\u2928",
        "Topf;": "\u{1D54B}",
        "topf;": "\u{1D565}",
        "tosa;": "\u2929",
        "trie;": "\u225C",
        "Tscr;": "\u{1D4AF}",
        "tscr;": "\u{1D4C9}",
        "TScy;": "\u0426",
        "tscy;": "\u0446",
        "Uarr;": "\u219F",
        "uArr;": "\u21D1",
        "uarr;": "\u2191",
        Ucirc: "\xDB",
        ucirc: "\xFB",
        "uHar;": "\u2963",
        "Uopf;": "\u{1D54C}",
        "uopf;": "\u{1D566}",
        "Upsi;": "\u03D2",
        "upsi;": "\u03C5",
        "Uscr;": "\u{1D4B0}",
        "uscr;": "\u{1D4CA}",
        "utri;": "\u25B5",
        "Uuml;": "\xDC",
        "uuml;": "\xFC",
        "vArr;": "\u21D5",
        "varr;": "\u2195",
        "Vbar;": "\u2AEB",
        "vBar;": "\u2AE8",
        "Vert;": "\u2016",
        "vert;": "|",
        "Vopf;": "\u{1D54D}",
        "vopf;": "\u{1D567}",
        "Vscr;": "\u{1D4B1}",
        "vscr;": "\u{1D4CB}",
        "Wopf;": "\u{1D54E}",
        "wopf;": "\u{1D568}",
        "Wscr;": "\u{1D4B2}",
        "wscr;": "\u{1D4CC}",
        "xcap;": "\u22C2",
        "xcup;": "\u22C3",
        "xmap;": "\u27FC",
        "xnis;": "\u22FB",
        "Xopf;": "\u{1D54F}",
        "xopf;": "\u{1D569}",
        "Xscr;": "\u{1D4B3}",
        "xscr;": "\u{1D4CD}",
        "xvee;": "\u22C1",
        "YAcy;": "\u042F",
        "yacy;": "\u044F",
        "YIcy;": "\u0407",
        "yicy;": "\u0457",
        "Yopf;": "\u{1D550}",
        "yopf;": "\u{1D56A}",
        "Yscr;": "\u{1D4B4}",
        "yscr;": "\u{1D4CE}",
        "YUcy;": "\u042E",
        "yucy;": "\u044E",
        "Yuml;": "\u0178",
        "yuml;": "\xFF",
        "Zdot;": "\u017B",
        "zdot;": "\u017C",
        "Zeta;": "\u0396",
        "zeta;": "\u03B6",
        "ZHcy;": "\u0416",
        "zhcy;": "\u0436",
        "Zopf;": "\u2124",
        "zopf;": "\u{1D56B}",
        "Zscr;": "\u{1D4B5}",
        "zscr;": "\u{1D4CF}",
        "zwnj;": "\u200C",
        Aacute: "\xC1",
        aacute: "\xE1",
        "Acirc;": "\xC2",
        "acirc;": "\xE2",
        "acute;": "\xB4",
        "AElig;": "\xC6",
        "aelig;": "\xE6",
        Agrave: "\xC0",
        agrave: "\xE0",
        "aleph;": "\u2135",
        "Alpha;": "\u0391",
        "alpha;": "\u03B1",
        "Amacr;": "\u0100",
        "amacr;": "\u0101",
        "amalg;": "\u2A3F",
        "angle;": "\u2220",
        "angrt;": "\u221F",
        "angst;": "\xC5",
        "Aogon;": "\u0104",
        "aogon;": "\u0105",
        "Aring;": "\xC5",
        "aring;": "\xE5",
        "asymp;": "\u2248",
        Atilde: "\xC3",
        atilde: "\xE3",
        "awint;": "\u2A11",
        "bcong;": "\u224C",
        "bdquo;": "\u201E",
        "bepsi;": "\u03F6",
        "blank;": "\u2423",
        "blk12;": "\u2592",
        "blk14;": "\u2591",
        "blk34;": "\u2593",
        "block;": "\u2588",
        "boxDL;": "\u2557",
        "boxDl;": "\u2556",
        "boxdL;": "\u2555",
        "boxdl;": "\u2510",
        "boxDR;": "\u2554",
        "boxDr;": "\u2553",
        "boxdR;": "\u2552",
        "boxdr;": "\u250C",
        "boxHD;": "\u2566",
        "boxHd;": "\u2564",
        "boxhD;": "\u2565",
        "boxhd;": "\u252C",
        "boxHU;": "\u2569",
        "boxHu;": "\u2567",
        "boxhU;": "\u2568",
        "boxhu;": "\u2534",
        "boxUL;": "\u255D",
        "boxUl;": "\u255C",
        "boxuL;": "\u255B",
        "boxul;": "\u2518",
        "boxUR;": "\u255A",
        "boxUr;": "\u2559",
        "boxuR;": "\u2558",
        "boxur;": "\u2514",
        "boxVH;": "\u256C",
        "boxVh;": "\u256B",
        "boxvH;": "\u256A",
        "boxvh;": "\u253C",
        "boxVL;": "\u2563",
        "boxVl;": "\u2562",
        "boxvL;": "\u2561",
        "boxvl;": "\u2524",
        "boxVR;": "\u2560",
        "boxVr;": "\u255F",
        "boxvR;": "\u255E",
        "boxvr;": "\u251C",
        "Breve;": "\u02D8",
        "breve;": "\u02D8",
        brvbar: "\xA6",
        "bsemi;": "\u204F",
        "bsime;": "\u22CD",
        "bsolb;": "\u29C5",
        "bumpE;": "\u2AAE",
        "bumpe;": "\u224F",
        "caret;": "\u2041",
        "caron;": "\u02C7",
        "ccaps;": "\u2A4D",
        Ccedil: "\xC7",
        ccedil: "\xE7",
        "Ccirc;": "\u0108",
        "ccirc;": "\u0109",
        "ccups;": "\u2A4C",
        "cedil;": "\xB8",
        "check;": "\u2713",
        "clubs;": "\u2663",
        "Colon;": "\u2237",
        "colon;": ":",
        "comma;": ",",
        "crarr;": "\u21B5",
        "Cross;": "\u2A2F",
        "cross;": "\u2717",
        "csube;": "\u2AD1",
        "csupe;": "\u2AD2",
        "ctdot;": "\u22EF",
        "cuepr;": "\u22DE",
        "cuesc;": "\u22DF",
        "cupor;": "\u2A45",
        curren: "\xA4",
        "cuvee;": "\u22CE",
        "cuwed;": "\u22CF",
        "cwint;": "\u2231",
        "Dashv;": "\u2AE4",
        "dashv;": "\u22A3",
        "dblac;": "\u02DD",
        "ddarr;": "\u21CA",
        "Delta;": "\u0394",
        "delta;": "\u03B4",
        "dharl;": "\u21C3",
        "dharr;": "\u21C2",
        "diams;": "\u2666",
        "disin;": "\u22F2",
        divide: "\xF7",
        "doteq;": "\u2250",
        "dtdot;": "\u22F1",
        "dtrif;": "\u25BE",
        "duarr;": "\u21F5",
        "duhar;": "\u296F",
        Eacute: "\xC9",
        eacute: "\xE9",
        "Ecirc;": "\xCA",
        "ecirc;": "\xEA",
        "eDDot;": "\u2A77",
        "efDot;": "\u2252",
        Egrave: "\xC8",
        egrave: "\xE8",
        "Emacr;": "\u0112",
        "emacr;": "\u0113",
        "empty;": "\u2205",
        "Eogon;": "\u0118",
        "eogon;": "\u0119",
        "eplus;": "\u2A71",
        "epsiv;": "\u03F5",
        "eqsim;": "\u2242",
        "Equal;": "\u2A75",
        "equiv;": "\u2261",
        "erarr;": "\u2971",
        "erDot;": "\u2253",
        "esdot;": "\u2250",
        "exist;": "\u2203",
        "fflig;": "\uFB00",
        "filig;": "\uFB01",
        "fjlig;": "fj",
        "fllig;": "\uFB02",
        "fltns;": "\u25B1",
        "forkv;": "\u2AD9",
        frac12: "\xBD",
        frac14: "\xBC",
        frac34: "\xBE",
        "frasl;": "\u2044",
        "frown;": "\u2322",
        "Gamma;": "\u0393",
        "gamma;": "\u03B3",
        "Gcirc;": "\u011C",
        "gcirc;": "\u011D",
        "gescc;": "\u2AA9",
        "gimel;": "\u2137",
        "gneqq;": "\u2269",
        "gnsim;": "\u22E7",
        "grave;": "`",
        "gsime;": "\u2A8E",
        "gsiml;": "\u2A90",
        "gtcir;": "\u2A7A",
        "gtdot;": "\u22D7",
        "Hacek;": "\u02C7",
        "harrw;": "\u21AD",
        "Hcirc;": "\u0124",
        "hcirc;": "\u0125",
        "hoarr;": "\u21FF",
        Iacute: "\xCD",
        iacute: "\xED",
        "Icirc;": "\xCE",
        "icirc;": "\xEE",
        "iexcl;": "\xA1",
        Igrave: "\xCC",
        igrave: "\xEC",
        "iiint;": "\u222D",
        "iiota;": "\u2129",
        "IJlig;": "\u0132",
        "ijlig;": "\u0133",
        "Imacr;": "\u012A",
        "imacr;": "\u012B",
        "image;": "\u2111",
        "imath;": "\u0131",
        "imped;": "\u01B5",
        "infin;": "\u221E",
        "Iogon;": "\u012E",
        "iogon;": "\u012F",
        "iprod;": "\u2A3C",
        iquest: "\xBF",
        "isinE;": "\u22F9",
        "isins;": "\u22F4",
        "isinv;": "\u2208",
        "Iukcy;": "\u0406",
        "iukcy;": "\u0456",
        "Jcirc;": "\u0134",
        "jcirc;": "\u0135",
        "jmath;": "\u0237",
        "Jukcy;": "\u0404",
        "jukcy;": "\u0454",
        "Kappa;": "\u039A",
        "kappa;": "\u03BA",
        "lAarr;": "\u21DA",
        "langd;": "\u2991",
        "laquo;": "\xAB",
        "larrb;": "\u21E4",
        "lates;": "\u2AAD\uFE00",
        "lBarr;": "\u290E",
        "lbarr;": "\u290C",
        "lbbrk;": "\u2772",
        "lbrke;": "\u298B",
        "lceil;": "\u2308",
        "ldquo;": "\u201C",
        "lescc;": "\u2AA8",
        "lhard;": "\u21BD",
        "lharu;": "\u21BC",
        "lhblk;": "\u2584",
        "llarr;": "\u21C7",
        "lltri;": "\u25FA",
        "lneqq;": "\u2268",
        "lnsim;": "\u22E6",
        "loang;": "\u27EC",
        "loarr;": "\u21FD",
        "lobrk;": "\u27E6",
        "lopar;": "\u2985",
        "lrarr;": "\u21C6",
        "lrhar;": "\u21CB",
        "lrtri;": "\u22BF",
        "lsime;": "\u2A8D",
        "lsimg;": "\u2A8F",
        "lsquo;": "\u2018",
        "ltcir;": "\u2A79",
        "ltdot;": "\u22D6",
        "ltrie;": "\u22B4",
        "ltrif;": "\u25C2",
        "mdash;": "\u2014",
        "mDDot;": "\u223A",
        "micro;": "\xB5",
        middot: "\xB7",
        "minus;": "\u2212",
        "mumap;": "\u22B8",
        "nabla;": "\u2207",
        "napid;": "\u224B\u0338",
        "napos;": "\u0149",
        "natur;": "\u266E",
        "nbump;": "\u224E\u0338",
        "ncong;": "\u2247",
        "ndash;": "\u2013",
        "neArr;": "\u21D7",
        "nearr;": "\u2197",
        "nedot;": "\u2250\u0338",
        "nesim;": "\u2242\u0338",
        "ngeqq;": "\u2267\u0338",
        "ngsim;": "\u2275",
        "nhArr;": "\u21CE",
        "nharr;": "\u21AE",
        "nhpar;": "\u2AF2",
        "nlArr;": "\u21CD",
        "nlarr;": "\u219A",
        "nleqq;": "\u2266\u0338",
        "nless;": "\u226E",
        "nlsim;": "\u2274",
        "nltri;": "\u22EA",
        "notin;": "\u2209",
        "notni;": "\u220C",
        "npart;": "\u2202\u0338",
        "nprec;": "\u2280",
        "nrArr;": "\u21CF",
        "nrarr;": "\u219B",
        "nrtri;": "\u22EB",
        "nsime;": "\u2244",
        "nsmid;": "\u2224",
        "nspar;": "\u2226",
        "nsubE;": "\u2AC5\u0338",
        "nsube;": "\u2288",
        "nsucc;": "\u2281",
        "nsupE;": "\u2AC6\u0338",
        "nsupe;": "\u2289",
        Ntilde: "\xD1",
        ntilde: "\xF1",
        "numsp;": "\u2007",
        "nvsim;": "\u223C\u20D2",
        "nwArr;": "\u21D6",
        "nwarr;": "\u2196",
        Oacute: "\xD3",
        oacute: "\xF3",
        "Ocirc;": "\xD4",
        "ocirc;": "\xF4",
        "odash;": "\u229D",
        "OElig;": "\u0152",
        "oelig;": "\u0153",
        "ofcir;": "\u29BF",
        Ograve: "\xD2",
        ograve: "\xF2",
        "ohbar;": "\u29B5",
        "olarr;": "\u21BA",
        "olcir;": "\u29BE",
        "oline;": "\u203E",
        "Omacr;": "\u014C",
        "omacr;": "\u014D",
        "Omega;": "\u03A9",
        "omega;": "\u03C9",
        "operp;": "\u29B9",
        "oplus;": "\u2295",
        "orarr;": "\u21BB",
        "order;": "\u2134",
        Oslash: "\xD8",
        oslash: "\xF8",
        Otilde: "\xD5",
        otilde: "\xF5",
        "ovbar;": "\u233D",
        "parsl;": "\u2AFD",
        "phone;": "\u260E",
        "plusb;": "\u229E",
        "pluse;": "\u2A72",
        plusmn: "\xB1",
        "pound;": "\xA3",
        "prcue;": "\u227C",
        "Prime;": "\u2033",
        "prime;": "\u2032",
        "prnap;": "\u2AB9",
        "prsim;": "\u227E",
        "quest;": "?",
        "rAarr;": "\u21DB",
        "radic;": "\u221A",
        "rangd;": "\u2992",
        "range;": "\u29A5",
        "raquo;": "\xBB",
        "rarrb;": "\u21E5",
        "rarrc;": "\u2933",
        "rarrw;": "\u219D",
        "ratio;": "\u2236",
        "RBarr;": "\u2910",
        "rBarr;": "\u290F",
        "rbarr;": "\u290D",
        "rbbrk;": "\u2773",
        "rbrke;": "\u298C",
        "rceil;": "\u2309",
        "rdquo;": "\u201D",
        "reals;": "\u211D",
        "rhard;": "\u21C1",
        "rharu;": "\u21C0",
        "rlarr;": "\u21C4",
        "rlhar;": "\u21CC",
        "rnmid;": "\u2AEE",
        "roang;": "\u27ED",
        "roarr;": "\u21FE",
        "robrk;": "\u27E7",
        "ropar;": "\u2986",
        "rrarr;": "\u21C9",
        "rsquo;": "\u2019",
        "rtrie;": "\u22B5",
        "rtrif;": "\u25B8",
        "sbquo;": "\u201A",
        "sccue;": "\u227D",
        "Scirc;": "\u015C",
        "scirc;": "\u015D",
        "scnap;": "\u2ABA",
        "scsim;": "\u227F",
        "sdotb;": "\u22A1",
        "sdote;": "\u2A66",
        "seArr;": "\u21D8",
        "searr;": "\u2198",
        "setmn;": "\u2216",
        "sharp;": "\u266F",
        "Sigma;": "\u03A3",
        "sigma;": "\u03C3",
        "simeq;": "\u2243",
        "simgE;": "\u2AA0",
        "simlE;": "\u2A9F",
        "simne;": "\u2246",
        "slarr;": "\u2190",
        "smile;": "\u2323",
        "smtes;": "\u2AAC\uFE00",
        "sqcap;": "\u2293",
        "sqcup;": "\u2294",
        "sqsub;": "\u228F",
        "sqsup;": "\u2290",
        "srarr;": "\u2192",
        "starf;": "\u2605",
        "strns;": "\xAF",
        "subnE;": "\u2ACB",
        "subne;": "\u228A",
        "supnE;": "\u2ACC",
        "supne;": "\u228B",
        "swArr;": "\u21D9",
        "swarr;": "\u2199",
        "szlig;": "\xDF",
        "Theta;": "\u0398",
        "theta;": "\u03B8",
        "thkap;": "\u2248",
        "THORN;": "\xDE",
        "thorn;": "\xFE",
        "Tilde;": "\u223C",
        "tilde;": "\u02DC",
        "times;": "\xD7",
        "TRADE;": "\u2122",
        "trade;": "\u2122",
        "trisb;": "\u29CD",
        "TSHcy;": "\u040B",
        "tshcy;": "\u045B",
        "twixt;": "\u226C",
        Uacute: "\xDA",
        uacute: "\xFA",
        "Ubrcy;": "\u040E",
        "ubrcy;": "\u045E",
        "Ucirc;": "\xDB",
        "ucirc;": "\xFB",
        "udarr;": "\u21C5",
        "udhar;": "\u296E",
        Ugrave: "\xD9",
        ugrave: "\xF9",
        "uharl;": "\u21BF",
        "uharr;": "\u21BE",
        "uhblk;": "\u2580",
        "ultri;": "\u25F8",
        "Umacr;": "\u016A",
        "umacr;": "\u016B",
        "Union;": "\u22C3",
        "Uogon;": "\u0172",
        "uogon;": "\u0173",
        "uplus;": "\u228E",
        "upsih;": "\u03D2",
        "UpTee;": "\u22A5",
        "Uring;": "\u016E",
        "uring;": "\u016F",
        "urtri;": "\u25F9",
        "utdot;": "\u22F0",
        "utrif;": "\u25B4",
        "uuarr;": "\u21C8",
        "varpi;": "\u03D6",
        "vBarv;": "\u2AE9",
        "VDash;": "\u22AB",
        "Vdash;": "\u22A9",
        "vDash;": "\u22A8",
        "vdash;": "\u22A2",
        "veeeq;": "\u225A",
        "vltri;": "\u22B2",
        "vnsub;": "\u2282\u20D2",
        "vnsup;": "\u2283\u20D2",
        "vprop;": "\u221D",
        "vrtri;": "\u22B3",
        "Wcirc;": "\u0174",
        "wcirc;": "\u0175",
        "Wedge;": "\u22C0",
        "wedge;": "\u2227",
        "xcirc;": "\u25EF",
        "xdtri;": "\u25BD",
        "xhArr;": "\u27FA",
        "xharr;": "\u27F7",
        "xlArr;": "\u27F8",
        "xlarr;": "\u27F5",
        "xodot;": "\u2A00",
        "xrArr;": "\u27F9",
        "xrarr;": "\u27F6",
        "xutri;": "\u25B3",
        Yacute: "\xDD",
        yacute: "\xFD",
        "Ycirc;": "\u0176",
        "ycirc;": "\u0177",
        "Aacute;": "\xC1",
        "aacute;": "\xE1",
        "Abreve;": "\u0102",
        "abreve;": "\u0103",
        "Agrave;": "\xC0",
        "agrave;": "\xE0",
        "andand;": "\u2A55",
        "angmsd;": "\u2221",
        "angsph;": "\u2222",
        "apacir;": "\u2A6F",
        "approx;": "\u2248",
        "Assign;": "\u2254",
        "Atilde;": "\xC3",
        "atilde;": "\xE3",
        "barvee;": "\u22BD",
        "Barwed;": "\u2306",
        "barwed;": "\u2305",
        "becaus;": "\u2235",
        "bernou;": "\u212C",
        "bigcap;": "\u22C2",
        "bigcup;": "\u22C3",
        "bigvee;": "\u22C1",
        "bkarow;": "\u290D",
        "bottom;": "\u22A5",
        "bowtie;": "\u22C8",
        "boxbox;": "\u29C9",
        "bprime;": "\u2035",
        "brvbar;": "\xA6",
        "bullet;": "\u2022",
        "Bumpeq;": "\u224E",
        "bumpeq;": "\u224F",
        "Cacute;": "\u0106",
        "cacute;": "\u0107",
        "capand;": "\u2A44",
        "capcap;": "\u2A4B",
        "capcup;": "\u2A47",
        "capdot;": "\u2A40",
        "Ccaron;": "\u010C",
        "ccaron;": "\u010D",
        "Ccedil;": "\xC7",
        "ccedil;": "\xE7",
        "circeq;": "\u2257",
        "cirmid;": "\u2AEF",
        "Colone;": "\u2A74",
        "colone;": "\u2254",
        "commat;": "@",
        "compfn;": "\u2218",
        "Conint;": "\u222F",
        "conint;": "\u222E",
        "coprod;": "\u2210",
        "copysr;": "\u2117",
        "cularr;": "\u21B6",
        "CupCap;": "\u224D",
        "cupcap;": "\u2A46",
        "cupcup;": "\u2A4A",
        "cupdot;": "\u228D",
        "curarr;": "\u21B7",
        "curren;": "\xA4",
        "cylcty;": "\u232D",
        "Dagger;": "\u2021",
        "dagger;": "\u2020",
        "daleth;": "\u2138",
        "Dcaron;": "\u010E",
        "dcaron;": "\u010F",
        "dfisht;": "\u297F",
        "divide;": "\xF7",
        "divonx;": "\u22C7",
        "dlcorn;": "\u231E",
        "dlcrop;": "\u230D",
        "dollar;": "$",
        "DotDot;": "\u20DC",
        "drcorn;": "\u231F",
        "drcrop;": "\u230C",
        "Dstrok;": "\u0110",
        "dstrok;": "\u0111",
        "Eacute;": "\xC9",
        "eacute;": "\xE9",
        "easter;": "\u2A6E",
        "Ecaron;": "\u011A",
        "ecaron;": "\u011B",
        "ecolon;": "\u2255",
        "Egrave;": "\xC8",
        "egrave;": "\xE8",
        "egsdot;": "\u2A98",
        "elsdot;": "\u2A97",
        "emptyv;": "\u2205",
        "emsp13;": "\u2004",
        "emsp14;": "\u2005",
        "eparsl;": "\u29E3",
        "eqcirc;": "\u2256",
        "equals;": "=",
        "equest;": "\u225F",
        "Exists;": "\u2203",
        "female;": "\u2640",
        "ffilig;": "\uFB03",
        "ffllig;": "\uFB04",
        "ForAll;": "\u2200",
        "forall;": "\u2200",
        "frac12;": "\xBD",
        "frac13;": "\u2153",
        "frac14;": "\xBC",
        "frac15;": "\u2155",
        "frac16;": "\u2159",
        "frac18;": "\u215B",
        "frac23;": "\u2154",
        "frac25;": "\u2156",
        "frac34;": "\xBE",
        "frac35;": "\u2157",
        "frac38;": "\u215C",
        "frac45;": "\u2158",
        "frac56;": "\u215A",
        "frac58;": "\u215D",
        "frac78;": "\u215E",
        "gacute;": "\u01F5",
        "Gammad;": "\u03DC",
        "gammad;": "\u03DD",
        "Gbreve;": "\u011E",
        "gbreve;": "\u011F",
        "Gcedil;": "\u0122",
        "gesdot;": "\u2A80",
        "gesles;": "\u2A94",
        "gtlPar;": "\u2995",
        "gtrarr;": "\u2978",
        "gtrdot;": "\u22D7",
        "gtrsim;": "\u2273",
        "hairsp;": "\u200A",
        "hamilt;": "\u210B",
        "HARDcy;": "\u042A",
        "hardcy;": "\u044A",
        "hearts;": "\u2665",
        "hellip;": "\u2026",
        "hercon;": "\u22B9",
        "homtht;": "\u223B",
        "horbar;": "\u2015",
        "hslash;": "\u210F",
        "Hstrok;": "\u0126",
        "hstrok;": "\u0127",
        "hybull;": "\u2043",
        "hyphen;": "\u2010",
        "Iacute;": "\xCD",
        "iacute;": "\xED",
        "Igrave;": "\xCC",
        "igrave;": "\xEC",
        "iiiint;": "\u2A0C",
        "iinfin;": "\u29DC",
        "incare;": "\u2105",
        "inodot;": "\u0131",
        "intcal;": "\u22BA",
        "iquest;": "\xBF",
        "isinsv;": "\u22F3",
        "Itilde;": "\u0128",
        "itilde;": "\u0129",
        "Jsercy;": "\u0408",
        "jsercy;": "\u0458",
        "kappav;": "\u03F0",
        "Kcedil;": "\u0136",
        "kcedil;": "\u0137",
        "kgreen;": "\u0138",
        "Lacute;": "\u0139",
        "lacute;": "\u013A",
        "lagran;": "\u2112",
        "Lambda;": "\u039B",
        "lambda;": "\u03BB",
        "langle;": "\u27E8",
        "larrfs;": "\u291D",
        "larrhk;": "\u21A9",
        "larrlp;": "\u21AB",
        "larrpl;": "\u2939",
        "larrtl;": "\u21A2",
        "lAtail;": "\u291B",
        "latail;": "\u2919",
        "lbrace;": "{",
        "lbrack;": "[",
        "Lcaron;": "\u013D",
        "lcaron;": "\u013E",
        "Lcedil;": "\u013B",
        "lcedil;": "\u013C",
        "ldquor;": "\u201E",
        "lesdot;": "\u2A7F",
        "lesges;": "\u2A93",
        "lfisht;": "\u297C",
        "lfloor;": "\u230A",
        "lharul;": "\u296A",
        "llhard;": "\u296B",
        "Lmidot;": "\u013F",
        "lmidot;": "\u0140",
        "lmoust;": "\u23B0",
        "loplus;": "\u2A2D",
        "lowast;": "\u2217",
        "lowbar;": "_",
        "lparlt;": "\u2993",
        "lrhard;": "\u296D",
        "lsaquo;": "\u2039",
        "lsquor;": "\u201A",
        "Lstrok;": "\u0141",
        "lstrok;": "\u0142",
        "lthree;": "\u22CB",
        "ltimes;": "\u22C9",
        "ltlarr;": "\u2976",
        "ltrPar;": "\u2996",
        "mapsto;": "\u21A6",
        "marker;": "\u25AE",
        "mcomma;": "\u2A29",
        "midast;": "*",
        "midcir;": "\u2AF0",
        "middot;": "\xB7",
        "minusb;": "\u229F",
        "minusd;": "\u2238",
        "mnplus;": "\u2213",
        "models;": "\u22A7",
        "mstpos;": "\u223E",
        "Nacute;": "\u0143",
        "nacute;": "\u0144",
        "nbumpe;": "\u224F\u0338",
        "Ncaron;": "\u0147",
        "ncaron;": "\u0148",
        "Ncedil;": "\u0145",
        "ncedil;": "\u0146",
        "nearhk;": "\u2924",
        "nequiv;": "\u2262",
        "nesear;": "\u2928",
        "nexist;": "\u2204",
        "nltrie;": "\u22EC",
        "notinE;": "\u22F9\u0338",
        "nparsl;": "\u2AFD\u20E5",
        "nprcue;": "\u22E0",
        "nrarrc;": "\u2933\u0338",
        "nrarrw;": "\u219D\u0338",
        "nrtrie;": "\u22ED",
        "nsccue;": "\u22E1",
        "nsimeq;": "\u2244",
        "Ntilde;": "\xD1",
        "ntilde;": "\xF1",
        "numero;": "\u2116",
        "nVDash;": "\u22AF",
        "nVdash;": "\u22AE",
        "nvDash;": "\u22AD",
        "nvdash;": "\u22AC",
        "nvHarr;": "\u2904",
        "nvlArr;": "\u2902",
        "nvrArr;": "\u2903",
        "nwarhk;": "\u2923",
        "nwnear;": "\u2927",
        "Oacute;": "\xD3",
        "oacute;": "\xF3",
        "Odblac;": "\u0150",
        "odblac;": "\u0151",
        "odsold;": "\u29BC",
        "Ograve;": "\xD2",
        "ograve;": "\xF2",
        "ominus;": "\u2296",
        "origof;": "\u22B6",
        "Oslash;": "\xD8",
        "oslash;": "\xF8",
        "Otilde;": "\xD5",
        "otilde;": "\xF5",
        "Otimes;": "\u2A37",
        "otimes;": "\u2297",
        "parsim;": "\u2AF3",
        "percnt;": "%",
        "period;": ".",
        "permil;": "\u2030",
        "phmmat;": "\u2133",
        "planck;": "\u210F",
        "plankv;": "\u210F",
        "plusdo;": "\u2214",
        "plusdu;": "\u2A25",
        "plusmn;": "\xB1",
        "preceq;": "\u2AAF",
        "primes;": "\u2119",
        "prnsim;": "\u22E8",
        "propto;": "\u221D",
        "prurel;": "\u22B0",
        "puncsp;": "\u2008",
        "qprime;": "\u2057",
        "Racute;": "\u0154",
        "racute;": "\u0155",
        "rangle;": "\u27E9",
        "rarrap;": "\u2975",
        "rarrfs;": "\u291E",
        "rarrhk;": "\u21AA",
        "rarrlp;": "\u21AC",
        "rarrpl;": "\u2945",
        "Rarrtl;": "\u2916",
        "rarrtl;": "\u21A3",
        "rAtail;": "\u291C",
        "ratail;": "\u291A",
        "rbrace;": "}",
        "rbrack;": "]",
        "Rcaron;": "\u0158",
        "rcaron;": "\u0159",
        "Rcedil;": "\u0156",
        "rcedil;": "\u0157",
        "rdquor;": "\u201D",
        "rfisht;": "\u297D",
        "rfloor;": "\u230B",
        "rharul;": "\u296C",
        "rmoust;": "\u23B1",
        "roplus;": "\u2A2E",
        "rpargt;": "\u2994",
        "rsaquo;": "\u203A",
        "rsquor;": "\u2019",
        "rthree;": "\u22CC",
        "rtimes;": "\u22CA",
        "Sacute;": "\u015A",
        "sacute;": "\u015B",
        "Scaron;": "\u0160",
        "scaron;": "\u0161",
        "Scedil;": "\u015E",
        "scedil;": "\u015F",
        "scnsim;": "\u22E9",
        "searhk;": "\u2925",
        "seswar;": "\u2929",
        "sfrown;": "\u2322",
        "SHCHcy;": "\u0429",
        "shchcy;": "\u0449",
        "sigmaf;": "\u03C2",
        "sigmav;": "\u03C2",
        "simdot;": "\u2A6A",
        "smashp;": "\u2A33",
        "SOFTcy;": "\u042C",
        "softcy;": "\u044C",
        "solbar;": "\u233F",
        "spades;": "\u2660",
        "sqcaps;": "\u2293\uFE00",
        "sqcups;": "\u2294\uFE00",
        "sqsube;": "\u2291",
        "sqsupe;": "\u2292",
        "Square;": "\u25A1",
        "square;": "\u25A1",
        "squarf;": "\u25AA",
        "ssetmn;": "\u2216",
        "ssmile;": "\u2323",
        "sstarf;": "\u22C6",
        "subdot;": "\u2ABD",
        "Subset;": "\u22D0",
        "subset;": "\u2282",
        "subsim;": "\u2AC7",
        "subsub;": "\u2AD5",
        "subsup;": "\u2AD3",
        "succeq;": "\u2AB0",
        "supdot;": "\u2ABE",
        "Supset;": "\u22D1",
        "supset;": "\u2283",
        "supsim;": "\u2AC8",
        "supsub;": "\u2AD4",
        "supsup;": "\u2AD6",
        "swarhk;": "\u2926",
        "swnwar;": "\u292A",
        "target;": "\u2316",
        "Tcaron;": "\u0164",
        "tcaron;": "\u0165",
        "Tcedil;": "\u0162",
        "tcedil;": "\u0163",
        "telrec;": "\u2315",
        "there4;": "\u2234",
        "thetav;": "\u03D1",
        "thinsp;": "\u2009",
        "thksim;": "\u223C",
        "timesb;": "\u22A0",
        "timesd;": "\u2A30",
        "topbot;": "\u2336",
        "topcir;": "\u2AF1",
        "tprime;": "\u2034",
        "tridot;": "\u25EC",
        "Tstrok;": "\u0166",
        "tstrok;": "\u0167",
        "Uacute;": "\xDA",
        "uacute;": "\xFA",
        "Ubreve;": "\u016C",
        "ubreve;": "\u016D",
        "Udblac;": "\u0170",
        "udblac;": "\u0171",
        "ufisht;": "\u297E",
        "Ugrave;": "\xD9",
        "ugrave;": "\xF9",
        "ulcorn;": "\u231C",
        "ulcrop;": "\u230F",
        "urcorn;": "\u231D",
        "urcrop;": "\u230E",
        "Utilde;": "\u0168",
        "utilde;": "\u0169",
        "vangrt;": "\u299C",
        "varphi;": "\u03D5",
        "varrho;": "\u03F1",
        "Vdashl;": "\u2AE6",
        "veebar;": "\u22BB",
        "vellip;": "\u22EE",
        "Verbar;": "\u2016",
        "verbar;": "|",
        "vsubnE;": "\u2ACB\uFE00",
        "vsubne;": "\u228A\uFE00",
        "vsupnE;": "\u2ACC\uFE00",
        "vsupne;": "\u228B\uFE00",
        "Vvdash;": "\u22AA",
        "wedbar;": "\u2A5F",
        "wedgeq;": "\u2259",
        "weierp;": "\u2118",
        "wreath;": "\u2240",
        "xoplus;": "\u2A01",
        "xotime;": "\u2A02",
        "xsqcup;": "\u2A06",
        "xuplus;": "\u2A04",
        "xwedge;": "\u22C0",
        "Yacute;": "\xDD",
        "yacute;": "\xFD",
        "Zacute;": "\u0179",
        "zacute;": "\u017A",
        "Zcaron;": "\u017D",
        "zcaron;": "\u017E",
        "zeetrf;": "\u2128",
        "alefsym;": "\u2135",
        "angrtvb;": "\u22BE",
        "angzarr;": "\u237C",
        "asympeq;": "\u224D",
        "backsim;": "\u223D",
        "Because;": "\u2235",
        "because;": "\u2235",
        "bemptyv;": "\u29B0",
        "between;": "\u226C",
        "bigcirc;": "\u25EF",
        "bigodot;": "\u2A00",
        "bigstar;": "\u2605",
        "bnequiv;": "\u2261\u20E5",
        "boxplus;": "\u229E",
        "Cayleys;": "\u212D",
        "Cconint;": "\u2230",
        "ccupssm;": "\u2A50",
        "Cedilla;": "\xB8",
        "cemptyv;": "\u29B2",
        "cirscir;": "\u29C2",
        "coloneq;": "\u2254",
        "congdot;": "\u2A6D",
        "cudarrl;": "\u2938",
        "cudarrr;": "\u2935",
        "cularrp;": "\u293D",
        "curarrm;": "\u293C",
        "dbkarow;": "\u290F",
        "ddagger;": "\u2021",
        "ddotseq;": "\u2A77",
        "demptyv;": "\u29B1",
        "Diamond;": "\u22C4",
        "diamond;": "\u22C4",
        "digamma;": "\u03DD",
        "dotplus;": "\u2214",
        "DownTee;": "\u22A4",
        "dwangle;": "\u29A6",
        "Element;": "\u2208",
        "Epsilon;": "\u0395",
        "epsilon;": "\u03B5",
        "eqcolon;": "\u2255",
        "equivDD;": "\u2A78",
        "gesdoto;": "\u2A82",
        "gtquest;": "\u2A7C",
        "gtrless;": "\u2277",
        "harrcir;": "\u2948",
        "Implies;": "\u21D2",
        "intprod;": "\u2A3C",
        "isindot;": "\u22F5",
        "larrbfs;": "\u291F",
        "larrsim;": "\u2973",
        "lbrksld;": "\u298F",
        "lbrkslu;": "\u298D",
        "ldrdhar;": "\u2967",
        "LeftTee;": "\u22A3",
        "lesdoto;": "\u2A81",
        "lessdot;": "\u22D6",
        "lessgtr;": "\u2276",
        "lesssim;": "\u2272",
        "lotimes;": "\u2A34",
        "lozenge;": "\u25CA",
        "ltquest;": "\u2A7B",
        "luruhar;": "\u2966",
        "maltese;": "\u2720",
        "minusdu;": "\u2A2A",
        "napprox;": "\u2249",
        "natural;": "\u266E",
        "nearrow;": "\u2197",
        "NewLine;": "\n",
        "nexists;": "\u2204",
        "NoBreak;": "\u2060",
        "notinva;": "\u2209",
        "notinvb;": "\u22F7",
        "notinvc;": "\u22F6",
        "NotLess;": "\u226E",
        "notniva;": "\u220C",
        "notnivb;": "\u22FE",
        "notnivc;": "\u22FD",
        "npolint;": "\u2A14",
        "npreceq;": "\u2AAF\u0338",
        "nsqsube;": "\u22E2",
        "nsqsupe;": "\u22E3",
        "nsubset;": "\u2282\u20D2",
        "nsucceq;": "\u2AB0\u0338",
        "nsupset;": "\u2283\u20D2",
        "nvinfin;": "\u29DE",
        "nvltrie;": "\u22B4\u20D2",
        "nvrtrie;": "\u22B5\u20D2",
        "nwarrow;": "\u2196",
        "olcross;": "\u29BB",
        "Omicron;": "\u039F",
        "omicron;": "\u03BF",
        "orderof;": "\u2134",
        "orslope;": "\u2A57",
        "OverBar;": "\u203E",
        "pertenk;": "\u2031",
        "planckh;": "\u210E",
        "pluscir;": "\u2A22",
        "plussim;": "\u2A26",
        "plustwo;": "\u2A27",
        "precsim;": "\u227E",
        "Product;": "\u220F",
        "quatint;": "\u2A16",
        "questeq;": "\u225F",
        "rarrbfs;": "\u2920",
        "rarrsim;": "\u2974",
        "rbrksld;": "\u298E",
        "rbrkslu;": "\u2990",
        "rdldhar;": "\u2969",
        "realine;": "\u211B",
        "rotimes;": "\u2A35",
        "ruluhar;": "\u2968",
        "searrow;": "\u2198",
        "simplus;": "\u2A24",
        "simrarr;": "\u2972",
        "subedot;": "\u2AC3",
        "submult;": "\u2AC1",
        "subplus;": "\u2ABF",
        "subrarr;": "\u2979",
        "succsim;": "\u227F",
        "supdsub;": "\u2AD8",
        "supedot;": "\u2AC4",
        "suphsol;": "\u27C9",
        "suphsub;": "\u2AD7",
        "suplarr;": "\u297B",
        "supmult;": "\u2AC2",
        "supplus;": "\u2AC0",
        "swarrow;": "\u2199",
        "topfork;": "\u2ADA",
        "triplus;": "\u2A39",
        "tritime;": "\u2A3B",
        "UpArrow;": "\u2191",
        "Uparrow;": "\u21D1",
        "uparrow;": "\u2191",
        "Upsilon;": "\u03A5",
        "upsilon;": "\u03C5",
        "uwangle;": "\u29A7",
        "vzigzag;": "\u299A",
        "zigrarr;": "\u21DD",
        "andslope;": "\u2A58",
        "angmsdaa;": "\u29A8",
        "angmsdab;": "\u29A9",
        "angmsdac;": "\u29AA",
        "angmsdad;": "\u29AB",
        "angmsdae;": "\u29AC",
        "angmsdaf;": "\u29AD",
        "angmsdag;": "\u29AE",
        "angmsdah;": "\u29AF",
        "angrtvbd;": "\u299D",
        "approxeq;": "\u224A",
        "awconint;": "\u2233",
        "backcong;": "\u224C",
        "barwedge;": "\u2305",
        "bbrktbrk;": "\u23B6",
        "bigoplus;": "\u2A01",
        "bigsqcup;": "\u2A06",
        "biguplus;": "\u2A04",
        "bigwedge;": "\u22C0",
        "boxminus;": "\u229F",
        "boxtimes;": "\u22A0",
        "bsolhsub;": "\u27C8",
        "capbrcup;": "\u2A49",
        "circledR;": "\xAE",
        "circledS;": "\u24C8",
        "cirfnint;": "\u2A10",
        "clubsuit;": "\u2663",
        "cupbrcap;": "\u2A48",
        "curlyvee;": "\u22CE",
        "cwconint;": "\u2232",
        "DDotrahd;": "\u2911",
        "doteqdot;": "\u2251",
        "DotEqual;": "\u2250",
        "dotminus;": "\u2238",
        "drbkarow;": "\u2910",
        "dzigrarr;": "\u27FF",
        "elinters;": "\u23E7",
        "emptyset;": "\u2205",
        "eqvparsl;": "\u29E5",
        "fpartint;": "\u2A0D",
        "geqslant;": "\u2A7E",
        "gesdotol;": "\u2A84",
        "gnapprox;": "\u2A8A",
        "hksearow;": "\u2925",
        "hkswarow;": "\u2926",
        "imagline;": "\u2110",
        "imagpart;": "\u2111",
        "infintie;": "\u29DD",
        "integers;": "\u2124",
        "Integral;": "\u222B",
        "intercal;": "\u22BA",
        "intlarhk;": "\u2A17",
        "laemptyv;": "\u29B4",
        "ldrushar;": "\u294B",
        "leqslant;": "\u2A7D",
        "lesdotor;": "\u2A83",
        "LessLess;": "\u2AA1",
        "llcorner;": "\u231E",
        "lnapprox;": "\u2A89",
        "lrcorner;": "\u231F",
        "lurdshar;": "\u294A",
        "mapstoup;": "\u21A5",
        "multimap;": "\u22B8",
        "naturals;": "\u2115",
        "ncongdot;": "\u2A6D\u0338",
        "NotEqual;": "\u2260",
        "notindot;": "\u22F5\u0338",
        "NotTilde;": "\u2241",
        "otimesas;": "\u2A36",
        "parallel;": "\u2225",
        "PartialD;": "\u2202",
        "plusacir;": "\u2A23",
        "pointint;": "\u2A15",
        "Precedes;": "\u227A",
        "precneqq;": "\u2AB5",
        "precnsim;": "\u22E8",
        "profalar;": "\u232E",
        "profline;": "\u2312",
        "profsurf;": "\u2313",
        "raemptyv;": "\u29B3",
        "realpart;": "\u211C",
        "RightTee;": "\u22A2",
        "rppolint;": "\u2A12",
        "rtriltri;": "\u29CE",
        "scpolint;": "\u2A13",
        "setminus;": "\u2216",
        "shortmid;": "\u2223",
        "smeparsl;": "\u29E4",
        "sqsubset;": "\u228F",
        "sqsupset;": "\u2290",
        "subseteq;": "\u2286",
        "Succeeds;": "\u227B",
        "succneqq;": "\u2AB6",
        "succnsim;": "\u22E9",
        "SuchThat;": "\u220B",
        "Superset;": "\u2283",
        "supseteq;": "\u2287",
        "thetasym;": "\u03D1",
        "thicksim;": "\u223C",
        "timesbar;": "\u2A31",
        "triangle;": "\u25B5",
        "triminus;": "\u2A3A",
        "trpezium;": "\u23E2",
        "Uarrocir;": "\u2949",
        "ulcorner;": "\u231C",
        "UnderBar;": "_",
        "urcorner;": "\u231D",
        "varkappa;": "\u03F0",
        "varsigma;": "\u03C2",
        "vartheta;": "\u03D1",
        "backprime;": "\u2035",
        "backsimeq;": "\u22CD",
        "Backslash;": "\u2216",
        "bigotimes;": "\u2A02",
        "CenterDot;": "\xB7",
        "centerdot;": "\xB7",
        "checkmark;": "\u2713",
        "CircleDot;": "\u2299",
        "complexes;": "\u2102",
        "Congruent;": "\u2261",
        "Coproduct;": "\u2210",
        "dotsquare;": "\u22A1",
        "DoubleDot;": "\xA8",
        "DownArrow;": "\u2193",
        "Downarrow;": "\u21D3",
        "downarrow;": "\u2193",
        "DownBreve;": "\u0311",
        "gtrapprox;": "\u2A86",
        "gtreqless;": "\u22DB",
        "gvertneqq;": "\u2269\uFE00",
        "heartsuit;": "\u2665",
        "HumpEqual;": "\u224F",
        "LeftArrow;": "\u2190",
        "Leftarrow;": "\u21D0",
        "leftarrow;": "\u2190",
        "LeftFloor;": "\u230A",
        "lesseqgtr;": "\u22DA",
        "LessTilde;": "\u2272",
        "lvertneqq;": "\u2268\uFE00",
        "Mellintrf;": "\u2133",
        "MinusPlus;": "\u2213",
        "ngeqslant;": "\u2A7E\u0338",
        "nleqslant;": "\u2A7D\u0338",
        "NotCupCap;": "\u226D",
        "NotExists;": "\u2204",
        "NotSubset;": "\u2282\u20D2",
        "nparallel;": "\u2226",
        "nshortmid;": "\u2224",
        "nsubseteq;": "\u2288",
        "nsupseteq;": "\u2289",
        "OverBrace;": "\u23DE",
        "pitchfork;": "\u22D4",
        "PlusMinus;": "\xB1",
        "rationals;": "\u211A",
        "spadesuit;": "\u2660",
        "subseteqq;": "\u2AC5",
        "subsetneq;": "\u228A",
        "supseteqq;": "\u2AC6",
        "supsetneq;": "\u228B",
        "Therefore;": "\u2234",
        "therefore;": "\u2234",
        "ThinSpace;": "\u2009",
        "triangleq;": "\u225C",
        "TripleDot;": "\u20DB",
        "UnionPlus;": "\u228E",
        "varpropto;": "\u221D",
        "Bernoullis;": "\u212C",
        "circledast;": "\u229B",
        "CirclePlus;": "\u2295",
        "complement;": "\u2201",
        "curlywedge;": "\u22CF",
        "eqslantgtr;": "\u2A96",
        "EqualTilde;": "\u2242",
        "Fouriertrf;": "\u2131",
        "gtreqqless;": "\u2A8C",
        "ImaginaryI;": "\u2148",
        "Laplacetrf;": "\u2112",
        "LeftVector;": "\u21BC",
        "lessapprox;": "\u2A85",
        "lesseqqgtr;": "\u2A8B",
        "Lleftarrow;": "\u21DA",
        "lmoustache;": "\u23B0",
        "longmapsto;": "\u27FC",
        "mapstodown;": "\u21A7",
        "mapstoleft;": "\u21A4",
        "nLeftarrow;": "\u21CD",
        "nleftarrow;": "\u219A",
        "NotElement;": "\u2209",
        "NotGreater;": "\u226F",
        "nsubseteqq;": "\u2AC5\u0338",
        "nsupseteqq;": "\u2AC6\u0338",
        "precapprox;": "\u2AB7",
        "Proportion;": "\u2237",
        "RightArrow;": "\u2192",
        "Rightarrow;": "\u21D2",
        "rightarrow;": "\u2192",
        "RightFloor;": "\u230B",
        "rmoustache;": "\u23B1",
        "sqsubseteq;": "\u2291",
        "sqsupseteq;": "\u2292",
        "subsetneqq;": "\u2ACB",
        "succapprox;": "\u2AB8",
        "supsetneqq;": "\u2ACC",
        "ThickSpace;": "\u205F\u200A",
        "TildeEqual;": "\u2243",
        "TildeTilde;": "\u2248",
        "UnderBrace;": "\u23DF",
        "UpArrowBar;": "\u2912",
        "UpTeeArrow;": "\u21A5",
        "upuparrows;": "\u21C8",
        "varepsilon;": "\u03F5",
        "varnothing;": "\u2205",
        "backepsilon;": "\u03F6",
        "blacksquare;": "\u25AA",
        "circledcirc;": "\u229A",
        "circleddash;": "\u229D",
        "CircleMinus;": "\u2296",
        "CircleTimes;": "\u2297",
        "curlyeqprec;": "\u22DE",
        "curlyeqsucc;": "\u22DF",
        "diamondsuit;": "\u2666",
        "eqslantless;": "\u2A95",
        "Equilibrium;": "\u21CC",
        "expectation;": "\u2130",
        "GreaterLess;": "\u2277",
        "LeftCeiling;": "\u2308",
        "LessGreater;": "\u2276",
        "MediumSpace;": "\u205F",
        "NotLessLess;": "\u226A\u0338",
        "NotPrecedes;": "\u2280",
        "NotSucceeds;": "\u2281",
        "NotSuperset;": "\u2283\u20D2",
        "nRightarrow;": "\u21CF",
        "nrightarrow;": "\u219B",
        "OverBracket;": "\u23B4",
        "preccurlyeq;": "\u227C",
        "precnapprox;": "\u2AB9",
        "quaternions;": "\u210D",
        "RightVector;": "\u21C0",
        "Rrightarrow;": "\u21DB",
        "RuleDelayed;": "\u29F4",
        "SmallCircle;": "\u2218",
        "SquareUnion;": "\u2294",
        "straightphi;": "\u03D5",
        "SubsetEqual;": "\u2286",
        "succcurlyeq;": "\u227D",
        "succnapprox;": "\u2ABA",
        "thickapprox;": "\u2248",
        "UpDownArrow;": "\u2195",
        "Updownarrow;": "\u21D5",
        "updownarrow;": "\u2195",
        "VerticalBar;": "\u2223",
        "blacklozenge;": "\u29EB",
        "DownArrowBar;": "\u2913",
        "DownTeeArrow;": "\u21A7",
        "ExponentialE;": "\u2147",
        "exponentiale;": "\u2147",
        "GreaterEqual;": "\u2265",
        "GreaterTilde;": "\u2273",
        "HilbertSpace;": "\u210B",
        "HumpDownHump;": "\u224E",
        "Intersection;": "\u22C2",
        "LeftArrowBar;": "\u21E4",
        "LeftTeeArrow;": "\u21A4",
        "LeftTriangle;": "\u22B2",
        "LeftUpVector;": "\u21BF",
        "NotCongruent;": "\u2262",
        "NotHumpEqual;": "\u224F\u0338",
        "NotLessEqual;": "\u2270",
        "NotLessTilde;": "\u2274",
        "Proportional;": "\u221D",
        "RightCeiling;": "\u2309",
        "risingdotseq;": "\u2253",
        "RoundImplies;": "\u2970",
        "ShortUpArrow;": "\u2191",
        "SquareSubset;": "\u228F",
        "triangledown;": "\u25BF",
        "triangleleft;": "\u25C3",
        "UnderBracket;": "\u23B5",
        "varsubsetneq;": "\u228A\uFE00",
        "varsupsetneq;": "\u228B\uFE00",
        "VerticalLine;": "|",
        "ApplyFunction;": "\u2061",
        "bigtriangleup;": "\u25B3",
        "blacktriangle;": "\u25B4",
        "DifferentialD;": "\u2146",
        "divideontimes;": "\u22C7",
        "DoubleLeftTee;": "\u2AE4",
        "DoubleUpArrow;": "\u21D1",
        "fallingdotseq;": "\u2252",
        "hookleftarrow;": "\u21A9",
        "leftarrowtail;": "\u21A2",
        "leftharpoonup;": "\u21BC",
        "LeftTeeVector;": "\u295A",
        "LeftVectorBar;": "\u2952",
        "LessFullEqual;": "\u2266",
        "LongLeftArrow;": "\u27F5",
        "Longleftarrow;": "\u27F8",
        "longleftarrow;": "\u27F5",
        "looparrowleft;": "\u21AB",
        "measuredangle;": "\u2221",
        "NotEqualTilde;": "\u2242\u0338",
        "NotTildeEqual;": "\u2244",
        "NotTildeTilde;": "\u2249",
        "ntriangleleft;": "\u22EA",
        "Poincareplane;": "\u210C",
        "PrecedesEqual;": "\u2AAF",
        "PrecedesTilde;": "\u227E",
        "RightArrowBar;": "\u21E5",
        "RightTeeArrow;": "\u21A6",
        "RightTriangle;": "\u22B3",
        "RightUpVector;": "\u21BE",
        "shortparallel;": "\u2225",
        "smallsetminus;": "\u2216",
        "SucceedsEqual;": "\u2AB0",
        "SucceedsTilde;": "\u227F",
        "SupersetEqual;": "\u2287",
        "triangleright;": "\u25B9",
        "UpEquilibrium;": "\u296E",
        "upharpoonleft;": "\u21BF",
        "varsubsetneqq;": "\u2ACB\uFE00",
        "varsupsetneqq;": "\u2ACC\uFE00",
        "VerticalTilde;": "\u2240",
        "VeryThinSpace;": "\u200A",
        "curvearrowleft;": "\u21B6",
        "DiacriticalDot;": "\u02D9",
        "doublebarwedge;": "\u2306",
        "DoubleRightTee;": "\u22A8",
        "downdownarrows;": "\u21CA",
        "DownLeftVector;": "\u21BD",
        "GreaterGreater;": "\u2AA2",
        "hookrightarrow;": "\u21AA",
        "HorizontalLine;": "\u2500",
        "InvisibleComma;": "\u2063",
        "InvisibleTimes;": "\u2062",
        "LeftDownVector;": "\u21C3",
        "leftleftarrows;": "\u21C7",
        "LeftRightArrow;": "\u2194",
        "Leftrightarrow;": "\u21D4",
        "leftrightarrow;": "\u2194",
        "leftthreetimes;": "\u22CB",
        "LessSlantEqual;": "\u2A7D",
        "LongRightArrow;": "\u27F6",
        "Longrightarrow;": "\u27F9",
        "longrightarrow;": "\u27F6",
        "looparrowright;": "\u21AC",
        "LowerLeftArrow;": "\u2199",
        "NestedLessLess;": "\u226A",
        "NotGreaterLess;": "\u2279",
        "NotLessGreater;": "\u2278",
        "NotSubsetEqual;": "\u2288",
        "NotVerticalBar;": "\u2224",
        "nshortparallel;": "\u2226",
        "ntriangleright;": "\u22EB",
        "OpenCurlyQuote;": "\u2018",
        "ReverseElement;": "\u220B",
        "rightarrowtail;": "\u21A3",
        "rightharpoonup;": "\u21C0",
        "RightTeeVector;": "\u295B",
        "RightVectorBar;": "\u2953",
        "ShortDownArrow;": "\u2193",
        "ShortLeftArrow;": "\u2190",
        "SquareSuperset;": "\u2290",
        "TildeFullEqual;": "\u2245",
        "trianglelefteq;": "\u22B4",
        "upharpoonright;": "\u21BE",
        "UpperLeftArrow;": "\u2196",
        "ZeroWidthSpace;": "\u200B",
        "bigtriangledown;": "\u25BD",
        "circlearrowleft;": "\u21BA",
        "CloseCurlyQuote;": "\u2019",
        "ContourIntegral;": "\u222E",
        "curvearrowright;": "\u21B7",
        "DoubleDownArrow;": "\u21D3",
        "DoubleLeftArrow;": "\u21D0",
        "downharpoonleft;": "\u21C3",
        "DownRightVector;": "\u21C1",
        "leftharpoondown;": "\u21BD",
        "leftrightarrows;": "\u21C6",
        "LeftRightVector;": "\u294E",
        "LeftTriangleBar;": "\u29CF",
        "LeftUpTeeVector;": "\u2960",
        "LeftUpVectorBar;": "\u2958",
        "LowerRightArrow;": "\u2198",
        "nLeftrightarrow;": "\u21CE",
        "nleftrightarrow;": "\u21AE",
        "NotGreaterEqual;": "\u2271",
        "NotGreaterTilde;": "\u2275",
        "NotHumpDownHump;": "\u224E\u0338",
        "NotLeftTriangle;": "\u22EA",
        "NotSquareSubset;": "\u228F\u0338",
        "ntrianglelefteq;": "\u22EC",
        "OverParenthesis;": "\u23DC",
        "RightDownVector;": "\u21C2",
        "rightleftarrows;": "\u21C4",
        "rightsquigarrow;": "\u219D",
        "rightthreetimes;": "\u22CC",
        "ShortRightArrow;": "\u2192",
        "straightepsilon;": "\u03F5",
        "trianglerighteq;": "\u22B5",
        "UpperRightArrow;": "\u2197",
        "vartriangleleft;": "\u22B2",
        "circlearrowright;": "\u21BB",
        "DiacriticalAcute;": "\xB4",
        "DiacriticalGrave;": "`",
        "DiacriticalTilde;": "\u02DC",
        "DoubleRightArrow;": "\u21D2",
        "DownArrowUpArrow;": "\u21F5",
        "downharpoonright;": "\u21C2",
        "EmptySmallSquare;": "\u25FB",
        "GreaterEqualLess;": "\u22DB",
        "GreaterFullEqual;": "\u2267",
        "LeftAngleBracket;": "\u27E8",
        "LeftUpDownVector;": "\u2951",
        "LessEqualGreater;": "\u22DA",
        "NonBreakingSpace;": "\xA0",
        "NotPrecedesEqual;": "\u2AAF\u0338",
        "NotRightTriangle;": "\u22EB",
        "NotSucceedsEqual;": "\u2AB0\u0338",
        "NotSucceedsTilde;": "\u227F\u0338",
        "NotSupersetEqual;": "\u2289",
        "ntrianglerighteq;": "\u22ED",
        "rightharpoondown;": "\u21C1",
        "rightrightarrows;": "\u21C9",
        "RightTriangleBar;": "\u29D0",
        "RightUpTeeVector;": "\u295C",
        "RightUpVectorBar;": "\u2954",
        "twoheadleftarrow;": "\u219E",
        "UnderParenthesis;": "\u23DD",
        "UpArrowDownArrow;": "\u21C5",
        "vartriangleright;": "\u22B3",
        "blacktriangledown;": "\u25BE",
        "blacktriangleleft;": "\u25C2",
        "DoubleUpDownArrow;": "\u21D5",
        "DoubleVerticalBar;": "\u2225",
        "DownLeftTeeVector;": "\u295E",
        "DownLeftVectorBar;": "\u2956",
        "FilledSmallSquare;": "\u25FC",
        "GreaterSlantEqual;": "\u2A7E",
        "LeftDoubleBracket;": "\u27E6",
        "LeftDownTeeVector;": "\u2961",
        "LeftDownVectorBar;": "\u2959",
        "leftrightharpoons;": "\u21CB",
        "LeftTriangleEqual;": "\u22B4",
        "NegativeThinSpace;": "\u200B",
        "NotGreaterGreater;": "\u226B\u0338",
        "NotLessSlantEqual;": "\u2A7D\u0338",
        "NotNestedLessLess;": "\u2AA1\u0338",
        "NotReverseElement;": "\u220C",
        "NotSquareSuperset;": "\u2290\u0338",
        "NotTildeFullEqual;": "\u2247",
        "RightAngleBracket;": "\u27E9",
        "rightleftharpoons;": "\u21CC",
        "RightUpDownVector;": "\u294F",
        "SquareSubsetEqual;": "\u2291",
        "twoheadrightarrow;": "\u21A0",
        "VerticalSeparator;": "\u2758",
        "blacktriangleright;": "\u25B8",
        "DownRightTeeVector;": "\u295F",
        "DownRightVectorBar;": "\u2957",
        "LongLeftRightArrow;": "\u27F7",
        "Longleftrightarrow;": "\u27FA",
        "longleftrightarrow;": "\u27F7",
        "NegativeThickSpace;": "\u200B",
        "NotLeftTriangleBar;": "\u29CF\u0338",
        "PrecedesSlantEqual;": "\u227C",
        "ReverseEquilibrium;": "\u21CB",
        "RightDoubleBracket;": "\u27E7",
        "RightDownTeeVector;": "\u295D",
        "RightDownVectorBar;": "\u2955",
        "RightTriangleEqual;": "\u22B5",
        "SquareIntersection;": "\u2293",
        "SucceedsSlantEqual;": "\u227D",
        "DoubleLongLeftArrow;": "\u27F8",
        "DownLeftRightVector;": "\u2950",
        "LeftArrowRightArrow;": "\u21C6",
        "leftrightsquigarrow;": "\u21AD",
        "NegativeMediumSpace;": "\u200B",
        "NotGreaterFullEqual;": "\u2267\u0338",
        "NotRightTriangleBar;": "\u29D0\u0338",
        "RightArrowLeftArrow;": "\u21C4",
        "SquareSupersetEqual;": "\u2292",
        "CapitalDifferentialD;": "\u2145",
        "DoubleLeftRightArrow;": "\u21D4",
        "DoubleLongRightArrow;": "\u27F9",
        "EmptyVerySmallSquare;": "\u25AB",
        "NestedGreaterGreater;": "\u226B",
        "NotDoubleVerticalBar;": "\u2226",
        "NotGreaterSlantEqual;": "\u2A7E\u0338",
        "NotLeftTriangleEqual;": "\u22EC",
        "NotSquareSubsetEqual;": "\u22E2",
        "OpenCurlyDoubleQuote;": "\u201C",
        "ReverseUpEquilibrium;": "\u296F",
        "CloseCurlyDoubleQuote;": "\u201D",
        "DoubleContourIntegral;": "\u222F",
        "FilledVerySmallSquare;": "\u25AA",
        "NegativeVeryThinSpace;": "\u200B",
        "NotPrecedesSlantEqual;": "\u22E0",
        "NotRightTriangleEqual;": "\u22ED",
        "NotSucceedsSlantEqual;": "\u22E1",
        "DiacriticalDoubleAcute;": "\u02DD",
        "NotSquareSupersetEqual;": "\u22E3",
        "NotNestedGreaterGreater;": "\u2AA2\u0338",
        "ClockwiseContourIntegral;": "\u2232",
        "DoubleLongLeftRightArrow;": "\u27FA",
        "CounterClockwiseContourIntegral;": "\u2233"
      };
      let maxCRNameLength;
      const decodeHtml = (rawText, asAttr) => {
        let offset2 = 0;
        const end = rawText.length;
        let decodedText = "";
        function advance(length) {
          offset2 += length;
          rawText = rawText.slice(length);
        }
        while (offset2 < end) {
          const head = /&(?:#x?)?/i.exec(rawText);
          if (!head || offset2 + head.index >= end) {
            const remaining = end - offset2;
            decodedText += rawText.slice(0, remaining);
            advance(remaining);
            break;
          }
          decodedText += rawText.slice(0, head.index);
          advance(head.index);
          if (head[0] === "&") {
            let name = "";
            let value = void 0;
            if (/[0-9a-z]/i.test(rawText[1])) {
              if (!maxCRNameLength) {
                maxCRNameLength = Object.keys(namedCharacterReferences).reduce((max, name2) => Math.max(max, name2.length), 0);
              }
              for (let length = maxCRNameLength; !value && length > 0; --length) {
                name = rawText.slice(1, 1 + length);
                value = namedCharacterReferences[name];
              }
              if (value) {
                const semi = name.endsWith(";");
                if (asAttr && !semi && /[=a-z0-9]/i.test(rawText[name.length + 1] || "")) {
                  decodedText += "&" + name;
                  advance(1 + name.length);
                } else {
                  decodedText += value;
                  advance(1 + name.length);
                }
              } else {
                decodedText += "&" + name;
                advance(1 + name.length);
              }
            } else {
              decodedText += "&";
              advance(1);
            }
          } else {
            const hex = head[0] === "&#x";
            const pattern2 = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;
            const body = pattern2.exec(rawText);
            if (!body) {
              decodedText += head[0];
              advance(head[0].length);
            } else {
              let cp2 = Number.parseInt(body[1], hex ? 16 : 10);
              if (cp2 === 0) {
                cp2 = 65533;
              } else if (cp2 > 1114111) {
                cp2 = 65533;
              } else if (cp2 >= 55296 && cp2 <= 57343) {
                cp2 = 65533;
              } else if (cp2 >= 64976 && cp2 <= 65007 || (cp2 & 65534) === 65534)
                ;
              else if (cp2 >= 1 && cp2 <= 8 || cp2 === 11 || cp2 >= 13 && cp2 <= 31 || cp2 >= 127 && cp2 <= 159) {
                cp2 = CCR_REPLACEMENTS[cp2] || cp2;
              }
              decodedText += String.fromCodePoint(cp2);
              advance(body[0].length);
            }
          }
        }
        return decodedText;
      };
      const CCR_REPLACEMENTS = {
        128: 8364,
        130: 8218,
        131: 402,
        132: 8222,
        133: 8230,
        134: 8224,
        135: 8225,
        136: 710,
        137: 8240,
        138: 352,
        139: 8249,
        140: 338,
        142: 381,
        145: 8216,
        146: 8217,
        147: 8220,
        148: 8221,
        149: 8226,
        150: 8211,
        151: 8212,
        152: 732,
        153: 8482,
        154: 353,
        155: 8250,
        156: 339,
        158: 382,
        159: 376
      };
      const isRawTextContainer = shared.makeMap("style,iframe,script,noscript", true);
      const parserOptions = {
        isVoidTag: shared.isVoidTag,
        isNativeTag: (tag) => shared.isHTMLTag(tag) || shared.isSVGTag(tag),
        isPreTag: (tag) => tag === "pre",
        decodeEntities: decodeHtml,
        isBuiltInComponent: (tag) => {
          if (compilerCore.isBuiltInType(tag, `Transition`)) {
            return TRANSITION;
          } else if (compilerCore.isBuiltInType(tag, `TransitionGroup`)) {
            return TRANSITION_GROUP;
          }
        },
        getNamespace(tag, parent) {
          let ns2 = parent ? parent.ns : 0;
          if (parent && ns2 === 2) {
            if (parent.tag === "annotation-xml") {
              if (tag === "svg") {
                return 1;
              }
              if (parent.props.some((a2) => a2.type === 6 && a2.name === "encoding" && a2.value != null && (a2.value.content === "text/html" || a2.value.content === "application/xhtml+xml"))) {
                ns2 = 0;
              }
            } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
              ns2 = 0;
            }
          } else if (parent && ns2 === 1) {
            if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
              ns2 = 0;
            }
          }
          if (ns2 === 0) {
            if (tag === "svg") {
              return 1;
            }
            if (tag === "math") {
              return 2;
            }
          }
          return ns2;
        },
        getTextMode({ tag, ns: ns2 }) {
          if (ns2 === 0) {
            if (tag === "textarea" || tag === "title") {
              return 1;
            }
            if (isRawTextContainer(tag)) {
              return 2;
            }
          }
          return 0;
        }
      };
      const transformStyle = (node2) => {
        if (node2.type === 1) {
          node2.props.forEach((p2, i2) => {
            if (p2.type === 6 && p2.name === "style" && p2.value) {
              node2.props[i2] = {
                type: 7,
                name: `bind`,
                arg: compilerCore.createSimpleExpression(`style`, true, p2.loc),
                exp: parseInlineCSS(p2.value.content, p2.loc),
                modifiers: [],
                loc: p2.loc
              };
            }
          });
        }
      };
      const parseInlineCSS = (cssText, loc) => {
        const normalized = shared.parseStringStyle(cssText);
        return compilerCore.createSimpleExpression(JSON.stringify(normalized), false, loc, 3);
      };
      function createDOMCompilerError(code, loc) {
        return compilerCore.createCompilerError(code, loc, DOMErrorMessages);
      }
      const DOMErrorMessages = {
        [50]: `v-html is missing expression.`,
        [51]: `v-html will override element children.`,
        [52]: `v-text is missing expression.`,
        [53]: `v-text will override element children.`,
        [54]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
        [55]: `v-model argument is not supported on plain elements.`,
        [56]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
        [57]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
        [58]: `v-show is missing expression.`,
        [59]: `<Transition> expects exactly one child element or component.`,
        [60]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
      };
      const transformVHtml = (dir, node2, context2) => {
        const { exp, loc } = dir;
        if (!exp) {
          context2.onError(createDOMCompilerError(50, loc));
        }
        if (node2.children.length) {
          context2.onError(createDOMCompilerError(51, loc));
          node2.children.length = 0;
        }
        return {
          props: [
            compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`innerHTML`, true, loc), exp || compilerCore.createSimpleExpression("", true))
          ]
        };
      };
      const transformVText = (dir, node2, context2) => {
        const { exp, loc } = dir;
        if (!exp) {
          context2.onError(createDOMCompilerError(52, loc));
        }
        if (node2.children.length) {
          context2.onError(createDOMCompilerError(53, loc));
          node2.children.length = 0;
        }
        return {
          props: [
            compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`textContent`, true), exp ? compilerCore.createCallExpression(context2.helperString(compilerCore.TO_DISPLAY_STRING), [exp], loc) : compilerCore.createSimpleExpression("", true))
          ]
        };
      };
      const transformModel2 = (dir, node2, context2) => {
        const baseResult = compilerCore.transformModel(dir, node2, context2);
        if (!baseResult.props.length || node2.tagType === 1) {
          return baseResult;
        }
        if (dir.arg) {
          context2.onError(createDOMCompilerError(55, dir.arg.loc));
        }
        function checkDuplicatedValue() {
          const value = compilerCore.findProp(node2, "value");
          if (value) {
            context2.onError(createDOMCompilerError(57, value.loc));
          }
        }
        const { tag } = node2;
        const isCustomElement = context2.isCustomElement(tag);
        if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
          let directiveToUse = V_MODEL_TEXT;
          let isInvalidType = false;
          if (tag === "input" || isCustomElement) {
            const type = compilerCore.findProp(node2, `type`);
            if (type) {
              if (type.type === 7) {
                directiveToUse = V_MODEL_DYNAMIC;
              } else if (type.value) {
                switch (type.value.content) {
                  case "radio":
                    directiveToUse = V_MODEL_RADIO;
                    break;
                  case "checkbox":
                    directiveToUse = V_MODEL_CHECKBOX;
                    break;
                  case "file":
                    isInvalidType = true;
                    context2.onError(createDOMCompilerError(56, dir.loc));
                    break;
                  default:
                    checkDuplicatedValue();
                    break;
                }
              }
            } else if (compilerCore.hasDynamicKeyVBind(node2)) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else {
              checkDuplicatedValue();
            }
          } else if (tag === "select") {
            directiveToUse = V_MODEL_SELECT;
          } else {
            checkDuplicatedValue();
          }
          if (!isInvalidType) {
            baseResult.needRuntime = context2.helper(directiveToUse);
          }
        } else {
          context2.onError(createDOMCompilerError(54, dir.loc));
        }
        baseResult.props = baseResult.props.filter((p2) => !(p2.key.type === 4 && p2.key.content === "modelValue"));
        return baseResult;
      };
      const isEventOptionModifier = shared.makeMap(`passive,once,capture`);
      const isNonKeyModifier = shared.makeMap(`stop,prevent,self,ctrl,shift,alt,meta,exact,middle`);
      const maybeKeyModifier = shared.makeMap("left,right");
      const isKeyboardEvent = shared.makeMap(`onkeyup,onkeydown,onkeypress`, true);
      const resolveModifiers = (key, modifiers, context2, loc) => {
        const keyModifiers = [];
        const nonKeyModifiers = [];
        const eventOptionModifiers = [];
        for (let i2 = 0; i2 < modifiers.length; i2++) {
          const modifier = modifiers[i2];
          if (modifier === "native" && compilerCore.checkCompatEnabled("COMPILER_V_ON_NATIVE", context2, loc)) {
            eventOptionModifiers.push(modifier);
          } else if (isEventOptionModifier(modifier)) {
            eventOptionModifiers.push(modifier);
          } else {
            if (maybeKeyModifier(modifier)) {
              if (compilerCore.isStaticExp(key)) {
                if (isKeyboardEvent(key.content)) {
                  keyModifiers.push(modifier);
                } else {
                  nonKeyModifiers.push(modifier);
                }
              } else {
                keyModifiers.push(modifier);
                nonKeyModifiers.push(modifier);
              }
            } else {
              if (isNonKeyModifier(modifier)) {
                nonKeyModifiers.push(modifier);
              } else {
                keyModifiers.push(modifier);
              }
            }
          }
        }
        return {
          keyModifiers,
          nonKeyModifiers,
          eventOptionModifiers
        };
      };
      const transformClick = (key, event) => {
        const isStaticClick = compilerCore.isStaticExp(key) && key.content.toLowerCase() === "onclick";
        return isStaticClick ? compilerCore.createSimpleExpression(event, true) : key.type !== 4 ? compilerCore.createCompoundExpression([
          `(`,
          key,
          `) === "onClick" ? "${event}" : (`,
          key,
          `)`
        ]) : key;
      };
      const transformOn2 = (dir, node2, context2) => {
        return compilerCore.transformOn(dir, node2, context2, (baseResult) => {
          const { modifiers } = dir;
          if (!modifiers.length)
            return baseResult;
          let { key, value: handlerExp } = baseResult.props[0];
          const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context2, dir.loc);
          if (nonKeyModifiers.includes("right")) {
            key = transformClick(key, `onContextmenu`);
          }
          if (nonKeyModifiers.includes("middle")) {
            key = transformClick(key, `onMouseup`);
          }
          if (nonKeyModifiers.length) {
            handlerExp = compilerCore.createCallExpression(context2.helper(V_ON_WITH_MODIFIERS), [
              handlerExp,
              JSON.stringify(nonKeyModifiers)
            ]);
          }
          if (keyModifiers.length && (!compilerCore.isStaticExp(key) || isKeyboardEvent(key.content))) {
            handlerExp = compilerCore.createCallExpression(context2.helper(V_ON_WITH_KEYS), [
              handlerExp,
              JSON.stringify(keyModifiers)
            ]);
          }
          if (eventOptionModifiers.length) {
            const modifierPostfix = eventOptionModifiers.map(shared.capitalize).join("");
            key = compilerCore.isStaticExp(key) ? compilerCore.createSimpleExpression(`${key.content}${modifierPostfix}`, true) : compilerCore.createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
          }
          return {
            props: [compilerCore.createObjectProperty(key, handlerExp)]
          };
        });
      };
      const transformShow = (dir, node2, context2) => {
        const { exp, loc } = dir;
        if (!exp) {
          context2.onError(createDOMCompilerError(58, loc));
        }
        return {
          props: [],
          needRuntime: context2.helper(V_SHOW)
        };
      };
      const warnTransitionChildren = (node2, context2) => {
        if (node2.type === 1 && node2.tagType === 1) {
          const component = context2.isBuiltInComponent(node2.tag);
          if (component === TRANSITION) {
            return () => {
              if (node2.children.length && hasMultipleChildren(node2)) {
                context2.onError(createDOMCompilerError(59, {
                  start: node2.children[0].loc.start,
                  end: node2.children[node2.children.length - 1].loc.end,
                  source: ""
                }));
              }
            };
          }
        }
      };
      function hasMultipleChildren(node2) {
        const children = node2.children = node2.children.filter((c2) => c2.type !== 3 && !(c2.type === 2 && !c2.content.trim()));
        const child = children[0];
        return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
      }
      const expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g;
      const stringifyStatic = (children, context2, parent) => {
        if (context2.scopes.vSlot > 0) {
          return;
        }
        let nc = 0;
        let ec = 0;
        const currentChunk = [];
        const stringifyCurrentChunk = (currentIndex) => {
          if (nc >= 20 || ec >= 5) {
            const staticCall = compilerCore.createCallExpression(context2.helper(compilerCore.CREATE_STATIC), [
              JSON.stringify(currentChunk.map((node2) => stringifyNode(node2, context2)).join("")).replace(expReplaceRE, `" + $1 + "`),
              String(currentChunk.length)
            ]);
            replaceHoist(currentChunk[0], staticCall, context2);
            if (currentChunk.length > 1) {
              for (let i3 = 1; i3 < currentChunk.length; i3++) {
                replaceHoist(currentChunk[i3], null, context2);
              }
              const deleteCount = currentChunk.length - 1;
              children.splice(currentIndex - currentChunk.length + 1, deleteCount);
              return deleteCount;
            }
          }
          return 0;
        };
        let i2 = 0;
        for (; i2 < children.length; i2++) {
          const child = children[i2];
          const hoisted = getHoistedNode(child);
          if (hoisted) {
            const node2 = child;
            const result2 = analyzeNode(node2);
            if (result2) {
              nc += result2[0];
              ec += result2[1];
              currentChunk.push(node2);
              continue;
            }
          }
          i2 -= stringifyCurrentChunk(i2);
          nc = 0;
          ec = 0;
          currentChunk.length = 0;
        }
        stringifyCurrentChunk(i2);
      };
      const getHoistedNode = (node2) => (node2.type === 1 && node2.tagType === 0 || node2.type == 12) && node2.codegenNode && node2.codegenNode.type === 4 && node2.codegenNode.hoisted;
      const dataAriaRE = /^(data|aria)-/;
      const isStringifiableAttr = (name, ns2) => {
        return (ns2 === 0 ? shared.isKnownHtmlAttr(name) : ns2 === 1 ? shared.isKnownSvgAttr(name) : false) || dataAriaRE.test(name);
      };
      const replaceHoist = (node2, replacement2, context2) => {
        const hoistToReplace = node2.codegenNode.hoisted;
        context2.hoists[context2.hoists.indexOf(hoistToReplace)] = replacement2;
      };
      const isNonStringifiable = shared.makeMap(`caption,thead,tr,th,tbody,td,tfoot,colgroup,col`);
      function analyzeNode(node2) {
        if (node2.type === 1 && isNonStringifiable(node2.tag)) {
          return false;
        }
        if (node2.type === 12) {
          return [1, 0];
        }
        let nc = 1;
        let ec = node2.props.length > 0 ? 1 : 0;
        let bailed = false;
        const bail2 = () => {
          bailed = true;
          return false;
        };
        function walk3(node3) {
          for (let i2 = 0; i2 < node3.props.length; i2++) {
            const p2 = node3.props[i2];
            if (p2.type === 6 && !isStringifiableAttr(p2.name, node3.ns)) {
              return bail2();
            }
            if (p2.type === 7 && p2.name === "bind") {
              if (p2.arg && (p2.arg.type === 8 || p2.arg.isStatic && !isStringifiableAttr(p2.arg.content, node3.ns))) {
                return bail2();
              }
              if (p2.exp && (p2.exp.type === 8 || p2.exp.constType < 3)) {
                return bail2();
              }
            }
          }
          for (let i2 = 0; i2 < node3.children.length; i2++) {
            nc++;
            const child = node3.children[i2];
            if (child.type === 1) {
              if (child.props.length > 0) {
                ec++;
              }
              walk3(child);
              if (bailed) {
                return false;
              }
            }
          }
          return true;
        }
        return walk3(node2) ? [nc, ec] : false;
      }
      function stringifyNode(node2, context2) {
        if (shared.isString(node2)) {
          return node2;
        }
        if (shared.isSymbol(node2)) {
          return ``;
        }
        switch (node2.type) {
          case 1:
            return stringifyElement(node2, context2);
          case 2:
            return shared.escapeHtml(node2.content);
          case 3:
            return `<!--${shared.escapeHtml(node2.content)}-->`;
          case 5:
            return shared.escapeHtml(shared.toDisplayString(evaluateConstant(node2.content)));
          case 8:
            return shared.escapeHtml(evaluateConstant(node2));
          case 12:
            return stringifyNode(node2.content, context2);
          default:
            return "";
        }
      }
      function stringifyElement(node2, context2) {
        let res = `<${node2.tag}`;
        for (let i2 = 0; i2 < node2.props.length; i2++) {
          const p2 = node2.props[i2];
          if (p2.type === 6) {
            res += ` ${p2.name}`;
            if (p2.value) {
              res += `="${shared.escapeHtml(p2.value.content)}"`;
            }
          } else if (p2.type === 7 && p2.name === "bind") {
            const exp = p2.exp;
            if (exp.content[0] === "_") {
              res += ` ${p2.arg.content}="__VUE_EXP_START__${exp.content}__VUE_EXP_END__"`;
              continue;
            }
            let evaluated = evaluateConstant(exp);
            if (evaluated != null) {
              const arg = p2.arg && p2.arg.content;
              if (arg === "class") {
                evaluated = shared.normalizeClass(evaluated);
              } else if (arg === "style") {
                evaluated = shared.stringifyStyle(shared.normalizeStyle(evaluated));
              }
              res += ` ${p2.arg.content}="${shared.escapeHtml(evaluated)}"`;
            }
          }
        }
        if (context2.scopeId) {
          res += ` ${context2.scopeId}`;
        }
        res += `>`;
        for (let i2 = 0; i2 < node2.children.length; i2++) {
          res += stringifyNode(node2.children[i2], context2);
        }
        if (!shared.isVoidTag(node2.tag)) {
          res += `</${node2.tag}>`;
        }
        return res;
      }
      function evaluateConstant(exp) {
        if (exp.type === 4) {
          return new Function(`return ${exp.content}`)();
        } else {
          let res = ``;
          exp.children.forEach((c2) => {
            if (shared.isString(c2) || shared.isSymbol(c2)) {
              return;
            }
            if (c2.type === 2) {
              res += c2.content;
            } else if (c2.type === 5) {
              res += shared.toDisplayString(evaluateConstant(c2.content));
            } else {
              res += evaluateConstant(c2);
            }
          });
          return res;
        }
      }
      const ignoreSideEffectTags = (node2, context2) => {
        if (node2.type === 1 && node2.tagType === 0 && (node2.tag === "script" || node2.tag === "style")) {
          context2.onError(createDOMCompilerError(60, node2.loc));
          context2.removeNode();
        }
      };
      const DOMNodeTransforms = [
        transformStyle,
        ...[warnTransitionChildren]
      ];
      const DOMDirectiveTransforms = {
        cloak: compilerCore.noopDirectiveTransform,
        html: transformVHtml,
        text: transformVText,
        model: transformModel2,
        on: transformOn2,
        show: transformShow
      };
      function compile2(template2, options2 = {}) {
        return compilerCore.baseCompile(template2, shared.extend({}, parserOptions, options2, {
          nodeTransforms: [
            ignoreSideEffectTags,
            ...DOMNodeTransforms,
            ...options2.nodeTransforms || []
          ],
          directiveTransforms: shared.extend({}, DOMDirectiveTransforms, options2.directiveTransforms || {}),
          transformHoist: stringifyStatic
        }));
      }
      function parse2(template2, options2 = {}) {
        return compilerCore.baseParse(template2, shared.extend({}, parserOptions, options2));
      }
      Object.keys(compilerCore).forEach(function(k2) {
        if (k2 !== "default")
          exports3[k2] = compilerCore[k2];
      });
      exports3.DOMDirectiveTransforms = DOMDirectiveTransforms;
      exports3.DOMNodeTransforms = DOMNodeTransforms;
      exports3.TRANSITION = TRANSITION;
      exports3.TRANSITION_GROUP = TRANSITION_GROUP;
      exports3.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX;
      exports3.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC;
      exports3.V_MODEL_RADIO = V_MODEL_RADIO;
      exports3.V_MODEL_SELECT = V_MODEL_SELECT;
      exports3.V_MODEL_TEXT = V_MODEL_TEXT;
      exports3.V_ON_WITH_KEYS = V_ON_WITH_KEYS;
      exports3.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS;
      exports3.V_SHOW = V_SHOW;
      exports3.compile = compile2;
      exports3.createDOMCompilerError = createDOMCompilerError;
      exports3.parse = parse2;
      exports3.parserOptions = parserOptions;
      exports3.transformStyle = transformStyle;
    })(compilerDom_cjs$2);
    var compilerDom_cjs = build2.getDefaultExportFromCjs(compilerDom_cjs$2);
    var compilerDom_cjs$1 = _mergeNamespaces2({
      __proto__: null,
      "default": compilerDom_cjs
    }, [compilerDom_cjs$2]);
    exports2.compilerDom_cjs = compilerDom_cjs$1;
  }
});

// node_modules/vite/package.json
var require_package = __commonJS({
  "node_modules/vite/package.json"(exports2, module2) {
    module2.exports = {
      name: "vite",
      version: "2.7.10",
      license: "MIT",
      author: "Evan You",
      description: "Native-ESM powered web dev build tool",
      bin: {
        vite: "bin/vite.js"
      },
      main: "dist/node/index.js",
      types: "dist/node/index.d.ts",
      files: [
        "bin",
        "dist",
        "client.d.ts",
        "src/client",
        "types"
      ],
      engines: {
        node: ">=12.2.0"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/vitejs/vite.git",
        directory: "packages/vite"
      },
      bugs: {
        url: "https://github.com/vitejs/vite/issues"
      },
      homepage: "https://github.com/vitejs/vite/tree/main/#readme",
      scripts: {
        dev: "rimraf dist && rollup -c -w",
        build: "rimraf dist && npm run lint && run-s build-bundle build-types",
        "build-bundle": "rollup -c",
        "build-types": "run-s build-temp-types patch-types roll-types",
        "build-temp-types": "tsc --emitDeclarationOnly --outDir temp/node -p src/node",
        "ci-build": "rimraf dist && run-s build-bundle build-types",
        "patch-types": "ts-node scripts/patchTypes.ts",
        "roll-types": "api-extractor run && rimraf temp",
        lint: "eslint --ext .ts src/**",
        format: 'prettier --write --parser typescript "src/**/*.ts"',
        changelog: "conventional-changelog -p angular -i CHANGELOG.md -s --commit-path .",
        release: "ts-node ../../scripts/release.ts"
      },
      "//": "READ CONTRIBUTING.md to understand what to put under deps vs. devDeps!",
      dependencies: {
        esbuild: "^0.13.12",
        postcss: "^8.4.5",
        resolve: "^1.20.0",
        rollup: "^2.59.0"
      },
      optionalDependencies: {
        fsevents: "~2.3.2"
      },
      devDependencies: {
        "@ampproject/remapping": "^1.0.2",
        "@babel/parser": "^7.16.6",
        "@babel/types": "^7.16.0",
        "@rollup/plugin-alias": "^3.1.8",
        "@rollup/plugin-commonjs": "^21.0.1",
        "@rollup/plugin-dynamic-import-vars": "^1.4.1",
        "@rollup/plugin-json": "^4.1.0",
        "@rollup/plugin-node-resolve": "13.1.1",
        "@rollup/plugin-typescript": "^8.3.0",
        "@rollup/pluginutils": "^4.1.2",
        "@types/convert-source-map": "^1.5.2",
        "@types/debug": "^4.1.7",
        "@types/estree": "^0.0.50",
        "@types/etag": "^1.8.1",
        "@types/less": "^3.0.3",
        "@types/micromatch": "^4.0.2",
        "@types/mime": "^2.0.3",
        "@types/node": "^16.11.14",
        "@types/resolve": "^1.20.1",
        "@types/sass": "~1.43.1",
        "@types/stylus": "^0.48.36",
        "@types/ws": "^8.2.2",
        "@vue/compiler-dom": "^3.2.26",
        acorn: "^8.7.0",
        cac: "6.7.9",
        chalk: "^4.1.2",
        chokidar: "^3.5.2",
        compression: "^1.7.4",
        connect: "^3.7.0",
        "connect-history-api-fallback": "^1.6.0",
        "convert-source-map": "^1.8.0",
        cors: "^2.8.5",
        debug: "^4.3.3",
        dotenv: "^10.0.0",
        "dotenv-expand": "^5.1.0",
        "es-module-lexer": "^0.9.3",
        "estree-walker": "^2.0.2",
        etag: "^1.8.1",
        execa: "^5.1.1",
        "fast-glob": "^3.2.7",
        "http-proxy": "^1.18.1",
        "launch-editor-middleware": "^2.3.0",
        "magic-string": "^0.25.7",
        micromatch: "^4.0.4",
        mime: "^3.0.0",
        okie: "^1.0.1",
        open: "^8.4.0",
        periscopic: "^2.0.3",
        "postcss-import": "^14.0.2",
        "postcss-load-config": "^3.1.0",
        "postcss-modules": "^4.2.2",
        "resolve.exports": "^1.1.0",
        "rollup-plugin-license": "^2.6.0",
        selfsigned: "^1.10.11",
        sirv: "^1.0.19",
        "source-map": "^0.6.1",
        "source-map-support": "^0.5.21",
        "strip-ansi": "^6.0.1",
        terser: "^5.10.0",
        tsconfck: "1.1.1",
        tslib: "^2.3.1",
        types: "link:./types",
        ws: "^8.3.0"
      },
      peerDependencies: {
        less: "*",
        sass: "*",
        stylus: "*"
      },
      peerDependenciesMeta: {
        sass: {
          optional: true
        },
        stylus: {
          optional: true
        },
        less: {
          optional: true
        }
      }
    };
  }
});

// node_modules/rollup/dist/es/rollup.browser.js
var rollup_browser_exports = {};
__export(rollup_browser_exports, {
  VERSION: () => e2,
  defineConfig: () => Vh,
  rollup: () => Th
});
function n2(e2, t, s2) {
  s2 === 4 ? e2.push([t[0], t[1], t[2], t[3]]) : s2 === 5 ? e2.push([t[0], t[1], t[2], t[3], t[4]]) : s2 === 1 && e2.push([t[0]]);
}
function r(e2) {
  var t = "";
  e2 = e2 < 0 ? -e2 << 1 | 1 : e2 << 1;
  do {
    var i2 = 31 & e2;
    (e2 >>>= 5) > 0 && (i2 |= 32), t += s2[i2];
  } while (e2 > 0);
  return t;
}
function c(e2) {
  var t = e2.split("\n"), s2 = t.filter(function(e3) {
    return /^\t+/.test(e3);
  }), i2 = t.filter(function(e3) {
    return /^ {2,}/.test(e3);
  });
  if (s2.length === 0 && i2.length === 0)
    return null;
  if (s2.length >= i2.length)
    return "	";
  var n3 = i2.reduce(function(e3, t2) {
    var s3 = /^ +/.exec(t2)[0].length;
    return Math.min(s3, e3);
  }, 1 / 0);
  return new Array(n3 + 1).join(" ");
}
function u(e2, t) {
  var s2 = e2.split(/[/\\]/), i2 = t.split(/[/\\]/);
  for (s2.pop(); s2[0] === i2[0]; )
    s2.shift(), i2.shift();
  if (s2.length)
    for (var n3 = s2.length; n3--; )
      s2[n3] = "..";
  return s2.concat(i2).join("/");
}
function p(e2) {
  return d2.call(e2) === "[object Object]";
}
function f(e2) {
  for (var t = e2.split("\n"), s2 = [], i2 = 0, n3 = 0; i2 < t.length; i2++)
    s2.push(n3), n3 += t[i2].length + 1;
  return function(e3) {
    for (var t2 = 0, i3 = s2.length; t2 < i3; ) {
      var n4 = t2 + i3 >> 1;
      e3 < s2[n4] ? i3 = n4 : t2 = n4 + 1;
    }
    var r2 = t2 - 1;
    return { line: r2, column: e3 - s2[r2] };
  };
}
function P(e2) {
  return S.test(e2);
}
function k(e2) {
  return A2.test(e2);
}
function w2(e2) {
  return e2.replace(/\\/g, "/");
}
function C2(e2) {
  return e2.split(/[/\\]/).pop() || "";
}
function I(e2) {
  const t = /[/\\][^/\\]*$/.exec(e2);
  if (!t)
    return ".";
  const s2 = e2.slice(0, -t[0].length);
  return s2 || "/";
}
function N(e2) {
  const t = /\.[^.]+$/.exec(C2(e2));
  return t ? t[0] : "";
}
function _(e2, t) {
  const s2 = e2.split(/[/\\]/).filter(Boolean), i2 = t.split(/[/\\]/).filter(Boolean);
  for (s2[0] === "." && s2.shift(), i2[0] === "." && i2.shift(); s2[0] && i2[0] && s2[0] === i2[0]; )
    s2.shift(), i2.shift();
  for (; i2[0] === ".." && s2.length > 0; )
    i2.shift(), s2.pop();
  for (; s2.pop(); )
    i2.unshift("..");
  return i2.join("/");
}
function $(...e2) {
  const t = e2.shift();
  if (!t)
    return "/";
  let s2 = t.split(/[/\\]/);
  for (const t2 of e2)
    if (P(t2))
      s2 = t2.split(/[/\\]/);
    else {
      const e3 = t2.split(/[/\\]/);
      for (; e3[0] === "." || e3[0] === ".."; ) {
        e3.shift() === ".." && s2.pop();
      }
      s2.push(...e3);
    }
  return s2.join("/");
}
function T(e2, t, s2) {
  const i2 = e2.get(t);
  if (i2)
    return i2;
  const n3 = s2();
  return e2.set(t, n3), n3;
}
function J(e2) {
  return e2 = e2.replace(/-(\w)/g, (e3, t) => t.toUpperCase()).replace(Q2, "_"), (Z(e2) || Y.has(e2)) && (e2 = `_${e2}`), e2 || "_";
}
function ee(e2, t) {
  const s2 = e2.length <= 1, i2 = e2.map((e3) => `"${e3}"`);
  let n3 = s2 ? i2[0] : `${i2.slice(0, -1).join(", ")} and ${i2.slice(-1)[0]}`;
  return t && (n3 += ` ${s2 ? t[0] : t[1]}`), n3;
}
function te(e2) {
  const t = C2(e2);
  return t.substr(0, t.length - N(e2).length);
}
function se(e2) {
  return P(e2) ? _($(), e2) : e2;
}
function ie(e2) {
  return e2[0] === "/" || e2[0] === "." && (e2[1] === "/" || e2[1] === ".") || P(e2);
}
function oe(e2, t, s2) {
  if (typeof s2 == "number")
    throw new Error("locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument");
  return function(e3, t2) {
    t2 === void 0 && (t2 = {});
    var s3 = t2.offsetLine || 0, i2 = t2.offsetColumn || 0, n3 = e3.split("\n"), r2 = 0, a2 = n3.map(function(e4, t3) {
      var s4 = r2 + e4.length + 1, i3 = { start: r2, end: s4, line: t3 };
      return r2 = s4, i3;
    }), o2 = 0;
    function h3(e4, t3) {
      return e4.start <= t3 && t3 < e4.end;
    }
    function l2(e4, t3) {
      return { line: s3 + e4.line, column: i2 + t3 - e4.start, character: t3 };
    }
    return function(t3, s4) {
      typeof t3 == "string" && (t3 = e3.indexOf(t3, s4 || 0));
      for (var i3 = a2[o2], n4 = t3 >= i3.end ? 1 : -1; i3; ) {
        if (h3(i3, t3))
          return l2(i3, t3);
        i3 = a2[o2 += n4];
      }
    };
  }(e2, s2)(t, s2 && s2.startIndex);
}
function he() {
  return { brokenFlow: 0, includedCallArguments: new Set(), includedLabels: new Set() };
}
function le() {
  return { accessed: new B2(), assigned: new B2(), brokenFlow: 0, called: new z(), ignore: { breaks: false, continues: false, labels: new Set(), returnYield: false }, includedLabels: new Set(), instantiated: new z(), replacedVariableInits: new Map() };
}
function ce(e2, t, s2) {
  s2(e2, t);
}
function ue(e2, t, s2) {
}
function me(e2, t, s2 = e2.type) {
  const { annotations: i2 } = t;
  let n3 = i2[t.annotationIndex];
  for (; n3 && e2.start >= n3.end; )
    Ee(e2, n3, t.code), n3 = i2[++t.annotationIndex];
  if (n3 && n3.end <= e2.end)
    for (de[s2](e2, t, me); (n3 = i2[t.annotationIndex]) && n3.end <= e2.end; )
      ++t.annotationIndex, be(e2, n3, false);
}
function Ee(e2, t, s2) {
  const i2 = [];
  let n3;
  if (xe(s2.slice(t.end, e2.start), ge)) {
    const t2 = e2.start;
    for (; ; ) {
      switch (i2.push(e2), e2.type) {
        case "ExpressionStatement":
        case "ChainExpression":
          e2 = e2.expression;
          continue;
        case "SequenceExpression":
          if (xe(s2.slice(t2, e2.start), ye)) {
            e2 = e2.expressions[0];
            continue;
          }
          n3 = true;
          break;
        case "ConditionalExpression":
          if (xe(s2.slice(t2, e2.start), ye)) {
            e2 = e2.test;
            continue;
          }
          n3 = true;
          break;
        case "LogicalExpression":
        case "BinaryExpression":
          if (xe(s2.slice(t2, e2.start), ye)) {
            e2 = e2.left;
            continue;
          }
          n3 = true;
          break;
        case "CallExpression":
        case "NewExpression":
          break;
        default:
          n3 = true;
      }
      break;
    }
  } else
    n3 = true;
  if (n3)
    be(e2, t, false);
  else
    for (const e3 of i2)
      be(e3, t, true);
}
function xe(e2, t) {
  let s2;
  for (; (s2 = t.exec(e2)) !== null; ) {
    if (s2[0] === "/") {
      const s3 = e2.charCodeAt(t.lastIndex);
      if (s3 === 42) {
        t.lastIndex = e2.indexOf("*/", t.lastIndex + 1) + 2;
        continue;
      }
      if (s3 === 47) {
        t.lastIndex = e2.indexOf("\n", t.lastIndex + 1) + 1;
        continue;
      }
    }
    return t.lastIndex = 0, false;
  }
  return true;
}
function be(e2, t, s2) {
  const i2 = s2 ? "_rollupAnnotations" : "_rollupRemoved", n3 = e2[i2];
  n3 ? n3.push(t) : e2[i2] = [t];
}
function ke(e2, t, s2, i2) {
  if (t.remove(s2, i2), e2.annotations)
    for (const i3 of e2.annotations) {
      if (!(i3.start < s2))
        return;
      t.remove(i3.start, i3.end);
    }
}
function we(e2, t) {
  if (e2.annotations || e2.parent.type !== "ExpressionStatement" || (e2 = e2.parent), e2.annotations)
    for (const s2 of e2.annotations)
      t.remove(s2.start, s2.end);
}
function Ie(e2, t, s2 = 0) {
  let i2, n3;
  for (i2 = e2.indexOf(t, s2); ; ) {
    if ((s2 = e2.indexOf("/", s2)) === -1 || s2 >= i2)
      return i2;
    n3 = e2.charCodeAt(++s2), ++s2, (s2 = n3 === 47 ? e2.indexOf("\n", s2) + 1 : e2.indexOf("*/", s2) + 2) > i2 && (i2 = e2.indexOf(t, s2));
  }
}
function _e(e2, t) {
  Ne.lastIndex = t;
  return Ne.exec(e2).index;
}
function $e(e2) {
  let t, s2, i2 = 0;
  for (t = e2.indexOf("\n", i2); ; ) {
    if (i2 = e2.indexOf("/", i2), i2 === -1 || i2 > t)
      return [t, t + 1];
    if (s2 = e2.charCodeAt(i2 + 1), s2 === 47)
      return [i2, t + 1];
    i2 = e2.indexOf("*/", i2 + 3) + 2, i2 > t && (t = e2.indexOf("\n", i2));
  }
}
function Te(e2, t, s2, i2, n3) {
  let r2, a2, o2, h3, l2 = e2[0], c2 = !l2.included || l2.needsBoundaries;
  c2 && (h3 = s2 + $e(t.original.slice(s2, l2.start))[1]);
  for (let s3 = 1; s3 <= e2.length; s3++)
    r2 = l2, a2 = h3, o2 = c2, l2 = e2[s3], c2 = l2 !== void 0 && (!l2.included || l2.needsBoundaries), o2 || c2 ? (h3 = r2.end + $e(t.original.slice(r2.end, l2 === void 0 ? i2 : l2.start))[1], r2.included ? o2 ? r2.render(t, n3, { end: h3, start: a2 }) : r2.render(t, n3) : ke(r2, t, a2, h3)) : r2.render(t, n3);
}
function Re(e2, t, s2, i2) {
  const n3 = [];
  let r2, a2, o2, h3, l2, c2 = s2 - 1;
  for (let i3 = 0; i3 < e2.length; i3++) {
    for (a2 = e2[i3], r2 !== void 0 && (c2 = r2.end + Ie(t.original.slice(r2.end, a2.start), ",")), o2 = h3 = c2 + 1 + $e(t.original.slice(c2 + 1, a2.start))[1]; l2 = t.original.charCodeAt(o2), l2 === 32 || l2 === 9 || l2 === 10 || l2 === 13; )
      o2++;
    r2 !== void 0 && n3.push({ contentEnd: h3, end: o2, node: r2, separator: c2, start: s2 }), r2 = a2, s2 = o2;
  }
  return n3.push({ contentEnd: i2, end: i2, node: r2, separator: null, start: s2 }), n3;
}
function Me(e2, t, s2) {
  for (; ; ) {
    const [i2, n3] = $e(e2.original.slice(t, s2));
    if (i2 === -1)
      break;
    e2.remove(t + i2, t += n3);
  }
}
function De(e2, { exportNamesByVariable: t, snippets: { _: s2, getObject: i2, getPropertyAccess: n3 } }, r2 = "") {
  if (e2.length === 1 && t.get(e2[0]).length === 1) {
    const i3 = e2[0];
    return `exports('${t.get(i3)}',${s2}${i3.getName(n3)}${r2})`;
  }
  {
    const s3 = [];
    for (const i3 of e2)
      for (const e3 of t.get(i3))
        s3.push([e3, i3.getName(n3) + r2]);
    return `exports(${i2(s3, { lineBreakIndent: null })})`;
  }
}
function Le(e2, t, s2, i2, { exportNamesByVariable: n3, snippets: { _: r2 } }) {
  i2.prependRight(t, `exports('${n3.get(e2)}',${r2}`), i2.appendLeft(s2, ")");
}
function Oe(e2, t, s2, i2, n3, r2) {
  const { _: a2, getPropertyAccess: o2 } = r2.snippets;
  n3.appendLeft(s2, `,${a2}${De([e2], r2)},${a2}${e2.getName(o2)}`), i2 && (n3.prependRight(t, "("), n3.appendLeft(s2, ")"));
}
function Ve(e2, t) {
  if (e2.type === "MemberExpression")
    return !e2.computed && Ve(e2.object, e2);
  if (e2.type === "Identifier") {
    if (!t)
      return true;
    switch (t.type) {
      case "MemberExpression":
        return t.computed || e2 === t.object;
      case "MethodDefinition":
        return t.computed;
      case "PropertyDefinition":
      case "Property":
        return t.computed || e2 === t.value;
      case "ExportSpecifier":
      case "ImportSpecifier":
        return e2 === t.local;
      case "LabeledStatement":
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      default:
        return true;
    }
  }
  return false;
}
function Xe(e2) {
  let t = Ke;
  for (const s2 of e2) {
    if (typeof s2 != "string")
      return null;
    if (t = t[s2], !t)
      return null;
  }
  return t[Be];
}
function et(e2) {
  for (; e2 && !/^Program|Function/.test(e2.type); )
    e2 = e2.parent;
  return e2;
}
function tt(e2) {
  let t = "";
  do {
    const s2 = e2 % 64;
    e2 = Math.floor(e2 / 64), t = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$"[s2] + t;
  } while (e2 !== 0);
  return t;
}
function st(e2, t) {
  let s2 = e2, i2 = 1;
  for (; t.has(s2) || Y.has(s2); )
    s2 = `${e2}$${tt(i2++)}`;
  return t.add(s2), s2;
}
function nt(e2, t = null) {
  return Object.create(t, e2);
}
function yt(e2, t, s2, i2) {
  if (typeof t != "string" || !e2[t])
    return true;
  if (!e2[t].callsArgs)
    return false;
  for (const n3 of e2[t].callsArgs)
    if (s2.args[n3] && s2.args[n3].hasEffectsWhenCalledAtPath(D, { args: it, thisParam: null, withNew: false }, i2))
      return true;
  return false;
}
function Et(e2, t) {
  return typeof t == "string" && e2[t] ? e2[t].returns : U;
}
function Yt(e2, t) {
  return e2.renderBaseName !== null && t.has(e2) && e2.isReassigned;
}
function ms2(e2) {
  return e2.computed ? function(e3) {
    if (e3 instanceof qt)
      return String(e3.value);
    return null;
  }(e2.property) : e2.property.name;
}
function gs(e2) {
  const t = e2.propertyKey, s2 = e2.object;
  if (typeof t == "string") {
    if (s2 instanceof Je)
      return [{ key: s2.name, pos: s2.start }, { key: t, pos: e2.property.start }];
    if (s2 instanceof ys) {
      const i2 = gs(s2);
      return i2 && [...i2, { key: t, pos: e2.property.start }];
    }
  }
  return null;
}
function js(e2, t, s2) {
  return t === "external" ? Is[String(s2(e2 instanceof ne ? e2.id : null))] : t === "default" ? "_interopNamespaceDefaultOnly" : null;
}
function Gs(e2) {
  return e2.replace(/^\t+/, (e3) => e3.split("	").join("  "));
}
function Hs(e2) {
  throw e2 instanceof Error || (e2 = Object.assign(new Error(e2.message), e2)), e2;
}
function qs2(e2, t, s2, i2) {
  if (typeof t == "object") {
    const { line: s3, column: n3 } = t;
    e2.loc = { column: n3, file: i2, line: s3 };
  } else {
    e2.pos = t;
    const { line: n3, column: r2 } = oe(s2, t, { offsetLine: 1 });
    e2.loc = { column: r2, file: i2, line: n3 };
  }
  if (e2.frame === void 0) {
    const { line: t2, column: i3 } = e2.loc;
    e2.frame = function(e3, t3, s3) {
      let i4 = e3.split("\n");
      const n3 = Math.max(0, t3 - 3);
      let r2 = Math.min(t3 + 2, i4.length);
      for (i4 = i4.slice(n3, r2); !/\S/.test(i4[i4.length - 1]); )
        i4.pop(), r2 -= 1;
      const a2 = String(r2).length;
      return i4.map((e4, i5) => {
        const r3 = n3 + i5 + 1 === t3;
        let o2 = String(i5 + n3 + 1);
        for (; o2.length < a2; )
          o2 = ` ${o2}`;
        if (r3) {
          const t4 = function(e5) {
            let t5 = "";
            for (; e5--; )
              t5 += " ";
            return t5;
          }(a2 + 2 + Gs(e4.slice(0, s3)).length) + "^";
          return `${o2}: ${Gs(e4)}
${t4}`;
        }
        return `${o2}: ${Gs(e4)}`;
      }).join("\n");
    }(s2, t2, i3);
  }
}
function Xs({ fileName: e2, code: t }, s2) {
  const i2 = { code: Ks.CHUNK_INVALID, message: `Chunk "${e2}" is not valid JavaScript: ${s2.message}.` };
  return qs2(i2, s2.loc, t, e2), i2;
}
function Ys(e2, t, s2) {
  return { code: "INVALID_EXPORT_OPTION", message: `"${e2}" was specified for "output.exports", but entry module "${se(s2)}" has the following exports: ${t.join(", ")}` };
}
function Qs(e2, t, s2, i2) {
  return { code: Ks.INVALID_OPTION, message: `Invalid value ${i2 !== void 0 ? `${JSON.stringify(i2)} ` : ""}for option "${e2}" - ${s2}.`, url: `https://rollupjs.org/guide/en/#${t}` };
}
function Zs(e2, t, s2) {
  return { code: Ks.MISSING_EXPORT, message: `'${e2}' is not exported by ${se(s2)}, imported by ${se(t)}`, url: "https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module" };
}
function Js(e2) {
  const t = Array.from(e2.implicitlyLoadedBefore, (e3) => se(e3.id)).sort();
  return { code: Ks.MISSING_IMPLICIT_DEPENDANT, message: `Module "${se(e2.id)}" that should be implicitly loaded before ${ee(t)} is not included in the module graph. Either it was not imported by an included module or only via a tree-shaken dynamic import, or no imported bindings were used and it had otherwise no side-effects.` };
}
function ei(e2, t, s2) {
  return { code: Ks.NAMESPACE_CONFLICT, message: `Conflicting namespaces: "${se(t.id)}" re-exports "${e2}" from both "${se(t.exportsAll[e2])}" and "${se(s2.exportsAll[e2])}" (will be ignored)`, name: e2, reexporter: t.id, sources: [t.exportsAll[e2], s2.exportsAll[e2]] };
}
function ti(e2, t, s2, i2) {
  return { code: Ks.AMBIGUOUS_EXTERNAL_NAMESPACES, message: `Ambiguous external namespace resolution: "${se(t)}" re-exports "${e2}" from one of the external modules ${ee(i2.map((e3) => se(e3)))}, guessing "${se(s2)}".`, name: e2, reexporter: t, sources: i2 };
}
function si(e2, t, s2) {
  const i2 = s2 ? "reexport" : "import";
  return { code: Ks.UNEXPECTED_NAMED_IMPORT, id: e2, message: `The named export "${t}" was ${i2}ed from the external module ${se(e2)} even though its interop type is "defaultOnly". Either remove or change this ${i2} or change the value of the "output.interop" option.`, url: "https://rollupjs.org/guide/en/#outputinterop" };
}
function ii(e2) {
  return { code: Ks.UNEXPECTED_NAMED_IMPORT, id: e2, message: `There was a namespace "*" reexport from the external module ${se(e2)} even though its interop type is "defaultOnly". This will be ignored as namespace reexports only reexport named exports. If this is not intended, either remove or change this reexport or change the value of the "output.interop" option.`, url: "https://rollupjs.org/guide/en/#outputinterop" };
}
function ni(e2) {
  return { code: Ks.VALIDATION_ERROR, message: e2 };
}
function ri() {
  return { code: Ks.ALREADY_CLOSED, message: 'Bundle is already closed, no more calls to "generate" or "write" are allowed.' };
}
function ai(e2, t, s2) {
  oi(e2, t, s2.onwarn, s2.strictDeprecations);
}
function oi(e2, t, s2, i2) {
  if (t || i2) {
    const t2 = function(e3) {
      return __spreadValues2({ code: Ks.DEPRECATED_FEATURE }, typeof e3 == "string" ? { message: e3 } : e3);
    }(e2);
    if (i2)
      return Hs(t2);
    s2(t2);
  }
}
function Ii(e2) {
  return e2.id;
}
function Mi(e2, t) {
  switch (t) {
    case 1:
      return `# ${e2}`;
    case 2:
      return `## ${e2}`;
    case 3:
      return e2;
    default:
      return `${"  ".repeat(t - 4)}- ${e2}`;
  }
}
function Di(e2, t = 3) {
  e2 = Mi(e2, t), Ri.hasOwnProperty(e2) || (Ri[e2] = { memory: 0, startMemory: void 0, startTime: void 0, time: 0, totalMemory: 0 });
  const s2 = Ti();
  Ri[e2].startTime = _i(), Ri[e2].startMemory = s2;
}
function Li(e2, t = 3) {
  if (e2 = Mi(e2, t), Ri.hasOwnProperty(e2)) {
    const t2 = Ti();
    Ri[e2].time += $i(Ri[e2].startTime), Ri[e2].totalMemory = Math.max(Ri[e2].totalMemory, t2), Ri[e2].memory += t2 - Ri[e2].startMemory;
  }
}
function Oi() {
  const e2 = {};
  for (const [t, { time: s2, memory: i2, totalMemory: n3 }] of Object.entries(Ri))
    e2[t] = [s2, i2, n3];
  return e2;
}
function zi(e2, t) {
  const s2 = {};
  for (const i2 of Object.keys(e2))
    if (Fi[i2] === true) {
      let n3 = `plugin ${t}`;
      e2.name && (n3 += ` (${e2.name})`), n3 += ` - ${i2}`, s2[i2] = function(...t2) {
        Vi(n3, 4);
        let r2 = e2[i2].apply(this === s2 ? e2 : this, t2);
        return Bi(n3, 4), r2 && typeof r2.then == "function" && (Vi(`${n3} (async)`, 4), r2 = r2.then((e3) => (Bi(`${n3} (async)`, 4), e3))), r2;
      };
    } else
      s2[i2] = e2[i2];
  return s2;
}
function Wi(e2) {
  e2.perf ? (Ri = {}, typeof process != "undefined" && typeof process.hrtime == "function" ? (_i = process.hrtime.bind(process), $i = (e3) => {
    return 1e3 * (t = process.hrtime(e3))[0] + t[1] / 1e6;
    var t;
  }) : typeof performance != "undefined" && typeof performance.now == "function" && (_i = () => [performance.now(), 0], $i = (e3) => performance.now() - e3[0]), typeof process != "undefined" && typeof process.memoryUsage == "function" && (Ti = () => process.memoryUsage().heapUsed), Vi = Di, Bi = Li, e2.plugins = e2.plugins.map(zi)) : (Vi = Ni, Bi = Ni);
}
function ji(e2) {
  e2.isExecuted = true;
  const t = [e2], s2 = new Set();
  for (const e3 of t)
    for (const i2 of [...e3.dependencies, ...e3.implicitlyLoadedBefore])
      i2 instanceof ne || i2.isExecuted || !i2.info.hasModuleSideEffects && !e3.implicitlyLoadedBefore.has(i2) || s2.has(i2.id) || (i2.isExecuted = true, s2.add(i2.id), t.push(i2));
}
function Gi(e2, t, s2, i2, n3 = new Map(), r2) {
  const a2 = n3.get(t);
  if (a2) {
    if (a2.has(e2))
      return i2 ? null : Hs((o2 = t, h3 = e2.id, { code: Ks.CIRCULAR_REEXPORT, id: h3, message: `"${o2}" cannot be exported from ${se(h3)} as it is a reexport that references itself.` }));
    a2.add(e2);
  } else
    n3.set(t, new Set([e2]));
  var o2, h3;
  return e2.getVariableForExportName(t, { importerForSideEffects: s2, isExportAllSearch: i2, searchedNamesAndModules: n3, skipExternalNamespaceReexports: r2 });
}
function qi(e2, t, s2) {
  if (e2.module instanceof Hi && e2.module !== s2) {
    const i2 = e2.module.cycles;
    if (i2.size > 0) {
      const n3 = s2.cycles;
      for (const r2 of n3)
        if (i2.has(r2)) {
          t.alternativeReexportModules.set(e2, s2);
          break;
        }
    }
  }
}
function Ki(e2) {
  return e2.endsWith(".js") ? e2.slice(0, -3) : e2;
}
function Xi(e2, t) {
  return e2.autoId ? `${e2.basePath ? e2.basePath + "/" : ""}${Ki(t)}` : e2.id || "";
}
function Yi(e2, t, s2, i2, n3, r2, a2, o2 = "return ") {
  const { _: h3, cnst: l2, getDirectReturnFunction: c2, getFunctionIntro: u2, getPropertyAccess: d3, n: p2, s: f2 } = n3;
  if (!s2)
    return `${p2}${p2}${o2}${function(e3, t2, s3, i3, n4) {
      if (e3.length > 0)
        return e3[0].local;
      for (const { defaultVariableName: e4, id: r3, isChunk: a3, name: o3, namedExportsMode: h4, namespaceVariableName: l3, reexports: c3 } of t2)
        if (c3)
          return Qi(o3, c3[0].imported, h4, a3, e4, l3, s3, r3, i3, n4);
    }(e2, t, i2, a2, d3)};`;
  let m3 = "";
  for (const { defaultVariableName: e3, id: n4, isChunk: o3, name: l3, namedExportsMode: u3, namespaceVariableName: f3, reexports: g2 } of t)
    if (g2 && s2) {
      for (const t2 of g2)
        if (t2.reexported !== "*") {
          const s3 = Qi(l3, t2.imported, u3, o3, e3, f3, i2, n4, a2, d3);
          if (m3 && (m3 += p2), t2.imported !== "*" && t2.needsLiveBinding) {
            const [e4, i3] = c2([], { functionReturn: true, lineBreakIndent: null, name: null });
            m3 += `Object.defineProperty(exports,${h3}'${t2.reexported}',${h3}{${p2}${r2}enumerable:${h3}true,${p2}${r2}get:${h3}${e4}${s3}${i3}${p2}});`;
          } else
            m3 += `exports${d3(t2.reexported)}${h3}=${h3}${s3};`;
        }
    }
  for (const { exported: t2, local: s3 } of e2) {
    const e3 = `exports${d3(t2)}`, i3 = s3;
    e3 !== i3 && (m3 && (m3 += p2), m3 += `${e3}${h3}=${h3}${i3};`);
  }
  for (const { name: e3, reexports: i3 } of t)
    if (i3 && s2) {
      for (const t2 of i3)
        if (t2.reexported === "*") {
          m3 && (m3 += p2);
          const s3 = `{${p2}${r2}if${h3}(k${h3}!==${h3}'default'${h3}&&${h3}!exports.hasOwnProperty(k))${h3}${Ji(e3, t2.needsLiveBinding, r2, n3)}${f2}${p2}}`;
          m3 += l2 === "var" && t2.needsLiveBinding ? `Object.keys(${e3}).forEach(${u2(["k"], { isAsync: false, name: null })}${s3});` : `for${h3}(${l2} k in ${e3})${h3}${s3}`;
        }
    }
  return m3 ? `${p2}${p2}${m3}` : "";
}
function Qi(e2, t, s2, i2, n3, r2, a2, o2, h3, l2) {
  if (t === "default") {
    if (!i2) {
      const t2 = String(a2(o2)), s3 = ws[t2] ? n3 : e2;
      return Cs(t2, h3) ? `${s3}${l2("default")}` : s3;
    }
    return s2 ? `${e2}${l2("default")}` : e2;
  }
  return t === "*" ? (i2 ? !s2 : Is[String(a2(o2))]) ? r2 : e2 : `${e2}${l2(t)}`;
}
function Zi(e2, t, s2, i2, n3) {
  let r2 = "";
  return e2 && (t && (r2 += function(e3) {
    return `Object.defineProperty(exports,${e3}'__esModule',${e3}{${e3}value:${e3}true${e3}});`;
  }(i2)), s2 && (r2 && (r2 += n3), r2 += function(e3) {
    return `exports[Symbol.toStringTag]${e3}=${e3}'Module';`;
  }(i2))), r2;
}
function en(e2, t, s2, i2, n3, r2, a2, o2) {
  const { _: h3, cnst: l2, n: c2 } = o2, u2 = new Set(), d3 = [], p2 = (e3, t2, s3) => {
    u2.add(t2), d3.push(`${l2} ${e3}${h3}=${h3}/*#__PURE__*/${t2}(${s3});`);
  };
  for (const { defaultVariableName: s3, imports: i3, id: n4, isChunk: r3, name: a3, namedExportsMode: o3, namespaceVariableName: h4, reexports: l3 } of e2)
    if (r3) {
      for (const { imported: e3, reexported: t2 } of [...i3 || [], ...l3 || []])
        if (e3 === "*" && t2 !== "*") {
          o3 || p2(h4, "_interopNamespaceDefaultOnly", a3);
          break;
        }
    } else {
      const e3 = String(t(n4));
      let r4 = false, o4 = false;
      for (const { imported: t2, reexported: n5 } of [...i3 || [], ...l3 || []]) {
        let i4, l4;
        t2 === "default" ? r4 || (r4 = true, s3 !== h4 && (l4 = s3, i4 = ws[e3])) : t2 === "*" && n5 !== "*" && (o4 || (o4 = true, i4 = Is[e3], l4 = h4)), i4 && p2(l4, i4, a3);
      }
    }
  return `${_s(u2, r2, a2, o2, s2, i2, n3)}${d3.length > 0 ? `${d3.join(c2)}${c2}${c2}` : ""}`;
}
function tn(e2) {
  return e2[0] === "." ? Ki(e2) : e2;
}
function nn(e2, t) {
  const s2 = t.map(({ id: e3 }) => e3).filter((e3) => e3 in sn);
  s2.length && e2({ code: "MISSING_NODE_BUILTINS", message: `Creating a browser bundle that depends on Node.js built-in modules (${ee(s2)}). You might need to include https://github.com/snowpackjs/rollup-plugin-polyfill-node`, modules: s2 });
}
function an(e2, t, s2, i2, { _: n3, getPropertyAccess: r2 }) {
  const a2 = e2.split(".");
  a2[0] = (typeof s2 == "function" ? s2(a2[0]) : s2[a2[0]]) || a2[0];
  const o2 = a2.pop();
  let h3 = t, l2 = a2.map((e3) => (h3 += r2(e3), `${h3}${n3}=${n3}${h3}${n3}||${n3}{}`)).concat(`${h3}${r2(o2)}`).join(`,${n3}`) + `${n3}=${n3}${i2}`;
  return a2.length > 0 && (l2 = `(${l2})`), l2;
}
function on(e2) {
  let t = e2.length;
  for (; t--; ) {
    const { imports: s2, reexports: i2 } = e2[t];
    if (s2 || i2)
      return e2.slice(0, t + 1);
  }
  return [];
}
function dn(e2, t, { _: s2, n: i2 }) {
  return e2.length === 0 ? "" : e2.length === 1 ? `exports('${e2[0].name}',${s2}${e2[0].value});${i2}${i2}` : `exports({${i2}` + e2.map(({ name: e3, value: i3 }) => `${t}${e3}:${s2}${i3}`).join(`,${i2}`) + `${i2}});${i2}${i2}`;
}
function mn(e2, t, s2) {
  return e2 ? `${t}${rn(e2, s2)}` : "null";
}
function xn(e2) {
  return function(t, s2) {
    return s2.mappings ? new En(s2, [t]) : (e2({ code: "SOURCEMAP_BROKEN", message: `Sourcemap is likely to be incorrect: a plugin (${s2.plugin}) was used to transform files, but didn't generate a sourcemap for the transformation. Consult the plugin documentation for help`, plugin: s2.plugin, url: "https://rollupjs.org/guide/en/#warning-sourcemap-is-likely-to-be-incorrect" }), new En({ mappings: [], names: [] }, [t]));
  };
}
function vn(e2, t, s2, i2, n3) {
  let r2;
  if (s2) {
    const t2 = s2.sources, i3 = s2.sourcesContent || [], n4 = I(e2) || ".", a2 = s2.sourceRoot || ".", o2 = t2.map((e3, t3) => new yn($(n4, a2, e3), i3[t3]));
    r2 = new En(s2, o2);
  } else
    r2 = new yn(e2, t);
  return i2.reduce(n3, r2);
}
function An(e2, t) {
  if (!e2)
    throw new Error(t || "Assertion failed");
}
function Cn(e2, t) {
  return (64512 & e2.charCodeAt(t)) == 55296 && (!(t < 0 || t + 1 >= e2.length) && (64512 & e2.charCodeAt(t + 1)) == 56320);
}
function In(e2) {
  return (e2 >>> 24 | e2 >>> 8 & 65280 | e2 << 8 & 16711680 | (255 & e2) << 24) >>> 0;
}
function Nn(e2) {
  return e2.length === 1 ? "0" + e2 : e2;
}
function _n(e2) {
  return e2.length === 7 ? "0" + e2 : e2.length === 6 ? "00" + e2 : e2.length === 5 ? "000" + e2 : e2.length === 4 ? "0000" + e2 : e2.length === 3 ? "00000" + e2 : e2.length === 2 ? "000000" + e2 : e2.length === 1 ? "0000000" + e2 : e2;
}
function Mn() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
function On(e2, t, s2) {
  return e2 & t ^ ~e2 & s2;
}
function Vn(e2, t, s2) {
  return e2 & t ^ e2 & s2 ^ t & s2;
}
function Bn(e2, t, s2) {
  return e2 ^ t ^ s2;
}
function tr() {
  if (!(this instanceof tr))
    return new tr();
  Jn.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = er, this.W = new Array(64);
}
function ar(e2, t, s2, i2, n3, r2, a2, o2, h3, l2, c2, u2, d3) {
  const p2 = e2.slice().reverse();
  for (const e3 of p2)
    e3.scope.addUsedOutsideNames(i2, n3, c2, u2);
  !function(e3, t2, s3) {
    for (const i3 of t2) {
      for (const t3 of i3.scope.variables.values())
        t3.included && !(t3.renderBaseName || t3 instanceof vi && t3.getOriginalVariable() !== t3) && t3.setRenderNames(null, st(t3.name, e3));
      if (s3.has(i3)) {
        const t3 = i3.namespace;
        t3.setRenderNames(null, st(t3.name, e3));
      }
    }
  }(i2, p2, d3), rr[n3](i2, s2, t, r2, a2, o2, h3, l2);
  for (const e3 of p2)
    e3.scope.deconflict(n3, c2, u2);
}
function or(e2, t, s2, i2, n3, r2, a2, o2) {
  for (const t2 of s2.dependencies)
    (n3 || t2 instanceof ne) && (t2.variableName = st(t2.suggestedVariableName, e2));
  for (const s3 of t) {
    const t2 = s3.module, i3 = s3.name;
    s3.isNamespace && (n3 || t2 instanceof ne) ? s3.setRenderNames(null, (t2 instanceof ne ? t2 : a2.get(t2)).variableName) : t2 instanceof ne && i3 === "default" ? s3.setRenderNames(null, st([...t2.exportedVariables].some(([e3, t3]) => t3 === "*" && e3.included) ? t2.suggestedVariableName + "__default" : t2.suggestedVariableName, e2)) : s3.setRenderNames(null, st(i3, e2));
  }
  for (const t2 of o2)
    t2.setRenderNames(null, st(t2.name, e2));
}
function hr(e2, t, { deconflictedDefault: s2, deconflictedNamespace: i2, dependencies: n3 }, r2, a2, o2, h3) {
  for (const t2 of n3)
    t2.variableName = st(t2.suggestedVariableName, e2);
  for (const t2 of i2)
    t2.namespaceVariableName = st(`${t2.suggestedVariableName}__namespace`, e2);
  for (const t2 of s2)
    i2.has(t2) && Ns(String(r2(t2.id)), o2) ? t2.defaultVariableName = t2.namespaceVariableName : t2.defaultVariableName = st(`${t2.suggestedVariableName}__default`, e2);
  for (const e3 of t) {
    const t2 = e3.module;
    if (t2 instanceof ne) {
      const s3 = e3.name;
      if (s3 === "default") {
        const s4 = String(r2(t2.id)), i3 = ws[s4] ? t2.defaultVariableName : t2.variableName;
        Cs(s4, o2) ? e3.setRenderNames(i3, "default") : e3.setRenderNames(null, i3);
      } else
        s3 === "*" ? e3.setRenderNames(null, Is[String(r2(t2.id))] ? t2.namespaceVariableName : t2.variableName) : e3.setRenderNames(t2.variableName, null);
    } else {
      const s3 = h3.get(t2);
      a2 && e3.isNamespace ? e3.setRenderNames(null, s3.exportMode === "default" ? s3.namespaceVariableName : s3.variableName) : s3.exportMode === "default" ? e3.setRenderNames(null, s3.variableName) : e3.setRenderNames(s3.variableName, s3.getVariableExportName(e3));
    }
  }
}
function dr(e2) {
  return e2.match(lr) ? e2.replace(ur, "\\\\").replace(cr, "\\$1") : e2;
}
function pr(e2, { exports: t, name: s2, format: i2 }, n3, r2, a2) {
  const o2 = e2.getExportNames();
  if (t === "default") {
    if (o2.length !== 1 || o2[0] !== "default")
      return Hs(Ys("default", o2, r2));
  } else if (t === "none" && o2.length)
    return Hs(Ys("none", o2, r2));
  return t === "auto" && (o2.length === 0 ? t = "none" : o2.length === 1 && o2[0] === "default" ? (i2 === "cjs" && n3.has("exports") && a2(function(e3) {
    const t2 = se(e3);
    return { code: Ks.PREFER_NAMED_EXPORTS, id: e3, message: `Entry module "${t2}" is implicitly using "default" export mode, which means for CommonJS output that its default export is assigned to "module.exports". For many tools, such CommonJS output will not be interchangeable with the original ES module. If this is intended, explicitly set "output.exports" to either "auto" or "default", otherwise you might want to consider changing the signature of "${t2}" to use named exports only.`, url: "https://rollupjs.org/guide/en/#outputexports" };
  }(r2)), t = "default") : (i2 !== "es" && i2 !== "system" && o2.indexOf("default") !== -1 && a2(function(e3, t2) {
    return { code: Ks.MIXED_EXPORTS, id: e3, message: `Entry module "${se(e3)}" is using named and default exports together. Consumers of your bundle will have to use \`${t2 || "chunk"}["default"]\` to access the default export, which may not be what you want. Use \`output.exports: "named"\` to disable this warning`, url: "https://rollupjs.org/guide/en/#outputexports" };
  }(r2, s2)), t = "named")), t;
}
function fr(e2) {
  const t = e2.split("\n"), s2 = t.filter((e3) => /^\t+/.test(e3)), i2 = t.filter((e3) => /^ {2,}/.test(e3));
  if (s2.length === 0 && i2.length === 0)
    return null;
  if (s2.length >= i2.length)
    return "	";
  const n3 = i2.reduce((e3, t2) => {
    const s3 = /^ +/.exec(t2)[0].length;
    return Math.min(s3, e3);
  }, 1 / 0);
  return new Array(n3 + 1).join(" ");
}
function mr(e2, t, s2, i2, n3) {
  const r2 = e2.getDependenciesToBeIncluded();
  for (const e3 of r2) {
    if (e3 instanceof ne) {
      t.push(e3);
      continue;
    }
    const r3 = n3.get(e3);
    r3 === i2 ? s2.has(e3) || (s2.add(e3), mr(e3, t, s2, i2, n3)) : t.push(r3);
  }
}
function gr(e2) {
  if (!e2)
    return null;
  if (typeof e2 == "string" && (e2 = JSON.parse(e2)), e2.mappings === "")
    return { mappings: [], names: [], sources: [], version: 3 };
  let s2;
  return s2 = typeof e2.mappings == "string" ? function(e3) {
    for (var s3 = [], i2 = [], r2 = [0, 0, 0, 0, 0], a2 = 0, o2 = 0, h3 = 0, l2 = 0; o2 < e3.length; o2++) {
      var c2 = e3.charCodeAt(o2);
      if (c2 === 44)
        n2(i2, r2, a2), a2 = 0;
      else if (c2 === 59)
        n2(i2, r2, a2), a2 = 0, s3.push(i2), i2 = [], r2[0] = 0;
      else {
        var u2 = t[c2];
        if (u2 === void 0)
          throw new Error("Invalid character (" + String.fromCharCode(c2) + ")");
        var d3 = 32 & u2;
        if (l2 += (u2 &= 31) << h3, d3)
          h3 += 5;
        else {
          var p2 = 1 & l2;
          l2 >>>= 1, p2 && (l2 = l2 === 0 ? -2147483648 : -l2), r2[a2] += l2, a2++, l2 = h3 = 0;
        }
      }
    }
    return n2(i2, r2, a2), s3.push(i2), s3;
  }(e2.mappings) : e2.mappings, __spreadProps2(__spreadValues2({}, e2), { mappings: s2 });
}
function yr(e2, t, s2) {
  return ie(e2) ? Hs(ni(`Invalid pattern "${e2}" for "${t}", patterns can be neither absolute nor relative paths.`)) : e2.replace(/\[(\w+)\]/g, (e3, i2) => {
    if (!s2.hasOwnProperty(i2))
      return Hs(ni(`"[${i2}]" is not a valid placeholder in "${t}" pattern.`));
    const n3 = s2[i2]();
    return ie(n3) ? Hs(ni(`Invalid substitution "${n3}" for placeholder "[${i2}]" in "${t}" pattern, can be neither absolute nor relative path.`)) : n3;
  });
}
function Er(e2, t) {
  const s2 = new Set(Object.keys(t).map((e3) => e3.toLowerCase()));
  if (!s2.has(e2.toLocaleLowerCase()))
    return e2;
  const i2 = N(e2);
  e2 = e2.substr(0, e2.length - i2.length);
  let n3, r2 = 1;
  for (; s2.has((n3 = e2 + ++r2 + i2).toLowerCase()); )
    ;
  return n3;
}
function vr(e2, t, s2, i2) {
  const n3 = typeof t == "function" ? t(e2.id) : t[e2.id];
  return n3 || (s2 ? (i2({ code: "MISSING_GLOBAL_NAME", guess: e2.variableName, message: `No name was provided for external module '${e2.id}' in output.globals \u2013 guessing '${e2.variableName}'`, source: e2.id }), e2.variableName) : void 0);
}
function Sr(e2) {
  return e2.chunkName || te(e2.id);
}
function Ar(e2, t, s2) {
  e2 in t && s2(function(e3) {
    return { code: Ks.FILE_NAME_CONFLICT, message: `The emitted file "${e3}" overwrites a previously emitted file of the same name.` };
  }(e2)), t[e2] = Pr;
}
function kr(e2, t, s2) {
  if (!(typeof e2 == "string" || e2 instanceof Uint8Array)) {
    const e3 = t.fileName || t.name || s2;
    return Hs(ni(`Could not set source for ${typeof e3 == "string" ? `asset "${e3}"` : "unnamed asset"}, asset source needs to be a string, Uint8Array or Buffer.`));
  }
  return e2;
}
function wr(e2, t) {
  return typeof e2.fileName != "string" ? Hs((s2 = e2.name || t, { code: Ks.ASSET_NOT_FINALISED, message: `Plugin error - Unable to get file name for asset "${s2}". Ensure that the source is set and that generate is called first.` })) : e2.fileName;
  var s2;
}
function Cr(e2, t) {
  var s2;
  const i2 = e2.fileName || e2.module && ((s2 = t == null ? void 0 : t.get(e2.module)) === null || s2 === void 0 ? void 0 : s2.id);
  return i2 || Hs((n3 = e2.fileName || e2.name, { code: Ks.CHUNK_NOT_GENERATED, message: `Plugin error - Unable to get file name for chunk "${n3}". Ensure that generate is called first.` }));
  var n3;
}
function Nr(e2, t) {
  if (typeof e2 == "string")
    return e2 === t;
  if (typeof t == "string")
    return false;
  if ("equals" in e2)
    return e2.equals(t);
  if (e2.length !== t.length)
    return false;
  for (let s2 = 0; s2 < e2.length; s2++)
    if (e2[s2] !== t[s2])
      return false;
  return true;
}
function Tr(e2, t) {
  const s2 = [], i2 = new Set(t.keys()), n3 = Object.create(null);
  for (const [e3, s3] of t) {
    Rr(e3, n3[s3] = n3[s3] || [], i2);
  }
  for (const [e3, t2] of Object.entries(n3))
    s2.push({ alias: e3, modules: t2 });
  const r2 = new Map(), { dependentEntryPointsByModule: a2, dynamicEntryModules: o2 } = function(e3) {
    const t2 = new Set(), s3 = new Map(), i3 = new Set(e3);
    for (const e4 of i3) {
      const n4 = new Set([e4]);
      for (const r3 of n4) {
        T(s3, r3, () => new Set()).add(e4);
        for (const e5 of r3.getDependenciesToBeIncluded())
          e5 instanceof ne || n4.add(e5);
        for (const { resolution: e5 } of r3.dynamicImports)
          e5 instanceof Hi && e5.includedDynamicImporters.length > 0 && (t2.add(e5), i3.add(e5));
        for (const e5 of r3.implicitlyLoadedBefore)
          t2.add(e5), i3.add(e5);
      }
    }
    return { dependentEntryPointsByModule: s3, dynamicEntryModules: t2 };
  }(e2), h3 = function(e3, t2) {
    const s3 = new Map();
    for (const i3 of t2) {
      const t3 = T(s3, i3, () => new Set());
      for (const s4 of [...i3.includedDynamicImporters, ...i3.implicitlyLoadedAfter])
        for (const i4 of e3.get(s4))
          t3.add(i4);
    }
    return s3;
  }(a2, o2), l2 = new Set(e2);
  function c2(e3, t2) {
    const s3 = new Set([e3]);
    for (const n4 of s3) {
      const o3 = T(r2, n4, () => new Set());
      if (!t2 || !u2(t2, a2.get(n4))) {
        o3.add(e3);
        for (const e4 of n4.getDependenciesToBeIncluded())
          e4 instanceof ne || i2.has(e4) || s3.add(e4);
      }
    }
  }
  function u2(e3, t2) {
    const s3 = new Set(e3);
    for (const e4 of s3)
      if (!t2.has(e4)) {
        if (l2.has(e4))
          return false;
        const t3 = h3.get(e4);
        for (const e5 of t3)
          s3.add(e5);
      }
    return true;
  }
  for (const t2 of e2)
    i2.has(t2) || c2(t2, null);
  for (const e3 of o2)
    i2.has(e3) || c2(e3, h3.get(e3));
  return s2.push(...function(e3, t2) {
    const s3 = Object.create(null);
    for (const [i3, n4] of t2) {
      let t3 = "";
      for (const s4 of e3)
        t3 += n4.has(s4) ? "X" : "_";
      const r3 = s3[t3];
      r3 ? r3.push(i3) : s3[t3] = [i3];
    }
    return Object.values(s3).map((e4) => ({ alias: null, modules: e4 }));
  }([...e2, ...o2], r2)), s2;
}
function Rr(e2, t, s2) {
  const i2 = new Set([e2]);
  for (const e3 of i2) {
    s2.add(e3), t.push(e3);
    for (const t2 of e3.dependencies)
      t2 instanceof ne || s2.has(t2) || i2.add(t2);
  }
}
function Dr(e2, t, s2) {
  const i2 = Symbol(e2.id), n3 = [se(e2.id)];
  let r2 = t;
  for (e2.cycles.add(i2); r2 !== e2; )
    r2.cycles.add(i2), n3.push(se(r2.id)), r2 = s2.get(r2);
  return n3.push(n3[0]), n3.reverse(), n3;
}
function Br(e2) {
  return [...e2.values()].filter((e3) => e3 instanceof Hi && (e3.isIncluded() || e3.info.isEntry || e3.includedDynamicImporters.length > 0));
}
function Fr(e2, t, s2) {
  const i2 = s2.get(t);
  if (typeof i2 == "string" && i2 !== e2)
    return Hs((n3 = t.id, r2 = e2, a2 = i2, { code: Ks.INVALID_CHUNK, message: `Cannot assign ${se(n3)} to the "${r2}" chunk as it is already in the "${a2}" chunk.` }));
  var n3, r2, a2;
  s2.set(t, e2);
}
function Qr(e2, t) {
  for (var s2 = 65536, i2 = 0; i2 < t.length; i2 += 2) {
    if ((s2 += t[i2]) > e2)
      return false;
    if ((s2 += t[i2 + 1]) >= e2)
      return true;
  }
}
function Zr(e2, t) {
  return e2 < 65 ? e2 === 36 : e2 < 91 || (e2 < 97 ? e2 === 95 : e2 < 123 || (e2 <= 65535 ? e2 >= 170 && qr.test(String.fromCharCode(e2)) : t !== false && Qr(e2, Xr)));
}
function Jr(e2, t) {
  return e2 < 48 ? e2 === 36 : e2 < 58 || !(e2 < 65) && (e2 < 91 || (e2 < 97 ? e2 === 95 : e2 < 123 || (e2 <= 65535 ? e2 >= 170 && Kr.test(String.fromCharCode(e2)) : t !== false && (Qr(e2, Xr) || Qr(e2, Yr)))));
}
function ta(e2, t) {
  return new ea(e2, { beforeExpr: true, binop: t });
}
function ra(e2, t) {
  return t === void 0 && (t = {}), t.keyword = e2, na[e2] = new ea(e2, t);
}
function la(e2) {
  return e2 === 10 || e2 === 13 || e2 === 8232 || e2 === 8233;
}
function ma(e2, t) {
  return pa.call(e2, t);
}
function ya(e2) {
  return new RegExp("^(?:" + e2.replace(/ /g, "|") + ")$");
}
function va(e2, t) {
  for (var s2 = 1, i2 = 0; ; ) {
    ha.lastIndex = i2;
    var n3 = ha.exec(e2);
    if (!(n3 && n3.index < t))
      return new Ea(s2, t - i2);
    ++s2, i2 = n3.index + n3[0].length;
  }
}
function Aa(e2) {
  var t = {};
  for (var s2 in ba)
    t[s2] = e2 && ma(e2, s2) ? e2[s2] : ba[s2];
  if (t.ecmaVersion === "latest" ? t.ecmaVersion = 1e8 : t.ecmaVersion == null ? (!Sa && typeof console == "object" && console.warn && (Sa = true, console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.")), t.ecmaVersion = 11) : t.ecmaVersion >= 2015 && (t.ecmaVersion -= 2009), t.allowReserved == null && (t.allowReserved = t.ecmaVersion < 5), ga(t.onToken)) {
    var i2 = t.onToken;
    t.onToken = function(e3) {
      return i2.push(e3);
    };
  }
  return ga(t.onComment) && (t.onComment = function(e3, t2) {
    return function(s3, i3, n3, r2, a2, o2) {
      var h3 = { type: s3 ? "Block" : "Line", value: i3, start: n3, end: r2 };
      e3.locations && (h3.loc = new xa(this, a2, o2)), e3.ranges && (h3.range = [n3, r2]), t2.push(h3);
    };
  }(t, t.onComment)), t;
}
function Pa(e2, t) {
  return 2 | (e2 ? 4 : 0) | (t ? 8 : 0);
}
function Na() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
}
function La(e2, t) {
  var s2 = t.key.name, i2 = e2[s2], n3 = "true";
  return t.type !== "MethodDefinition" || t.kind !== "get" && t.kind !== "set" || (n3 = (t.static ? "s" : "i") + t.kind), i2 === "iget" && n3 === "iset" || i2 === "iset" && n3 === "iget" || i2 === "sget" && n3 === "sset" || i2 === "sset" && n3 === "sget" ? (e2[s2] = "true", false) : !!i2 || (e2[s2] = n3, false);
}
function Oa(e2, t) {
  var s2 = e2.computed, i2 = e2.key;
  return !s2 && (i2.type === "Identifier" && i2.name === t || i2.type === "Literal" && i2.value === t);
}
function ja(e2) {
  return e2.type === "MemberExpression" && e2.property.type === "PrivateIdentifier" || e2.type === "ChainExpression" && ja(e2.expression);
}
function Ya(e2, t, s2, i2) {
  return e2.type = t, e2.end = s2, this.options.locations && (e2.loc.end = i2), this.options.ranges && (e2.range[1] = s2), e2;
}
function ao(e2) {
  var t = ro[e2] = { binary: ya(Ja[e2] + " " + eo), nonBinary: { General_Category: ya(eo), Script: ya(no[e2]) } };
  t.nonBinary.Script_Extensions = t.nonBinary.Script, t.nonBinary.gc = t.nonBinary.General_Category, t.nonBinary.sc = t.nonBinary.Script, t.nonBinary.scx = t.nonBinary.Script_Extensions;
}
function lo(e2) {
  return e2 <= 65535 ? String.fromCharCode(e2) : (e2 -= 65536, String.fromCharCode(55296 + (e2 >> 10), 56320 + (1023 & e2)));
}
function co(e2) {
  return e2 === 36 || e2 >= 40 && e2 <= 43 || e2 === 46 || e2 === 63 || e2 >= 91 && e2 <= 94 || e2 >= 123 && e2 <= 125;
}
function uo(e2) {
  return e2 >= 65 && e2 <= 90 || e2 >= 97 && e2 <= 122;
}
function po(e2) {
  return uo(e2) || e2 === 95;
}
function fo(e2) {
  return po(e2) || mo(e2);
}
function mo(e2) {
  return e2 >= 48 && e2 <= 57;
}
function go(e2) {
  return e2 >= 48 && e2 <= 57 || e2 >= 65 && e2 <= 70 || e2 >= 97 && e2 <= 102;
}
function yo(e2) {
  return e2 >= 65 && e2 <= 70 ? e2 - 65 + 10 : e2 >= 97 && e2 <= 102 ? e2 - 97 + 10 : e2 - 48;
}
function Eo(e2) {
  return e2 >= 48 && e2 <= 55;
}
function bo(e2) {
  return typeof BigInt != "function" ? null : BigInt(e2.replace(/_/g, ""));
}
function So(e2) {
  return e2 <= 65535 ? String.fromCharCode(e2) : (e2 -= 65536, String.fromCharCode(55296 + (e2 >> 10), 56320 + (1023 & e2)));
}
async function Io(e2, t, s2, i2, n3, r2, a2, o2) {
  const h3 = await function(e3, t2, s3, i3, n4, r3, a3) {
    let o3 = null, h4 = null;
    if (n4) {
      o3 = new Set();
      for (const s4 of n4)
        e3 === s4.source && t2 === s4.importer && o3.add(s4.plugin);
      h4 = (e4, t3) => __spreadProps2(__spreadValues2({}, e4), { resolve: (e5, s4, { custom: r4, isEntry: a4, skipSelf: o4 } = q) => i3(e5, s4, r4, a4, o4 ? [...n4, { importer: s4, plugin: t3, source: e5 }] : n4) });
    }
    return s3.hookFirst("resolveId", [e3, t2, { custom: r3, isEntry: a3 }], h4, o3);
  }(e2, t, i2, n3, r2, a2, o2);
  return h3;
}
function No(e2, t, { hook: s2, id: i2 } = {}) {
  return typeof e2 == "string" && (e2 = { message: e2 }), e2.code && e2.code !== Ks.PLUGIN_ERROR && (e2.pluginCode = e2.code), e2.code = Ks.PLUGIN_ERROR, e2.plugin = t, s2 && (e2.hook = s2), i2 && (e2.id = i2), Hs(e2);
}
function To(e2) {
  return e2.startsWith("at position ") || e2.startsWith("at output position ") ? Hs({ code: "ANONYMOUS_PLUGIN_CACHE", message: "A plugin is trying to use the Rollup cache but is not declaring a plugin name or cacheKey." }) : Hs({ code: "DUPLICATE_PLUGIN_NAME", message: `The plugin name ${e2} is being used twice in the same build. Plugin names must be distinct or provide a cacheKey (please post an issue to the plugin if you are a plugin user).` });
}
async function Ro(e2, t, s2, i2) {
  const n3 = t.id, r2 = [];
  let a2 = e2.map === null ? null : gr(e2.map);
  const o2 = e2.code;
  let h3 = e2.ast;
  const c2 = [], u2 = [];
  let d3 = false;
  const p2 = () => d3 = true;
  let f2 = "";
  const m3 = e2.code;
  let g2;
  try {
    g2 = await s2.hookReduceArg0("transform", [m3, n3], function(e3, s3, n4) {
      let a3, o3;
      if (typeof s3 == "string")
        a3 = s3;
      else {
        if (!s3 || typeof s3 != "object")
          return e3;
        if (t.updateOptions(s3), s3.code == null)
          return (s3.map || s3.ast) && i2(function(e4) {
            return { code: Ks.NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE, message: `The plugin "${e4}" returned a "map" or "ast" without returning a "code". This will be ignored.` };
          }(n4.name)), e3;
        ({ code: a3, map: o3, ast: h3 } = s3);
      }
      return o3 !== null && r2.push(gr(typeof o3 == "string" ? JSON.parse(o3) : o3) || { missing: true, plugin: n4.name }), a3;
    }, (e3, t2) => {
      return f2 = t2.name, __spreadProps2(__spreadValues2({}, e3), { addWatchFile(t3) {
        c2.push(t3), e3.addWatchFile(t3);
      }, cache: d3 ? e3.cache : (h4 = e3.cache, g3 = p2, { delete: (e4) => (g3(), h4.delete(e4)), get: (e4) => (g3(), h4.get(e4)), has: (e4) => (g3(), h4.has(e4)), set: (e4, t3) => (g3(), h4.set(e4, t3)) }), emitAsset: (t3, s3) => (u2.push({ name: t3, source: s3, type: "asset" }), e3.emitAsset(t3, s3)), emitChunk: (t3, s3) => (u2.push({ id: t3, name: s3 && s3.name, type: "chunk" }), e3.emitChunk(t3, s3)), emitFile: (e4) => (u2.push(e4), s2.emitFile(e4)), error: (t3, s3) => (typeof t3 == "string" && (t3 = { message: t3 }), s3 && qs2(t3, s3, m3, n3), t3.id = n3, t3.hook = "transform", e3.error(t3)), getCombinedSourcemap() {
        const e4 = function(e5, t3, s3, i3, n4) {
          return i3.length ? __spreadValues2({ version: 3 }, vn(e5, t3, s3, i3, xn(n4)).traceMappings()) : s3;
        }(n3, o2, a2, r2, i2);
        if (!e4) {
          return new b(o2).generateMap({ hires: true, includeContent: true, source: n3 });
        }
        return a2 !== e4 && (a2 = e4, r2.length = 0), new l(__spreadProps2(__spreadValues2({}, e4), { file: null, sourcesContent: e4.sourcesContent }));
      }, setAssetSource() {
        return this.error({ code: "INVALID_SETASSETSOURCE", message: "setAssetSource cannot be called in transform for caching reasons. Use emitFile with a source, or call setAssetSource in another hook." });
      }, warn(t3, s3) {
        typeof t3 == "string" && (t3 = { message: t3 }), s3 && qs2(t3, s3, m3, n3), t3.id = n3, t3.hook = "transform", e3.warn(t3);
      } });
      var h4, g3;
    });
  } catch (e3) {
    No(e3, f2, { hook: "transform", id: n3 });
  }
  return d3 || u2.length && (t.transformFiles = u2), { ast: h3, code: g2, customTransformCache: d3, meta: t.info.meta, originalCode: o2, originalSourcemap: a2, sourcemapChain: r2, transformDependencies: c2 };
}
function Do(e2, t) {
  return k(e2) ? t ? $(t, "..", e2) : $(e2) : e2;
}
function Lo(e2, { fileName: t, name: s2 }, i2) {
  t !== null ? e2.chunkFileNames.add(t) : s2 !== null && (e2.chunkName === null && (e2.chunkName = s2), i2 && e2.userChunkNames.add(s2));
}
function Oo(e2, t, s2) {
  return s2 === true || s2 === "ifRelativeSource" && k(t) || !P(e2);
}
function Bo(e2, t, s2, i2, n3, r2) {
  let a2 = false;
  return (...o2) => (a2 || (a2 = true, ai({ message: `The "this.${t}" plugin context function used by plugin ${i2} is deprecated. The "this.${s2}" plugin context function should be used instead.`, plugin: i2 }, n3, r2)), e2(...o2));
}
function Fo(e2, t, s2, i2, n3, r2) {
  let a2, o2 = true;
  if (typeof e2.cacheKey != "string" && (e2.name.startsWith("at position ") || e2.name.startsWith("at output position ") || r2.has(e2.name) ? o2 = false : r2.add(e2.name)), t)
    if (o2) {
      const s3 = e2.cacheKey || e2.name;
      l2 = t[s3] || (t[s3] = Object.create(null)), a2 = { delete: (e3) => delete l2[e3], get(e3) {
        const t2 = l2[e3];
        if (t2)
          return t2[0] = 0, t2[1];
      }, has(e3) {
        const t2 = l2[e3];
        return !!t2 && (t2[0] = 0, true);
      }, set(e3, t2) {
        l2[e3] = [0, t2];
      } };
    } else
      h3 = e2.name, a2 = { delete: () => To(h3), get: () => To(h3), has: () => To(h3), set: () => To(h3) };
  else
    a2 = $o;
  var h3, l2;
  const c2 = { addWatchFile(e3) {
    if (s2.phase >= Ci.GENERATE)
      return this.error({ code: Ks.INVALID_ROLLUP_PHASE, message: "Cannot call addWatchFile after the build has finished." });
    s2.watchFiles[e3] = true;
  }, cache: a2, emitAsset: Bo((e3, t2) => n3.emitFile({ name: e3, source: t2, type: "asset" }), "emitAsset", "emitFile", e2.name, true, i2), emitChunk: Bo((e3, t2) => n3.emitFile({ id: e3, name: t2 && t2.name, type: "chunk" }), "emitChunk", "emitFile", e2.name, true, i2), emitFile: n3.emitFile.bind(n3), error: (t2) => No(t2, e2.name), getAssetFileName: Bo(n3.getFileName, "getAssetFileName", "getFileName", e2.name, true, i2), getChunkFileName: Bo(n3.getFileName, "getChunkFileName", "getFileName", e2.name, true, i2), getFileName: n3.getFileName, getModuleIds: () => s2.modulesById.keys(), getModuleInfo: s2.getModuleInfo, getWatchFiles: () => Object.keys(s2.watchFiles), isExternal: Bo((e3, t2, s3 = false) => i2.external(e3, t2, s3), "isExternal", "resolve", e2.name, true, i2), load: (e3) => s2.moduleLoader.preloadModule(e3), meta: { rollupVersion: "2.63.0", watchMode: s2.watchMode }, get moduleIds() {
    const t2 = s2.modulesById.keys();
    return function* () {
      ai({ message: `Accessing "this.moduleIds" on the plugin context by plugin ${e2.name} is deprecated. The "this.getModuleIds" plugin context function should be used instead.`, plugin: e2.name }, false, i2), yield* t2;
    }();
  }, parse: s2.contextParse.bind(s2), resolve: (t2, i3, { custom: n4, isEntry: r3, skipSelf: a3 } = q) => s2.moduleLoader.resolveId(t2, i3, n4, r3, a3 ? [{ importer: i3, plugin: e2, source: t2 }] : null), resolveId: Bo((e3, t2) => s2.moduleLoader.resolveId(e3, t2, q, void 0).then((e4) => e4 && e4.id), "resolveId", "resolve", e2.name, true, i2), setAssetSource: n3.setAssetSource, warn(t2) {
    typeof t2 == "string" && (t2 = { message: t2 }), t2.code && (t2.pluginCode = t2.code), t2.code = "PLUGIN_WARNING", t2.plugin = e2.name, i2.onwarn(t2);
  } };
  return c2;
}
function Wo(e2, t) {
  return Hs({ code: "INVALID_PLUGIN_HOOK", message: `Error running plugin hook ${e2} for ${t}, expected a function hook.` });
}
function Go(e2) {
  return Array.isArray(e2) ? e2.filter(Boolean) : e2 ? [e2] : [];
}
function qo(e2, t, s2, i2, n3 = /$./) {
  const r2 = new Set(t), a2 = Object.keys(e2).filter((e3) => !(r2.has(e3) || n3.test(e3)));
  a2.length > 0 && i2({ code: "UNKNOWN_OPTION", message: `Unknown ${s2}: ${a2.join(", ")}. Allowed options: ${[...r2].sort().join(", ")}` });
}
function ph(e2) {
  const t = /^[a-z]:/i.exec(e2), s2 = t ? t[0] : "";
  return s2 + e2.substr(s2.length).replace(dh, "_");
}
function kh(e2, t) {
  const s2 = e2.exports;
  if (s2 == null)
    t.add("exports");
  else if (!["default", "named", "none", "auto"].includes(s2))
    return Hs((i2 = s2, { code: Ks.INVALID_EXPORT_OPTION, message: `"output.exports" must be "default", "named", "none", "auto", or left unspecified (defaults to "auto"), received "${i2}"`, url: "https://rollupjs.org/guide/en/#outputexports" }));
  var i2;
  return s2 || "auto";
}
function Th(e2) {
  return async function(e3, t) {
    const { options: s2, unsetOptions: i2 } = await async function(e4, t2) {
      if (!e4)
        throw new Error("You must supply an options object to rollup");
      const s3 = Go(e4.plugins), { options: i3, unsetOptions: n4 } = function(e5) {
        var t3, s4, i4;
        const n5 = new Set(), r3 = (t3 = e5.context) !== null && t3 !== void 0 ? t3 : "undefined", a3 = Zo(e5), o2 = e5.strictDeprecations || false, h3 = { acorn: Jo(e5), acornInjectPlugins: eh(e5), cache: th(e5), context: r3, experimentalCacheExpiry: (s4 = e5.experimentalCacheExpiry) !== null && s4 !== void 0 ? s4 : 10, external: sh(e5.external), inlineDynamicImports: ih(e5, a3, o2), input: nh(e5), makeAbsoluteExternalsRelative: (i4 = e5.makeAbsoluteExternalsRelative) === null || i4 === void 0 || i4, manualChunks: rh(e5, a3, o2), maxParallelFileReads: ah(e5), moduleContext: oh(e5, r3), onwarn: a3, perf: e5.perf || false, plugins: Go(e5.plugins), preserveEntrySignatures: hh(e5, n5), preserveModules: lh(e5, a3, o2), preserveSymlinks: e5.preserveSymlinks || false, shimMissingExports: e5.shimMissingExports || false, strictDeprecations: o2, treeshake: ch(e5, a3, o2) };
        return qo(e5, [...Object.keys(h3), "watch"], "input options", h3.onwarn, /^(output)$/), { options: h3, unsetOptions: n5 };
      }(await s3.reduce(function(e5) {
        return async (t3, s4) => s4.options && await s4.options.call({ meta: { rollupVersion: "2.63.0", watchMode: e5 } }, await t3) || t3;
      }(t2), Promise.resolve(e4)));
      return Rh(i3.plugins, "at position "), { options: i3, unsetOptions: n4 };
    }(e3, t !== null);
    Wi(s2);
    const n3 = new Uo(s2, t), r2 = e3.cache !== false;
    delete s2.cache, delete e3.cache, Vi("BUILD", 1);
    try {
      await n3.pluginDriver.hookParallel("buildStart", [s2]), await n3.build();
    } catch (e4) {
      const t2 = Object.keys(n3.watchFiles);
      throw t2.length > 0 && (e4.watchFiles = t2), await n3.pluginDriver.hookParallel("buildEnd", [e4]), await n3.pluginDriver.hookParallel("closeBundle", []), e4;
    }
    await n3.pluginDriver.hookParallel("buildEnd", []), Bi("BUILD", 1);
    const a2 = { cache: r2 ? n3.getCache() : void 0, async close() {
      a2.closed || (a2.closed = true, await n3.pluginDriver.hookParallel("closeBundle", []));
    }, closed: false, generate: async (e4) => a2.closed ? Hs(ri()) : Mh(false, s2, i2, e4, n3), watchFiles: Object.keys(n3.watchFiles), write: async (e4) => a2.closed ? Hs(ri()) : Mh(true, s2, i2, e4, n3) };
    s2.perf && (a2.getTimings = Oi);
    return a2;
  }(e2, null);
}
function Rh(e2, t) {
  for (let s2 = 0; s2 < e2.length; s2++) {
    const i2 = e2[s2];
    i2.name || (i2.name = `${t}${s2 + 1}`);
  }
}
async function Mh(e2, t, s2, i2, n3) {
  const { options: r2, outputPluginDriver: a2, unsetOptions: o2 } = function(e3, t2, s3, i3) {
    if (!e3)
      throw new Error("You must supply an options object");
    const n4 = Go(e3.plugins);
    Rh(n4, "at output position ");
    const r3 = t2.createOutputPluginDriver(n4);
    return __spreadProps2(__spreadValues2({}, Dh(s3, i3, e3, r3)), { outputPluginDriver: r3 });
  }(i2, n3.pluginDriver, t, s2), h3 = new Vr(r2, o2, t, a2, n3), l2 = await h3.generate(e2);
  if (e2) {
    if (!r2.dir && !r2.file)
      return Hs({ code: "MISSING_OPTION", message: 'You must specify "output.file" or "output.dir" for the build.' });
    await Promise.all(Object.values(l2).map((e3) => function(e4, t2) {
      const s3 = $(t2.dir || I(t2.file), e4.fileName);
      let i3, n4;
      if (e4.type === "asset")
        n4 = e4.source;
      else if (n4 = e4.code, t2.sourcemap && e4.map) {
        let r3;
        t2.sourcemap === "inline" ? r3 = e4.map.toUrl() : (r3 = `${C2(e4.fileName)}.map`, i3 = wo(`${s3}.map`, e4.map.toString())), t2.sourcemap !== "hidden" && (n4 += `//# sourceMappingURL=${r3}
`);
      }
      return Promise.all([wo(s3, n4), i3]);
    }(e3, r2))), await a2.hookParallel("writeBundle", [r2, l2]);
  }
  return c2 = l2, { output: Object.values(c2).filter((e3) => Object.keys(e3).length > 0).sort((e3, t2) => {
    const s3 = Oh(e3), i3 = Oh(t2);
    return s3 === i3 ? 0 : s3 < i3 ? -1 : 1;
  }) };
  var c2;
}
function Dh(e2, t, s2, i2) {
  return function(e3, t2, s3) {
    var i3, n3, r2, a2, o2, h3, l2;
    const c2 = new Set(s3), u2 = e3.compact || false, d3 = mh(e3), p2 = gh(e3, t2), f2 = yh(e3, p2, t2), m3 = fh(e3, f2, t2), g2 = Eh(e3, t2), y3 = { amd: vh(e3), assetFileNames: (i3 = e3.assetFileNames) !== null && i3 !== void 0 ? i3 : "assets/[name]-[hash][extname]", banner: bh(e3, "banner"), chunkFileNames: (n3 = e3.chunkFileNames) !== null && n3 !== void 0 ? n3 : "[name]-[hash].js", compact: u2, dir: Sh(e3, m3), dynamicImportFunction: Ah(e3, t2), entryFileNames: Ph(e3, c2), esModule: (r2 = e3.esModule) === null || r2 === void 0 || r2, exports: kh(e3, c2), extend: e3.extend || false, externalLiveBindings: (a2 = e3.externalLiveBindings) === null || a2 === void 0 || a2, file: m3, footer: bh(e3, "footer"), format: d3, freeze: (o2 = e3.freeze) === null || o2 === void 0 || o2, generatedCode: wh(e3, g2), globals: e3.globals || {}, hoistTransitiveImports: (h3 = e3.hoistTransitiveImports) === null || h3 === void 0 || h3, indent: Ch(e3, u2), inlineDynamicImports: p2, interop: Nh(e3, t2), intro: bh(e3, "intro"), manualChunks: _h(e3, p2, f2, t2), minifyInternalExports: $h(e3, d3, u2), name: e3.name, namespaceToStringTag: e3.namespaceToStringTag || false, noConflict: e3.noConflict || false, outro: bh(e3, "outro"), paths: e3.paths || {}, plugins: Go(e3.plugins), preferConst: g2, preserveModules: f2, preserveModulesRoot: xh(e3), sanitizeFileName: typeof e3.sanitizeFileName == "function" ? e3.sanitizeFileName : e3.sanitizeFileName === false ? (e4) => e4 : ph, sourcemap: e3.sourcemap || false, sourcemapExcludeSources: e3.sourcemapExcludeSources || false, sourcemapFile: e3.sourcemapFile, sourcemapPathTransform: e3.sourcemapPathTransform, strict: (l2 = e3.strict) === null || l2 === void 0 || l2, systemNullSetters: e3.systemNullSetters || false, validate: e3.validate || false };
    return qo(e3, Object.keys(y3), "output options", t2.onwarn), { options: y3, unsetOptions: c2 };
  }(i2.hookReduceArg0Sync("outputOptions", [s2.output || s2], (e3, t2) => t2 || e3, (e3) => {
    const t2 = () => e3.error({ code: Ks.CANNOT_EMIT_FROM_OPTIONS_HOOK, message: 'Cannot emit files or set asset sources in the "outputOptions" hook, use the "renderStart" hook instead.' });
    return __spreadProps2(__spreadValues2({}, e3), { emitFile: t2, setAssetSource: t2 });
  }), e2, t);
}
function Oh(e2) {
  return e2.type === "asset" ? Lh.ASSET : e2.isEntry ? Lh.ENTRY_CHUNK : Lh.SECONDARY_CHUNK;
}
function Vh(e2) {
  return e2;
}
var e2, t, s2, i2, a, o, h2, l, d2, m2, g, y2, E2, x, v, b, S, A2, R, M, D, L, O, V, B2, F, z, W, j, U, G, H, q, K, X, Y, Q2, Z, ne, re, ae, de, pe, fe, ge, ye, ve, Se, Ae, Pe, Ce, Ne, Be, Fe, ze, We, je, Ue, Ge, He, qe, Ke, Ye, Qe, Ze, Je, it, rt, at, ot, ht, lt, ct, ut, dt, pt, ft, mt, gt, xt, vt, bt, St, At, Pt, kt, wt, Ct, It, Nt, _t, $t, Tt, Rt, Mt, Dt, Lt, Ot, Vt, Bt, Ft, zt, Wt, jt, Ut, Gt, Ht, qt, Kt, Xt, Qt, Zt, Jt, es, ts, ss, is, ns, rs, as, os2, hs, ls, cs, us, ds, ps, fs2, ys, Es, xs, vs, bs, Ss, As, Ps, ks, ws, Cs, Is, Ns, _s, $s, Ts, Rs, Ms, Ds, Ls, Os, Vs, Bs, Fs, zs, Ws, Us, Ks, hi, li, ci, ui, di, pi, fi, mi, gi, yi, Ei, xi, vi, bi, Si, Ai, Pi, ki, wi, Ci, Ni, _i, $i, Ti, Ri, Vi, Bi, Fi, Ui, Hi, Ji, sn, rn, hn, ln, cn, un, pn, fn, gn, yn, En, bn, Sn, Pn, kn, wn, $n, Tn, Rn, Dn, Ln, Fn, zn, Wn, jn, Un, Gn, Hn, qn, Kn, Xn, Yn, Qn, Zn, Jn, er, sr, ir, nr, rr, lr, cr, ur, xr, br, Pr, Ir, _r, $r, Mr, Lr, Or, Vr, zr, Wr, jr, Ur, Gr, Hr, qr, Kr, Xr, Yr, ea, sa, ia, na, aa, oa, ha, ca, ua, da, pa, fa, ga, Ea, xa, ba, Sa, ka, wa, Ca, Ia, _a, $a, Ta, Ra, Ma, Da, Va, Ba, Fa, za, Wa, Ua, Ga, Ha, qa, Ka, Xa, Qa, Za, Ja, eo, to, so, io, no, ro, oo, ho, xo, vo, Ao, Po, ko, wo, Co, _o, $o, Mo, Vo, zo, jo, Uo, Ho, Ko, Xo, Yo, Qo, Zo, Jo, eh, th, sh, ih, nh, rh, ah, oh, hh, lh, ch, uh, dh, fh, mh, gh, yh, Eh, xh, vh, bh, Sh, Ah, Ph, wh, Ch, Ih, Nh, _h, $h, Lh;
var init_rollup_browser = __esm({
  "node_modules/rollup/dist/es/rollup.browser.js"() {
    for (e2 = "2.63.0", t = {}, s2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", i2 = 0; i2 < s2.length; i2++)
      t[s2.charCodeAt(i2)] = i2;
    a = function e(t) {
      this.bits = t instanceof e ? t.bits.slice() : [];
    };
    a.prototype.add = function(e2) {
      this.bits[e2 >> 5] |= 1 << (31 & e2);
    }, a.prototype.has = function(e2) {
      return !!(this.bits[e2 >> 5] & 1 << (31 & e2));
    };
    o = function(e2, t, s2) {
      this.start = e2, this.end = t, this.original = s2, this.intro = "", this.outro = "", this.content = s2, this.storeName = false, this.edited = false, Object.defineProperties(this, { previous: { writable: true, value: null }, next: { writable: true, value: null } });
    };
    o.prototype.appendLeft = function(e2) {
      this.outro += e2;
    }, o.prototype.appendRight = function(e2) {
      this.intro = this.intro + e2;
    }, o.prototype.clone = function() {
      var e2 = new o(this.start, this.end, this.original);
      return e2.intro = this.intro, e2.outro = this.outro, e2.content = this.content, e2.storeName = this.storeName, e2.edited = this.edited, e2;
    }, o.prototype.contains = function(e2) {
      return this.start < e2 && e2 < this.end;
    }, o.prototype.eachNext = function(e2) {
      for (var t = this; t; )
        e2(t), t = t.next;
    }, o.prototype.eachPrevious = function(e2) {
      for (var t = this; t; )
        e2(t), t = t.previous;
    }, o.prototype.edit = function(e2, t, s2) {
      return this.content = e2, s2 || (this.intro = "", this.outro = ""), this.storeName = t, this.edited = true, this;
    }, o.prototype.prependLeft = function(e2) {
      this.outro = e2 + this.outro;
    }, o.prototype.prependRight = function(e2) {
      this.intro = e2 + this.intro;
    }, o.prototype.split = function(e2) {
      var t = e2 - this.start, s2 = this.original.slice(0, t), i2 = this.original.slice(t);
      this.original = s2;
      var n3 = new o(e2, this.end, i2);
      return n3.outro = this.outro, this.outro = "", this.end = e2, this.edited ? (n3.edit("", false), this.content = "") : this.content = s2, n3.next = this.next, n3.next && (n3.next.previous = n3), n3.previous = this, this.next = n3, n3;
    }, o.prototype.toString = function() {
      return this.intro + this.content + this.outro;
    }, o.prototype.trimEnd = function(e2) {
      if (this.outro = this.outro.replace(e2, ""), this.outro.length)
        return true;
      var t = this.content.replace(e2, "");
      return t.length ? (t !== this.content && this.split(this.start + t.length).edit("", void 0, true), true) : (this.edit("", void 0, true), this.intro = this.intro.replace(e2, ""), !!this.intro.length || void 0);
    }, o.prototype.trimStart = function(e2) {
      if (this.intro = this.intro.replace(e2, ""), this.intro.length)
        return true;
      var t = this.content.replace(e2, "");
      return t.length ? (t !== this.content && (this.split(this.end - t.length), this.edit("", void 0, true)), true) : (this.edit("", void 0, true), this.outro = this.outro.replace(e2, ""), !!this.outro.length || void 0);
    };
    h2 = function() {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
    typeof window != "undefined" && typeof window.btoa == "function" ? h2 = function(e2) {
      return window.btoa(unescape(encodeURIComponent(e2)));
    } : typeof Buffer == "function" && (h2 = function(e2) {
      return Buffer.from(e2, "utf-8").toString("base64");
    });
    l = function(e2) {
      this.version = 3, this.file = e2.file, this.sources = e2.sources, this.sourcesContent = e2.sourcesContent, this.names = e2.names, this.mappings = function(e3) {
        for (var t = 0, s2 = 0, i2 = 0, n3 = 0, a2 = "", o2 = 0; o2 < e3.length; o2++) {
          var h3 = e3[o2];
          if (o2 > 0 && (a2 += ";"), h3.length !== 0) {
            for (var l2 = 0, c2 = [], u2 = 0, d3 = h3; u2 < d3.length; u2++) {
              var p2 = d3[u2], f2 = r(p2[0] - l2);
              l2 = p2[0], p2.length > 1 && (f2 += r(p2[1] - t) + r(p2[2] - s2) + r(p2[3] - i2), t = p2[1], s2 = p2[2], i2 = p2[3]), p2.length === 5 && (f2 += r(p2[4] - n3), n3 = p2[4]), c2.push(f2);
            }
            a2 += c2.join(",");
          }
        }
        return a2;
      }(e2.mappings);
    };
    l.prototype.toString = function() {
      return JSON.stringify(this);
    }, l.prototype.toUrl = function() {
      return "data:application/json;charset=utf-8;base64," + h2(this.toString());
    };
    d2 = Object.prototype.toString;
    m2 = function(e2) {
      this.hires = e2, this.generatedCodeLine = 0, this.generatedCodeColumn = 0, this.raw = [], this.rawSegments = this.raw[this.generatedCodeLine] = [], this.pending = null;
    };
    m2.prototype.addEdit = function(e2, t, s2, i2) {
      if (t.length) {
        var n3 = [this.generatedCodeColumn, e2, s2.line, s2.column];
        i2 >= 0 && n3.push(i2), this.rawSegments.push(n3);
      } else
        this.pending && this.rawSegments.push(this.pending);
      this.advance(t), this.pending = null;
    }, m2.prototype.addUneditedChunk = function(e2, t, s2, i2, n3) {
      for (var r2 = t.start, a2 = true; r2 < t.end; )
        (this.hires || a2 || n3.has(r2)) && this.rawSegments.push([this.generatedCodeColumn, e2, i2.line, i2.column]), s2[r2] === "\n" ? (i2.line += 1, i2.column = 0, this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, a2 = true) : (i2.column += 1, this.generatedCodeColumn += 1, a2 = false), r2 += 1;
      this.pending = null;
    }, m2.prototype.advance = function(e2) {
      if (e2) {
        var t = e2.split("\n");
        if (t.length > 1) {
          for (var s2 = 0; s2 < t.length - 1; s2++)
            this.generatedCodeLine++, this.raw[this.generatedCodeLine] = this.rawSegments = [];
          this.generatedCodeColumn = 0;
        }
        this.generatedCodeColumn += t[t.length - 1].length;
      }
    };
    g = "\n";
    y2 = { insertLeft: false, insertRight: false, storeName: false };
    E2 = function(e2, t) {
      t === void 0 && (t = {});
      var s2 = new o(0, e2.length, e2);
      Object.defineProperties(this, { original: { writable: true, value: e2 }, outro: { writable: true, value: "" }, intro: { writable: true, value: "" }, firstChunk: { writable: true, value: s2 }, lastChunk: { writable: true, value: s2 }, lastSearchedChunk: { writable: true, value: s2 }, byStart: { writable: true, value: {} }, byEnd: { writable: true, value: {} }, filename: { writable: true, value: t.filename }, indentExclusionRanges: { writable: true, value: t.indentExclusionRanges }, sourcemapLocations: { writable: true, value: new a() }, storedNames: { writable: true, value: {} }, indentStr: { writable: true, value: c(e2) } }), this.byStart[0] = s2, this.byEnd[e2.length] = s2;
    };
    E2.prototype.addSourcemapLocation = function(e2) {
      this.sourcemapLocations.add(e2);
    }, E2.prototype.append = function(e2) {
      if (typeof e2 != "string")
        throw new TypeError("outro content must be a string");
      return this.outro += e2, this;
    }, E2.prototype.appendLeft = function(e2, t) {
      if (typeof t != "string")
        throw new TypeError("inserted content must be a string");
      this._split(e2);
      var s2 = this.byEnd[e2];
      return s2 ? s2.appendLeft(t) : this.intro += t, this;
    }, E2.prototype.appendRight = function(e2, t) {
      if (typeof t != "string")
        throw new TypeError("inserted content must be a string");
      this._split(e2);
      var s2 = this.byStart[e2];
      return s2 ? s2.appendRight(t) : this.outro += t, this;
    }, E2.prototype.clone = function() {
      for (var e2 = new E2(this.original, { filename: this.filename }), t = this.firstChunk, s2 = e2.firstChunk = e2.lastSearchedChunk = t.clone(); t; ) {
        e2.byStart[s2.start] = s2, e2.byEnd[s2.end] = s2;
        var i2 = t.next, n3 = i2 && i2.clone();
        n3 && (s2.next = n3, n3.previous = s2, s2 = n3), t = i2;
      }
      return e2.lastChunk = s2, this.indentExclusionRanges && (e2.indentExclusionRanges = this.indentExclusionRanges.slice()), e2.sourcemapLocations = new a(this.sourcemapLocations), e2.intro = this.intro, e2.outro = this.outro, e2;
    }, E2.prototype.generateDecodedMap = function(e2) {
      var t = this;
      e2 = e2 || {};
      var s2 = Object.keys(this.storedNames), i2 = new m2(e2.hires), n3 = f(this.original);
      return this.intro && i2.advance(this.intro), this.firstChunk.eachNext(function(e3) {
        var r2 = n3(e3.start);
        e3.intro.length && i2.advance(e3.intro), e3.edited ? i2.addEdit(0, e3.content, r2, e3.storeName ? s2.indexOf(e3.original) : -1) : i2.addUneditedChunk(0, e3, t.original, r2, t.sourcemapLocations), e3.outro.length && i2.advance(e3.outro);
      }), { file: e2.file ? e2.file.split(/[/\\]/).pop() : null, sources: [e2.source ? u(e2.file || "", e2.source) : null], sourcesContent: e2.includeContent ? [this.original] : [null], names: s2, mappings: i2.raw };
    }, E2.prototype.generateMap = function(e2) {
      return new l(this.generateDecodedMap(e2));
    }, E2.prototype.getIndentString = function() {
      return this.indentStr === null ? "	" : this.indentStr;
    }, E2.prototype.indent = function(e2, t) {
      var s2 = /^[^\r\n]/gm;
      if (p(e2) && (t = e2, e2 = void 0), (e2 = e2 !== void 0 ? e2 : this.indentStr || "	") === "")
        return this;
      var i2 = {};
      (t = t || {}).exclude && (typeof t.exclude[0] == "number" ? [t.exclude] : t.exclude).forEach(function(e3) {
        for (var t2 = e3[0]; t2 < e3[1]; t2 += 1)
          i2[t2] = true;
      });
      var n3 = t.indentStart !== false, r2 = function(t2) {
        return n3 ? "" + e2 + t2 : (n3 = true, t2);
      };
      this.intro = this.intro.replace(s2, r2);
      for (var a2 = 0, o2 = this.firstChunk; o2; ) {
        var h3 = o2.end;
        if (o2.edited)
          i2[a2] || (o2.content = o2.content.replace(s2, r2), o2.content.length && (n3 = o2.content[o2.content.length - 1] === "\n"));
        else
          for (a2 = o2.start; a2 < h3; ) {
            if (!i2[a2]) {
              var l2 = this.original[a2];
              l2 === "\n" ? n3 = true : l2 !== "\r" && n3 && (n3 = false, a2 === o2.start ? o2.prependRight(e2) : (this._splitChunk(o2, a2), (o2 = o2.next).prependRight(e2)));
            }
            a2 += 1;
          }
        a2 = o2.end, o2 = o2.next;
      }
      return this.outro = this.outro.replace(s2, r2), this;
    }, E2.prototype.insert = function() {
      throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
    }, E2.prototype.insertLeft = function(e2, t) {
      return y2.insertLeft || (console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"), y2.insertLeft = true), this.appendLeft(e2, t);
    }, E2.prototype.insertRight = function(e2, t) {
      return y2.insertRight || (console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"), y2.insertRight = true), this.prependRight(e2, t);
    }, E2.prototype.move = function(e2, t, s2) {
      if (s2 >= e2 && s2 <= t)
        throw new Error("Cannot move a selection inside itself");
      this._split(e2), this._split(t), this._split(s2);
      var i2 = this.byStart[e2], n3 = this.byEnd[t], r2 = i2.previous, a2 = n3.next, o2 = this.byStart[s2];
      if (!o2 && n3 === this.lastChunk)
        return this;
      var h3 = o2 ? o2.previous : this.lastChunk;
      return r2 && (r2.next = a2), a2 && (a2.previous = r2), h3 && (h3.next = i2), o2 && (o2.previous = n3), i2.previous || (this.firstChunk = n3.next), n3.next || (this.lastChunk = i2.previous, this.lastChunk.next = null), i2.previous = h3, n3.next = o2 || null, h3 || (this.firstChunk = i2), o2 || (this.lastChunk = n3), this;
    }, E2.prototype.overwrite = function(e2, t, s2, i2) {
      if (typeof s2 != "string")
        throw new TypeError("replacement content must be a string");
      for (; e2 < 0; )
        e2 += this.original.length;
      for (; t < 0; )
        t += this.original.length;
      if (t > this.original.length)
        throw new Error("end is out of bounds");
      if (e2 === t)
        throw new Error("Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead");
      this._split(e2), this._split(t), i2 === true && (y2.storeName || (console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"), y2.storeName = true), i2 = { storeName: true });
      var n3 = i2 !== void 0 && i2.storeName, r2 = i2 !== void 0 && i2.contentOnly;
      if (n3) {
        var a2 = this.original.slice(e2, t);
        this.storedNames[a2] = true;
      }
      var h3 = this.byStart[e2], l2 = this.byEnd[t];
      if (h3) {
        if (t > h3.end && h3.next !== this.byStart[h3.end])
          throw new Error("Cannot overwrite across a split point");
        if (h3.edit(s2, n3, r2), h3 !== l2) {
          for (var c2 = h3.next; c2 !== l2; )
            c2.edit("", false), c2 = c2.next;
          c2.edit("", false);
        }
      } else {
        var u2 = new o(e2, t, "").edit(s2, n3);
        l2.next = u2, u2.previous = l2;
      }
      return this;
    }, E2.prototype.prepend = function(e2) {
      if (typeof e2 != "string")
        throw new TypeError("outro content must be a string");
      return this.intro = e2 + this.intro, this;
    }, E2.prototype.prependLeft = function(e2, t) {
      if (typeof t != "string")
        throw new TypeError("inserted content must be a string");
      this._split(e2);
      var s2 = this.byEnd[e2];
      return s2 ? s2.prependLeft(t) : this.intro = t + this.intro, this;
    }, E2.prototype.prependRight = function(e2, t) {
      if (typeof t != "string")
        throw new TypeError("inserted content must be a string");
      this._split(e2);
      var s2 = this.byStart[e2];
      return s2 ? s2.prependRight(t) : this.outro = t + this.outro, this;
    }, E2.prototype.remove = function(e2, t) {
      for (; e2 < 0; )
        e2 += this.original.length;
      for (; t < 0; )
        t += this.original.length;
      if (e2 === t)
        return this;
      if (e2 < 0 || t > this.original.length)
        throw new Error("Character is out of bounds");
      if (e2 > t)
        throw new Error("end must be greater than start");
      this._split(e2), this._split(t);
      for (var s2 = this.byStart[e2]; s2; )
        s2.intro = "", s2.outro = "", s2.edit(""), s2 = t > s2.end ? this.byStart[s2.end] : null;
      return this;
    }, E2.prototype.lastChar = function() {
      if (this.outro.length)
        return this.outro[this.outro.length - 1];
      var e2 = this.lastChunk;
      do {
        if (e2.outro.length)
          return e2.outro[e2.outro.length - 1];
        if (e2.content.length)
          return e2.content[e2.content.length - 1];
        if (e2.intro.length)
          return e2.intro[e2.intro.length - 1];
      } while (e2 = e2.previous);
      return this.intro.length ? this.intro[this.intro.length - 1] : "";
    }, E2.prototype.lastLine = function() {
      var e2 = this.outro.lastIndexOf(g);
      if (e2 !== -1)
        return this.outro.substr(e2 + 1);
      var t = this.outro, s2 = this.lastChunk;
      do {
        if (s2.outro.length > 0) {
          if ((e2 = s2.outro.lastIndexOf(g)) !== -1)
            return s2.outro.substr(e2 + 1) + t;
          t = s2.outro + t;
        }
        if (s2.content.length > 0) {
          if ((e2 = s2.content.lastIndexOf(g)) !== -1)
            return s2.content.substr(e2 + 1) + t;
          t = s2.content + t;
        }
        if (s2.intro.length > 0) {
          if ((e2 = s2.intro.lastIndexOf(g)) !== -1)
            return s2.intro.substr(e2 + 1) + t;
          t = s2.intro + t;
        }
      } while (s2 = s2.previous);
      return (e2 = this.intro.lastIndexOf(g)) !== -1 ? this.intro.substr(e2 + 1) + t : this.intro + t;
    }, E2.prototype.slice = function(e2, t) {
      for (e2 === void 0 && (e2 = 0), t === void 0 && (t = this.original.length); e2 < 0; )
        e2 += this.original.length;
      for (; t < 0; )
        t += this.original.length;
      for (var s2 = "", i2 = this.firstChunk; i2 && (i2.start > e2 || i2.end <= e2); ) {
        if (i2.start < t && i2.end >= t)
          return s2;
        i2 = i2.next;
      }
      if (i2 && i2.edited && i2.start !== e2)
        throw new Error("Cannot use replaced character " + e2 + " as slice start anchor.");
      for (var n3 = i2; i2; ) {
        !i2.intro || n3 === i2 && i2.start !== e2 || (s2 += i2.intro);
        var r2 = i2.start < t && i2.end >= t;
        if (r2 && i2.edited && i2.end !== t)
          throw new Error("Cannot use replaced character " + t + " as slice end anchor.");
        var a2 = n3 === i2 ? e2 - i2.start : 0, o2 = r2 ? i2.content.length + t - i2.end : i2.content.length;
        if (s2 += i2.content.slice(a2, o2), !i2.outro || r2 && i2.end !== t || (s2 += i2.outro), r2)
          break;
        i2 = i2.next;
      }
      return s2;
    }, E2.prototype.snip = function(e2, t) {
      var s2 = this.clone();
      return s2.remove(0, e2), s2.remove(t, s2.original.length), s2;
    }, E2.prototype._split = function(e2) {
      if (!this.byStart[e2] && !this.byEnd[e2])
        for (var t = this.lastSearchedChunk, s2 = e2 > t.end; t; ) {
          if (t.contains(e2))
            return this._splitChunk(t, e2);
          t = s2 ? this.byStart[t.end] : this.byEnd[t.start];
        }
    }, E2.prototype._splitChunk = function(e2, t) {
      if (e2.edited && e2.content.length) {
        var s2 = f(this.original)(t);
        throw new Error("Cannot split a chunk that has already been edited (" + s2.line + ":" + s2.column + ' \u2013 "' + e2.original + '")');
      }
      var i2 = e2.split(t);
      return this.byEnd[t] = e2, this.byStart[t] = i2, this.byEnd[i2.end] = i2, e2 === this.lastChunk && (this.lastChunk = i2), this.lastSearchedChunk = e2, true;
    }, E2.prototype.toString = function() {
      for (var e2 = this.intro, t = this.firstChunk; t; )
        e2 += t.toString(), t = t.next;
      return e2 + this.outro;
    }, E2.prototype.isEmpty = function() {
      var e2 = this.firstChunk;
      do {
        if (e2.intro.length && e2.intro.trim() || e2.content.length && e2.content.trim() || e2.outro.length && e2.outro.trim())
          return false;
      } while (e2 = e2.next);
      return true;
    }, E2.prototype.length = function() {
      var e2 = this.firstChunk, t = 0;
      do {
        t += e2.intro.length + e2.content.length + e2.outro.length;
      } while (e2 = e2.next);
      return t;
    }, E2.prototype.trimLines = function() {
      return this.trim("[\\r\\n]");
    }, E2.prototype.trim = function(e2) {
      return this.trimStart(e2).trimEnd(e2);
    }, E2.prototype.trimEndAborted = function(e2) {
      var t = new RegExp((e2 || "\\s") + "+$");
      if (this.outro = this.outro.replace(t, ""), this.outro.length)
        return true;
      var s2 = this.lastChunk;
      do {
        var i2 = s2.end, n3 = s2.trimEnd(t);
        if (s2.end !== i2 && (this.lastChunk === s2 && (this.lastChunk = s2.next), this.byEnd[s2.end] = s2, this.byStart[s2.next.start] = s2.next, this.byEnd[s2.next.end] = s2.next), n3)
          return true;
        s2 = s2.previous;
      } while (s2);
      return false;
    }, E2.prototype.trimEnd = function(e2) {
      return this.trimEndAborted(e2), this;
    }, E2.prototype.trimStartAborted = function(e2) {
      var t = new RegExp("^" + (e2 || "\\s") + "+");
      if (this.intro = this.intro.replace(t, ""), this.intro.length)
        return true;
      var s2 = this.firstChunk;
      do {
        var i2 = s2.end, n3 = s2.trimStart(t);
        if (s2.end !== i2 && (s2 === this.lastChunk && (this.lastChunk = s2.next), this.byEnd[s2.end] = s2, this.byStart[s2.next.start] = s2.next, this.byEnd[s2.next.end] = s2.next), n3)
          return true;
        s2 = s2.next;
      } while (s2);
      return false;
    }, E2.prototype.trimStart = function(e2) {
      return this.trimStartAborted(e2), this;
    };
    x = Object.prototype.hasOwnProperty;
    v = function(e2) {
      e2 === void 0 && (e2 = {}), this.intro = e2.intro || "", this.separator = e2.separator !== void 0 ? e2.separator : "\n", this.sources = [], this.uniqueSources = [], this.uniqueSourceIndexByFilename = {};
    };
    v.prototype.addSource = function(e2) {
      if (e2 instanceof E2)
        return this.addSource({ content: e2, filename: e2.filename, separator: this.separator });
      if (!p(e2) || !e2.content)
        throw new Error("bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`");
      if (["filename", "indentExclusionRanges", "separator"].forEach(function(t2) {
        x.call(e2, t2) || (e2[t2] = e2.content[t2]);
      }), e2.separator === void 0 && (e2.separator = this.separator), e2.filename)
        if (x.call(this.uniqueSourceIndexByFilename, e2.filename)) {
          var t = this.uniqueSources[this.uniqueSourceIndexByFilename[e2.filename]];
          if (e2.content.original !== t.content)
            throw new Error("Illegal source: same filename (" + e2.filename + "), different contents");
        } else
          this.uniqueSourceIndexByFilename[e2.filename] = this.uniqueSources.length, this.uniqueSources.push({ filename: e2.filename, content: e2.content.original });
      return this.sources.push(e2), this;
    }, v.prototype.append = function(e2, t) {
      return this.addSource({ content: new E2(e2), separator: t && t.separator || "" }), this;
    }, v.prototype.clone = function() {
      var e2 = new v({ intro: this.intro, separator: this.separator });
      return this.sources.forEach(function(t) {
        e2.addSource({ filename: t.filename, content: t.content.clone(), separator: t.separator });
      }), e2;
    }, v.prototype.generateDecodedMap = function(e2) {
      var t = this;
      e2 === void 0 && (e2 = {});
      var s2 = [];
      this.sources.forEach(function(e3) {
        Object.keys(e3.content.storedNames).forEach(function(e4) {
          ~s2.indexOf(e4) || s2.push(e4);
        });
      });
      var i2 = new m2(e2.hires);
      return this.intro && i2.advance(this.intro), this.sources.forEach(function(e3, n3) {
        n3 > 0 && i2.advance(t.separator);
        var r2 = e3.filename ? t.uniqueSourceIndexByFilename[e3.filename] : -1, a2 = e3.content, o2 = f(a2.original);
        a2.intro && i2.advance(a2.intro), a2.firstChunk.eachNext(function(t2) {
          var n4 = o2(t2.start);
          t2.intro.length && i2.advance(t2.intro), e3.filename ? t2.edited ? i2.addEdit(r2, t2.content, n4, t2.storeName ? s2.indexOf(t2.original) : -1) : i2.addUneditedChunk(r2, t2, a2.original, n4, a2.sourcemapLocations) : i2.advance(t2.content), t2.outro.length && i2.advance(t2.outro);
        }), a2.outro && i2.advance(a2.outro);
      }), { file: e2.file ? e2.file.split(/[/\\]/).pop() : null, sources: this.uniqueSources.map(function(t2) {
        return e2.file ? u(e2.file, t2.filename) : t2.filename;
      }), sourcesContent: this.uniqueSources.map(function(t2) {
        return e2.includeContent ? t2.content : null;
      }), names: s2, mappings: i2.raw };
    }, v.prototype.generateMap = function(e2) {
      return new l(this.generateDecodedMap(e2));
    }, v.prototype.getIndentString = function() {
      var e2 = {};
      return this.sources.forEach(function(t) {
        var s2 = t.content.indentStr;
        s2 !== null && (e2[s2] || (e2[s2] = 0), e2[s2] += 1);
      }), Object.keys(e2).sort(function(t, s2) {
        return e2[t] - e2[s2];
      })[0] || "	";
    }, v.prototype.indent = function(e2) {
      var t = this;
      if (arguments.length || (e2 = this.getIndentString()), e2 === "")
        return this;
      var s2 = !this.intro || this.intro.slice(-1) === "\n";
      return this.sources.forEach(function(i2, n3) {
        var r2 = i2.separator !== void 0 ? i2.separator : t.separator, a2 = s2 || n3 > 0 && /\r?\n$/.test(r2);
        i2.content.indent(e2, { exclude: i2.indentExclusionRanges, indentStart: a2 }), s2 = i2.content.lastChar() === "\n";
      }), this.intro && (this.intro = e2 + this.intro.replace(/^[^\n]/gm, function(t2, s3) {
        return s3 > 0 ? e2 + t2 : t2;
      })), this;
    }, v.prototype.prepend = function(e2) {
      return this.intro = e2 + this.intro, this;
    }, v.prototype.toString = function() {
      var e2 = this, t = this.sources.map(function(t2, s2) {
        var i2 = t2.separator !== void 0 ? t2.separator : e2.separator;
        return (s2 > 0 ? i2 : "") + t2.content.toString();
      }).join("");
      return this.intro + t;
    }, v.prototype.isEmpty = function() {
      return (!this.intro.length || !this.intro.trim()) && !this.sources.some(function(e2) {
        return !e2.content.isEmpty();
      });
    }, v.prototype.length = function() {
      return this.sources.reduce(function(e2, t) {
        return e2 + t.content.length();
      }, this.intro.length);
    }, v.prototype.trimLines = function() {
      return this.trim("[\\r\\n]");
    }, v.prototype.trim = function(e2) {
      return this.trimStart(e2).trimEnd(e2);
    }, v.prototype.trimStart = function(e2) {
      var t = new RegExp("^" + (e2 || "\\s") + "+");
      if (this.intro = this.intro.replace(t, ""), !this.intro) {
        var s2, i2 = 0;
        do {
          if (!(s2 = this.sources[i2++]))
            break;
        } while (!s2.content.trimStartAborted(e2));
      }
      return this;
    }, v.prototype.trimEnd = function(e2) {
      var t, s2 = new RegExp((e2 || "\\s") + "+$"), i2 = this.sources.length - 1;
      do {
        if (!(t = this.sources[i2--])) {
          this.intro = this.intro.replace(s2, "");
          break;
        }
      } while (!t.content.trimEndAborted(e2));
      return this;
    };
    b = E2;
    S = /^(?:\/|(?:[A-Za-z]:)?[\\|/])/;
    A2 = /^\.?\.\//;
    R = Symbol("Unknown Key");
    M = Symbol("Unknown Integer");
    D = [];
    L = [R];
    O = [M];
    V = Symbol("Entities");
    B2 = class {
      constructor() {
        this.entityPaths = Object.create(null, { [V]: { value: new Set() } });
      }
      trackEntityAtPathAndGetIfTracked(e2, t) {
        const s2 = this.getEntities(e2);
        return !!s2.has(t) || (s2.add(t), false);
      }
      withTrackedEntityAtPath(e2, t, s2, i2) {
        const n3 = this.getEntities(e2);
        if (n3.has(t))
          return i2;
        n3.add(t);
        const r2 = s2();
        return n3.delete(t), r2;
      }
      getEntities(e2) {
        let t = this.entityPaths;
        for (const s2 of e2)
          t = t[s2] = t[s2] || Object.create(null, { [V]: { value: new Set() } });
        return t[V];
      }
    };
    F = new B2();
    z = class {
      constructor() {
        this.entityPaths = Object.create(null, { [V]: { value: new Map() } });
      }
      trackEntityAtPathAndGetIfTracked(e2, t, s2) {
        let i2 = this.entityPaths;
        for (const t2 of e2)
          i2 = i2[t2] = i2[t2] || Object.create(null, { [V]: { value: new Map() } });
        const n3 = T(i2[V], t, () => new Set());
        return !!n3.has(s2) || (n3.add(s2), false);
      }
    };
    W = Symbol("Unknown Value");
    j = class {
      constructor() {
        this.included = false;
      }
      deoptimizePath(e2) {
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        s2.deoptimizePath(L);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return W;
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return U;
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return true;
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return true;
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return true;
      }
      include(e2, t) {
        this.included = true;
      }
      includeCallArguments(e2, t) {
        for (const s2 of t)
          s2.include(e2, false);
      }
    };
    U = new class extends j {
    }();
    G = class extends j {
      constructor(e2) {
        super(), this.name = e2, this.alwaysRendered = false, this.initReached = false, this.isId = false, this.isReassigned = false, this.kind = null, this.renderBaseName = null, this.renderName = null;
      }
      addReference(e2) {
      }
      getBaseVariableName() {
        return this.renderBaseName || this.renderName || this.name;
      }
      getName(e2) {
        const t = this.renderName || this.name;
        return this.renderBaseName ? `${this.renderBaseName}${e2(t)}` : t;
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return e2.length > 0;
      }
      include() {
        this.included = true;
      }
      markCalledFromTryStatement() {
      }
      setRenderNames(e2, t) {
        this.renderBaseName = e2, this.renderName = t;
      }
    };
    H = class extends G {
      constructor(e2, t) {
        super(t), this.referenced = false, this.module = e2, this.isNamespace = t === "*";
      }
      addReference(e2) {
        this.referenced = true, this.name !== "default" && this.name !== "*" || this.module.suggestName(e2.name);
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > (this.isNamespace ? 1 : 0);
      }
      include() {
        this.included || (this.included = true, this.module.used = true);
      }
    };
    q = Object.freeze(Object.create(null));
    K = Object.freeze({});
    X = Object.freeze([]);
    Y = new Set(["await", "break", "case", "catch", "class", "const", "continue", "debugger", "default", "delete", "do", "else", "enum", "eval", "export", "extends", "false", "finally", "for", "function", "if", "implements", "import", "in", "instanceof", "interface", "let", "NaN", "new", "null", "package", "private", "protected", "public", "return", "static", "super", "switch", "this", "throw", "true", "try", "typeof", "undefined", "var", "void", "while", "with", "yield"]);
    Q2 = /[^$_a-zA-Z0-9]/g;
    Z = (e2) => /\d/.test(e2[0]);
    ne = class {
      constructor(e2, t, s2, i2, n3) {
        this.options = e2, this.id = t, this.renormalizeRenderPath = n3, this.declarations = Object.create(null), this.defaultVariableName = "", this.dynamicImporters = [], this.execIndex = 1 / 0, this.exportedVariables = new Map(), this.importers = [], this.mostCommonSuggestion = 0, this.nameSuggestions = Object.create(null), this.namespaceVariableName = "", this.reexported = false, this.renderPath = void 0, this.used = false, this.variableName = "", this.suggestedVariableName = J(t.split(/[\\/]/).pop());
        const { importers: r2, dynamicImporters: a2 } = this;
        this.info = { ast: null, code: null, dynamicallyImportedIds: X, get dynamicImporters() {
          return a2.sort();
        }, hasModuleSideEffects: s2, id: t, implicitlyLoadedAfterOneOf: X, implicitlyLoadedBefore: X, importedIds: X, get importers() {
          return r2.sort();
        }, isEntry: false, isExternal: true, isIncluded: null, meta: i2, syntheticNamedExports: false };
      }
      getVariableForExportName(e2) {
        let t = this.declarations[e2];
        return t || (this.declarations[e2] = t = new H(this, e2), this.exportedVariables.set(t, e2), t);
      }
      setRenderPath(e2, t) {
        return this.renderPath = typeof e2.paths == "function" ? e2.paths(this.id) : e2.paths[this.id], this.renderPath || (this.renderPath = this.renormalizeRenderPath ? w2(_(t, this.id)) : this.id), this.renderPath;
      }
      suggestName(e2) {
        this.nameSuggestions[e2] || (this.nameSuggestions[e2] = 0), this.nameSuggestions[e2] += 1, this.nameSuggestions[e2] > this.mostCommonSuggestion && (this.mostCommonSuggestion = this.nameSuggestions[e2], this.suggestedVariableName = e2);
      }
      warnUnusedImports() {
        const e2 = Object.keys(this.declarations).filter((e3) => {
          if (e3 === "*")
            return false;
          const t2 = this.declarations[e3];
          return !t2.included && !this.reexported && !t2.referenced;
        });
        if (e2.length === 0)
          return;
        const t = new Set();
        for (const s3 of e2) {
          const { importers: e3 } = this.declarations[s3].module;
          for (const s4 of e3)
            t.add(s4);
        }
        const s2 = [...t];
        this.options.onwarn({ code: "UNUSED_EXTERNAL_IMPORT", message: `${ee(e2, ["is", "are"])} imported from external module "${this.id}" but never used in ${ee(s2.map((e3) => se(e3)))}.`, names: e2, source: this.id, sources: s2 });
      }
    };
    re = { ArrayPattern(e2, t) {
      for (const s2 of t.elements)
        s2 && re[s2.type](e2, s2);
    }, AssignmentPattern(e2, t) {
      re[t.left.type](e2, t.left);
    }, Identifier(e2, t) {
      e2.push(t.name);
    }, MemberExpression() {
    }, ObjectPattern(e2, t) {
      for (const s2 of t.properties)
        s2.type === "RestElement" ? re.RestElement(e2, s2) : re[s2.value.type](e2, s2.value);
    }, RestElement(e2, t) {
      re[t.argument.type](e2, t.argument);
    } };
    ae = function(e2) {
      const t = [];
      return re[e2.type](t, e2), t;
    };
    new Set("break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl".split(" ")).add("");
    de = {};
    de.Program = de.BlockStatement = de.StaticBlock = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.body; i2 < n3.length; i2 += 1) {
        s2(n3[i2], t, "Statement");
      }
    }, de.Statement = ce, de.EmptyStatement = ue, de.ExpressionStatement = de.ParenthesizedExpression = de.ChainExpression = function(e2, t, s2) {
      return s2(e2.expression, t, "Expression");
    }, de.IfStatement = function(e2, t, s2) {
      s2(e2.test, t, "Expression"), s2(e2.consequent, t, "Statement"), e2.alternate && s2(e2.alternate, t, "Statement");
    }, de.LabeledStatement = function(e2, t, s2) {
      return s2(e2.body, t, "Statement");
    }, de.BreakStatement = de.ContinueStatement = ue, de.WithStatement = function(e2, t, s2) {
      s2(e2.object, t, "Expression"), s2(e2.body, t, "Statement");
    }, de.SwitchStatement = function(e2, t, s2) {
      s2(e2.discriminant, t, "Expression");
      for (var i2 = 0, n3 = e2.cases; i2 < n3.length; i2 += 1) {
        var r2 = n3[i2];
        r2.test && s2(r2.test, t, "Expression");
        for (var a2 = 0, o2 = r2.consequent; a2 < o2.length; a2 += 1) {
          s2(o2[a2], t, "Statement");
        }
      }
    }, de.SwitchCase = function(e2, t, s2) {
      e2.test && s2(e2.test, t, "Expression");
      for (var i2 = 0, n3 = e2.consequent; i2 < n3.length; i2 += 1) {
        s2(n3[i2], t, "Statement");
      }
    }, de.ReturnStatement = de.YieldExpression = de.AwaitExpression = function(e2, t, s2) {
      e2.argument && s2(e2.argument, t, "Expression");
    }, de.ThrowStatement = de.SpreadElement = function(e2, t, s2) {
      return s2(e2.argument, t, "Expression");
    }, de.TryStatement = function(e2, t, s2) {
      s2(e2.block, t, "Statement"), e2.handler && s2(e2.handler, t), e2.finalizer && s2(e2.finalizer, t, "Statement");
    }, de.CatchClause = function(e2, t, s2) {
      e2.param && s2(e2.param, t, "Pattern"), s2(e2.body, t, "Statement");
    }, de.WhileStatement = de.DoWhileStatement = function(e2, t, s2) {
      s2(e2.test, t, "Expression"), s2(e2.body, t, "Statement");
    }, de.ForStatement = function(e2, t, s2) {
      e2.init && s2(e2.init, t, "ForInit"), e2.test && s2(e2.test, t, "Expression"), e2.update && s2(e2.update, t, "Expression"), s2(e2.body, t, "Statement");
    }, de.ForInStatement = de.ForOfStatement = function(e2, t, s2) {
      s2(e2.left, t, "ForInit"), s2(e2.right, t, "Expression"), s2(e2.body, t, "Statement");
    }, de.ForInit = function(e2, t, s2) {
      e2.type === "VariableDeclaration" ? s2(e2, t) : s2(e2, t, "Expression");
    }, de.DebuggerStatement = ue, de.FunctionDeclaration = function(e2, t, s2) {
      return s2(e2, t, "Function");
    }, de.VariableDeclaration = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.declarations; i2 < n3.length; i2 += 1) {
        s2(n3[i2], t);
      }
    }, de.VariableDeclarator = function(e2, t, s2) {
      s2(e2.id, t, "Pattern"), e2.init && s2(e2.init, t, "Expression");
    }, de.Function = function(e2, t, s2) {
      e2.id && s2(e2.id, t, "Pattern");
      for (var i2 = 0, n3 = e2.params; i2 < n3.length; i2 += 1) {
        s2(n3[i2], t, "Pattern");
      }
      s2(e2.body, t, e2.expression ? "Expression" : "Statement");
    }, de.Pattern = function(e2, t, s2) {
      e2.type === "Identifier" ? s2(e2, t, "VariablePattern") : e2.type === "MemberExpression" ? s2(e2, t, "MemberPattern") : s2(e2, t);
    }, de.VariablePattern = ue, de.MemberPattern = ce, de.RestElement = function(e2, t, s2) {
      return s2(e2.argument, t, "Pattern");
    }, de.ArrayPattern = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.elements; i2 < n3.length; i2 += 1) {
        var r2 = n3[i2];
        r2 && s2(r2, t, "Pattern");
      }
    }, de.ObjectPattern = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.properties; i2 < n3.length; i2 += 1) {
        var r2 = n3[i2];
        r2.type === "Property" ? (r2.computed && s2(r2.key, t, "Expression"), s2(r2.value, t, "Pattern")) : r2.type === "RestElement" && s2(r2.argument, t, "Pattern");
      }
    }, de.Expression = ce, de.ThisExpression = de.Super = de.MetaProperty = ue, de.ArrayExpression = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.elements; i2 < n3.length; i2 += 1) {
        var r2 = n3[i2];
        r2 && s2(r2, t, "Expression");
      }
    }, de.ObjectExpression = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.properties; i2 < n3.length; i2 += 1) {
        s2(n3[i2], t);
      }
    }, de.FunctionExpression = de.ArrowFunctionExpression = de.FunctionDeclaration, de.SequenceExpression = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.expressions; i2 < n3.length; i2 += 1) {
        s2(n3[i2], t, "Expression");
      }
    }, de.TemplateLiteral = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.quasis; i2 < n3.length; i2 += 1) {
        s2(n3[i2], t);
      }
      for (var r2 = 0, a2 = e2.expressions; r2 < a2.length; r2 += 1) {
        s2(a2[r2], t, "Expression");
      }
    }, de.TemplateElement = ue, de.UnaryExpression = de.UpdateExpression = function(e2, t, s2) {
      s2(e2.argument, t, "Expression");
    }, de.BinaryExpression = de.LogicalExpression = function(e2, t, s2) {
      s2(e2.left, t, "Expression"), s2(e2.right, t, "Expression");
    }, de.AssignmentExpression = de.AssignmentPattern = function(e2, t, s2) {
      s2(e2.left, t, "Pattern"), s2(e2.right, t, "Expression");
    }, de.ConditionalExpression = function(e2, t, s2) {
      s2(e2.test, t, "Expression"), s2(e2.consequent, t, "Expression"), s2(e2.alternate, t, "Expression");
    }, de.NewExpression = de.CallExpression = function(e2, t, s2) {
      if (s2(e2.callee, t, "Expression"), e2.arguments)
        for (var i2 = 0, n3 = e2.arguments; i2 < n3.length; i2 += 1) {
          s2(n3[i2], t, "Expression");
        }
    }, de.MemberExpression = function(e2, t, s2) {
      s2(e2.object, t, "Expression"), e2.computed && s2(e2.property, t, "Expression");
    }, de.ExportNamedDeclaration = de.ExportDefaultDeclaration = function(e2, t, s2) {
      e2.declaration && s2(e2.declaration, t, e2.type === "ExportNamedDeclaration" || e2.declaration.id ? "Statement" : "Expression"), e2.source && s2(e2.source, t, "Expression");
    }, de.ExportAllDeclaration = function(e2, t, s2) {
      e2.exported && s2(e2.exported, t), s2(e2.source, t, "Expression");
    }, de.ImportDeclaration = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.specifiers; i2 < n3.length; i2 += 1) {
        s2(n3[i2], t);
      }
      s2(e2.source, t, "Expression");
    }, de.ImportExpression = function(e2, t, s2) {
      s2(e2.source, t, "Expression");
    }, de.ImportSpecifier = de.ImportDefaultSpecifier = de.ImportNamespaceSpecifier = de.Identifier = de.PrivateIdentifier = de.Literal = ue, de.TaggedTemplateExpression = function(e2, t, s2) {
      s2(e2.tag, t, "Expression"), s2(e2.quasi, t, "Expression");
    }, de.ClassDeclaration = de.ClassExpression = function(e2, t, s2) {
      return s2(e2, t, "Class");
    }, de.Class = function(e2, t, s2) {
      e2.id && s2(e2.id, t, "Pattern"), e2.superClass && s2(e2.superClass, t, "Expression"), s2(e2.body, t);
    }, de.ClassBody = function(e2, t, s2) {
      for (var i2 = 0, n3 = e2.body; i2 < n3.length; i2 += 1) {
        s2(n3[i2], t);
      }
    }, de.MethodDefinition = de.PropertyDefinition = de.Property = function(e2, t, s2) {
      e2.computed && s2(e2.key, t, "Expression"), e2.value && s2(e2.value, t, "Expression");
    };
    pe = "sourceMa";
    pe += "ppingURL";
    fe = new RegExp("^#[ \\f\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+sourceMappingURL=.+");
    de.PropertyDefinition = function(e2, t, s2) {
      e2.computed && s2(e2.key, t, "Expression"), e2.value && s2(e2.value, t, "Expression");
    };
    ge = /[^\s(]/g;
    ye = /\S/g;
    ve = /[@#]__PURE__/;
    Se = { Literal: [], Program: ["body"] };
    Ae = class extends j {
      constructor(e2, t, s2) {
        super(), this.esTreeNode = e2, this.keys = Se[e2.type] || function(e3) {
          return Se[e3.type] = Object.keys(e3).filter((t2) => typeof e3[t2] == "object" && t2.charCodeAt(0) !== 95), Se[e3.type];
        }(e2), this.parent = t, this.context = t.context, this.createScope(s2), this.parseNode(e2), this.initialise(), this.context.magicString.addSourcemapLocation(this.start), this.context.magicString.addSourcemapLocation(this.end);
      }
      addExportedVariables(e2, t) {
      }
      bind() {
        for (const e2 of this.keys) {
          const t = this[e2];
          if (t !== null)
            if (Array.isArray(t))
              for (const e3 of t)
                e3 !== null && e3.bind();
            else
              t.bind();
        }
      }
      createScope(e2) {
        this.scope = e2;
      }
      hasEffects(e2) {
        this.deoptimized === false && this.applyDeoptimizations();
        for (const t of this.keys) {
          const s2 = this[t];
          if (s2 !== null) {
            if (Array.isArray(s2)) {
              for (const t2 of s2)
                if (t2 !== null && t2.hasEffects(e2))
                  return true;
            } else if (s2.hasEffects(e2))
              return true;
          }
        }
        return false;
      }
      include(e2, t) {
        this.deoptimized === false && this.applyDeoptimizations(), this.included = true;
        for (const s2 of this.keys) {
          const i2 = this[s2];
          if (i2 !== null)
            if (Array.isArray(i2))
              for (const s3 of i2)
                s3 !== null && s3.include(e2, t);
            else
              i2.include(e2, t);
        }
      }
      includeAsSingleStatement(e2, t) {
        this.include(e2, t);
      }
      initialise() {
      }
      insertSemicolon(e2) {
        e2.original[this.end - 1] !== ";" && e2.appendLeft(this.end, ";");
      }
      parseNode(e2) {
        for (const [t, s2] of Object.entries(e2))
          if (!this.hasOwnProperty(t))
            if (t.charCodeAt(0) === 95) {
              if (t === "_rollupAnnotations")
                this.annotations = s2;
              else if (t === "_rollupRemoved")
                for (const { start: e3, end: t2 } of s2)
                  this.context.magicString.remove(e3, t2);
            } else if (typeof s2 != "object" || s2 === null)
              this[t] = s2;
            else if (Array.isArray(s2)) {
              this[t] = [];
              for (const e3 of s2)
                this[t].push(e3 === null ? null : new (this.context.getNodeConstructor(e3.type))(e3, this, this.scope));
            } else
              this[t] = new (this.context.getNodeConstructor(s2.type))(s2, this, this.scope);
      }
      render(e2, t) {
        for (const s2 of this.keys) {
          const i2 = this[s2];
          if (i2 !== null)
            if (Array.isArray(i2))
              for (const s3 of i2)
                s3 !== null && s3.render(e2, t);
            else
              i2.render(e2, t);
        }
      }
      shouldBeIncluded(e2) {
        return this.included || !e2.brokenFlow && this.hasEffects(le());
      }
      applyDeoptimizations() {
      }
    };
    Pe = class extends Ae {
      hasEffects() {
        return false;
      }
      initialise() {
        this.context.addExport(this);
      }
      render(e2, t, s2) {
        e2.remove(s2.start, s2.end);
      }
    };
    Pe.prototype.needsBoundaries = true;
    Ce = { isNoStatement: true };
    Ne = /\S/g;
    Be = Symbol("Value Properties");
    Fe = { pure: true };
    ze = { pure: false };
    We = { __proto__: null, [Be]: ze };
    je = { __proto__: null, [Be]: Fe };
    Ue = { __proto__: null, [Be]: ze, prototype: We };
    Ge = { __proto__: null, [Be]: Fe, prototype: We };
    He = { __proto__: null, [Be]: Fe, from: je, of: je, prototype: We };
    qe = { __proto__: null, [Be]: Fe, supportedLocalesOf: Ge };
    Ke = { global: We, globalThis: We, self: We, window: We, __proto__: null, [Be]: ze, Array: { __proto__: null, [Be]: ze, from: We, isArray: je, of: je, prototype: We }, ArrayBuffer: { __proto__: null, [Be]: Fe, isView: je, prototype: We }, Atomics: We, BigInt: Ue, BigInt64Array: Ue, BigUint64Array: Ue, Boolean: Ge, constructor: Ue, DataView: Ge, Date: { __proto__: null, [Be]: Fe, now: je, parse: je, prototype: We, UTC: je }, decodeURI: je, decodeURIComponent: je, encodeURI: je, encodeURIComponent: je, Error: Ge, escape: je, eval: We, EvalError: Ge, Float32Array: He, Float64Array: He, Function: Ue, hasOwnProperty: We, Infinity: We, Int16Array: He, Int32Array: He, Int8Array: He, isFinite: je, isNaN: je, isPrototypeOf: We, JSON: We, Map: Ge, Math: { __proto__: null, [Be]: ze, abs: je, acos: je, acosh: je, asin: je, asinh: je, atan: je, atan2: je, atanh: je, cbrt: je, ceil: je, clz32: je, cos: je, cosh: je, exp: je, expm1: je, floor: je, fround: je, hypot: je, imul: je, log: je, log10: je, log1p: je, log2: je, max: je, min: je, pow: je, random: je, round: je, sign: je, sin: je, sinh: je, sqrt: je, tan: je, tanh: je, trunc: je }, NaN: We, Number: { __proto__: null, [Be]: Fe, isFinite: je, isInteger: je, isNaN: je, isSafeInteger: je, parseFloat: je, parseInt: je, prototype: We }, Object: { __proto__: null, [Be]: Fe, create: je, getOwnPropertyDescriptor: je, getOwnPropertyNames: je, getOwnPropertySymbols: je, getPrototypeOf: je, is: je, isExtensible: je, isFrozen: je, isSealed: je, keys: je, prototype: We }, parseFloat: je, parseInt: je, Promise: { __proto__: null, [Be]: ze, all: We, prototype: We, race: We, reject: We, resolve: We }, propertyIsEnumerable: We, Proxy: We, RangeError: Ge, ReferenceError: Ge, Reflect: We, RegExp: Ge, Set: Ge, SharedArrayBuffer: Ue, String: { __proto__: null, [Be]: Fe, fromCharCode: je, fromCodePoint: je, prototype: We, raw: je }, Symbol: { __proto__: null, [Be]: Fe, for: je, keyFor: je, prototype: We }, SyntaxError: Ge, toLocaleString: We, toString: We, TypeError: Ge, Uint16Array: He, Uint32Array: He, Uint8Array: He, Uint8ClampedArray: He, unescape: je, URIError: Ge, valueOf: We, WeakMap: Ge, WeakSet: Ge, clearInterval: Ue, clearTimeout: Ue, console: We, Intl: { __proto__: null, [Be]: ze, Collator: qe, DateTimeFormat: qe, ListFormat: qe, NumberFormat: qe, PluralRules: qe, RelativeTimeFormat: qe }, setInterval: Ue, setTimeout: Ue, TextDecoder: Ue, TextEncoder: Ue, URL: Ue, URLSearchParams: Ue, AbortController: Ue, AbortSignal: Ue, addEventListener: We, alert: We, AnalyserNode: Ue, Animation: Ue, AnimationEvent: Ue, applicationCache: We, ApplicationCache: Ue, ApplicationCacheErrorEvent: Ue, atob: We, Attr: Ue, Audio: Ue, AudioBuffer: Ue, AudioBufferSourceNode: Ue, AudioContext: Ue, AudioDestinationNode: Ue, AudioListener: Ue, AudioNode: Ue, AudioParam: Ue, AudioProcessingEvent: Ue, AudioScheduledSourceNode: Ue, AudioWorkletNode: Ue, BarProp: Ue, BaseAudioContext: Ue, BatteryManager: Ue, BeforeUnloadEvent: Ue, BiquadFilterNode: Ue, Blob: Ue, BlobEvent: Ue, blur: We, BroadcastChannel: Ue, btoa: We, ByteLengthQueuingStrategy: Ue, Cache: Ue, caches: We, CacheStorage: Ue, cancelAnimationFrame: We, cancelIdleCallback: We, CanvasCaptureMediaStreamTrack: Ue, CanvasGradient: Ue, CanvasPattern: Ue, CanvasRenderingContext2D: Ue, ChannelMergerNode: Ue, ChannelSplitterNode: Ue, CharacterData: Ue, clientInformation: We, ClipboardEvent: Ue, close: We, closed: We, CloseEvent: Ue, Comment: Ue, CompositionEvent: Ue, confirm: We, ConstantSourceNode: Ue, ConvolverNode: Ue, CountQueuingStrategy: Ue, createImageBitmap: We, Credential: Ue, CredentialsContainer: Ue, crypto: We, Crypto: Ue, CryptoKey: Ue, CSS: Ue, CSSConditionRule: Ue, CSSFontFaceRule: Ue, CSSGroupingRule: Ue, CSSImportRule: Ue, CSSKeyframeRule: Ue, CSSKeyframesRule: Ue, CSSMediaRule: Ue, CSSNamespaceRule: Ue, CSSPageRule: Ue, CSSRule: Ue, CSSRuleList: Ue, CSSStyleDeclaration: Ue, CSSStyleRule: Ue, CSSStyleSheet: Ue, CSSSupportsRule: Ue, CustomElementRegistry: Ue, customElements: We, CustomEvent: Ue, DataTransfer: Ue, DataTransferItem: Ue, DataTransferItemList: Ue, defaultstatus: We, defaultStatus: We, DelayNode: Ue, DeviceMotionEvent: Ue, DeviceOrientationEvent: Ue, devicePixelRatio: We, dispatchEvent: We, document: We, Document: Ue, DocumentFragment: Ue, DocumentType: Ue, DOMError: Ue, DOMException: Ue, DOMImplementation: Ue, DOMMatrix: Ue, DOMMatrixReadOnly: Ue, DOMParser: Ue, DOMPoint: Ue, DOMPointReadOnly: Ue, DOMQuad: Ue, DOMRect: Ue, DOMRectReadOnly: Ue, DOMStringList: Ue, DOMStringMap: Ue, DOMTokenList: Ue, DragEvent: Ue, DynamicsCompressorNode: Ue, Element: Ue, ErrorEvent: Ue, Event: Ue, EventSource: Ue, EventTarget: Ue, external: We, fetch: We, File: Ue, FileList: Ue, FileReader: Ue, find: We, focus: We, FocusEvent: Ue, FontFace: Ue, FontFaceSetLoadEvent: Ue, FormData: Ue, frames: We, GainNode: Ue, Gamepad: Ue, GamepadButton: Ue, GamepadEvent: Ue, getComputedStyle: We, getSelection: We, HashChangeEvent: Ue, Headers: Ue, history: We, History: Ue, HTMLAllCollection: Ue, HTMLAnchorElement: Ue, HTMLAreaElement: Ue, HTMLAudioElement: Ue, HTMLBaseElement: Ue, HTMLBodyElement: Ue, HTMLBRElement: Ue, HTMLButtonElement: Ue, HTMLCanvasElement: Ue, HTMLCollection: Ue, HTMLContentElement: Ue, HTMLDataElement: Ue, HTMLDataListElement: Ue, HTMLDetailsElement: Ue, HTMLDialogElement: Ue, HTMLDirectoryElement: Ue, HTMLDivElement: Ue, HTMLDListElement: Ue, HTMLDocument: Ue, HTMLElement: Ue, HTMLEmbedElement: Ue, HTMLFieldSetElement: Ue, HTMLFontElement: Ue, HTMLFormControlsCollection: Ue, HTMLFormElement: Ue, HTMLFrameElement: Ue, HTMLFrameSetElement: Ue, HTMLHeadElement: Ue, HTMLHeadingElement: Ue, HTMLHRElement: Ue, HTMLHtmlElement: Ue, HTMLIFrameElement: Ue, HTMLImageElement: Ue, HTMLInputElement: Ue, HTMLLabelElement: Ue, HTMLLegendElement: Ue, HTMLLIElement: Ue, HTMLLinkElement: Ue, HTMLMapElement: Ue, HTMLMarqueeElement: Ue, HTMLMediaElement: Ue, HTMLMenuElement: Ue, HTMLMetaElement: Ue, HTMLMeterElement: Ue, HTMLModElement: Ue, HTMLObjectElement: Ue, HTMLOListElement: Ue, HTMLOptGroupElement: Ue, HTMLOptionElement: Ue, HTMLOptionsCollection: Ue, HTMLOutputElement: Ue, HTMLParagraphElement: Ue, HTMLParamElement: Ue, HTMLPictureElement: Ue, HTMLPreElement: Ue, HTMLProgressElement: Ue, HTMLQuoteElement: Ue, HTMLScriptElement: Ue, HTMLSelectElement: Ue, HTMLShadowElement: Ue, HTMLSlotElement: Ue, HTMLSourceElement: Ue, HTMLSpanElement: Ue, HTMLStyleElement: Ue, HTMLTableCaptionElement: Ue, HTMLTableCellElement: Ue, HTMLTableColElement: Ue, HTMLTableElement: Ue, HTMLTableRowElement: Ue, HTMLTableSectionElement: Ue, HTMLTemplateElement: Ue, HTMLTextAreaElement: Ue, HTMLTimeElement: Ue, HTMLTitleElement: Ue, HTMLTrackElement: Ue, HTMLUListElement: Ue, HTMLUnknownElement: Ue, HTMLVideoElement: Ue, IDBCursor: Ue, IDBCursorWithValue: Ue, IDBDatabase: Ue, IDBFactory: Ue, IDBIndex: Ue, IDBKeyRange: Ue, IDBObjectStore: Ue, IDBOpenDBRequest: Ue, IDBRequest: Ue, IDBTransaction: Ue, IDBVersionChangeEvent: Ue, IdleDeadline: Ue, IIRFilterNode: Ue, Image: Ue, ImageBitmap: Ue, ImageBitmapRenderingContext: Ue, ImageCapture: Ue, ImageData: Ue, indexedDB: We, innerHeight: We, innerWidth: We, InputEvent: Ue, IntersectionObserver: Ue, IntersectionObserverEntry: Ue, isSecureContext: We, KeyboardEvent: Ue, KeyframeEffect: Ue, length: We, localStorage: We, location: We, Location: Ue, locationbar: We, matchMedia: We, MediaDeviceInfo: Ue, MediaDevices: Ue, MediaElementAudioSourceNode: Ue, MediaEncryptedEvent: Ue, MediaError: Ue, MediaKeyMessageEvent: Ue, MediaKeySession: Ue, MediaKeyStatusMap: Ue, MediaKeySystemAccess: Ue, MediaList: Ue, MediaQueryList: Ue, MediaQueryListEvent: Ue, MediaRecorder: Ue, MediaSettingsRange: Ue, MediaSource: Ue, MediaStream: Ue, MediaStreamAudioDestinationNode: Ue, MediaStreamAudioSourceNode: Ue, MediaStreamEvent: Ue, MediaStreamTrack: Ue, MediaStreamTrackEvent: Ue, menubar: We, MessageChannel: Ue, MessageEvent: Ue, MessagePort: Ue, MIDIAccess: Ue, MIDIConnectionEvent: Ue, MIDIInput: Ue, MIDIInputMap: Ue, MIDIMessageEvent: Ue, MIDIOutput: Ue, MIDIOutputMap: Ue, MIDIPort: Ue, MimeType: Ue, MimeTypeArray: Ue, MouseEvent: Ue, moveBy: We, moveTo: We, MutationEvent: Ue, MutationObserver: Ue, MutationRecord: Ue, name: We, NamedNodeMap: Ue, NavigationPreloadManager: Ue, navigator: We, Navigator: Ue, NetworkInformation: Ue, Node: Ue, NodeFilter: We, NodeIterator: Ue, NodeList: Ue, Notification: Ue, OfflineAudioCompletionEvent: Ue, OfflineAudioContext: Ue, offscreenBuffering: We, OffscreenCanvas: Ue, open: We, openDatabase: We, Option: Ue, origin: We, OscillatorNode: Ue, outerHeight: We, outerWidth: We, PageTransitionEvent: Ue, pageXOffset: We, pageYOffset: We, PannerNode: Ue, parent: We, Path2D: Ue, PaymentAddress: Ue, PaymentRequest: Ue, PaymentRequestUpdateEvent: Ue, PaymentResponse: Ue, performance: We, Performance: Ue, PerformanceEntry: Ue, PerformanceLongTaskTiming: Ue, PerformanceMark: Ue, PerformanceMeasure: Ue, PerformanceNavigation: Ue, PerformanceNavigationTiming: Ue, PerformanceObserver: Ue, PerformanceObserverEntryList: Ue, PerformancePaintTiming: Ue, PerformanceResourceTiming: Ue, PerformanceTiming: Ue, PeriodicWave: Ue, Permissions: Ue, PermissionStatus: Ue, personalbar: We, PhotoCapabilities: Ue, Plugin: Ue, PluginArray: Ue, PointerEvent: Ue, PopStateEvent: Ue, postMessage: We, Presentation: Ue, PresentationAvailability: Ue, PresentationConnection: Ue, PresentationConnectionAvailableEvent: Ue, PresentationConnectionCloseEvent: Ue, PresentationConnectionList: Ue, PresentationReceiver: Ue, PresentationRequest: Ue, print: We, ProcessingInstruction: Ue, ProgressEvent: Ue, PromiseRejectionEvent: Ue, prompt: We, PushManager: Ue, PushSubscription: Ue, PushSubscriptionOptions: Ue, queueMicrotask: We, RadioNodeList: Ue, Range: Ue, ReadableStream: Ue, RemotePlayback: Ue, removeEventListener: We, Request: Ue, requestAnimationFrame: We, requestIdleCallback: We, resizeBy: We, ResizeObserver: Ue, ResizeObserverEntry: Ue, resizeTo: We, Response: Ue, RTCCertificate: Ue, RTCDataChannel: Ue, RTCDataChannelEvent: Ue, RTCDtlsTransport: Ue, RTCIceCandidate: Ue, RTCIceTransport: Ue, RTCPeerConnection: Ue, RTCPeerConnectionIceEvent: Ue, RTCRtpReceiver: Ue, RTCRtpSender: Ue, RTCSctpTransport: Ue, RTCSessionDescription: Ue, RTCStatsReport: Ue, RTCTrackEvent: Ue, screen: We, Screen: Ue, screenLeft: We, ScreenOrientation: Ue, screenTop: We, screenX: We, screenY: We, ScriptProcessorNode: Ue, scroll: We, scrollbars: We, scrollBy: We, scrollTo: We, scrollX: We, scrollY: We, SecurityPolicyViolationEvent: Ue, Selection: Ue, ServiceWorker: Ue, ServiceWorkerContainer: Ue, ServiceWorkerRegistration: Ue, sessionStorage: We, ShadowRoot: Ue, SharedWorker: Ue, SourceBuffer: Ue, SourceBufferList: Ue, speechSynthesis: We, SpeechSynthesisEvent: Ue, SpeechSynthesisUtterance: Ue, StaticRange: Ue, status: We, statusbar: We, StereoPannerNode: Ue, stop: We, Storage: Ue, StorageEvent: Ue, StorageManager: Ue, styleMedia: We, StyleSheet: Ue, StyleSheetList: Ue, SubtleCrypto: Ue, SVGAElement: Ue, SVGAngle: Ue, SVGAnimatedAngle: Ue, SVGAnimatedBoolean: Ue, SVGAnimatedEnumeration: Ue, SVGAnimatedInteger: Ue, SVGAnimatedLength: Ue, SVGAnimatedLengthList: Ue, SVGAnimatedNumber: Ue, SVGAnimatedNumberList: Ue, SVGAnimatedPreserveAspectRatio: Ue, SVGAnimatedRect: Ue, SVGAnimatedString: Ue, SVGAnimatedTransformList: Ue, SVGAnimateElement: Ue, SVGAnimateMotionElement: Ue, SVGAnimateTransformElement: Ue, SVGAnimationElement: Ue, SVGCircleElement: Ue, SVGClipPathElement: Ue, SVGComponentTransferFunctionElement: Ue, SVGDefsElement: Ue, SVGDescElement: Ue, SVGDiscardElement: Ue, SVGElement: Ue, SVGEllipseElement: Ue, SVGFEBlendElement: Ue, SVGFEColorMatrixElement: Ue, SVGFEComponentTransferElement: Ue, SVGFECompositeElement: Ue, SVGFEConvolveMatrixElement: Ue, SVGFEDiffuseLightingElement: Ue, SVGFEDisplacementMapElement: Ue, SVGFEDistantLightElement: Ue, SVGFEDropShadowElement: Ue, SVGFEFloodElement: Ue, SVGFEFuncAElement: Ue, SVGFEFuncBElement: Ue, SVGFEFuncGElement: Ue, SVGFEFuncRElement: Ue, SVGFEGaussianBlurElement: Ue, SVGFEImageElement: Ue, SVGFEMergeElement: Ue, SVGFEMergeNodeElement: Ue, SVGFEMorphologyElement: Ue, SVGFEOffsetElement: Ue, SVGFEPointLightElement: Ue, SVGFESpecularLightingElement: Ue, SVGFESpotLightElement: Ue, SVGFETileElement: Ue, SVGFETurbulenceElement: Ue, SVGFilterElement: Ue, SVGForeignObjectElement: Ue, SVGGElement: Ue, SVGGeometryElement: Ue, SVGGradientElement: Ue, SVGGraphicsElement: Ue, SVGImageElement: Ue, SVGLength: Ue, SVGLengthList: Ue, SVGLinearGradientElement: Ue, SVGLineElement: Ue, SVGMarkerElement: Ue, SVGMaskElement: Ue, SVGMatrix: Ue, SVGMetadataElement: Ue, SVGMPathElement: Ue, SVGNumber: Ue, SVGNumberList: Ue, SVGPathElement: Ue, SVGPatternElement: Ue, SVGPoint: Ue, SVGPointList: Ue, SVGPolygonElement: Ue, SVGPolylineElement: Ue, SVGPreserveAspectRatio: Ue, SVGRadialGradientElement: Ue, SVGRect: Ue, SVGRectElement: Ue, SVGScriptElement: Ue, SVGSetElement: Ue, SVGStopElement: Ue, SVGStringList: Ue, SVGStyleElement: Ue, SVGSVGElement: Ue, SVGSwitchElement: Ue, SVGSymbolElement: Ue, SVGTextContentElement: Ue, SVGTextElement: Ue, SVGTextPathElement: Ue, SVGTextPositioningElement: Ue, SVGTitleElement: Ue, SVGTransform: Ue, SVGTransformList: Ue, SVGTSpanElement: Ue, SVGUnitTypes: Ue, SVGUseElement: Ue, SVGViewElement: Ue, TaskAttributionTiming: Ue, Text: Ue, TextEvent: Ue, TextMetrics: Ue, TextTrack: Ue, TextTrackCue: Ue, TextTrackCueList: Ue, TextTrackList: Ue, TimeRanges: Ue, toolbar: We, top: We, Touch: Ue, TouchEvent: Ue, TouchList: Ue, TrackEvent: Ue, TransitionEvent: Ue, TreeWalker: Ue, UIEvent: Ue, ValidityState: Ue, visualViewport: We, VisualViewport: Ue, VTTCue: Ue, WaveShaperNode: Ue, WebAssembly: We, WebGL2RenderingContext: Ue, WebGLActiveInfo: Ue, WebGLBuffer: Ue, WebGLContextEvent: Ue, WebGLFramebuffer: Ue, WebGLProgram: Ue, WebGLQuery: Ue, WebGLRenderbuffer: Ue, WebGLRenderingContext: Ue, WebGLSampler: Ue, WebGLShader: Ue, WebGLShaderPrecisionFormat: Ue, WebGLSync: Ue, WebGLTexture: Ue, WebGLTransformFeedback: Ue, WebGLUniformLocation: Ue, WebGLVertexArrayObject: Ue, WebSocket: Ue, WheelEvent: Ue, Window: Ue, Worker: Ue, WritableStream: Ue, XMLDocument: Ue, XMLHttpRequest: Ue, XMLHttpRequestEventTarget: Ue, XMLHttpRequestUpload: Ue, XMLSerializer: Ue, XPathEvaluator: Ue, XPathExpression: Ue, XPathResult: Ue, XSLTProcessor: Ue };
    for (const e2 of ["window", "global", "self", "globalThis"])
      Ke[e2] = Ke;
    Ye = class extends G {
      constructor() {
        super(...arguments), this.isReassigned = true;
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return !function(e3) {
          return e3.length === 1 ? e3[0] === "undefined" || Xe(e3) !== null : Xe(e3.slice(0, -1)) !== null;
        }([this.name, ...e2]);
      }
      hasEffectsWhenCalledAtPath(e2) {
        return !function(e3) {
          const t = Xe(e3);
          return t !== null && t.pure;
        }([this.name, ...e2]);
      }
    };
    Qe = class extends G {
      constructor(e2, t, s2, i2) {
        super(e2), this.calledFromTryStatement = false, this.additionalInitializers = null, this.expressionsToBeDeoptimized = [], this.declarations = t ? [t] : [], this.init = s2, this.deoptimizationTracker = i2.deoptimizationTracker, this.module = i2.module;
      }
      addDeclaration(e2, t) {
        this.declarations.push(e2);
        const s2 = this.markInitializersForDeoptimization();
        t !== null && s2.push(t);
      }
      consolidateInitializers() {
        if (this.additionalInitializers !== null) {
          for (const e2 of this.additionalInitializers)
            e2.deoptimizePath(L);
          this.additionalInitializers = null;
        }
      }
      deoptimizePath(e2) {
        var t, s2;
        if (!this.isReassigned && !this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(e2, this))
          if (e2.length === 0) {
            if (!this.isReassigned) {
              this.isReassigned = true;
              const e3 = this.expressionsToBeDeoptimized;
              this.expressionsToBeDeoptimized = [];
              for (const t2 of e3)
                t2.deoptimizeCache();
              (t = this.init) === null || t === void 0 || t.deoptimizePath(L);
            }
          } else
            (s2 = this.init) === null || s2 === void 0 || s2.deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        if (this.isReassigned || !this.init)
          return s2.deoptimizePath(L);
        i2.withTrackedEntityAtPath(t, this.init, () => this.init.deoptimizeThisOnEventAtPath(e2, t, s2, i2), void 0);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.isReassigned || !this.init ? W : t.withTrackedEntityAtPath(e2, this.init, () => (this.expressionsToBeDeoptimized.push(s2), this.init.getLiteralValueAtPath(e2, t, s2)), W);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return this.isReassigned || !this.init ? U : s2.withTrackedEntityAtPath(e2, this.init, () => (this.expressionsToBeDeoptimized.push(i2), this.init.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2)), U);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return !!this.isReassigned || this.init && !t.accessed.trackEntityAtPathAndGetIfTracked(e2, this) && this.init.hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return !!this.included || e2.length !== 0 && (!!this.isReassigned || this.init && !t.accessed.trackEntityAtPathAndGetIfTracked(e2, this) && this.init.hasEffectsWhenAssignedAtPath(e2, t));
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return !!this.isReassigned || this.init && !(t.withNew ? s2.instantiated : s2.called).trackEntityAtPathAndGetIfTracked(e2, t, this) && this.init.hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      include() {
        if (!this.included) {
          this.included = true;
          for (const e2 of this.declarations) {
            e2.included || e2.include(he(), false);
            let t = e2.parent;
            for (; !t.included && (t.included = true, t.type !== "Program"); )
              t = t.parent;
          }
        }
      }
      includeCallArguments(e2, t) {
        if (this.isReassigned || this.init && e2.includedCallArguments.has(this.init))
          for (const s2 of t)
            s2.include(e2, false);
        else
          this.init && (e2.includedCallArguments.add(this.init), this.init.includeCallArguments(e2, t), e2.includedCallArguments.delete(this.init));
      }
      markCalledFromTryStatement() {
        this.calledFromTryStatement = true;
      }
      markInitializersForDeoptimization() {
        return this.additionalInitializers === null && (this.additionalInitializers = this.init === null ? [] : [this.init], this.init = U, this.isReassigned = true), this.additionalInitializers;
      }
    };
    Ze = { __proto__: null, class: true, const: true, let: true, var: true };
    Je = class extends Ae {
      constructor() {
        super(...arguments), this.variable = null, this.deoptimized = false, this.isTDZAccess = null;
      }
      addExportedVariables(e2, t) {
        this.variable !== null && t.has(this.variable) && e2.push(this.variable);
      }
      bind() {
        this.variable === null && Ve(this, this.parent) && (this.variable = this.scope.findVariable(this.name), this.variable.addReference(this));
      }
      declare(e2, t) {
        let s2;
        const { treeshake: i2 } = this.context.options;
        switch (e2) {
          case "var":
            s2 = this.scope.addDeclaration(this, this.context, t, true), i2 && i2.correctVarValueBeforeDeclaration && s2.markInitializersForDeoptimization();
            break;
          case "function":
          case "let":
          case "const":
          case "class":
            s2 = this.scope.addDeclaration(this, this.context, t, false);
            break;
          case "parameter":
            s2 = this.scope.addParameterDeclaration(this);
            break;
          default:
            throw new Error(`Internal Error: Unexpected identifier kind ${e2}.`);
        }
        return s2.kind = e2, [this.variable = s2];
      }
      deoptimizePath(e2) {
        e2.length !== 0 || this.scope.contains(this.name) || this.disallowImportReassignment(), this.variable.deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.variable.deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.getVariableRespectingTDZ().getLiteralValueAtPath(e2, t, s2);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return this.getVariableRespectingTDZ().getReturnExpressionWhenCalledAtPath(e2, t, s2, i2);
      }
      hasEffects() {
        return this.deoptimized || this.applyDeoptimizations(), !(!this.isPossibleTDZ() || this.variable.kind === "var") || this.context.options.treeshake.unknownGlobalSideEffects && this.variable instanceof Ye && this.variable.hasEffectsWhenAccessedAtPath(D);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return this.variable !== null && this.getVariableRespectingTDZ().hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return !this.variable || (e2.length > 0 ? this.getVariableRespectingTDZ() : this.variable).hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return !this.variable || this.getVariableRespectingTDZ().hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      include() {
        this.deoptimized || this.applyDeoptimizations(), this.included || (this.included = true, this.variable !== null && this.context.includeVariableInModule(this.variable));
      }
      includeCallArguments(e2, t) {
        this.getVariableRespectingTDZ().includeCallArguments(e2, t);
      }
      isPossibleTDZ() {
        if (this.isTDZAccess !== null)
          return this.isTDZAccess;
        if (!(this.variable instanceof Qe && this.variable.kind && this.variable.kind in Ze))
          return this.isTDZAccess = false;
        let e2;
        return this.variable.declarations && this.variable.declarations.length === 1 && (e2 = this.variable.declarations[0]) && this.start < e2.start && et(this) === et(e2) ? this.isTDZAccess = true : this.variable.initReached ? this.isTDZAccess = false : this.isTDZAccess = true;
      }
      markDeclarationReached() {
        this.variable.initReached = true;
      }
      render(e2, { snippets: { getPropertyAccess: t } }, { renderedParentType: s2, isCalleeOfRenderedParent: i2, isShorthandProperty: n3 } = q) {
        if (this.variable) {
          const r2 = this.variable.getName(t);
          r2 !== this.name && (e2.overwrite(this.start, this.end, r2, { contentOnly: true, storeName: true }), n3 && e2.prependRight(this.start, `${this.name}: `)), r2 === "eval" && s2 === "CallExpression" && i2 && e2.appendRight(this.start, "0, ");
        }
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.variable !== null && this.variable instanceof Qe && (this.variable.consolidateInitializers(), this.context.requestTreeshakingPass());
      }
      disallowImportReassignment() {
        return this.context.error({ code: "ILLEGAL_REASSIGNMENT", message: `Illegal reassignment to import '${this.name}'` }, this.start);
      }
      getVariableRespectingTDZ() {
        return this.isPossibleTDZ() ? U : this.variable;
      }
    };
    it = [];
    rt = new class extends j {
      getLiteralValueAtPath() {
      }
    }();
    at = { value: { callsArgs: null, returns: U } };
    ot = new class extends j {
      getReturnExpressionWhenCalledAtPath(e2) {
        return e2.length === 1 ? Et(ft, e2[0]) : U;
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return e2.length !== 1 || yt(ft, e2[0], t, s2);
      }
    }();
    ht = { value: { callsArgs: null, returns: ot } };
    lt = new class extends j {
      getReturnExpressionWhenCalledAtPath(e2) {
        return e2.length === 1 ? Et(mt, e2[0]) : U;
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return e2.length !== 1 || yt(mt, e2[0], t, s2);
      }
    }();
    ct = { value: { callsArgs: null, returns: lt } };
    ut = new class extends j {
      getReturnExpressionWhenCalledAtPath(e2) {
        return e2.length === 1 ? Et(gt, e2[0]) : U;
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return e2.length !== 1 || yt(gt, e2[0], t, s2);
      }
    }();
    dt = { value: { callsArgs: null, returns: ut } };
    pt = nt({ hasOwnProperty: ht, isPrototypeOf: ht, propertyIsEnumerable: ht, toLocaleString: dt, toString: dt, valueOf: at });
    ft = nt({ valueOf: ht }, pt);
    mt = nt({ toExponential: dt, toFixed: dt, toLocaleString: dt, toPrecision: dt, valueOf: ct }, pt);
    gt = nt({ anchor: dt, at, big: dt, blink: dt, bold: dt, charAt: dt, charCodeAt: ct, codePointAt: at, concat: dt, endsWith: ht, fixed: dt, fontcolor: dt, fontsize: dt, includes: ht, indexOf: ct, italics: dt, lastIndexOf: ct, link: dt, localeCompare: ct, match: at, matchAll: at, normalize: dt, padEnd: dt, padStart: dt, repeat: dt, replace: { value: { callsArgs: [1], returns: ut } }, replaceAll: { value: { callsArgs: [1], returns: ut } }, search: ct, slice: dt, small: dt, split: at, startsWith: ht, strike: dt, sub: dt, substr: dt, substring: dt, sup: dt, toLocaleLowerCase: dt, toLocaleUpperCase: dt, toLowerCase: dt, toString: dt, toUpperCase: dt, trim: dt, trimEnd: dt, trimLeft: dt, trimRight: dt, trimStart: dt, valueOf: dt }, pt);
    xt = class {
      constructor() {
        this.children = [], this.variables = new Map();
      }
      addDeclaration(e2, t, s2, i2) {
        const n3 = e2.name;
        let r2 = this.variables.get(n3);
        return r2 ? r2.addDeclaration(e2, s2) : (r2 = new Qe(e2.name, e2, s2 || rt, t), this.variables.set(n3, r2)), r2;
      }
      contains(e2) {
        return this.variables.has(e2);
      }
      findVariable(e2) {
        throw new Error("Internal Error: findVariable needs to be implemented by a subclass");
      }
    };
    vt = class extends xt {
      constructor(e2) {
        super(), this.accessedOutsideVariables = new Map(), this.parent = e2, e2.children.push(this);
      }
      addAccessedDynamicImport(e2) {
        (this.accessedDynamicImports || (this.accessedDynamicImports = new Set())).add(e2), this.parent instanceof vt && this.parent.addAccessedDynamicImport(e2);
      }
      addAccessedGlobals(e2, t) {
        const s2 = t.get(this) || new Set();
        for (const t2 of e2)
          s2.add(t2);
        t.set(this, s2), this.parent instanceof vt && this.parent.addAccessedGlobals(e2, t);
      }
      addNamespaceMemberAccess(e2, t) {
        this.accessedOutsideVariables.set(e2, t), this.parent.addNamespaceMemberAccess(e2, t);
      }
      addReturnExpression(e2) {
        this.parent instanceof vt && this.parent.addReturnExpression(e2);
      }
      addUsedOutsideNames(e2, t, s2, i2) {
        for (const i3 of this.accessedOutsideVariables.values())
          i3.included && (e2.add(i3.getBaseVariableName()), t === "system" && s2.has(i3) && e2.add("exports"));
        const n3 = i2.get(this);
        if (n3)
          for (const t2 of n3)
            e2.add(t2);
      }
      contains(e2) {
        return this.variables.has(e2) || this.parent.contains(e2);
      }
      deconflict(e2, t, s2) {
        const i2 = new Set();
        if (this.addUsedOutsideNames(i2, e2, t, s2), this.accessedDynamicImports)
          for (const e3 of this.accessedDynamicImports)
            e3.inlineNamespace && i2.add(e3.inlineNamespace.getBaseVariableName());
        for (const [e3, t2] of this.variables)
          (t2.included || t2.alwaysRendered) && t2.setRenderNames(null, st(e3, i2));
        for (const i3 of this.children)
          i3.deconflict(e2, t, s2);
      }
      findLexicalBoundary() {
        return this.parent.findLexicalBoundary();
      }
      findVariable(e2) {
        const t = this.variables.get(e2) || this.accessedOutsideVariables.get(e2);
        if (t)
          return t;
        const s2 = this.parent.findVariable(e2);
        return this.accessedOutsideVariables.set(e2, s2), s2;
      }
    };
    bt = class extends Ae {
      constructor() {
        super(...arguments), this.accessedValue = null, this.accessorCallOptions = { args: it, thisParam: null, withNew: false };
      }
      deoptimizeCache() {
      }
      deoptimizePath(e2) {
        this.getAccessedValue().deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        return e2 === 0 && this.kind === "get" && t.length === 0 || e2 === 1 && this.kind === "set" && t.length === 0 ? this.value.deoptimizeThisOnEventAtPath(2, D, s2, i2) : void this.getAccessedValue().deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.getAccessedValue().getLiteralValueAtPath(e2, t, s2);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return this.getAccessedValue().getReturnExpressionWhenCalledAtPath(e2, t, s2, i2);
      }
      hasEffects(e2) {
        return this.key.hasEffects(e2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return this.kind === "get" && e2.length === 0 ? this.value.hasEffectsWhenCalledAtPath(D, this.accessorCallOptions, t) : this.getAccessedValue().hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return this.kind === "set" ? this.value.hasEffectsWhenCalledAtPath(D, this.accessorCallOptions, t) : this.getAccessedValue().hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return this.getAccessedValue().hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      getAccessedValue() {
        return this.accessedValue === null ? this.kind === "get" ? (this.accessedValue = U, this.accessedValue = this.value.getReturnExpressionWhenCalledAtPath(D, this.accessorCallOptions, F, this)) : this.accessedValue = this.value : this.accessedValue;
      }
    };
    St = class extends bt {
    };
    At = /^\d+$/;
    Pt = class extends j {
      constructor(e2, t, s2 = false) {
        if (super(), this.prototypeExpression = t, this.immutable = s2, this.allProperties = [], this.deoptimizedPaths = Object.create(null), this.expressionsToBeDeoptimizedByKey = Object.create(null), this.gettersByKey = Object.create(null), this.hasUnknownDeoptimizedInteger = false, this.hasUnknownDeoptimizedProperty = false, this.propertiesAndGettersByKey = Object.create(null), this.propertiesAndSettersByKey = Object.create(null), this.settersByKey = Object.create(null), this.thisParametersToBeDeoptimized = new Set(), this.unknownIntegerProps = [], this.unmatchableGetters = [], this.unmatchablePropertiesAndGetters = [], this.unmatchableSetters = [], Array.isArray(e2))
          this.buildPropertyMaps(e2);
        else {
          this.propertiesAndGettersByKey = this.propertiesAndSettersByKey = e2;
          for (const t2 of Object.values(e2))
            this.allProperties.push(...t2);
        }
      }
      deoptimizeAllProperties() {
        var e2;
        if (!this.hasUnknownDeoptimizedProperty) {
          this.hasUnknownDeoptimizedProperty = true;
          for (const e3 of Object.values(this.propertiesAndGettersByKey).concat(Object.values(this.settersByKey)))
            for (const t of e3)
              t.deoptimizePath(L);
          (e2 = this.prototypeExpression) === null || e2 === void 0 || e2.deoptimizePath([R, R]), this.deoptimizeCachedEntities();
        }
      }
      deoptimizeIntegerProperties() {
        if (!this.hasUnknownDeoptimizedProperty && !this.hasUnknownDeoptimizedInteger) {
          this.hasUnknownDeoptimizedInteger = true;
          for (const [e2, t] of Object.entries(this.propertiesAndGettersByKey))
            if (At.test(e2))
              for (const e3 of t)
                e3.deoptimizePath(L);
          this.deoptimizeCachedIntegerEntities();
        }
      }
      deoptimizePath(e2) {
        var t;
        if (this.hasUnknownDeoptimizedProperty || this.immutable)
          return;
        const s2 = e2[0];
        if (e2.length === 1) {
          if (typeof s2 != "string")
            return s2 === M ? this.deoptimizeIntegerProperties() : this.deoptimizeAllProperties();
          if (!this.deoptimizedPaths[s2]) {
            this.deoptimizedPaths[s2] = true;
            const e3 = this.expressionsToBeDeoptimizedByKey[s2];
            if (e3)
              for (const t2 of e3)
                t2.deoptimizeCache();
          }
        }
        const i2 = e2.length === 1 ? L : e2.slice(1);
        for (const e3 of typeof s2 == "string" ? (this.propertiesAndGettersByKey[s2] || this.unmatchablePropertiesAndGetters).concat(this.settersByKey[s2] || this.unmatchableSetters) : this.allProperties)
          e3.deoptimizePath(i2);
        (t = this.prototypeExpression) === null || t === void 0 || t.deoptimizePath(e2.length === 1 ? [R, R] : e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        var n3;
        const [r2, ...a2] = t;
        if (this.hasUnknownDeoptimizedProperty || (e2 === 2 || t.length > 1) && typeof r2 == "string" && this.deoptimizedPaths[r2])
          return void s2.deoptimizePath(L);
        const [o2, h3, l2] = e2 === 2 || t.length > 1 ? [this.propertiesAndGettersByKey, this.propertiesAndGettersByKey, this.unmatchablePropertiesAndGetters] : e2 === 0 ? [this.propertiesAndGettersByKey, this.gettersByKey, this.unmatchableGetters] : [this.propertiesAndSettersByKey, this.settersByKey, this.unmatchableSetters];
        if (typeof r2 == "string") {
          if (o2[r2]) {
            const t2 = h3[r2];
            if (t2)
              for (const n4 of t2)
                n4.deoptimizeThisOnEventAtPath(e2, a2, s2, i2);
            return void (this.immutable || this.thisParametersToBeDeoptimized.add(s2));
          }
          for (const t2 of l2)
            t2.deoptimizeThisOnEventAtPath(e2, a2, s2, i2);
          if (At.test(r2))
            for (const t2 of this.unknownIntegerProps)
              t2.deoptimizeThisOnEventAtPath(e2, a2, s2, i2);
        } else {
          for (const t2 of Object.values(h3).concat([l2]))
            for (const n4 of t2)
              n4.deoptimizeThisOnEventAtPath(e2, a2, s2, i2);
          for (const t2 of this.unknownIntegerProps)
            t2.deoptimizeThisOnEventAtPath(e2, a2, s2, i2);
        }
        this.immutable || this.thisParametersToBeDeoptimized.add(s2), (n3 = this.prototypeExpression) === null || n3 === void 0 || n3.deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        if (e2.length === 0)
          return W;
        const i2 = e2[0], n3 = this.getMemberExpressionAndTrackDeopt(i2, s2);
        return n3 ? n3.getLiteralValueAtPath(e2.slice(1), t, s2) : this.prototypeExpression ? this.prototypeExpression.getLiteralValueAtPath(e2, t, s2) : e2.length !== 1 ? W : void 0;
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        if (e2.length === 0)
          return U;
        const n3 = e2[0], r2 = this.getMemberExpressionAndTrackDeopt(n3, i2);
        return r2 ? r2.getReturnExpressionWhenCalledAtPath(e2.slice(1), t, s2, i2) : this.prototypeExpression ? this.prototypeExpression.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) : U;
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        const [s2, ...i2] = e2;
        if (e2.length > 1) {
          if (typeof s2 != "string")
            return true;
          const n3 = this.getMemberExpression(s2);
          return n3 ? n3.hasEffectsWhenAccessedAtPath(i2, t) : !this.prototypeExpression || this.prototypeExpression.hasEffectsWhenAccessedAtPath(e2, t);
        }
        if (this.hasUnknownDeoptimizedProperty)
          return true;
        if (typeof s2 == "string") {
          if (this.propertiesAndGettersByKey[s2]) {
            const e3 = this.gettersByKey[s2];
            if (e3) {
              for (const s3 of e3)
                if (s3.hasEffectsWhenAccessedAtPath(i2, t))
                  return true;
            }
            return false;
          }
          for (const e3 of this.unmatchableGetters)
            if (e3.hasEffectsWhenAccessedAtPath(i2, t))
              return true;
        } else
          for (const e3 of Object.values(this.gettersByKey).concat([this.unmatchableGetters]))
            for (const s3 of e3)
              if (s3.hasEffectsWhenAccessedAtPath(i2, t))
                return true;
        return !!this.prototypeExpression && this.prototypeExpression.hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        const [s2, ...i2] = e2;
        if (e2.length > 1) {
          if (typeof s2 != "string")
            return true;
          const n3 = this.getMemberExpression(s2);
          return n3 ? n3.hasEffectsWhenAssignedAtPath(i2, t) : !this.prototypeExpression || this.prototypeExpression.hasEffectsWhenAssignedAtPath(e2, t);
        }
        if (this.hasUnknownDeoptimizedProperty)
          return true;
        if (typeof s2 == "string") {
          if (this.propertiesAndSettersByKey[s2]) {
            const e3 = this.settersByKey[s2];
            if (e3) {
              for (const s3 of e3)
                if (s3.hasEffectsWhenAssignedAtPath(i2, t))
                  return true;
            }
            return false;
          }
          for (const e3 of this.unmatchableSetters)
            if (e3.hasEffectsWhenAssignedAtPath(i2, t))
              return true;
        }
        return !!this.prototypeExpression && this.prototypeExpression.hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        const i2 = e2[0], n3 = this.getMemberExpression(i2);
        return n3 ? n3.hasEffectsWhenCalledAtPath(e2.slice(1), t, s2) : !this.prototypeExpression || this.prototypeExpression.hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      buildPropertyMaps(e2) {
        const { allProperties: t, propertiesAndGettersByKey: s2, propertiesAndSettersByKey: i2, settersByKey: n3, gettersByKey: r2, unknownIntegerProps: a2, unmatchablePropertiesAndGetters: o2, unmatchableGetters: h3, unmatchableSetters: l2 } = this, c2 = [];
        for (let u2 = e2.length - 1; u2 >= 0; u2--) {
          const { key: d3, kind: p2, property: f2 } = e2[u2];
          if (t.push(f2), typeof d3 != "string") {
            if (d3 === M) {
              a2.push(f2);
              continue;
            }
            p2 === "set" && l2.push(f2), p2 === "get" && h3.push(f2), p2 !== "get" && c2.push(f2), p2 !== "set" && o2.push(f2);
          } else
            p2 === "set" ? i2[d3] || (i2[d3] = [f2, ...c2], n3[d3] = [f2, ...l2]) : p2 === "get" ? s2[d3] || (s2[d3] = [f2, ...o2], r2[d3] = [f2, ...h3]) : (i2[d3] || (i2[d3] = [f2, ...c2]), s2[d3] || (s2[d3] = [f2, ...o2]));
        }
      }
      deoptimizeCachedEntities() {
        for (const e2 of Object.values(this.expressionsToBeDeoptimizedByKey))
          for (const t of e2)
            t.deoptimizeCache();
        for (const e2 of this.thisParametersToBeDeoptimized)
          e2.deoptimizePath(L);
      }
      deoptimizeCachedIntegerEntities() {
        for (const [e2, t] of Object.entries(this.expressionsToBeDeoptimizedByKey))
          if (At.test(e2))
            for (const e3 of t)
              e3.deoptimizeCache();
        for (const e2 of this.thisParametersToBeDeoptimized)
          e2.deoptimizePath(O);
      }
      getMemberExpression(e2) {
        if (this.hasUnknownDeoptimizedProperty || typeof e2 != "string" || this.hasUnknownDeoptimizedInteger && At.test(e2) || this.deoptimizedPaths[e2])
          return U;
        const t = this.propertiesAndGettersByKey[e2];
        return (t == null ? void 0 : t.length) === 1 ? t[0] : t || this.unmatchablePropertiesAndGetters.length > 0 || this.unknownIntegerProps.length && At.test(e2) ? U : null;
      }
      getMemberExpressionAndTrackDeopt(e2, t) {
        if (typeof e2 != "string")
          return U;
        const s2 = this.getMemberExpression(e2);
        if (s2 !== U && !this.immutable) {
          (this.expressionsToBeDeoptimizedByKey[e2] = this.expressionsToBeDeoptimizedByKey[e2] || []).push(t);
        }
        return s2;
      }
    };
    kt = class extends j {
      constructor(e2, t) {
        super(), this.object = e2, this.key = t;
      }
      deoptimizePath(e2) {
        this.object.deoptimizePath([this.key, ...e2]);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.object.deoptimizeThisOnEventAtPath(e2, [this.key, ...t], s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.object.getLiteralValueAtPath([this.key, ...e2], t, s2);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return this.object.getReturnExpressionWhenCalledAtPath([this.key, ...e2], t, s2, i2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return e2.length !== 0 && this.object.hasEffectsWhenAccessedAtPath([this.key, ...e2], t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return this.object.hasEffectsWhenAssignedAtPath([this.key, ...e2], t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return this.object.hasEffectsWhenCalledAtPath([this.key, ...e2], t, s2);
      }
    };
    wt = class extends j {
      constructor(e2) {
        super(), this.description = e2;
      }
      deoptimizeThisOnEventAtPath(e2, t, s2) {
        e2 === 2 && t.length === 0 && this.description.mutatesSelfAsArray && s2.deoptimizePath(O);
      }
      getReturnExpressionWhenCalledAtPath(e2, t) {
        return e2.length > 0 ? U : this.description.returnsPrimitive || (this.description.returns === "self" ? t.thisParam || U : this.description.returns());
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      hasEffectsWhenAssignedAtPath(e2) {
        return e2.length > 0;
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        var i2, n3;
        if (e2.length > 0 || this.description.mutatesSelfAsArray === true && ((i2 = t.thisParam) === null || i2 === void 0 ? void 0 : i2.hasEffectsWhenAssignedAtPath(O, s2)))
          return true;
        if (!this.description.callsArgs)
          return false;
        for (const e3 of this.description.callsArgs)
          if ((n3 = t.args[e3]) === null || n3 === void 0 ? void 0 : n3.hasEffectsWhenCalledAtPath(D, { args: it, thisParam: null, withNew: false }, s2))
            return true;
        return false;
      }
      includeCallArguments(e2, t) {
        for (const s2 of t)
          s2.include(e2, false);
      }
    };
    Ct = [new wt({ callsArgs: null, mutatesSelfAsArray: false, returns: null, returnsPrimitive: ot })];
    It = [new wt({ callsArgs: null, mutatesSelfAsArray: false, returns: null, returnsPrimitive: ut })];
    Nt = [new wt({ callsArgs: null, mutatesSelfAsArray: false, returns: null, returnsPrimitive: lt })];
    _t = [new wt({ callsArgs: null, mutatesSelfAsArray: false, returns: null, returnsPrimitive: U })];
    $t = new Pt({ __proto__: null, hasOwnProperty: Ct, isPrototypeOf: Ct, propertyIsEnumerable: Ct, toLocaleString: It, toString: It, valueOf: _t }, null, true);
    Tt = class extends Ae {
      constructor() {
        super(...arguments), this.objectEntity = null;
      }
      createScope(e2) {
        this.scope = new vt(e2);
      }
      deoptimizeCache() {
        this.getObjectEntity().deoptimizeAllProperties();
      }
      deoptimizePath(e2) {
        this.getObjectEntity().deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.getObjectEntity().deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.getObjectEntity().getLiteralValueAtPath(e2, t, s2);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(e2, t, s2, i2);
      }
      hasEffects(e2) {
        var t, s2;
        const i2 = ((t = this.superClass) === null || t === void 0 ? void 0 : t.hasEffects(e2)) || this.body.hasEffects(e2);
        return (s2 = this.id) === null || s2 === void 0 || s2.markDeclarationReached(), i2 || super.hasEffects(e2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return this.getObjectEntity().hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return this.getObjectEntity().hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return e2.length === 0 ? !t.withNew || (this.classConstructor !== null ? this.classConstructor.hasEffectsWhenCalledAtPath(D, t, s2) : this.superClass !== null && this.superClass.hasEffectsWhenCalledAtPath(e2, t, s2)) : this.getObjectEntity().hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      include(e2, t) {
        var s2;
        this.included = true, (s2 = this.superClass) === null || s2 === void 0 || s2.include(e2, t), this.body.include(e2, t), this.id && (this.id.markDeclarationReached(), this.id.include());
      }
      initialise() {
        var e2;
        (e2 = this.id) === null || e2 === void 0 || e2.declare("class", this);
        for (const e3 of this.body.body)
          if (e3 instanceof St && e3.kind === "constructor")
            return void (this.classConstructor = e3);
        this.classConstructor = null;
      }
      getObjectEntity() {
        if (this.objectEntity !== null)
          return this.objectEntity;
        const e2 = [], t = [];
        for (const s2 of this.body.body) {
          const i2 = s2.static ? e2 : t, n3 = s2.kind;
          if (i2 === t && !n3)
            continue;
          const r2 = n3 === "set" || n3 === "get" ? n3 : "init";
          let a2;
          if (s2.computed) {
            const e3 = s2.key.getLiteralValueAtPath(D, F, this);
            if (e3 === W) {
              i2.push({ key: R, kind: r2, property: s2 });
              continue;
            }
            a2 = String(e3);
          } else
            a2 = s2.key instanceof Je ? s2.key.name : String(s2.key.value);
          i2.push({ key: a2, kind: r2, property: s2 });
        }
        return e2.unshift({ key: "prototype", kind: "init", property: new Pt(t, this.superClass ? new kt(this.superClass, "prototype") : $t) }), this.objectEntity = new Pt(e2, this.superClass || $t);
      }
    };
    Rt = class extends Tt {
      initialise() {
        super.initialise(), this.id !== null && (this.id.variable.isId = true);
      }
      parseNode(e2) {
        e2.id !== null && (this.id = new Je(e2.id, this, this.scope.parent)), super.parseNode(e2);
      }
      render(e2, t) {
        const { exportNamesByVariable: s2, format: i2, snippets: { _: n3 } } = t;
        i2 === "system" && this.id && s2.has(this.id.variable) && e2.appendLeft(this.end, `${n3}${De([this.id.variable], t)};`), super.render(e2, t);
      }
    };
    Mt = class extends Qe {
      constructor(e2) {
        super("arguments", null, U, e2);
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      hasEffectsWhenAssignedAtPath() {
        return true;
      }
      hasEffectsWhenCalledAtPath() {
        return true;
      }
    };
    Dt = class extends Qe {
      constructor(e2) {
        super("this", null, null, e2), this.deoptimizedPaths = [], this.entitiesToBeDeoptimized = new Set(), this.thisDeoptimizationList = [], this.thisDeoptimizations = new z();
      }
      addEntityToBeDeoptimized(e2) {
        for (const t of this.deoptimizedPaths)
          e2.deoptimizePath(t);
        for (const t of this.thisDeoptimizationList)
          this.applyThisDeoptimizationEvent(e2, t);
        this.entitiesToBeDeoptimized.add(e2);
      }
      deoptimizePath(e2) {
        if (e2.length !== 0 && !this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(e2, this)) {
          this.deoptimizedPaths.push(e2);
          for (const t of this.entitiesToBeDeoptimized)
            t.deoptimizePath(e2);
        }
      }
      deoptimizeThisOnEventAtPath(e2, t, s2) {
        const i2 = { event: e2, path: t, thisParameter: s2 };
        if (!this.thisDeoptimizations.trackEntityAtPathAndGetIfTracked(t, e2, s2)) {
          for (const e3 of this.entitiesToBeDeoptimized)
            this.applyThisDeoptimizationEvent(e3, i2);
          this.thisDeoptimizationList.push(i2);
        }
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return this.getInit(t).hasEffectsWhenAccessedAtPath(e2, t) || super.hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return this.getInit(t).hasEffectsWhenAssignedAtPath(e2, t) || super.hasEffectsWhenAssignedAtPath(e2, t);
      }
      applyThisDeoptimizationEvent(e2, { event: t, path: s2, thisParameter: i2 }) {
        e2.deoptimizeThisOnEventAtPath(t, s2, i2 === this ? e2 : i2, F);
      }
      getInit(e2) {
        return e2.replacedVariableInits.get(this) || U;
      }
    };
    Lt = class extends Ae {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        t.length > 0 && this.argument.deoptimizeThisOnEventAtPath(e2, [R, ...t], s2, i2);
      }
      hasEffects(e2) {
        this.deoptimized || this.applyDeoptimizations();
        const { propertyReadSideEffects: t } = this.context.options.treeshake;
        return this.argument.hasEffects(e2) || t && (t === "always" || this.argument.hasEffectsWhenAccessedAtPath(L, e2));
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.argument.deoptimizePath([R, R]), this.context.requestTreeshakingPass();
      }
    };
    Ot = class extends vt {
      constructor(e2, t) {
        super(e2), this.parameters = [], this.hasRest = false, this.context = t, this.hoistedBodyVarScope = new vt(this);
      }
      addParameterDeclaration(e2) {
        const t = e2.name;
        let s2 = this.hoistedBodyVarScope.variables.get(t);
        return s2 ? s2.addDeclaration(e2, null) : s2 = new Qe(t, e2, U, this.context), this.variables.set(t, s2), s2;
      }
      addParameterVariables(e2, t) {
        this.parameters = e2;
        for (const t2 of e2)
          for (const e3 of t2)
            e3.alwaysRendered = true;
        this.hasRest = t;
      }
      includeCallArguments(e2, t) {
        let s2 = false, i2 = false;
        const n3 = this.hasRest && this.parameters[this.parameters.length - 1];
        for (const s3 of t)
          if (s3 instanceof Lt) {
            for (const s4 of t)
              s4.include(e2, false);
            break;
          }
        for (let r2 = t.length - 1; r2 >= 0; r2--) {
          const a2 = this.parameters[r2] || n3, o2 = t[r2];
          if (a2)
            if (s2 = false, a2.length === 0)
              i2 = true;
            else
              for (const e3 of a2)
                e3.included && (i2 = true), e3.calledFromTryStatement && (s2 = true);
          !i2 && o2.shouldBeIncluded(e2) && (i2 = true), i2 && o2.include(e2, s2);
        }
      }
    };
    Vt = class extends Ot {
      constructor() {
        super(...arguments), this.returnExpression = null, this.returnExpressions = [];
      }
      addReturnExpression(e2) {
        this.returnExpressions.push(e2);
      }
      getReturnExpression() {
        return this.returnExpression === null && this.updateReturnExpression(), this.returnExpression;
      }
      updateReturnExpression() {
        if (this.returnExpressions.length === 1)
          this.returnExpression = this.returnExpressions[0];
        else {
          this.returnExpression = U;
          for (const e2 of this.returnExpressions)
            e2.deoptimizePath(L);
        }
      }
    };
    Bt = class extends Vt {
      constructor(e2, t) {
        super(e2, t), this.variables.set("arguments", this.argumentsVariable = new Mt(t)), this.variables.set("this", this.thisVariable = new Dt(t));
      }
      findLexicalBoundary() {
        return this;
      }
      includeCallArguments(e2, t) {
        if (super.includeCallArguments(e2, t), this.argumentsVariable.included)
          for (const s2 of t)
            s2.included || s2.include(e2, false);
      }
    };
    Ft = class extends vt {
      addDeclaration(e2, t, s2, i2) {
        if (i2) {
          const n3 = this.parent.addDeclaration(e2, t, s2, i2);
          return n3.markInitializersForDeoptimization(), n3;
        }
        return super.addDeclaration(e2, t, s2, false);
      }
    };
    zt = class extends Ae {
      initialise() {
        this.directive && this.directive !== "use strict" && this.parent.type === "Program" && this.context.warn({ code: "MODULE_LEVEL_DIRECTIVE", message: `Module level directives cause errors when bundled, '${this.directive}' was ignored.` }, this.start);
      }
      render(e2, t) {
        super.render(e2, t), this.included && this.insertSemicolon(e2);
      }
      shouldBeIncluded(e2) {
        return this.directive && this.directive !== "use strict" ? this.parent.type !== "Program" : super.shouldBeIncluded(e2);
      }
    };
    Wt = class extends Ae {
      constructor() {
        super(...arguments), this.directlyIncluded = false;
      }
      addImplicitReturnExpressionToScope() {
        const e2 = this.body[this.body.length - 1];
        e2 && e2.type === "ReturnStatement" || this.scope.addReturnExpression(U);
      }
      createScope(e2) {
        this.scope = this.parent.preventChildBlockScope ? e2 : new Ft(e2);
      }
      hasEffects(e2) {
        if (this.deoptimizeBody)
          return true;
        for (const t of this.body) {
          if (e2.brokenFlow)
            break;
          if (t.hasEffects(e2))
            return true;
        }
        return false;
      }
      include(e2, t) {
        if (!this.deoptimizeBody || !this.directlyIncluded) {
          this.included = true, this.directlyIncluded = true, this.deoptimizeBody && (t = true);
          for (const s2 of this.body)
            (t || s2.shouldBeIncluded(e2)) && s2.include(e2, t);
        }
      }
      initialise() {
        const e2 = this.body[0];
        this.deoptimizeBody = e2 instanceof zt && e2.directive === "use asm";
      }
      render(e2, t) {
        this.body.length ? Te(this.body, e2, this.start + 1, this.end - 1, t) : super.render(e2, t);
      }
    };
    jt = class extends Ae {
      constructor() {
        super(...arguments), this.deoptimized = false, this.declarationInit = null;
      }
      addExportedVariables(e2, t) {
        this.argument.addExportedVariables(e2, t);
      }
      declare(e2, t) {
        return this.declarationInit = t, this.argument.declare(e2, U);
      }
      deoptimizePath(e2) {
        e2.length === 0 && this.argument.deoptimizePath(D);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return e2.length > 0 || this.argument.hasEffectsWhenAssignedAtPath(D, t);
      }
      markDeclarationReached() {
        this.argument.markDeclarationReached();
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.declarationInit !== null && (this.declarationInit.deoptimizePath([R, R]), this.context.requestTreeshakingPass());
      }
    };
    Ut = class extends Ae {
      constructor() {
        super(...arguments), this.deoptimizedReturn = false, this.isPrototypeDeoptimized = false;
      }
      createScope(e2) {
        this.scope = new Bt(e2, this.context);
      }
      deoptimizePath(e2) {
        e2.length === 1 && (e2[0] === "prototype" ? this.isPrototypeDeoptimized = true : e2[0] === R && (this.isPrototypeDeoptimized = true, this.scope.getReturnExpression().deoptimizePath(L)));
      }
      deoptimizeThisOnEventAtPath(e2, t, s2) {
        e2 === 2 && (t.length > 0 ? s2.deoptimizePath(L) : this.scope.thisVariable.addEntityToBeDeoptimized(s2));
      }
      getReturnExpressionWhenCalledAtPath(e2) {
        return e2.length !== 0 ? U : this.async ? (this.deoptimizedReturn || (this.deoptimizedReturn = true, this.scope.getReturnExpression().deoptimizePath(L), this.context.requestTreeshakingPass()), U) : this.scope.getReturnExpression();
      }
      hasEffects() {
        return this.id !== null && this.id.hasEffects();
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return !(e2.length <= 1) && (e2.length > 2 || e2[0] !== "prototype" || this.isPrototypeDeoptimized);
      }
      hasEffectsWhenAssignedAtPath(e2) {
        return !(e2.length <= 1) && (e2.length > 2 || e2[0] !== "prototype" || this.isPrototypeDeoptimized);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        if (e2.length > 0)
          return true;
        if (this.async) {
          const { propertyReadSideEffects: e3 } = this.context.options.treeshake, t2 = this.scope.getReturnExpression();
          if (t2.hasEffectsWhenCalledAtPath(["then"], { args: it, thisParam: null, withNew: false }, s2) || e3 && (e3 === "always" || t2.hasEffectsWhenAccessedAtPath(["then"], s2)))
            return true;
        }
        for (const e3 of this.params)
          if (e3.hasEffects(s2))
            return true;
        const i2 = s2.replacedVariableInits.get(this.scope.thisVariable);
        s2.replacedVariableInits.set(this.scope.thisVariable, t.withNew ? new Pt(Object.create(null), $t) : U);
        const { brokenFlow: n3, ignore: r2 } = s2;
        return s2.ignore = { breaks: false, continues: false, labels: new Set(), returnYield: true }, !!this.body.hasEffects(s2) || (s2.brokenFlow = n3, i2 ? s2.replacedVariableInits.set(this.scope.thisVariable, i2) : s2.replacedVariableInits.delete(this.scope.thisVariable), s2.ignore = r2, false);
      }
      include(e2, t) {
        this.included = true, this.id && this.id.include();
        const s2 = this.scope.argumentsVariable.included;
        for (const i3 of this.params)
          i3 instanceof Je && !s2 || i3.include(e2, t);
        const { brokenFlow: i2 } = e2;
        e2.brokenFlow = 0, this.body.include(e2, t), e2.brokenFlow = i2;
      }
      includeCallArguments(e2, t) {
        this.scope.includeCallArguments(e2, t);
      }
      initialise() {
        this.id !== null && this.id.declare("function", this), this.scope.addParameterVariables(this.params.map((e2) => e2.declare("parameter", U)), this.params[this.params.length - 1] instanceof jt), this.body.addImplicitReturnExpressionToScope();
      }
      parseNode(e2) {
        this.body = new Wt(e2.body, this, this.scope.hoistedBodyVarScope), super.parseNode(e2);
      }
    };
    Ut.prototype.preventChildBlockScope = true;
    Gt = class extends Ut {
      initialise() {
        super.initialise(), this.id !== null && (this.id.variable.isId = true);
      }
      parseNode(e2) {
        e2.id !== null && (this.id = new Je(e2.id, this, this.scope.parent)), super.parseNode(e2);
      }
    };
    Ht = class extends Ae {
      include(e2, t) {
        super.include(e2, t), t && this.context.includeVariableInModule(this.variable);
      }
      initialise() {
        const e2 = this.declaration;
        this.declarationName = e2.id && e2.id.name || this.declaration.name, this.variable = this.scope.addExportDefaultDeclaration(this.declarationName || this.context.getModuleName(), this, this.context), this.context.addExport(this);
      }
      render(e2, t, s2) {
        const { start: i2, end: n3 } = s2, r2 = function(e3, t2) {
          return _e(e3, Ie(e3, "default", t2) + 7);
        }(e2.original, this.start);
        if (this.declaration instanceof Gt)
          this.renderNamedDeclaration(e2, r2, "function", "(", this.declaration.id === null, t);
        else if (this.declaration instanceof Rt)
          this.renderNamedDeclaration(e2, r2, "class", "{", this.declaration.id === null, t);
        else {
          if (this.variable.getOriginalVariable() !== this.variable)
            return void ke(this, e2, i2, n3);
          if (!this.variable.included)
            return e2.remove(this.start, r2), this.declaration.render(e2, t, { renderedSurroundingElement: "ExpressionStatement" }), void (e2.original[this.end - 1] !== ";" && e2.appendLeft(this.end, ";"));
          this.renderVariableDeclaration(e2, r2, t);
        }
        this.declaration.render(e2, t);
      }
      renderNamedDeclaration(e2, t, s2, i2, n3, r2) {
        const { exportNamesByVariable: a2, format: o2, snippets: { getPropertyAccess: h3 } } = r2, l2 = this.variable.getName(h3);
        e2.remove(this.start, t), n3 && e2.appendLeft(function(e3, t2, s3, i3) {
          const n4 = Ie(e3, t2, i3) + t2.length;
          e3 = e3.slice(n4, Ie(e3, s3, n4));
          const r3 = Ie(e3, "*");
          return r3 === -1 ? n4 : n4 + r3 + 1;
        }(e2.original, s2, i2, t), ` ${l2}`), o2 === "system" && this.declaration instanceof Rt && a2.has(this.variable) && e2.appendLeft(this.end, ` ${De([this.variable], r2)};`);
      }
      renderVariableDeclaration(e2, t, { format: s2, exportNamesByVariable: i2, snippets: { cnst: n3, getPropertyAccess: r2 } }) {
        const a2 = e2.original.charCodeAt(this.end - 1) === 59, o2 = s2 === "system" && i2.get(this.variable);
        o2 ? (e2.overwrite(this.start, t, `${n3} ${this.variable.getName(r2)} = exports('${o2[0]}', `), e2.appendRight(a2 ? this.end - 1 : this.end, ")" + (a2 ? "" : ";"))) : (e2.overwrite(this.start, t, `${n3} ${this.variable.getName(r2)} = `), a2 || e2.appendLeft(this.end, ";"));
      }
    };
    Ht.prototype.needsBoundaries = true;
    qt = class extends Ae {
      deoptimizeThisOnEventAtPath() {
      }
      getLiteralValueAtPath(e2) {
        return e2.length > 0 || this.value === null && this.context.code.charCodeAt(this.start) !== 110 || typeof this.value == "bigint" || this.context.code.charCodeAt(this.start) === 47 ? W : this.value;
      }
      getReturnExpressionWhenCalledAtPath(e2) {
        return e2.length !== 1 ? U : Et(this.members, e2[0]);
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return this.value === null ? e2.length > 0 : e2.length > 1;
      }
      hasEffectsWhenAssignedAtPath(e2) {
        return e2.length > 0;
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return e2.length !== 1 || yt(this.members, e2[0], t, s2);
      }
      initialise() {
        this.members = function(e2) {
          switch (typeof e2) {
            case "boolean":
              return ft;
            case "number":
              return mt;
            case "string":
              return gt;
            default:
              return Object.create(null);
          }
        }(this.value);
      }
      parseNode(e2) {
        this.value = e2.value, this.regex = e2.regex, super.parseNode(e2);
      }
      render(e2) {
        typeof this.value == "string" && e2.indentExclusionRanges.push([this.start + 1, this.end - 1]);
      }
    };
    Kt = class extends Ae {
      constructor() {
        super(...arguments), this.hasCachedEffect = false;
      }
      hasEffects(e2) {
        if (this.hasCachedEffect)
          return true;
        for (const t of this.body)
          if (t.hasEffects(e2))
            return this.hasCachedEffect = true;
        return false;
      }
      include(e2, t) {
        this.included = true;
        for (const s2 of this.body)
          (t || s2.shouldBeIncluded(e2)) && s2.include(e2, t);
      }
      render(e2, t) {
        this.body.length ? Te(this.body, e2, this.start, this.end, t) : super.render(e2, t);
      }
    };
    Xt = class extends Ae {
      getLiteralValueAtPath(e2) {
        return e2.length > 0 || this.quasis.length !== 1 ? W : this.quasis[0].value.cooked;
      }
      render(e2, t) {
        e2.indentExclusionRanges.push([this.start, this.end]), super.render(e2, t);
      }
    };
    Qt = class extends Ae {
      deoptimizePath() {
        for (const e2 of this.declarations)
          e2.deoptimizePath(D);
      }
      hasEffectsWhenAssignedAtPath() {
        return false;
      }
      include(e2, t) {
        this.included = true;
        for (const s2 of this.declarations)
          (t || s2.shouldBeIncluded(e2)) && s2.include(e2, t);
      }
      includeAsSingleStatement(e2, t) {
        this.included = true;
        for (const s2 of this.declarations)
          (t || s2.shouldBeIncluded(e2)) && (s2.include(e2, t), s2.id.include(e2, t));
      }
      initialise() {
        for (const e2 of this.declarations)
          e2.declareDeclarator(this.kind);
      }
      render(e2, t, s2 = q) {
        if (function(e3, t2) {
          for (const s3 of e3) {
            if (!s3.id.included)
              return false;
            if (s3.id.type === "Identifier") {
              if (t2.has(s3.id.variable))
                return false;
            } else {
              const e4 = [];
              if (s3.id.addExportedVariables(e4, t2), e4.length > 0)
                return false;
            }
          }
          return true;
        }(this.declarations, t.exportNamesByVariable)) {
          for (const s3 of this.declarations)
            s3.render(e2, t);
          s2.isNoStatement || e2.original.charCodeAt(this.end - 1) === 59 || e2.appendLeft(this.end, ";");
        } else
          this.renderReplacedDeclarations(e2, t, s2);
      }
      renderDeclarationEnd(e2, t, s2, i2, n3, r2, a2, o2) {
        e2.original.charCodeAt(this.end - 1) === 59 && e2.remove(this.end - 1, this.end), o2 || (t += ";"), s2 !== null ? (e2.original.charCodeAt(i2 - 1) !== 10 || e2.original.charCodeAt(this.end) !== 10 && e2.original.charCodeAt(this.end) !== 13 || (i2--, e2.original.charCodeAt(i2) === 13 && i2--), i2 === s2 + 1 ? e2.overwrite(s2, n3, t) : (e2.overwrite(s2, s2 + 1, t), e2.remove(i2, n3))) : e2.appendLeft(n3, t), r2.length > 0 && e2.appendLeft(n3, ` ${De(r2, a2)};`);
      }
      renderReplacedDeclarations(e2, t, { isNoStatement: s2 }) {
        const i2 = Re(this.declarations, e2, this.start + this.kind.length, this.end - (e2.original.charCodeAt(this.end - 1) === 59 ? 1 : 0));
        let n3, r2;
        r2 = _e(e2.original, this.start + this.kind.length);
        let a2 = r2 - 1;
        e2.remove(this.start, a2);
        let o2, h3, l2 = false, c2 = false, u2 = "";
        const d3 = [], p2 = function(e3, t2, s3) {
          var i3;
          let n4 = null;
          if (t2.format === "system") {
            for (const { node: r3 } of e3)
              r3.id instanceof Je && r3.init && s3.length === 0 && ((i3 = t2.exportNamesByVariable.get(r3.id.variable)) === null || i3 === void 0 ? void 0 : i3.length) === 1 ? (n4 = r3.id.variable, s3.push(n4)) : r3.id.addExportedVariables(s3, t2.exportNamesByVariable);
            s3.length > 1 ? n4 = null : n4 && (s3.length = 0);
          }
          return n4;
        }(i2, t, d3);
        for (const { node: s3, start: d4, separator: f2, contentEnd: m3, end: g2 } of i2)
          if (s3.included) {
            if (s3.render(e2, t), o2 = "", h3 = "", !s3.id.included || s3.id instanceof Je && Yt(s3.id.variable, t.exportNamesByVariable))
              c2 && (u2 += ";"), l2 = false;
            else {
              if (p2 && p2 === s3.id.variable) {
                const i3 = Ie(e2.original, "=", s3.id.end);
                Le(p2, _e(e2.original, i3 + 1), f2 === null ? m3 : f2, e2, t);
              }
              l2 ? u2 += "," : (c2 && (u2 += ";"), o2 += `${this.kind} `, l2 = true);
            }
            r2 === a2 + 1 ? e2.overwrite(a2, r2, u2 + o2) : (e2.overwrite(a2, a2 + 1, u2), e2.appendLeft(r2, o2)), n3 = m3, r2 = g2, c2 = true, a2 = f2, u2 = "";
          } else
            e2.remove(d4, g2);
        this.renderDeclarationEnd(e2, u2, a2, n3, r2, d3, t, s2);
      }
    };
    Zt = [{ key: M, kind: "init", property: U }, { key: "length", kind: "init", property: lt }];
    Jt = [new wt({ callsArgs: [0], mutatesSelfAsArray: "deopt-only", returns: null, returnsPrimitive: ot })];
    es = [new wt({ callsArgs: [0], mutatesSelfAsArray: "deopt-only", returns: null, returnsPrimitive: lt })];
    ts = [new wt({ callsArgs: null, mutatesSelfAsArray: true, returns: () => new Pt(Zt, cs), returnsPrimitive: null })];
    ss = [new wt({ callsArgs: null, mutatesSelfAsArray: "deopt-only", returns: () => new Pt(Zt, cs), returnsPrimitive: null })];
    is = [new wt({ callsArgs: [0], mutatesSelfAsArray: "deopt-only", returns: () => new Pt(Zt, cs), returnsPrimitive: null })];
    ns = [new wt({ callsArgs: null, mutatesSelfAsArray: true, returns: null, returnsPrimitive: lt })];
    rs = [new wt({ callsArgs: null, mutatesSelfAsArray: true, returns: null, returnsPrimitive: U })];
    as = [new wt({ callsArgs: null, mutatesSelfAsArray: "deopt-only", returns: null, returnsPrimitive: U })];
    os2 = [new wt({ callsArgs: [0], mutatesSelfAsArray: "deopt-only", returns: null, returnsPrimitive: U })];
    hs = [new wt({ callsArgs: null, mutatesSelfAsArray: true, returns: "self", returnsPrimitive: null })];
    ls = [new wt({ callsArgs: [0], mutatesSelfAsArray: true, returns: "self", returnsPrimitive: null })];
    cs = new Pt({ __proto__: null, at: as, concat: ss, copyWithin: hs, entries: ss, every: Jt, fill: hs, filter: is, find: os2, findIndex: es, findLast: os2, findLastIndex: es, flat: ss, flatMap: is, forEach: os2, includes: Ct, indexOf: Nt, join: It, keys: _t, lastIndexOf: Nt, map: is, pop: rs, push: ns, reduce: os2, reduceRight: os2, reverse: hs, shift: rs, slice: ss, some: Jt, sort: ls, splice: ts, toLocaleString: It, toString: It, unshift: ns, values: as }, $t, true);
    us = class extends Ae {
      constructor() {
        super(...arguments), this.deoptimizedReturn = false;
      }
      createScope(e2) {
        this.scope = new Vt(e2, this.context);
      }
      deoptimizePath(e2) {
        e2.length === 1 && e2[0] === R && this.scope.getReturnExpression().deoptimizePath(L);
      }
      deoptimizeThisOnEventAtPath() {
      }
      getReturnExpressionWhenCalledAtPath(e2) {
        return e2.length !== 0 ? U : this.async ? (this.deoptimizedReturn || (this.deoptimizedReturn = true, this.scope.getReturnExpression().deoptimizePath(L), this.context.requestTreeshakingPass()), U) : this.scope.getReturnExpression();
      }
      hasEffects() {
        return false;
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      hasEffectsWhenAssignedAtPath(e2) {
        return e2.length > 1;
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        if (e2.length > 0)
          return true;
        if (this.async) {
          const { propertyReadSideEffects: e3 } = this.context.options.treeshake, t2 = this.scope.getReturnExpression();
          if (t2.hasEffectsWhenCalledAtPath(["then"], { args: it, thisParam: null, withNew: false }, s2) || e3 && (e3 === "always" || t2.hasEffectsWhenAccessedAtPath(["then"], s2)))
            return true;
        }
        for (const e3 of this.params)
          if (e3.hasEffects(s2))
            return true;
        const { ignore: i2, brokenFlow: n3 } = s2;
        return s2.ignore = { breaks: false, continues: false, labels: new Set(), returnYield: true }, !!this.body.hasEffects(s2) || (s2.ignore = i2, s2.brokenFlow = n3, false);
      }
      include(e2, t) {
        this.included = true;
        for (const s3 of this.params)
          s3 instanceof Je || s3.include(e2, t);
        const { brokenFlow: s2 } = e2;
        e2.brokenFlow = 0, this.body.include(e2, t), e2.brokenFlow = s2;
      }
      includeCallArguments(e2, t) {
        this.scope.includeCallArguments(e2, t);
      }
      initialise() {
        this.scope.addParameterVariables(this.params.map((e2) => e2.declare("parameter", U)), this.params[this.params.length - 1] instanceof jt), this.body instanceof Wt ? this.body.addImplicitReturnExpressionToScope() : this.scope.addReturnExpression(this.body);
      }
      parseNode(e2) {
        e2.body.type === "BlockStatement" && (this.body = new Wt(e2.body, this, this.scope.hoistedBodyVarScope)), super.parseNode(e2);
      }
    };
    us.prototype.preventChildBlockScope = true;
    ds = class extends Ae {
      addExportedVariables(e2, t) {
        for (const s2 of this.properties)
          s2.type === "Property" ? s2.value.addExportedVariables(e2, t) : s2.argument.addExportedVariables(e2, t);
      }
      declare(e2, t) {
        const s2 = [];
        for (const i2 of this.properties)
          s2.push(...i2.declare(e2, t));
        return s2;
      }
      deoptimizePath(e2) {
        if (e2.length === 0)
          for (const t of this.properties)
            t.deoptimizePath(e2);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        if (e2.length > 0)
          return true;
        for (const e3 of this.properties)
          if (e3.hasEffectsWhenAssignedAtPath(D, t))
            return true;
        return false;
      }
      markDeclarationReached() {
        for (const e2 of this.properties)
          e2.markDeclarationReached();
      }
    };
    ps = class extends Ae {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      hasEffects(e2) {
        return this.deoptimized || this.applyDeoptimizations(), this.right.hasEffects(e2) || this.left.hasEffects(e2) || this.left.hasEffectsWhenAssignedAtPath(D, e2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return e2.length > 0 && this.right.hasEffectsWhenAccessedAtPath(e2, t);
      }
      include(e2, t) {
        let s2;
        this.deoptimized || this.applyDeoptimizations(), this.included = true, (t || this.operator !== "=" || this.left.included || (s2 = le(), this.left.hasEffects(s2) || this.left.hasEffectsWhenAssignedAtPath(D, s2))) && this.left.include(e2, t), this.right.include(e2, t);
      }
      render(e2, t, { preventASI: s2, renderedParentType: i2, renderedSurroundingElement: n3 } = q) {
        if (this.left.included)
          this.left.render(e2, t), this.right.render(e2, t);
        else {
          const r2 = _e(e2.original, Ie(e2.original, "=", this.left.end) + 1);
          e2.remove(this.start, r2), s2 && Me(e2, r2, this.right.start), this.right.render(e2, t, { renderedParentType: i2 || this.parent.type, renderedSurroundingElement: n3 || this.parent.type });
        }
        if (t.format === "system")
          if (this.left instanceof Je) {
            const s3 = this.left.variable, i3 = t.exportNamesByVariable.get(s3);
            if (i3)
              return void (i3.length === 1 ? Le(s3, this.start, this.end, e2, t) : Oe(s3, this.start, this.end, this.parent.type !== "ExpressionStatement", e2, t));
          } else {
            const s3 = [];
            if (this.left.addExportedVariables(s3, t.exportNamesByVariable), s3.length > 0)
              return void function(e3, t2, s4, i3, n4, r2) {
                const { _: a2, getDirectReturnIifeLeft: o2 } = r2.snippets;
                n4.prependRight(t2, o2(["v"], `${De(e3, r2)},${a2}v`, { needsArrowReturnParens: true, needsWrappedFunction: i3 })), n4.appendLeft(s4, ")");
              }(s3, this.start, this.end, n3 === "ExpressionStatement", e2, t);
          }
        this.left.included && this.left instanceof ds && (n3 === "ExpressionStatement" || n3 === "ArrowFunctionExpression") && (e2.appendRight(this.start, "("), e2.prependLeft(this.end, ")"));
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.left.deoptimizePath(D), this.right.deoptimizePath(L), this.context.requestTreeshakingPass();
      }
    };
    fs2 = { "!=": (e2, t) => e2 != t, "!==": (e2, t) => e2 !== t, "%": (e2, t) => e2 % t, "&": (e2, t) => e2 & t, "*": (e2, t) => e2 * t, "**": (e2, t) => e2 ** t, "+": (e2, t) => e2 + t, "-": (e2, t) => e2 - t, "/": (e2, t) => e2 / t, "<": (e2, t) => e2 < t, "<<": (e2, t) => e2 << t, "<=": (e2, t) => e2 <= t, "==": (e2, t) => e2 == t, "===": (e2, t) => e2 === t, ">": (e2, t) => e2 > t, ">=": (e2, t) => e2 >= t, ">>": (e2, t) => e2 >> t, ">>>": (e2, t) => e2 >>> t, "^": (e2, t) => e2 ^ t, in: () => W, instanceof: () => W, "|": (e2, t) => e2 | t };
    ys = class extends Ae {
      constructor() {
        super(...arguments), this.variable = null, this.deoptimized = false, this.bound = false, this.expressionsToBeDeoptimized = [], this.replacement = null;
      }
      bind() {
        this.bound = true;
        const e2 = gs(this), t = e2 && this.scope.findVariable(e2[0].key);
        if (t && t.isNamespace) {
          const s2 = this.resolveNamespaceVariables(t, e2.slice(1));
          s2 ? typeof s2 == "string" ? this.replacement = s2 : (this.variable = s2, this.scope.addNamespaceMemberAccess(function(e3) {
            let t2 = e3[0].key;
            for (let s3 = 1; s3 < e3.length; s3++)
              t2 += "." + e3[s3].key;
            return t2;
          }(e2), s2)) : super.bind();
        } else
          super.bind();
      }
      deoptimizeCache() {
        const e2 = this.expressionsToBeDeoptimized;
        this.expressionsToBeDeoptimized = [], this.propertyKey = R, this.object.deoptimizePath(L);
        for (const t of e2)
          t.deoptimizeCache();
      }
      deoptimizePath(e2) {
        e2.length === 0 && this.disallowNamespaceReassignment(), this.variable ? this.variable.deoptimizePath(e2) : this.replacement || e2.length < 7 && this.object.deoptimizePath([this.getPropertyKey(), ...e2]);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.variable ? this.variable.deoptimizeThisOnEventAtPath(e2, t, s2, i2) : this.replacement || (t.length < 7 ? this.object.deoptimizeThisOnEventAtPath(e2, [this.getPropertyKey(), ...t], s2, i2) : s2.deoptimizePath(L));
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.variable !== null ? this.variable.getLiteralValueAtPath(e2, t, s2) : this.replacement ? W : (this.expressionsToBeDeoptimized.push(s2), e2.length < 7 ? this.object.getLiteralValueAtPath([this.getPropertyKey(), ...e2], t, s2) : W);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return this.variable !== null ? this.variable.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) : this.replacement ? U : (this.expressionsToBeDeoptimized.push(i2), e2.length < 7 ? this.object.getReturnExpressionWhenCalledAtPath([this.getPropertyKey(), ...e2], t, s2, i2) : U);
      }
      hasEffects(e2) {
        this.deoptimized || this.applyDeoptimizations();
        const { propertyReadSideEffects: t } = this.context.options.treeshake;
        return this.property.hasEffects(e2) || this.object.hasEffects(e2) || !(this.variable || this.replacement || this.parent instanceof ps && this.parent.operator === "=") && t && (t === "always" || this.object.hasEffectsWhenAccessedAtPath([this.getPropertyKey()], e2));
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return this.variable !== null ? this.variable.hasEffectsWhenAccessedAtPath(e2, t) : !!this.replacement || (!(e2.length < 7) || this.object.hasEffectsWhenAccessedAtPath([this.getPropertyKey(), ...e2], t));
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return this.variable !== null ? this.variable.hasEffectsWhenAssignedAtPath(e2, t) : !!this.replacement || (!(e2.length < 7) || this.object.hasEffectsWhenAssignedAtPath([this.getPropertyKey(), ...e2], t));
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return this.variable !== null ? this.variable.hasEffectsWhenCalledAtPath(e2, t, s2) : !!this.replacement || (!(e2.length < 7) || this.object.hasEffectsWhenCalledAtPath([this.getPropertyKey(), ...e2], t, s2));
      }
      include(e2, t) {
        this.deoptimized || this.applyDeoptimizations(), this.included || (this.included = true, this.variable !== null && this.context.includeVariableInModule(this.variable)), this.object.include(e2, t), this.property.include(e2, t);
      }
      includeCallArguments(e2, t) {
        this.variable ? this.variable.includeCallArguments(e2, t) : super.includeCallArguments(e2, t);
      }
      initialise() {
        this.propertyKey = ms2(this);
      }
      render(e2, t, { renderedParentType: s2, isCalleeOfRenderedParent: i2, renderedSurroundingElement: n3 } = q) {
        if (this.variable || this.replacement) {
          const { snippets: { getPropertyAccess: n4 } } = t;
          let r2 = this.variable ? this.variable.getName(n4) : this.replacement;
          s2 && i2 && (r2 = "0, " + r2), e2.overwrite(this.start, this.end, r2, { contentOnly: true, storeName: true });
        } else
          s2 && i2 && e2.appendRight(this.start, "0, "), this.object.render(e2, t, { renderedSurroundingElement: n3 }), this.property.render(e2, t);
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        const { propertyReadSideEffects: e2 } = this.context.options.treeshake;
        this.bound && e2 && !this.variable && !this.replacement && (this.parent instanceof ps && this.parent.operator === "=" || this.object.deoptimizeThisOnEventAtPath(0, [this.propertyKey], this.object, F), this.parent instanceof ps && this.object.deoptimizeThisOnEventAtPath(1, [this.propertyKey], this.object, F), this.context.requestTreeshakingPass());
      }
      disallowNamespaceReassignment() {
        if (this.object instanceof Je) {
          this.scope.findVariable(this.object.name).isNamespace && (this.variable && this.context.includeVariableInModule(this.variable), this.context.warn({ code: "ILLEGAL_NAMESPACE_REASSIGNMENT", message: `Illegal reassignment to import '${this.object.name}'` }, this.start));
        }
      }
      getPropertyKey() {
        if (this.propertyKey === null) {
          this.propertyKey = R;
          const e2 = this.property.getLiteralValueAtPath(D, F, this);
          return this.propertyKey = e2 === W ? R : String(e2);
        }
        return this.propertyKey;
      }
      resolveNamespaceVariables(e2, t) {
        if (t.length === 0)
          return e2;
        if (!e2.isNamespace || e2 instanceof H)
          return null;
        const s2 = t[0].key, i2 = e2.context.traceExport(s2);
        if (!i2) {
          const i3 = e2.context.fileName;
          return this.context.warn({ code: "MISSING_EXPORT", exporter: se(i3), importer: se(this.context.fileName), message: `'${s2}' is not exported by '${se(i3)}'`, missing: s2, url: "https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module" }, t[0].pos), "undefined";
        }
        return this.resolveNamespaceVariables(i2, t.slice(1));
      }
    };
    Es = class extends Ot {
      addDeclaration(e2, t, s2, i2) {
        const n3 = this.variables.get(e2.name);
        return n3 ? (this.parent.addDeclaration(e2, t, rt, i2), n3.addDeclaration(e2, s2), n3) : this.parent.addDeclaration(e2, t, s2, i2);
      }
    };
    xs = class extends vt {
      constructor(e2, t, s2) {
        super(e2), this.variables.set("this", this.thisVariable = new Qe("this", null, t, s2)), this.instanceScope = new vt(this), this.instanceScope.variables.set("this", new Dt(s2));
      }
      findLexicalBoundary() {
        return this;
      }
    };
    vs = class extends j {
      constructor(e2) {
        super(), this.expressions = e2, this.included = false;
      }
      deoptimizePath(e2) {
        for (const t of this.expressions)
          t.deoptimizePath(e2);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return new vs(this.expressions.map((n3) => n3.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2)));
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        for (const s2 of this.expressions)
          if (s2.hasEffectsWhenAccessedAtPath(e2, t))
            return true;
        return false;
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        for (const s2 of this.expressions)
          if (s2.hasEffectsWhenAssignedAtPath(e2, t))
            return true;
        return false;
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        for (const i2 of this.expressions)
          if (i2.hasEffectsWhenCalledAtPath(e2, t, s2))
            return true;
        return false;
      }
      include(e2, t) {
        for (const s2 of this.expressions)
          s2.included || s2.include(e2, t);
      }
    };
    bs = class extends Ae {
      bind() {
        this.declaration !== null && this.declaration.bind();
      }
      hasEffects(e2) {
        return this.declaration !== null && this.declaration.hasEffects(e2);
      }
      initialise() {
        this.context.addExport(this);
      }
      render(e2, t, s2) {
        const { start: i2, end: n3 } = s2;
        this.declaration === null ? e2.remove(i2, n3) : (e2.remove(this.start, this.declaration.start), this.declaration.render(e2, t, { end: n3, start: i2 }));
      }
    };
    bs.prototype.needsBoundaries = true;
    Ss = class extends Ft {
      constructor() {
        super(...arguments), this.hoistedDeclarations = [];
      }
      addDeclaration(e2, t, s2, i2) {
        return this.hoistedDeclarations.push(e2), super.addDeclaration(e2, t, s2, i2);
      }
    };
    As = Symbol("unset");
    Ps = class extends Ae {
      constructor() {
        super(...arguments), this.testValue = As;
      }
      deoptimizeCache() {
        this.testValue = W;
      }
      hasEffects(e2) {
        if (this.test.hasEffects(e2))
          return true;
        const t = this.getTestValue();
        if (t === W) {
          const { brokenFlow: t2 } = e2;
          if (this.consequent.hasEffects(e2))
            return true;
          const s2 = e2.brokenFlow;
          return e2.brokenFlow = t2, this.alternate === null ? false : !!this.alternate.hasEffects(e2) || (e2.brokenFlow = e2.brokenFlow < s2 ? e2.brokenFlow : s2, false);
        }
        return t ? this.consequent.hasEffects(e2) : this.alternate !== null && this.alternate.hasEffects(e2);
      }
      include(e2, t) {
        if (this.included = true, t)
          this.includeRecursively(t, e2);
        else {
          const t2 = this.getTestValue();
          t2 === W ? this.includeUnknownTest(e2) : this.includeKnownTest(e2, t2);
        }
      }
      parseNode(e2) {
        this.consequentScope = new Ss(this.scope), this.consequent = new (this.context.getNodeConstructor(e2.consequent.type))(e2.consequent, this, this.consequentScope), e2.alternate && (this.alternateScope = new Ss(this.scope), this.alternate = new (this.context.getNodeConstructor(e2.alternate.type))(e2.alternate, this, this.alternateScope)), super.parseNode(e2);
      }
      render(e2, t) {
        const { snippets: { getPropertyAccess: s2 } } = t, i2 = this.getTestValue(), n3 = [], r2 = this.test.included, a2 = !this.context.options.treeshake;
        r2 ? this.test.render(e2, t) : e2.remove(this.start, this.consequent.start), this.consequent.included && (a2 || i2 === W || i2) ? this.consequent.render(e2, t) : (e2.overwrite(this.consequent.start, this.consequent.end, r2 ? ";" : ""), n3.push(...this.consequentScope.hoistedDeclarations)), this.alternate && (!this.alternate.included || !a2 && i2 !== W && i2 ? (r2 && this.shouldKeepAlternateBranch() ? e2.overwrite(this.alternate.start, this.end, ";") : e2.remove(this.consequent.end, this.end), n3.push(...this.alternateScope.hoistedDeclarations)) : (r2 ? e2.original.charCodeAt(this.alternate.start - 1) === 101 && e2.prependLeft(this.alternate.start, " ") : e2.remove(this.consequent.end, this.alternate.start), this.alternate.render(e2, t))), this.renderHoistedDeclarations(n3, e2, s2);
      }
      getTestValue() {
        return this.testValue === As ? this.testValue = this.test.getLiteralValueAtPath(D, F, this) : this.testValue;
      }
      includeKnownTest(e2, t) {
        this.test.shouldBeIncluded(e2) && this.test.include(e2, false), t && this.consequent.shouldBeIncluded(e2) && this.consequent.includeAsSingleStatement(e2, false), this.alternate !== null && !t && this.alternate.shouldBeIncluded(e2) && this.alternate.includeAsSingleStatement(e2, false);
      }
      includeRecursively(e2, t) {
        this.test.include(t, e2), this.consequent.include(t, e2), this.alternate !== null && this.alternate.include(t, e2);
      }
      includeUnknownTest(e2) {
        this.test.include(e2, false);
        const { brokenFlow: t } = e2;
        let s2 = 0;
        this.consequent.shouldBeIncluded(e2) && (this.consequent.includeAsSingleStatement(e2, false), s2 = e2.brokenFlow, e2.brokenFlow = t), this.alternate !== null && this.alternate.shouldBeIncluded(e2) && (this.alternate.includeAsSingleStatement(e2, false), e2.brokenFlow = e2.brokenFlow < s2 ? e2.brokenFlow : s2);
      }
      renderHoistedDeclarations(e2, t, s2) {
        const i2 = [...new Set(e2.map((e3) => {
          const t2 = e3.variable;
          return t2.included ? t2.getName(s2) : "";
        }))].filter(Boolean).join(", ");
        if (i2) {
          const e3 = this.parent.type, s3 = e3 !== "Program" && e3 !== "BlockStatement";
          t.prependRight(this.start, `${s3 ? "{ " : ""}var ${i2}; `), s3 && t.appendLeft(this.end, " }");
        }
      }
      shouldKeepAlternateBranch() {
        let e2 = this.parent;
        do {
          if (e2 instanceof Ps && e2.alternate)
            return true;
          if (e2 instanceof Wt)
            return false;
          e2 = e2.parent;
        } while (e2);
        return false;
      }
    };
    ks = class extends Ae {
      bind() {
      }
      hasEffects() {
        return false;
      }
      initialise() {
        this.context.addImport(this);
      }
      render(e2, t, s2) {
        e2.remove(s2.start, s2.end);
      }
    };
    ks.prototype.needsBoundaries = true;
    ws = { auto: "_interopDefault", default: null, defaultOnly: null, esModule: null, false: null, true: "_interopDefaultLegacy" };
    Cs = (e2, t) => e2 === "esModule" || t && (e2 === "auto" || e2 === "true");
    Is = { auto: "_interopNamespace", default: "_interopNamespaceDefault", defaultOnly: "_interopNamespaceDefaultOnly", esModule: null, false: null, true: "_interopNamespace" };
    Ns = (e2, t) => Cs(e2, t) && ws[e2] === "_interopDefault";
    _s = (e2, t, s2, i2, n3, r2, a2) => {
      const o2 = new Set(e2);
      for (const e3 of Ws)
        t.has(e3) && o2.add(e3);
      return Ws.map((e3) => o2.has(e3) ? $s[e3](s2, i2, n3, r2, a2, o2) : "").join("");
    };
    $s = { _interopDefaultLegacy(e2, t, s2) {
      const { _: i2, getDirectReturnFunction: n3, n: r2 } = t, [a2, o2] = n3(["e"], { functionReturn: true, lineBreakIndent: null, name: "_interopDefaultLegacy" });
      return `${a2}e${i2}&&${i2}typeof e${i2}===${i2}'object'${i2}&&${i2}'default'${i2}in e${i2}?${i2}${s2 ? Ts(t) : Rs(t)}${o2}${r2}${r2}`;
    }, _interopDefault(e2, t, s2) {
      const { _: i2, getDirectReturnFunction: n3, n: r2 } = t, [a2, o2] = n3(["e"], { functionReturn: true, lineBreakIndent: null, name: "_interopDefault" });
      return `${a2}e${i2}&&${i2}e.__esModule${i2}?${i2}${s2 ? Ts(t) : Rs(t)}${o2}${r2}${r2}`;
    }, _interopNamespaceDefaultOnly(e2, { _: t, getDirectReturnFunction: s2, getObject: i2, n: n3 }, r2, a2, o2) {
      const [h3, l2] = s2(["e"], { functionReturn: true, lineBreakIndent: null, name: "_interopNamespaceDefaultOnly" });
      return `${h3}${zs(i2([["__proto__", "null"], ...o2 ? [[null, `[Symbol.toStringTag]:${t}'Module'`]] : [], ["default", "e"]], { lineBreakIndent: null }), a2)}${l2}${n3}${n3}`;
    }, _interopNamespaceDefault(e2, t, s2, i2, n3) {
      const { _: r2, n: a2 } = t;
      return `function _interopNamespaceDefault(e)${r2}{${a2}` + Ms(e2, e2, t, s2, i2, n3) + `}${a2}${a2}`;
    }, _interopNamespace(e2, t, s2, i2, n3, r2) {
      const { _: a2, getDirectReturnFunction: o2, n: h3 } = t;
      if (r2.has("_interopNamespaceDefault")) {
        const [e3, t2] = o2(["e"], { functionReturn: true, lineBreakIndent: null, name: "_interopNamespace" });
        return `${e3}e${a2}&&${a2}e.__esModule${a2}?${a2}e${a2}:${a2}_interopNamespaceDefault(e)${t2}${h3}${h3}`;
      }
      return `function _interopNamespace(e)${a2}{${h3}${e2}if${a2}(e${a2}&&${a2}e.__esModule)${a2}return e;${h3}` + Ms(e2, e2, t, s2, i2, n3) + `}${h3}${h3}`;
    }, _mergeNamespaces(e2, t, s2, i2) {
      const { _: n3, cnst: r2, n: a2 } = t, o2 = r2 === "var" && s2;
      return `function _mergeNamespaces(n, m)${n3}{${a2}${e2}${Ls(`{${a2}${e2}${e2}${e2}if${n3}(k${n3}!==${n3}'default'${n3}&&${n3}!(k in n))${n3}{${a2}` + (s2 ? o2 ? Vs : Bs : Fs)(e2, e2 + e2 + e2 + e2, t) + `${e2}${e2}${e2}}${a2}${e2}${e2}}`, o2, e2, t)}${a2}${e2}return ${zs("n", i2)};${a2}}${a2}${a2}`;
    } };
    Ts = ({ _: e2, getObject: t }) => `e${e2}:${e2}${t([["default", "e"]], { lineBreakIndent: null })}`;
    Rs = ({ _: e2, getPropertyAccess: t }) => `e${t("default")}${e2}:${e2}e`;
    Ms = (e2, t, s2, i2, n3, r2) => {
      const { _: a2, cnst: o2, getPropertyAccess: h3, n: l2, s: c2 } = s2, u2 = `{${l2}` + (i2 ? Os : Fs)(e2, t + e2 + e2, s2) + `${t}${e2}}`;
      return `${t}${o2} n${a2}=${a2}${r2 ? `{__proto__:${a2}null,${a2}[Symbol.toStringTag]:${a2}'Module'}` : "Object.create(null)"};${l2}${t}if${a2}(e)${a2}{${l2}${t}${e2}${Ds(u2, !i2, s2)}${l2}${t}}${l2}${t}n${h3("default")}${a2}=${a2}e;${l2}${t}return ${zs("n", n3)}${c2}${l2}`;
    };
    Ds = (e2, t, { _: s2, cnst: i2, getFunctionIntro: n3, s: r2 }) => i2 !== "var" || t ? `for${s2}(${i2} k in e)${s2}${e2}` : `Object.keys(e).forEach(${n3(["k"], { isAsync: false, name: null })}${e2})${r2}`;
    Ls = (e2, t, s2, { _: i2, cnst: n3, getDirectReturnFunction: r2, getFunctionIntro: a2, n: o2 }) => {
      if (t) {
        const [t2, n4] = r2(["e"], { functionReturn: false, lineBreakIndent: { base: s2, t: s2 }, name: null });
        return `m.forEach(${t2}e${i2}&&${i2}typeof e${i2}!==${i2}'string'${i2}&&${i2}!Array.isArray(e)${i2}&&${i2}Object.keys(e).forEach(${a2(["k"], { isAsync: false, name: null })}${e2})${n4});`;
      }
      return `for${i2}(var i${i2}=${i2}0;${i2}i${i2}<${i2}m.length;${i2}i++)${i2}{${o2}${s2}${s2}${n3} e${i2}=${i2}m[i];${o2}${s2}${s2}if${i2}(typeof e${i2}!==${i2}'string'${i2}&&${i2}!Array.isArray(e))${i2}{${i2}for${i2}(${n3} k in e)${i2}${e2}${i2}}${o2}${s2}}`;
    };
    Os = (e2, t, s2) => {
      const { _: i2, n: n3 } = s2;
      return `${t}if${i2}(k${i2}!==${i2}'default')${i2}{${n3}` + Vs(e2, t + e2, s2) + `${t}}${n3}`;
    };
    Vs = (e2, t, { _: s2, cnst: i2, getDirectReturnFunction: n3, n: r2 }) => {
      const [a2, o2] = n3([], { functionReturn: true, lineBreakIndent: null, name: null });
      return `${t}${i2} d${s2}=${s2}Object.getOwnPropertyDescriptor(e,${s2}k);${r2}${t}Object.defineProperty(n,${s2}k,${s2}d.get${s2}?${s2}d${s2}:${s2}{${r2}${t}${e2}enumerable:${s2}true,${r2}${t}${e2}get:${s2}${a2}e[k]${o2}${r2}${t}});${r2}`;
    };
    Bs = (e2, t, { _: s2, cnst: i2, getDirectReturnFunction: n3, n: r2 }) => {
      const [a2, o2] = n3([], { functionReturn: true, lineBreakIndent: null, name: null });
      return `${t}${i2} d${s2}=${s2}Object.getOwnPropertyDescriptor(e,${s2}k);${r2}${t}if${s2}(d)${s2}{${r2}${t}${e2}Object.defineProperty(n,${s2}k,${s2}d.get${s2}?${s2}d${s2}:${s2}{${r2}${t}${e2}${e2}enumerable:${s2}true,${r2}${t}${e2}${e2}get:${s2}${a2}e[k]${o2}${r2}${t}${e2}});${r2}${t}}${r2}`;
    };
    Fs = (e2, t, { _: s2, n: i2 }) => `${t}n[k]${s2}=${s2}e[k];${i2}`;
    zs = (e2, t) => t ? `Object.freeze(${e2})` : e2;
    Ws = Object.keys($s);
    Us = { amd: ["require"], cjs: ["require"], system: ["module"] };
    !function(e2) {
      e2.ALREADY_CLOSED = "ALREADY_CLOSED", e2.ASSET_NOT_FINALISED = "ASSET_NOT_FINALISED", e2.ASSET_NOT_FOUND = "ASSET_NOT_FOUND", e2.ASSET_SOURCE_ALREADY_SET = "ASSET_SOURCE_ALREADY_SET", e2.ASSET_SOURCE_MISSING = "ASSET_SOURCE_MISSING", e2.BAD_LOADER = "BAD_LOADER", e2.CANNOT_EMIT_FROM_OPTIONS_HOOK = "CANNOT_EMIT_FROM_OPTIONS_HOOK", e2.CHUNK_NOT_GENERATED = "CHUNK_NOT_GENERATED", e2.CHUNK_INVALID = "CHUNK_INVALID", e2.CIRCULAR_REEXPORT = "CIRCULAR_REEXPORT", e2.CYCLIC_CROSS_CHUNK_REEXPORT = "CYCLIC_CROSS_CHUNK_REEXPORT", e2.DEPRECATED_FEATURE = "DEPRECATED_FEATURE", e2.EXTERNAL_SYNTHETIC_EXPORTS = "EXTERNAL_SYNTHETIC_EXPORTS", e2.FILE_NAME_CONFLICT = "FILE_NAME_CONFLICT", e2.FILE_NOT_FOUND = "FILE_NOT_FOUND", e2.INPUT_HOOK_IN_OUTPUT_PLUGIN = "INPUT_HOOK_IN_OUTPUT_PLUGIN", e2.INVALID_CHUNK = "INVALID_CHUNK", e2.INVALID_EXPORT_OPTION = "INVALID_EXPORT_OPTION", e2.INVALID_EXTERNAL_ID = "INVALID_EXTERNAL_ID", e2.INVALID_OPTION = "INVALID_OPTION", e2.INVALID_PLUGIN_HOOK = "INVALID_PLUGIN_HOOK", e2.INVALID_ROLLUP_PHASE = "INVALID_ROLLUP_PHASE", e2.MISSING_EXPORT = "MISSING_EXPORT", e2.MISSING_IMPLICIT_DEPENDANT = "MISSING_IMPLICIT_DEPENDANT", e2.MIXED_EXPORTS = "MIXED_EXPORTS", e2.NAMESPACE_CONFLICT = "NAMESPACE_CONFLICT", e2.AMBIGUOUS_EXTERNAL_NAMESPACES = "AMBIGUOUS_EXTERNAL_NAMESPACES", e2.NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE = "NO_TRANSFORM_MAP_OR_AST_WITHOUT_CODE", e2.PLUGIN_ERROR = "PLUGIN_ERROR", e2.PREFER_NAMED_EXPORTS = "PREFER_NAMED_EXPORTS", e2.SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT = "SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT", e2.UNEXPECTED_NAMED_IMPORT = "UNEXPECTED_NAMED_IMPORT", e2.UNRESOLVED_ENTRY = "UNRESOLVED_ENTRY", e2.UNRESOLVED_IMPORT = "UNRESOLVED_IMPORT", e2.VALIDATION_ERROR = "VALIDATION_ERROR";
    }(Ks || (Ks = {}));
    hi = "ROLLUP_ASSET_URL_";
    li = "ROLLUP_FILE_URL_";
    ci = { amd: ["document", "module", "URL"], cjs: ["document", "require", "URL"], es: [], iife: ["document", "URL"], system: ["module"], umd: ["document", "require", "URL"] };
    ui = { amd: ["document", "require", "URL"], cjs: ["document", "require", "URL"], es: [], iife: ["document", "URL"], system: ["module", "URL"], umd: ["document", "require", "URL"] };
    di = (e2, t = "URL") => `new ${t}(${e2}).href`;
    pi = (e2, t = false) => di(`'${e2}', ${t ? "typeof document === 'undefined' ? location.href : " : ""}document.currentScript && document.currentScript.src || document.baseURI`);
    fi = (e2) => (t, { chunkId: s2 }) => {
      const i2 = e2(s2);
      return t === null ? `({ url: ${i2} })` : t === "url" ? i2 : "undefined";
    };
    mi = (e2, t = false) => `${t ? "typeof document === 'undefined' ? location.href : " : ""}(document.currentScript && document.currentScript.src || new URL('${e2}', document.baseURI).href)`;
    gi = { amd: (e2) => (e2[0] !== "." && (e2 = "./" + e2), di(`require.toUrl('${e2}'), document.baseURI`)), cjs: (e2) => `(typeof document === 'undefined' ? ${di(`'file:' + __dirname + '/${e2}'`, "(require('u' + 'rl').URL)")} : ${pi(e2)})`, es: (e2) => di(`'${e2}', import.meta.url`), iife: (e2) => pi(e2), system: (e2) => di(`'${e2}', module.meta.url`), umd: (e2) => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${di(`'file:' + __dirname + '/${e2}'`, "(require('u' + 'rl').URL)")} : ${pi(e2, true)})` };
    yi = { amd: fi(() => di("module.uri, document.baseURI")), cjs: fi((e2) => `(typeof document === 'undefined' ? ${di("'file:' + __filename", "(require('u' + 'rl').URL)")} : ${mi(e2)})`), iife: fi((e2) => mi(e2)), system: (e2, { snippets: { getPropertyAccess: t } }) => e2 === null ? "module.meta" : `module.meta${t(e2)}`, umd: fi((e2) => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${di("'file:' + __filename", "(require('u' + 'rl').URL)")} : ${mi(e2, true)})`) };
    Ei = class extends Ae {
      hasEffects(e2) {
        if (this.test && this.test.hasEffects(e2))
          return true;
        for (const t of this.consequent) {
          if (e2.brokenFlow)
            break;
          if (t.hasEffects(e2))
            return true;
        }
        return false;
      }
      include(e2, t) {
        this.included = true, this.test && this.test.include(e2, t);
        for (const s2 of this.consequent)
          (t || s2.shouldBeIncluded(e2)) && s2.include(e2, t);
      }
      render(e2, t, s2) {
        if (this.consequent.length) {
          this.test && this.test.render(e2, t);
          const i2 = this.test ? this.test.end : Ie(e2.original, "default", this.start) + 7, n3 = Ie(e2.original, ":", i2) + 1;
          Te(this.consequent, e2, n3, s2.end, t);
        } else
          super.render(e2, t);
      }
    };
    Ei.prototype.needsBoundaries = true;
    xi = class extends G {
      constructor() {
        super("undefined");
      }
      getLiteralValueAtPath() {
      }
    };
    vi = class extends Qe {
      constructor(e2, t, s2) {
        super(e2, t, t.declaration, s2), this.hasId = false, this.originalId = null, this.originalVariable = null;
        const i2 = t.declaration;
        (i2 instanceof Gt || i2 instanceof Rt) && i2.id ? (this.hasId = true, this.originalId = i2.id) : i2 instanceof Je && (this.originalId = i2);
      }
      addReference(e2) {
        this.hasId || (this.name = e2.name);
      }
      getAssignedVariableName() {
        return this.originalId && this.originalId.name || null;
      }
      getBaseVariableName() {
        const e2 = this.getOriginalVariable();
        return e2 === this ? super.getBaseVariableName() : e2.getBaseVariableName();
      }
      getDirectOriginalVariable() {
        return !this.originalId || !this.hasId && (this.originalId.isPossibleTDZ() || this.originalId.variable.isReassigned || this.originalId.variable instanceof xi || "syntheticNamespace" in this.originalId.variable) ? null : this.originalId.variable;
      }
      getName(e2) {
        const t = this.getOriginalVariable();
        return t === this ? super.getName(e2) : t.getName(e2);
      }
      getOriginalVariable() {
        if (this.originalVariable)
          return this.originalVariable;
        let e2, t = this;
        const s2 = new Set();
        do {
          s2.add(t), e2 = t, t = e2.getDirectOriginalVariable();
        } while (t instanceof vi && !s2.has(t));
        return this.originalVariable = t || e2;
      }
    };
    bi = class extends vt {
      constructor(e2, t) {
        super(e2), this.context = t, this.variables.set("this", new Qe("this", null, rt, t));
      }
      addExportDefaultDeclaration(e2, t, s2) {
        const i2 = new vi(e2, t, s2);
        return this.variables.set("default", i2), i2;
      }
      addNamespaceMemberAccess() {
      }
      deconflict(e2, t, s2) {
        for (const i2 of this.children)
          i2.deconflict(e2, t, s2);
      }
      findLexicalBoundary() {
        return this;
      }
      findVariable(e2) {
        const t = this.variables.get(e2) || this.accessedOutsideVariables.get(e2);
        if (t)
          return t;
        const s2 = this.context.traceVariable(e2) || this.parent.findVariable(e2);
        return s2 instanceof Ye && this.accessedOutsideVariables.set(e2, s2), s2;
      }
    };
    Si = { "!": (e2) => !e2, "+": (e2) => +e2, "-": (e2) => -e2, delete: () => W, typeof: (e2) => typeof e2, void: () => {
    }, "~": (e2) => ~e2 };
    Ai = { ArrayExpression: class extends Ae {
      constructor() {
        super(...arguments), this.objectEntity = null;
      }
      deoptimizePath(e2) {
        this.getObjectEntity().deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.getObjectEntity().deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.getObjectEntity().getLiteralValueAtPath(e2, t, s2);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(e2, t, s2, i2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return this.getObjectEntity().hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return this.getObjectEntity().hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return this.getObjectEntity().hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      getObjectEntity() {
        if (this.objectEntity !== null)
          return this.objectEntity;
        const e2 = [{ key: "length", kind: "init", property: lt }];
        let t = false;
        for (let s2 = 0; s2 < this.elements.length; s2++) {
          const i2 = this.elements[s2];
          i2 instanceof Lt || t ? i2 && (t = true, e2.unshift({ key: M, kind: "init", property: i2 })) : i2 ? e2.push({ key: String(s2), kind: "init", property: i2 }) : e2.push({ key: String(s2), kind: "init", property: rt });
        }
        return this.objectEntity = new Pt(e2, cs);
      }
    }, ArrayPattern: class extends Ae {
      addExportedVariables(e2, t) {
        for (const s2 of this.elements)
          s2 !== null && s2.addExportedVariables(e2, t);
      }
      declare(e2) {
        const t = [];
        for (const s2 of this.elements)
          s2 !== null && t.push(...s2.declare(e2, U));
        return t;
      }
      deoptimizePath(e2) {
        if (e2.length === 0)
          for (const t of this.elements)
            t !== null && t.deoptimizePath(e2);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        if (e2.length > 0)
          return true;
        for (const e3 of this.elements)
          if (e3 !== null && e3.hasEffectsWhenAssignedAtPath(D, t))
            return true;
        return false;
      }
      markDeclarationReached() {
        for (const e2 of this.elements)
          e2 !== null && e2.markDeclarationReached();
      }
    }, ArrowFunctionExpression: us, AssignmentExpression: ps, AssignmentPattern: class extends Ae {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      addExportedVariables(e2, t) {
        this.left.addExportedVariables(e2, t);
      }
      declare(e2, t) {
        return this.left.declare(e2, t);
      }
      deoptimizePath(e2) {
        e2.length === 0 && this.left.deoptimizePath(e2);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return e2.length > 0 || this.left.hasEffectsWhenAssignedAtPath(D, t);
      }
      markDeclarationReached() {
        this.left.markDeclarationReached();
      }
      render(e2, t, { isShorthandProperty: s2 } = q) {
        this.left.render(e2, t, { isShorthandProperty: s2 }), this.right.render(e2, t);
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.left.deoptimizePath(D), this.right.deoptimizePath(L), this.context.requestTreeshakingPass();
      }
    }, AwaitExpression: class extends Ae {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      hasEffects() {
        return this.deoptimized || this.applyDeoptimizations(), true;
      }
      include(e2, t) {
        if (this.deoptimized || this.applyDeoptimizations(), !this.included) {
          this.included = true;
          e:
            if (!this.context.usesTopLevelAwait) {
              let e3 = this.parent;
              do {
                if (e3 instanceof Ut || e3 instanceof us)
                  break e;
              } while (e3 = e3.parent);
              this.context.usesTopLevelAwait = true;
            }
        }
        this.argument.include(e2, t);
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.argument.deoptimizePath(L), this.context.requestTreeshakingPass();
      }
    }, BinaryExpression: class extends Ae {
      deoptimizeCache() {
      }
      getLiteralValueAtPath(e2, t, s2) {
        if (e2.length > 0)
          return W;
        const i2 = this.left.getLiteralValueAtPath(D, t, s2);
        if (i2 === W)
          return W;
        const n3 = this.right.getLiteralValueAtPath(D, t, s2);
        if (n3 === W)
          return W;
        const r2 = fs2[this.operator];
        return r2 ? r2(i2, n3) : W;
      }
      hasEffects(e2) {
        return this.operator === "+" && this.parent instanceof zt && this.left.getLiteralValueAtPath(D, F, this) === "" || super.hasEffects(e2);
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      render(e2, t, { renderedSurroundingElement: s2 } = q) {
        this.left.render(e2, t, { renderedSurroundingElement: s2 }), this.right.render(e2, t);
      }
    }, BlockStatement: Wt, BreakStatement: class extends Ae {
      hasEffects(e2) {
        if (this.label) {
          if (!e2.ignore.labels.has(this.label.name))
            return true;
          e2.includedLabels.add(this.label.name), e2.brokenFlow = 2;
        } else {
          if (!e2.ignore.breaks)
            return true;
          e2.brokenFlow = 1;
        }
        return false;
      }
      include(e2) {
        this.included = true, this.label && (this.label.include(), e2.includedLabels.add(this.label.name)), e2.brokenFlow = this.label ? 2 : 1;
      }
    }, CallExpression: class extends Ae {
      constructor() {
        super(...arguments), this.deoptimized = false, this.deoptimizableDependentExpressions = [], this.expressionsToBeDeoptimized = new Set(), this.returnExpression = null;
      }
      bind() {
        if (super.bind(), this.callee instanceof Je) {
          this.scope.findVariable(this.callee.name).isNamespace && this.context.warn({ code: "CANNOT_CALL_NAMESPACE", message: `Cannot call a namespace ('${this.callee.name}')` }, this.start), this.callee.name === "eval" && this.context.warn({ code: "EVAL", message: "Use of eval is strongly discouraged, as it poses security risks and may cause issues with minification", url: "https://rollupjs.org/guide/en/#avoiding-eval" }, this.start);
        }
        this.callOptions = { args: this.arguments, thisParam: this.callee instanceof ys && !this.callee.variable ? this.callee.object : null, withNew: false };
      }
      deoptimizeCache() {
        if (this.returnExpression !== U) {
          this.returnExpression = U;
          for (const e2 of this.deoptimizableDependentExpressions)
            e2.deoptimizeCache();
          for (const e2 of this.expressionsToBeDeoptimized)
            e2.deoptimizePath(L);
        }
      }
      deoptimizePath(e2) {
        if (e2.length === 0 || this.context.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(e2, this))
          return;
        const t = this.getReturnExpression();
        t !== U && t.deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        const n3 = this.getReturnExpression(i2);
        n3 === U ? s2.deoptimizePath(L) : i2.withTrackedEntityAtPath(t, n3, () => {
          this.expressionsToBeDeoptimized.add(s2), n3.deoptimizeThisOnEventAtPath(e2, t, s2, i2);
        }, void 0);
      }
      getLiteralValueAtPath(e2, t, s2) {
        const i2 = this.getReturnExpression(t);
        return i2 === U ? W : t.withTrackedEntityAtPath(e2, i2, () => (this.deoptimizableDependentExpressions.push(s2), i2.getLiteralValueAtPath(e2, t, s2)), W);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        const n3 = this.getReturnExpression(s2);
        return this.returnExpression === U ? U : s2.withTrackedEntityAtPath(e2, n3, () => (this.deoptimizableDependentExpressions.push(i2), n3.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2)), U);
      }
      hasEffects(e2) {
        try {
          for (const t of this.arguments)
            if (t.hasEffects(e2))
              return true;
          return (!this.context.options.treeshake.annotations || !this.annotations) && (this.callee.hasEffects(e2) || this.callee.hasEffectsWhenCalledAtPath(D, this.callOptions, e2));
        } finally {
          this.deoptimized || this.applyDeoptimizations();
        }
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return !t.accessed.trackEntityAtPathAndGetIfTracked(e2, this) && this.getReturnExpression().hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return !t.assigned.trackEntityAtPathAndGetIfTracked(e2, this) && this.getReturnExpression().hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return !(t.withNew ? s2.instantiated : s2.called).trackEntityAtPathAndGetIfTracked(e2, t, this) && this.getReturnExpression().hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      include(e2, t) {
        this.deoptimized || this.applyDeoptimizations(), t ? (super.include(e2, t), t === "variables" && this.callee instanceof Je && this.callee.variable && this.callee.variable.markCalledFromTryStatement()) : (this.included = true, this.callee.include(e2, false)), this.callee.includeCallArguments(e2, this.arguments);
        const s2 = this.getReturnExpression();
        s2.included || s2.include(e2, false);
      }
      render(e2, t, { renderedSurroundingElement: s2 } = q) {
        if (this.callee.render(e2, t, { isCalleeOfRenderedParent: true, renderedSurroundingElement: s2 }), this.arguments.length > 0)
          if (this.arguments[this.arguments.length - 1].included)
            for (const s3 of this.arguments)
              s3.render(e2, t);
          else {
            let s3 = this.arguments.length - 2;
            for (; s3 >= 0 && !this.arguments[s3].included; )
              s3--;
            if (s3 >= 0) {
              for (let i2 = 0; i2 <= s3; i2++)
                this.arguments[i2].render(e2, t);
              e2.remove(Ie(e2.original, ",", this.arguments[s3].end), this.end - 1);
            } else
              e2.remove(Ie(e2.original, "(", this.callee.end) + 1, this.end - 1);
          }
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        const { thisParam: e2 } = this.callOptions;
        e2 && this.callee.deoptimizeThisOnEventAtPath(2, D, e2, F);
        for (const e3 of this.arguments)
          e3.deoptimizePath(L);
        this.context.requestTreeshakingPass();
      }
      getReturnExpression(e2 = F) {
        return this.returnExpression === null ? (this.returnExpression = U, this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(D, this.callOptions, e2, this)) : this.returnExpression;
      }
    }, CatchClause: class extends Ae {
      createScope(e2) {
        this.scope = new Es(e2, this.context);
      }
      parseNode(e2) {
        const { param: t } = e2;
        t && (this.param = new (this.context.getNodeConstructor(t.type))(t, this, this.scope), this.param.declare("parameter", U)), super.parseNode(e2);
      }
    }, ChainExpression: class extends Ae {
    }, ClassBody: class extends Ae {
      createScope(e2) {
        this.scope = new xs(e2, this.parent, this.context);
      }
      include(e2, t) {
        this.included = true, this.context.includeVariableInModule(this.scope.thisVariable);
        for (const s2 of this.body)
          s2.include(e2, t);
      }
      parseNode(e2) {
        const t = this.body = [];
        for (const s2 of e2.body)
          t.push(new (this.context.getNodeConstructor(s2.type))(s2, this, s2.static ? this.scope : this.scope.instanceScope));
        super.parseNode(e2);
      }
    }, ClassDeclaration: Rt, ClassExpression: class extends Tt {
      render(e2, t, { renderedSurroundingElement: s2 } = q) {
        super.render(e2, t), s2 === "ExpressionStatement" && (e2.appendRight(this.start, "("), e2.prependLeft(this.end, ")"));
      }
    }, ConditionalExpression: class extends Ae {
      constructor() {
        super(...arguments), this.expressionsToBeDeoptimized = [], this.isBranchResolutionAnalysed = false, this.usedBranch = null;
      }
      deoptimizeCache() {
        if (this.usedBranch !== null) {
          const e2 = this.usedBranch === this.consequent ? this.alternate : this.consequent;
          this.usedBranch = null, e2.deoptimizePath(L);
          for (const e3 of this.expressionsToBeDeoptimized)
            e3.deoptimizeCache();
        }
      }
      deoptimizePath(e2) {
        const t = this.getUsedBranch();
        t === null ? (this.consequent.deoptimizePath(e2), this.alternate.deoptimizePath(e2)) : t.deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.consequent.deoptimizeThisOnEventAtPath(e2, t, s2, i2), this.alternate.deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        const i2 = this.getUsedBranch();
        return i2 === null ? W : (this.expressionsToBeDeoptimized.push(s2), i2.getLiteralValueAtPath(e2, t, s2));
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        const n3 = this.getUsedBranch();
        return n3 === null ? new vs([this.consequent.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2), this.alternate.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2)]) : (this.expressionsToBeDeoptimized.push(i2), n3.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2));
      }
      hasEffects(e2) {
        if (this.test.hasEffects(e2))
          return true;
        const t = this.getUsedBranch();
        return t === null ? this.consequent.hasEffects(e2) || this.alternate.hasEffects(e2) : t.hasEffects(e2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        const s2 = this.getUsedBranch();
        return s2 === null ? this.consequent.hasEffectsWhenAccessedAtPath(e2, t) || this.alternate.hasEffectsWhenAccessedAtPath(e2, t) : s2.hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        const s2 = this.getUsedBranch();
        return s2 === null ? this.consequent.hasEffectsWhenAssignedAtPath(e2, t) || this.alternate.hasEffectsWhenAssignedAtPath(e2, t) : s2.hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        const i2 = this.getUsedBranch();
        return i2 === null ? this.consequent.hasEffectsWhenCalledAtPath(e2, t, s2) || this.alternate.hasEffectsWhenCalledAtPath(e2, t, s2) : i2.hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      include(e2, t) {
        this.included = true;
        const s2 = this.getUsedBranch();
        t || this.test.shouldBeIncluded(e2) || s2 === null ? (this.test.include(e2, t), this.consequent.include(e2, t), this.alternate.include(e2, t)) : s2.include(e2, t);
      }
      includeCallArguments(e2, t) {
        const s2 = this.getUsedBranch();
        s2 === null ? (this.consequent.includeCallArguments(e2, t), this.alternate.includeCallArguments(e2, t)) : s2.includeCallArguments(e2, t);
      }
      render(e2, t, { isCalleeOfRenderedParent: s2, preventASI: i2, renderedParentType: n3, renderedSurroundingElement: r2 } = q) {
        const a2 = this.getUsedBranch();
        if (this.test.included)
          this.test.render(e2, t, { renderedSurroundingElement: r2 }), this.consequent.render(e2, t), this.alternate.render(e2, t);
        else {
          const o2 = Ie(e2.original, ":", this.consequent.end), h3 = _e(e2.original, (this.consequent.included ? Ie(e2.original, "?", this.test.end) : o2) + 1);
          i2 && Me(e2, h3, a2.start), e2.remove(this.start, h3), this.consequent.included && e2.remove(o2, this.end), we(this, e2), a2.render(e2, t, { isCalleeOfRenderedParent: s2, preventASI: true, renderedParentType: n3 || this.parent.type, renderedSurroundingElement: r2 || this.parent.type });
        }
      }
      getUsedBranch() {
        if (this.isBranchResolutionAnalysed)
          return this.usedBranch;
        this.isBranchResolutionAnalysed = true;
        const e2 = this.test.getLiteralValueAtPath(D, F, this);
        return e2 === W ? null : this.usedBranch = e2 ? this.consequent : this.alternate;
      }
    }, ContinueStatement: class extends Ae {
      hasEffects(e2) {
        if (this.label) {
          if (!e2.ignore.labels.has(this.label.name))
            return true;
          e2.includedLabels.add(this.label.name), e2.brokenFlow = 2;
        } else {
          if (!e2.ignore.continues)
            return true;
          e2.brokenFlow = 1;
        }
        return false;
      }
      include(e2) {
        this.included = true, this.label && (this.label.include(), e2.includedLabels.add(this.label.name)), e2.brokenFlow = this.label ? 2 : 1;
      }
    }, DoWhileStatement: class extends Ae {
      hasEffects(e2) {
        if (this.test.hasEffects(e2))
          return true;
        const { brokenFlow: t, ignore: { breaks: s2, continues: i2 } } = e2;
        return e2.ignore.breaks = true, e2.ignore.continues = true, !!this.body.hasEffects(e2) || (e2.ignore.breaks = s2, e2.ignore.continues = i2, e2.brokenFlow = t, false);
      }
      include(e2, t) {
        this.included = true, this.test.include(e2, t);
        const { brokenFlow: s2 } = e2;
        this.body.includeAsSingleStatement(e2, t), e2.brokenFlow = s2;
      }
    }, EmptyStatement: class extends Ae {
      hasEffects() {
        return false;
      }
    }, ExportAllDeclaration: Pe, ExportDefaultDeclaration: Ht, ExportNamedDeclaration: bs, ExportSpecifier: class extends Ae {
    }, ExpressionStatement: zt, ForInStatement: class extends Ae {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      createScope(e2) {
        this.scope = new Ft(e2);
      }
      hasEffects(e2) {
        if (this.deoptimized || this.applyDeoptimizations(), this.left && (this.left.hasEffects(e2) || this.left.hasEffectsWhenAssignedAtPath(D, e2)) || this.right && this.right.hasEffects(e2))
          return true;
        const { brokenFlow: t, ignore: { breaks: s2, continues: i2 } } = e2;
        return e2.ignore.breaks = true, e2.ignore.continues = true, !!this.body.hasEffects(e2) || (e2.ignore.breaks = s2, e2.ignore.continues = i2, e2.brokenFlow = t, false);
      }
      include(e2, t) {
        this.deoptimized || this.applyDeoptimizations(), this.included = true, this.left.include(e2, t || true), this.right.include(e2, t);
        const { brokenFlow: s2 } = e2;
        this.body.includeAsSingleStatement(e2, t), e2.brokenFlow = s2;
      }
      render(e2, t) {
        this.left.render(e2, t, Ce), this.right.render(e2, t, Ce), e2.original.charCodeAt(this.right.start - 1) === 110 && e2.prependLeft(this.right.start, " "), this.body.render(e2, t);
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.left.deoptimizePath(D), this.context.requestTreeshakingPass();
      }
    }, ForOfStatement: class extends Ae {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      createScope(e2) {
        this.scope = new Ft(e2);
      }
      hasEffects() {
        return this.deoptimized || this.applyDeoptimizations(), true;
      }
      include(e2, t) {
        this.deoptimized || this.applyDeoptimizations(), this.included = true, this.left.include(e2, t || true), this.right.include(e2, t);
        const { brokenFlow: s2 } = e2;
        this.body.includeAsSingleStatement(e2, t), e2.brokenFlow = s2;
      }
      render(e2, t) {
        this.left.render(e2, t, Ce), this.right.render(e2, t, Ce), e2.original.charCodeAt(this.right.start - 1) === 102 && e2.prependLeft(this.right.start, " "), this.body.render(e2, t);
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.left.deoptimizePath(D), this.context.requestTreeshakingPass();
      }
    }, ForStatement: class extends Ae {
      createScope(e2) {
        this.scope = new Ft(e2);
      }
      hasEffects(e2) {
        if (this.init && this.init.hasEffects(e2) || this.test && this.test.hasEffects(e2) || this.update && this.update.hasEffects(e2))
          return true;
        const { brokenFlow: t, ignore: { breaks: s2, continues: i2 } } = e2;
        return e2.ignore.breaks = true, e2.ignore.continues = true, !!this.body.hasEffects(e2) || (e2.ignore.breaks = s2, e2.ignore.continues = i2, e2.brokenFlow = t, false);
      }
      include(e2, t) {
        this.included = true, this.init && this.init.includeAsSingleStatement(e2, t), this.test && this.test.include(e2, t);
        const { brokenFlow: s2 } = e2;
        this.update && this.update.include(e2, t), this.body.includeAsSingleStatement(e2, t), e2.brokenFlow = s2;
      }
      render(e2, t) {
        this.init && this.init.render(e2, t, Ce), this.test && this.test.render(e2, t, Ce), this.update && this.update.render(e2, t, Ce), this.body.render(e2, t);
      }
    }, FunctionDeclaration: Gt, FunctionExpression: class extends Ut {
      render(e2, t, { renderedSurroundingElement: s2 } = q) {
        super.render(e2, t), s2 === "ExpressionStatement" && (e2.appendRight(this.start, "("), e2.prependLeft(this.end, ")"));
      }
    }, Identifier: Je, IfStatement: Ps, ImportDeclaration: ks, ImportDefaultSpecifier: class extends Ae {
    }, ImportExpression: class extends Ae {
      constructor() {
        super(...arguments), this.inlineNamespace = null, this.mechanism = null, this.resolution = null;
      }
      hasEffects() {
        return true;
      }
      include(e2, t) {
        this.included || (this.included = true, this.context.includeDynamicImport(this), this.scope.addAccessedDynamicImport(this)), this.source.include(e2, t);
      }
      initialise() {
        this.context.addDynamicImport(this);
      }
      render(e2, t) {
        if (this.inlineNamespace) {
          const { snippets: { getDirectReturnFunction: s2, getPropertyAccess: i2 } } = t, [n3, r2] = s2([], { functionReturn: true, lineBreakIndent: null, name: null });
          e2.overwrite(this.start, this.end, `Promise.resolve().then(${n3}${this.inlineNamespace.getName(i2)}${r2})`, { contentOnly: true });
        } else
          this.mechanism && (e2.overwrite(this.start, Ie(e2.original, "(", this.start + 6) + 1, this.mechanism.left, { contentOnly: true }), e2.overwrite(this.end - 1, this.end, this.mechanism.right, { contentOnly: true })), this.source.render(e2, t);
      }
      renderFinalResolution(e2, t, s2, { getDirectReturnFunction: i2 }) {
        if (e2.overwrite(this.source.start, this.source.end, t), s2) {
          const [t2, n3] = i2(["n"], { functionReturn: true, lineBreakIndent: null, name: null });
          e2.prependLeft(this.end, `.then(${t2}n.${s2}${n3})`);
        }
      }
      setExternalResolution(e2, t, s2, i2, n3, r2) {
        const { format: a2 } = s2;
        this.resolution = t;
        const o2 = [...Us[a2] || []];
        let h3;
        ({ helper: h3, mechanism: this.mechanism } = this.getDynamicImportMechanismAndHelper(t, e2, s2, i2, n3)), h3 && o2.push(h3), o2.length > 0 && this.scope.addAccessedGlobals(o2, r2);
      }
      setInternalResolution(e2) {
        this.inlineNamespace = e2;
      }
      getDynamicImportMechanismAndHelper(e2, t, { compact: s2, dynamicImportFunction: i2, format: n3, generatedCode: { arrowFunctions: r2 }, interop: a2 }, { _: o2, getDirectReturnFunction: h3, getDirectReturnIifeLeft: l2 }, c2) {
        const u2 = c2.hookFirstSync("renderDynamicImport", [{ customResolution: typeof this.resolution == "string" ? this.resolution : null, format: n3, moduleId: this.context.module.id, targetModuleId: this.resolution && typeof this.resolution != "string" ? this.resolution.id : null }]);
        if (u2)
          return { helper: null, mechanism: u2 };
        const d3 = !this.resolution || typeof this.resolution == "string";
        switch (n3) {
          case "cjs": {
            const s3 = js(e2, t, a2);
            let i3 = "require(", n4 = ")";
            s3 && (i3 = `/*#__PURE__*/${s3}(${i3}`, n4 += ")");
            const [o3, c3] = h3([], { functionReturn: true, lineBreakIndent: null, name: null });
            return i3 = `Promise.resolve().then(${o3}${i3}`, n4 += `${c3})`, !r2 && d3 && (i3 = l2(["t"], `${i3}t${n4}`, { needsArrowReturnParens: false, needsWrappedFunction: true }), n4 = ")"), { helper: s3, mechanism: { left: i3, right: n4 } };
          }
          case "amd": {
            const i3 = s2 ? "c" : "resolve", n4 = s2 ? "e" : "reject", c3 = js(e2, t, a2), [u3, p2] = h3(["m"], { functionReturn: false, lineBreakIndent: null, name: null }), f2 = c3 ? `${u3}${i3}(/*#__PURE__*/${c3}(m))${p2}` : i3, [m3, g2] = h3([i3, n4], { functionReturn: false, lineBreakIndent: null, name: null });
            let y3 = `new Promise(${m3}require([`, E3 = `],${o2}${f2},${o2}${n4})${g2})`;
            return !r2 && d3 && (y3 = l2(["t"], `${y3}t${E3}`, { needsArrowReturnParens: false, needsWrappedFunction: true }), E3 = ")"), { helper: c3, mechanism: { left: y3, right: E3 } };
          }
          case "system":
            return { helper: null, mechanism: { left: "module.import(", right: ")" } };
          case "es":
            if (i2)
              return { helper: null, mechanism: { left: `${i2}(`, right: ")" } };
        }
        return { helper: null, mechanism: null };
      }
    }, ImportNamespaceSpecifier: class extends Ae {
    }, ImportSpecifier: class extends Ae {
    }, LabeledStatement: class extends Ae {
      hasEffects(e2) {
        const t = e2.brokenFlow;
        return e2.ignore.labels.add(this.label.name), !!this.body.hasEffects(e2) || (e2.ignore.labels.delete(this.label.name), e2.includedLabels.has(this.label.name) && (e2.includedLabels.delete(this.label.name), e2.brokenFlow = t), false);
      }
      include(e2, t) {
        this.included = true;
        const s2 = e2.brokenFlow;
        this.body.include(e2, t), (t || e2.includedLabels.has(this.label.name)) && (this.label.include(), e2.includedLabels.delete(this.label.name), e2.brokenFlow = s2);
      }
      render(e2, t) {
        this.label.included ? this.label.render(e2, t) : e2.remove(this.start, _e(e2.original, Ie(e2.original, ":", this.label.end) + 1)), this.body.render(e2, t);
      }
    }, Literal: qt, LogicalExpression: class extends Ae {
      constructor() {
        super(...arguments), this.expressionsToBeDeoptimized = [], this.isBranchResolutionAnalysed = false, this.usedBranch = null;
      }
      deoptimizeCache() {
        if (this.usedBranch !== null) {
          const e2 = this.usedBranch === this.left ? this.right : this.left;
          this.usedBranch = null, e2.deoptimizePath(L);
          for (const e3 of this.expressionsToBeDeoptimized)
            e3.deoptimizeCache();
        }
      }
      deoptimizePath(e2) {
        const t = this.getUsedBranch();
        t === null ? (this.left.deoptimizePath(e2), this.right.deoptimizePath(e2)) : t.deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.left.deoptimizeThisOnEventAtPath(e2, t, s2, i2), this.right.deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        const i2 = this.getUsedBranch();
        return i2 === null ? W : (this.expressionsToBeDeoptimized.push(s2), i2.getLiteralValueAtPath(e2, t, s2));
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        const n3 = this.getUsedBranch();
        return n3 === null ? new vs([this.left.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2), this.right.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2)]) : (this.expressionsToBeDeoptimized.push(i2), n3.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2));
      }
      hasEffects(e2) {
        return !!this.left.hasEffects(e2) || this.getUsedBranch() !== this.left && this.right.hasEffects(e2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        const s2 = this.getUsedBranch();
        return s2 === null ? this.left.hasEffectsWhenAccessedAtPath(e2, t) || this.right.hasEffectsWhenAccessedAtPath(e2, t) : s2.hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        const s2 = this.getUsedBranch();
        return s2 === null ? this.left.hasEffectsWhenAssignedAtPath(e2, t) || this.right.hasEffectsWhenAssignedAtPath(e2, t) : s2.hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        const i2 = this.getUsedBranch();
        return i2 === null ? this.left.hasEffectsWhenCalledAtPath(e2, t, s2) || this.right.hasEffectsWhenCalledAtPath(e2, t, s2) : i2.hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      include(e2, t) {
        this.included = true;
        const s2 = this.getUsedBranch();
        t || s2 === this.right && this.left.shouldBeIncluded(e2) || s2 === null ? (this.left.include(e2, t), this.right.include(e2, t)) : s2.include(e2, t);
      }
      render(e2, t, { isCalleeOfRenderedParent: s2, preventASI: i2, renderedParentType: n3, renderedSurroundingElement: r2 } = q) {
        if (this.left.included && this.right.included)
          this.left.render(e2, t, { preventASI: i2, renderedSurroundingElement: r2 }), this.right.render(e2, t);
        else {
          const a2 = Ie(e2.original, this.operator, this.left.end);
          if (this.right.included) {
            const t2 = _e(e2.original, a2 + 2);
            e2.remove(this.start, t2), i2 && Me(e2, t2, this.right.start);
          } else
            e2.remove(a2, this.end);
          we(this, e2), this.getUsedBranch().render(e2, t, { isCalleeOfRenderedParent: s2, preventASI: i2, renderedParentType: n3 || this.parent.type, renderedSurroundingElement: r2 || this.parent.type });
        }
      }
      getUsedBranch() {
        if (!this.isBranchResolutionAnalysed) {
          this.isBranchResolutionAnalysed = true;
          const e2 = this.left.getLiteralValueAtPath(D, F, this);
          if (e2 === W)
            return null;
          this.usedBranch = this.operator === "||" && e2 || this.operator === "&&" && !e2 || this.operator === "??" && e2 != null ? this.left : this.right;
        }
        return this.usedBranch;
      }
    }, MemberExpression: ys, MetaProperty: class extends Ae {
      addAccessedGlobals(e2, t) {
        const s2 = this.metaProperty, i2 = (s2 && (s2.startsWith(li) || s2.startsWith(hi) || s2.startsWith("ROLLUP_CHUNK_URL_")) ? ui : ci)[e2];
        i2.length > 0 && this.scope.addAccessedGlobals(i2, t);
      }
      getReferencedFileName(e2) {
        const t = this.metaProperty;
        return t && t.startsWith(li) ? e2.getFileName(t.substr(li.length)) : null;
      }
      hasEffects() {
        return false;
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      include() {
        if (!this.included && (this.included = true, this.meta.name === "import")) {
          this.context.addImportMeta(this);
          const e2 = this.parent;
          this.metaProperty = e2 instanceof ys && typeof e2.propertyKey == "string" ? e2.propertyKey : null;
        }
      }
      renderFinalMechanism(e2, t, s2, i2, n3) {
        var r2;
        const a2 = this.parent, o2 = this.metaProperty;
        if (o2 && (o2.startsWith(li) || o2.startsWith(hi) || o2.startsWith("ROLLUP_CHUNK_URL_"))) {
          let i3, r3 = null, h4 = null, l2 = null;
          o2.startsWith(li) ? (r3 = o2.substr(li.length), i3 = n3.getFileName(r3)) : o2.startsWith(hi) ? (ai(`Using the "${hi}" prefix to reference files is deprecated. Use the "${li}" prefix instead.`, true, this.context.options), h4 = o2.substr(hi.length), i3 = n3.getFileName(h4)) : (ai(`Using the "ROLLUP_CHUNK_URL_" prefix to reference files is deprecated. Use the "${li}" prefix instead.`, true, this.context.options), l2 = o2.substr("ROLLUP_CHUNK_URL_".length), i3 = n3.getFileName(l2));
          const c2 = w2(_(I(t), i3));
          let u2;
          return h4 !== null && (u2 = n3.hookFirstSync("resolveAssetUrl", [{ assetFileName: i3, chunkId: t, format: s2, moduleId: this.context.module.id, relativeAssetPath: c2 }])), u2 || (u2 = n3.hookFirstSync("resolveFileUrl", [{ assetReferenceId: h4, chunkId: t, chunkReferenceId: l2, fileName: i3, format: s2, moduleId: this.context.module.id, referenceId: r3 || h4 || l2, relativePath: c2 }]) || gi[s2](c2)), void e2.overwrite(a2.start, a2.end, u2, { contentOnly: true });
        }
        const h3 = n3.hookFirstSync("resolveImportMeta", [o2, { chunkId: t, format: s2, moduleId: this.context.module.id }]) || ((r2 = yi[s2]) === null || r2 === void 0 ? void 0 : r2.call(yi, o2, { chunkId: t, snippets: i2 }));
        typeof h3 == "string" && (a2 instanceof ys ? e2.overwrite(a2.start, a2.end, h3, { contentOnly: true }) : e2.overwrite(this.start, this.end, h3, { contentOnly: true }));
      }
    }, MethodDefinition: St, NewExpression: class extends Ae {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      hasEffects(e2) {
        this.deoptimized || this.applyDeoptimizations();
        for (const t of this.arguments)
          if (t.hasEffects(e2))
            return true;
        return (!this.context.options.treeshake.annotations || !this.annotations) && (this.callee.hasEffects(e2) || this.callee.hasEffectsWhenCalledAtPath(D, this.callOptions, e2));
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 0;
      }
      initialise() {
        this.callOptions = { args: this.arguments, thisParam: null, withNew: true };
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        for (const e2 of this.arguments)
          e2.deoptimizePath(L);
        this.context.requestTreeshakingPass();
      }
    }, ObjectExpression: class extends Ae {
      constructor() {
        super(...arguments), this.objectEntity = null;
      }
      deoptimizeCache() {
        this.getObjectEntity().deoptimizeAllProperties();
      }
      deoptimizePath(e2) {
        this.getObjectEntity().deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.getObjectEntity().deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.getObjectEntity().getLiteralValueAtPath(e2, t, s2);
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(e2, t, s2, i2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return this.getObjectEntity().hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return this.getObjectEntity().hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return this.getObjectEntity().hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      render(e2, t, { renderedSurroundingElement: s2 } = q) {
        super.render(e2, t), s2 !== "ExpressionStatement" && s2 !== "ArrowFunctionExpression" || (e2.appendRight(this.start, "("), e2.prependLeft(this.end, ")"));
      }
      getObjectEntity() {
        if (this.objectEntity !== null)
          return this.objectEntity;
        let e2 = $t;
        const t = [];
        for (const s2 of this.properties) {
          if (s2 instanceof Lt) {
            t.push({ key: R, kind: "init", property: s2 });
            continue;
          }
          let i2;
          if (s2.computed) {
            const e3 = s2.key.getLiteralValueAtPath(D, F, this);
            if (e3 === W) {
              t.push({ key: R, kind: s2.kind, property: s2 });
              continue;
            }
            i2 = String(e3);
          } else if (i2 = s2.key instanceof Je ? s2.key.name : String(s2.key.value), i2 === "__proto__" && s2.kind === "init") {
            e2 = s2.value instanceof qt && s2.value.value === null ? null : s2.value;
            continue;
          }
          t.push({ key: i2, kind: s2.kind, property: s2 });
        }
        return this.objectEntity = new Pt(t, e2);
      }
    }, ObjectPattern: ds, PrivateIdentifier: class extends Ae {
    }, Program: Kt, Property: class extends bt {
      constructor() {
        super(...arguments), this.deoptimized = false, this.declarationInit = null;
      }
      declare(e2, t) {
        return this.declarationInit = t, this.value.declare(e2, U);
      }
      hasEffects(e2) {
        this.deoptimized || this.applyDeoptimizations();
        const t = this.context.options.treeshake.propertyReadSideEffects;
        return this.parent.type === "ObjectPattern" && t === "always" || this.key.hasEffects(e2) || this.value.hasEffects(e2);
      }
      markDeclarationReached() {
        this.value.markDeclarationReached();
      }
      render(e2, t) {
        this.shorthand || this.key.render(e2, t), this.value.render(e2, t, { isShorthandProperty: this.shorthand });
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.declarationInit !== null && (this.declarationInit.deoptimizePath([R, R]), this.context.requestTreeshakingPass());
      }
    }, PropertyDefinition: class extends Ae {
      deoptimizePath(e2) {
        var t;
        (t = this.value) === null || t === void 0 || t.deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        var n3;
        (n3 = this.value) === null || n3 === void 0 || n3.deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.value ? this.value.getLiteralValueAtPath(e2, t, s2) : W;
      }
      getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) {
        return this.value ? this.value.getReturnExpressionWhenCalledAtPath(e2, t, s2, i2) : U;
      }
      hasEffects(e2) {
        return this.key.hasEffects(e2) || this.static && this.value !== null && this.value.hasEffects(e2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return !this.value || this.value.hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return !this.value || this.value.hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return !this.value || this.value.hasEffectsWhenCalledAtPath(e2, t, s2);
      }
    }, RestElement: jt, ReturnStatement: class extends Ae {
      hasEffects(e2) {
        return !(e2.ignore.returnYield && (this.argument === null || !this.argument.hasEffects(e2))) || (e2.brokenFlow = 2, false);
      }
      include(e2, t) {
        this.included = true, this.argument && this.argument.include(e2, t), e2.brokenFlow = 2;
      }
      initialise() {
        this.scope.addReturnExpression(this.argument || U);
      }
      render(e2, t) {
        this.argument && (this.argument.render(e2, t, { preventASI: true }), this.argument.start === this.start + 6 && e2.prependLeft(this.start + 6, " "));
      }
    }, SequenceExpression: class extends Ae {
      deoptimizePath(e2) {
        this.expressions[this.expressions.length - 1].deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.expressions[this.expressions.length - 1].deoptimizeThisOnEventAtPath(e2, t, s2, i2);
      }
      getLiteralValueAtPath(e2, t, s2) {
        return this.expressions[this.expressions.length - 1].getLiteralValueAtPath(e2, t, s2);
      }
      hasEffects(e2) {
        for (const t of this.expressions)
          if (t.hasEffects(e2))
            return true;
        return false;
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return e2.length > 0 && this.expressions[this.expressions.length - 1].hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return this.expressions[this.expressions.length - 1].hasEffectsWhenAssignedAtPath(e2, t);
      }
      hasEffectsWhenCalledAtPath(e2, t, s2) {
        return this.expressions[this.expressions.length - 1].hasEffectsWhenCalledAtPath(e2, t, s2);
      }
      include(e2, t) {
        this.included = true;
        const s2 = this.expressions[this.expressions.length - 1];
        for (const i2 of this.expressions)
          (t || i2 === s2 && !(this.parent instanceof zt) || i2.shouldBeIncluded(e2)) && i2.include(e2, t);
      }
      render(e2, t, { renderedParentType: s2, isCalleeOfRenderedParent: i2, preventASI: n3 } = q) {
        let r2 = 0, a2 = null;
        const o2 = this.expressions[this.expressions.length - 1];
        for (const { node: h3, separator: l2, start: c2, end: u2 } of Re(this.expressions, e2, this.start, this.end))
          if (h3.included)
            if (r2++, a2 = l2, r2 === 1 && n3 && Me(e2, c2, h3.start), r2 === 1) {
              const n4 = s2 || this.parent.type;
              h3.render(e2, t, { isCalleeOfRenderedParent: i2 && h3 === o2, renderedParentType: n4, renderedSurroundingElement: n4 });
            } else
              h3.render(e2, t);
          else
            ke(h3, e2, c2, u2);
        a2 && e2.remove(a2, this.end);
      }
    }, SpreadElement: Lt, StaticBlock: class extends Ae {
      createScope(e2) {
        this.scope = new Ft(e2);
      }
      hasEffects(e2) {
        for (const t of this.body)
          if (t.hasEffects(e2))
            return true;
        return false;
      }
      include(e2, t) {
        this.included = true;
        for (const s2 of this.body)
          (t || s2.shouldBeIncluded(e2)) && s2.include(e2, t);
      }
      render(e2, t) {
        this.body.length ? Te(this.body, e2, this.start + 1, this.end - 1, t) : super.render(e2, t);
      }
    }, Super: class extends Ae {
      bind() {
        this.variable = this.scope.findVariable("this");
      }
      deoptimizePath(e2) {
        this.variable.deoptimizePath(e2);
      }
      include() {
        this.included || (this.included = true, this.context.includeVariableInModule(this.variable));
      }
    }, SwitchCase: Ei, SwitchStatement: class extends Ae {
      createScope(e2) {
        this.scope = new Ft(e2);
      }
      hasEffects(e2) {
        if (this.discriminant.hasEffects(e2))
          return true;
        const { brokenFlow: t, ignore: { breaks: s2 } } = e2;
        let i2 = 1 / 0;
        e2.ignore.breaks = true;
        for (const s3 of this.cases) {
          if (s3.hasEffects(e2))
            return true;
          i2 = e2.brokenFlow < i2 ? e2.brokenFlow : i2, e2.brokenFlow = t;
        }
        return this.defaultCase !== null && i2 !== 1 && (e2.brokenFlow = i2), e2.ignore.breaks = s2, false;
      }
      include(e2, t) {
        this.included = true, this.discriminant.include(e2, t);
        const { brokenFlow: s2 } = e2;
        let i2 = 1 / 0, n3 = t || this.defaultCase !== null && this.defaultCase < this.cases.length - 1;
        for (let r2 = this.cases.length - 1; r2 >= 0; r2--) {
          const a2 = this.cases[r2];
          if (a2.included && (n3 = true), !n3) {
            const e3 = le();
            e3.ignore.breaks = true, n3 = a2.hasEffects(e3);
          }
          n3 ? (a2.include(e2, t), i2 = i2 < e2.brokenFlow ? i2 : e2.brokenFlow, e2.brokenFlow = s2) : i2 = s2;
        }
        n3 && this.defaultCase !== null && i2 !== 1 && (e2.brokenFlow = i2);
      }
      initialise() {
        for (let e2 = 0; e2 < this.cases.length; e2++)
          if (this.cases[e2].test === null)
            return void (this.defaultCase = e2);
        this.defaultCase = null;
      }
      render(e2, t) {
        this.discriminant.render(e2, t), this.cases.length > 0 && Te(this.cases, e2, this.cases[0].start, this.end - 1, t);
      }
    }, TaggedTemplateExpression: class extends Ae {
      bind() {
        if (super.bind(), this.tag.type === "Identifier") {
          const e2 = this.tag.name;
          this.scope.findVariable(e2).isNamespace && this.context.warn({ code: "CANNOT_CALL_NAMESPACE", message: `Cannot call a namespace ('${e2}')` }, this.start);
        }
      }
      hasEffects(e2) {
        return super.hasEffects(e2) || this.tag.hasEffectsWhenCalledAtPath(D, this.callOptions, e2);
      }
      initialise() {
        this.callOptions = { args: it, thisParam: null, withNew: false };
      }
      render(e2, t) {
        this.tag.render(e2, t, { isCalleeOfRenderedParent: true }), this.quasi.render(e2, t);
      }
    }, TemplateElement: class extends Ae {
      bind() {
      }
      hasEffects() {
        return false;
      }
      include() {
        this.included = true;
      }
      parseNode(e2) {
        this.value = e2.value, super.parseNode(e2);
      }
      render() {
      }
    }, TemplateLiteral: Xt, ThisExpression: class extends Ae {
      bind() {
        this.variable = this.scope.findVariable("this");
      }
      deoptimizePath(e2) {
        this.variable.deoptimizePath(e2);
      }
      deoptimizeThisOnEventAtPath(e2, t, s2, i2) {
        this.variable.deoptimizeThisOnEventAtPath(e2, t, s2 === this ? this.variable : s2, i2);
      }
      hasEffectsWhenAccessedAtPath(e2, t) {
        return e2.length > 0 && this.variable.hasEffectsWhenAccessedAtPath(e2, t);
      }
      hasEffectsWhenAssignedAtPath(e2, t) {
        return this.variable.hasEffectsWhenAssignedAtPath(e2, t);
      }
      include() {
        this.included || (this.included = true, this.context.includeVariableInModule(this.variable));
      }
      initialise() {
        this.alias = this.scope.findLexicalBoundary() instanceof bi ? this.context.moduleContext : null, this.alias === "undefined" && this.context.warn({ code: "THIS_IS_UNDEFINED", message: "The 'this' keyword is equivalent to 'undefined' at the top level of an ES module, and has been rewritten", url: "https://rollupjs.org/guide/en/#error-this-is-undefined" }, this.start);
      }
      render(e2) {
        this.alias !== null && e2.overwrite(this.start, this.end, this.alias, { contentOnly: false, storeName: true });
      }
    }, ThrowStatement: class extends Ae {
      hasEffects() {
        return true;
      }
      include(e2, t) {
        this.included = true, this.argument.include(e2, t), e2.brokenFlow = 2;
      }
      render(e2, t) {
        this.argument.render(e2, t, { preventASI: true }), this.argument.start === this.start + 5 && e2.prependLeft(this.start + 5, " ");
      }
    }, TryStatement: class extends Ae {
      constructor() {
        super(...arguments), this.directlyIncluded = false, this.includedLabelsAfterBlock = null;
      }
      hasEffects(e2) {
        return (this.context.options.treeshake.tryCatchDeoptimization ? this.block.body.length > 0 : this.block.hasEffects(e2)) || this.finalizer !== null && this.finalizer.hasEffects(e2);
      }
      include(e2, t) {
        var s2;
        const i2 = (s2 = this.context.options.treeshake) === null || s2 === void 0 ? void 0 : s2.tryCatchDeoptimization, { brokenFlow: n3 } = e2;
        if (this.directlyIncluded && i2) {
          if (this.includedLabelsAfterBlock)
            for (const t2 of this.includedLabelsAfterBlock)
              e2.includedLabels.add(t2);
        } else
          this.included = true, this.directlyIncluded = true, this.block.include(e2, i2 ? "variables" : t), e2.includedLabels.size > 0 && (this.includedLabelsAfterBlock = [...e2.includedLabels]), e2.brokenFlow = n3;
        this.handler !== null && (this.handler.include(e2, t), e2.brokenFlow = n3), this.finalizer !== null && this.finalizer.include(e2, t);
      }
    }, UnaryExpression: class extends Ae {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      getLiteralValueAtPath(e2, t, s2) {
        if (e2.length > 0)
          return W;
        const i2 = this.argument.getLiteralValueAtPath(D, t, s2);
        return i2 === W ? W : Si[this.operator](i2);
      }
      hasEffects(e2) {
        return this.deoptimized || this.applyDeoptimizations(), !(this.operator === "typeof" && this.argument instanceof Je) && (this.argument.hasEffects(e2) || this.operator === "delete" && this.argument.hasEffectsWhenAssignedAtPath(D, e2));
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return this.operator === "void" ? e2.length > 0 : e2.length > 1;
      }
      applyDeoptimizations() {
        this.deoptimized = true, this.operator === "delete" && (this.argument.deoptimizePath(D), this.context.requestTreeshakingPass());
      }
    }, UnknownNode: class extends Ae {
      hasEffects() {
        return true;
      }
      include(e2) {
        super.include(e2, true);
      }
    }, UpdateExpression: class extends Ae {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      hasEffects(e2) {
        return this.deoptimized || this.applyDeoptimizations(), this.argument.hasEffects(e2) || this.argument.hasEffectsWhenAssignedAtPath(D, e2);
      }
      hasEffectsWhenAccessedAtPath(e2) {
        return e2.length > 1;
      }
      render(e2, t) {
        const { exportNamesByVariable: s2, format: i2, snippets: { _: n3 } } = t;
        if (this.argument.render(e2, t), i2 === "system") {
          const i3 = this.argument.variable, r2 = s2.get(i3);
          if (r2)
            if (this.prefix)
              r2.length === 1 ? Le(i3, this.start, this.end, e2, t) : Oe(i3, this.start, this.end, this.parent.type !== "ExpressionStatement", e2, t);
            else {
              const s3 = this.operator[0];
              !function(e3, t2, s4, i4, n4, r3, a2) {
                const { _: o2 } = r3.snippets;
                n4.prependRight(t2, `${De([e3], r3, a2)},${o2}`), i4 && (n4.prependRight(t2, "("), n4.appendLeft(s4, ")"));
              }(i3, this.start, this.end, this.parent.type !== "ExpressionStatement", e2, t, `${n3}${s3}${n3}1`);
            }
        }
      }
      applyDeoptimizations() {
        if (this.deoptimized = true, this.argument.deoptimizePath(D), this.argument instanceof Je) {
          this.scope.findVariable(this.argument.name).isReassigned = true;
        }
        this.context.requestTreeshakingPass();
      }
    }, VariableDeclaration: Qt, VariableDeclarator: class extends Ae {
      declareDeclarator(e2) {
        this.id.declare(e2, this.init || rt);
      }
      deoptimizePath(e2) {
        this.id.deoptimizePath(e2);
      }
      hasEffects(e2) {
        const t = this.init !== null && this.init.hasEffects(e2);
        return this.id.markDeclarationReached(), t || this.id.hasEffects(e2);
      }
      include(e2, t) {
        this.included = true, this.init && this.init.include(e2, t), this.id.markDeclarationReached(), (t || this.id.shouldBeIncluded(e2)) && this.id.include(e2, t);
      }
      render(e2, t) {
        const { exportNamesByVariable: s2, snippets: { _: i2 } } = t, n3 = this.id.included;
        if (n3)
          this.id.render(e2, t);
        else {
          const t2 = Ie(e2.original, "=", this.id.end);
          e2.remove(this.start, _e(e2.original, t2 + 1));
        }
        this.init ? this.init.render(e2, t, n3 ? q : { renderedSurroundingElement: "ExpressionStatement" }) : this.id instanceof Je && Yt(this.id.variable, s2) && e2.appendLeft(this.end, `${i2}=${i2}void 0`);
      }
    }, WhileStatement: class extends Ae {
      hasEffects(e2) {
        if (this.test.hasEffects(e2))
          return true;
        const { brokenFlow: t, ignore: { breaks: s2, continues: i2 } } = e2;
        return e2.ignore.breaks = true, e2.ignore.continues = true, !!this.body.hasEffects(e2) || (e2.ignore.breaks = s2, e2.ignore.continues = i2, e2.brokenFlow = t, false);
      }
      include(e2, t) {
        this.included = true, this.test.include(e2, t);
        const { brokenFlow: s2 } = e2;
        this.body.includeAsSingleStatement(e2, t), e2.brokenFlow = s2;
      }
    }, YieldExpression: class extends Ae {
      constructor() {
        super(...arguments), this.deoptimized = false;
      }
      hasEffects(e2) {
        return this.deoptimized || this.applyDeoptimizations(), !e2.ignore.returnYield || this.argument !== null && this.argument.hasEffects(e2);
      }
      render(e2, t) {
        this.argument && (this.argument.render(e2, t, { preventASI: true }), this.argument.start === this.start + 5 && e2.prependLeft(this.start + 5, " "));
      }
      applyDeoptimizations() {
        this.deoptimized = true;
        const { argument: e2 } = this;
        e2 && (e2.deoptimizePath(L), this.context.requestTreeshakingPass());
      }
    } };
    Pi = class extends G {
      constructor(e2) {
        super("_missingExportShim"), this.module = e2;
      }
      include() {
        super.include(), this.module.needsExportShim = true;
      }
    };
    ki = class extends G {
      constructor(e2) {
        super(e2.getModuleName()), this.memberVariables = null, this.mergedNamespaces = [], this.referencedEarly = false, this.references = [], this.context = e2, this.module = e2.module;
      }
      addReference(e2) {
        this.references.push(e2), this.name = e2.name;
      }
      getMemberVariables() {
        if (this.memberVariables)
          return this.memberVariables;
        const e2 = Object.create(null);
        for (const t of this.context.getExports().concat(this.context.getReexports()))
          if (t[0] !== "*" && t !== this.module.info.syntheticNamedExports) {
            const s2 = this.context.traceExport(t);
            s2 && (e2[t] = s2);
          }
        return this.memberVariables = e2;
      }
      include() {
        this.included = true, this.context.includeAllExports();
      }
      prepare(e2) {
        this.mergedNamespaces.length > 0 && this.module.scope.addAccessedGlobals(["_mergeNamespaces"], e2);
      }
      renderBlock(e2) {
        const { exportNamesByVariable: t, format: s2, freeze: i2, indent: n3, namespaceToStringTag: r2, snippets: { _: a2, cnst: o2, getObject: h3, getPropertyAccess: l2, n: c2, s: u2 } } = e2, d3 = this.getMemberVariables(), p2 = Object.entries(d3).map(([e3, t2]) => this.referencedEarly || t2.isReassigned ? [null, `get ${e3}${a2}()${a2}{${a2}return ${t2.getName(l2)}${u2}${a2}}`] : [e3, t2.getName(l2)]);
        r2 && p2.unshift([null, `[Symbol.toStringTag]:${a2}'Module'`]), p2.unshift([null, `__proto__:${a2}null`]);
        let f2 = h3(p2, { lineBreakIndent: { base: "", t: n3 } });
        if (this.mergedNamespaces.length > 0) {
          f2 = `/*#__PURE__*/_mergeNamespaces(${f2}, [${this.mergedNamespaces.map((e3) => e3.getName(l2)).join(`,${a2}`)}])`;
        }
        i2 && (f2 = `/*#__PURE__*/Object.freeze(${f2})`);
        return f2 = `${o2} ${this.getName(l2)}${a2}=${a2}${f2};`, s2 === "system" && t.has(this) && (f2 += `${c2}${De([this], e2)};`), f2;
      }
      renderFirst() {
        return this.referencedEarly;
      }
      setMergedNamespaces(e2) {
        this.mergedNamespaces = e2;
        const t = this.context.getModuleExecIndex();
        for (const e3 of this.references)
          if (e3.context.getModuleExecIndex() <= t) {
            this.referencedEarly = true;
            break;
          }
      }
    };
    ki.prototype.isNamespace = true;
    wi = class extends G {
      constructor(e2, t, s2) {
        super(t), this.baseVariable = null, this.context = e2, this.module = e2.module, this.syntheticNamespace = s2;
      }
      getBaseVariable() {
        if (this.baseVariable)
          return this.baseVariable;
        let e2 = this.syntheticNamespace;
        for (; e2 instanceof vi || e2 instanceof wi; ) {
          if (e2 instanceof vi) {
            const t = e2.getOriginalVariable();
            if (t === e2)
              break;
            e2 = t;
          }
          e2 instanceof wi && (e2 = e2.syntheticNamespace);
        }
        return this.baseVariable = e2;
      }
      getBaseVariableName() {
        return this.syntheticNamespace.getBaseVariableName();
      }
      getName(e2) {
        return `${this.syntheticNamespace.getName(e2)}${e2(this.name)}`;
      }
      include() {
        this.included = true, this.context.includeVariableInModule(this.syntheticNamespace);
      }
      setRenderNames(e2, t) {
        super.setRenderNames(e2, t);
      }
    };
    !function(e2) {
      e2[e2.LOAD_AND_PARSE = 0] = "LOAD_AND_PARSE", e2[e2.ANALYSE = 1] = "ANALYSE", e2[e2.GENERATE = 2] = "GENERATE";
    }(Ci || (Ci = {}));
    Ni = () => {
    };
    _i = () => [0, 0];
    $i = () => 0;
    Ti = () => 0;
    Ri = {};
    Vi = Ni;
    Bi = Ni;
    Fi = { load: true, resolveDynamicImport: true, resolveId: true, transform: true };
    Ui = { identifier: null, localName: "_missingExportShim" };
    Hi = class {
      constructor(e2, t, s2, i2, n3, r2, a2) {
        this.graph = e2, this.id = t, this.options = s2, this.alternativeReexportModules = new Map(), this.ast = null, this.chunkFileNames = new Set(), this.chunkName = null, this.cycles = new Set(), this.dependencies = new Set(), this.dynamicDependencies = new Set(), this.dynamicImporters = [], this.dynamicImports = [], this.execIndex = 1 / 0, this.exportAllSources = new Set(), this.exports = Object.create(null), this.exportsAll = Object.create(null), this.implicitlyLoadedAfter = new Set(), this.implicitlyLoadedBefore = new Set(), this.importDescriptions = Object.create(null), this.importMetas = [], this.importedFromNotTreeshaken = false, this.importers = [], this.imports = new Set(), this.includedDynamicImporters = [], this.isExecuted = false, this.isUserDefinedEntryPoint = false, this.needsExportShim = false, this.reexportDescriptions = Object.create(null), this.sideEffectDependenciesByVariable = new Map(), this.sources = new Set(), this.userChunkNames = new Set(), this.usesTopLevelAwait = false, this.allExportNames = null, this.exportAllModules = [], this.exportNamesByVariable = null, this.exportShimVariable = new Pi(this), this.namespaceReexportsByName = Object.create(null), this.relevantDependencies = null, this.syntheticExports = new Map(), this.syntheticNamespace = null, this.transformDependencies = [], this.transitiveReexports = null, this.excludeFromSourcemap = /\0/.test(t), this.context = s2.moduleContext(t), this.preserveSignature = this.options.preserveEntrySignatures;
        const o2 = this;
        this.info = { ast: null, code: null, get dynamicallyImportedIds() {
          const e3 = [];
          for (const { id: t2 } of o2.dynamicImports)
            t2 && e3.push(t2);
          return e3;
        }, get dynamicImporters() {
          return o2.dynamicImporters.sort();
        }, hasModuleSideEffects: n3, id: t, get implicitlyLoadedAfterOneOf() {
          return Array.from(o2.implicitlyLoadedAfter, Ii).sort();
        }, get implicitlyLoadedBefore() {
          return Array.from(o2.implicitlyLoadedBefore, Ii).sort();
        }, get importedIds() {
          return Array.from(o2.sources, (e3) => {
            var t2;
            return (t2 = o2.resolvedIds[e3]) === null || t2 === void 0 ? void 0 : t2.id;
          }).filter(Boolean);
        }, get importers() {
          return o2.importers.sort();
        }, isEntry: i2, isExternal: false, get isIncluded() {
          return o2.graph.phase !== Ci.GENERATE ? null : o2.isIncluded();
        }, meta: a2, syntheticNamedExports: r2 };
      }
      basename() {
        const e2 = C2(this.id), t = N(this.id);
        return J(t ? e2.slice(0, -t.length) : e2);
      }
      bindReferences() {
        this.ast.bind();
      }
      error(e2, t) {
        return this.addLocationToLogProps(e2, t), Hs(e2);
      }
      getAllExportNames() {
        if (this.allExportNames)
          return this.allExportNames;
        const e2 = this.allExportNames = new Set();
        for (const t of Object.keys(this.exports))
          e2.add(t);
        for (const t of Object.keys(this.reexportDescriptions))
          e2.add(t);
        for (const t of this.exportAllModules)
          if (t instanceof ne)
            e2.add(`*${t.id}`);
          else
            for (const s2 of t.getAllExportNames())
              s2 !== "default" && e2.add(s2);
        return e2;
      }
      getDependenciesToBeIncluded() {
        if (this.relevantDependencies)
          return this.relevantDependencies;
        const e2 = new Set(), t = new Set(), s2 = new Set();
        let i2 = this.imports.keys();
        if (this.info.isEntry || this.includedDynamicImporters.length > 0 || this.namespace.included || this.implicitlyLoadedAfter.size > 0) {
          i2 = new Set(i2);
          for (const e3 of [...this.getReexports(), ...this.getExports()]) {
            const t2 = this.getVariableForExportName(e3);
            t2 && i2.add(t2);
          }
        }
        for (let e3 of i2) {
          const i3 = this.sideEffectDependenciesByVariable.get(e3);
          if (i3)
            for (const e4 of i3)
              s2.add(e4);
          e3 instanceof wi ? e3 = e3.getBaseVariable() : e3 instanceof vi && (e3 = e3.getOriginalVariable()), t.add(e3.module);
        }
        if (this.options.treeshake && this.info.hasModuleSideEffects !== "no-treeshake")
          this.addRelevantSideEffectDependencies(e2, t, s2);
        else
          for (const t2 of this.dependencies)
            e2.add(t2);
        for (const s3 of t)
          e2.add(s3);
        return this.relevantDependencies = e2;
      }
      getExportNamesByVariable() {
        if (this.exportNamesByVariable)
          return this.exportNamesByVariable;
        const e2 = new Map();
        for (const t of this.getAllExportNames()) {
          if (t === this.info.syntheticNamedExports)
            continue;
          let s2 = this.getVariableForExportName(t);
          if (s2 instanceof vi && (s2 = s2.getOriginalVariable()), !s2 || !(s2.included || s2 instanceof H))
            continue;
          const i2 = e2.get(s2);
          i2 ? i2.push(t) : e2.set(s2, [t]);
        }
        return this.exportNamesByVariable = e2;
      }
      getExports() {
        return Object.keys(this.exports);
      }
      getReexports() {
        if (this.transitiveReexports)
          return this.transitiveReexports;
        this.transitiveReexports = [];
        const e2 = new Set();
        for (const t in this.reexportDescriptions)
          e2.add(t);
        for (const t of this.exportAllModules)
          if (t instanceof ne)
            e2.add(`*${t.id}`);
          else
            for (const s2 of [...t.getReexports(), ...t.getExports()])
              s2 !== "default" && e2.add(s2);
        return this.transitiveReexports = [...e2];
      }
      getRenderedExports() {
        const e2 = [], t = [];
        for (const s2 in this.exports) {
          const i2 = this.getVariableForExportName(s2);
          (i2 && i2.included ? e2 : t).push(s2);
        }
        return { removedExports: t, renderedExports: e2 };
      }
      getSyntheticNamespace() {
        return this.syntheticNamespace === null && (this.syntheticNamespace = void 0, this.syntheticNamespace = this.getVariableForExportName(typeof this.info.syntheticNamedExports == "string" ? this.info.syntheticNamedExports : "default")), this.syntheticNamespace ? this.syntheticNamespace : Hs((e2 = this.id, t = this.info.syntheticNamedExports, { code: Ks.SYNTHETIC_NAMED_EXPORTS_NEED_NAMESPACE_EXPORT, id: e2, message: `Module "${se(e2)}" that is marked with 'syntheticNamedExports: ${JSON.stringify(t)}' needs ${typeof t == "string" && t !== "default" ? `an export named "${t}"` : "a default export"} that does not reexport an unresolved named export of the same module.` }));
        var e2, t;
      }
      getVariableForExportName(e2, { importerForSideEffects: t, isExportAllSearch: s2, searchedNamesAndModules: i2, skipExternalNamespaceReexports: n3 } = K) {
        if (e2[0] === "*") {
          if (e2.length === 1)
            return this.namespace;
          return this.graph.modulesById.get(e2.slice(1)).getVariableForExportName("*");
        }
        const r2 = this.reexportDescriptions[e2];
        if (r2) {
          const e3 = Gi(r2.module, r2.localName, t, false, i2, false);
          return e3 ? (t && qi(e3, t, this), e3) : this.error(Zs(r2.localName, this.id, r2.module.id), r2.start);
        }
        const a2 = this.exports[e2];
        if (a2) {
          if (a2 === Ui)
            return this.exportShimVariable;
          const e3 = a2.localName, s3 = this.traceVariable(e3, t);
          return t && (T(t.sideEffectDependenciesByVariable, s3, () => new Set()).add(this), qi(s3, t, this)), s3;
        }
        if (e2 !== "default") {
          const s3 = e2 in this.namespaceReexportsByName ? this.namespaceReexportsByName[e2] : this.getVariableFromNamespaceReexports(e2, t, i2, n3);
          if (n3 || (this.namespaceReexportsByName[e2] = s3), s3)
            return s3;
        }
        if (this.info.syntheticNamedExports) {
          let t2 = this.syntheticExports.get(e2);
          if (!t2) {
            const s3 = this.getSyntheticNamespace();
            return t2 = new wi(this.astContext, e2, s3), this.syntheticExports.set(e2, t2), t2;
          }
          return t2;
        }
        return !s2 && this.options.shimMissingExports ? (this.shimMissingExport(e2), this.exportShimVariable) : null;
      }
      hasEffects() {
        return this.info.hasModuleSideEffects === "no-treeshake" || this.ast.included && this.ast.hasEffects(le());
      }
      include() {
        const e2 = he();
        this.ast.shouldBeIncluded(e2) && this.ast.include(e2, false);
      }
      includeAllExports(e2) {
        this.isExecuted || (ji(this), this.graph.needsTreeshakingPass = true);
        for (const t of this.getExports())
          if (e2 || t !== this.info.syntheticNamedExports) {
            const e3 = this.getVariableForExportName(t);
            e3.deoptimizePath(L), e3.included || this.includeVariable(e3);
          }
        for (const e3 of this.getReexports()) {
          const t = this.getVariableForExportName(e3);
          t && (t.deoptimizePath(L), t.included || this.includeVariable(t), t instanceof H && (t.module.reexported = true));
        }
        e2 && this.namespace.setMergedNamespaces(this.includeAndGetAdditionalMergedNamespaces());
      }
      includeAllInBundle() {
        this.ast.include(he(), true), this.includeAllExports(false);
      }
      isIncluded() {
        return this.ast.included || this.namespace.included || this.importedFromNotTreeshaken;
      }
      linkImports() {
        this.addModulesToImportDescriptions(this.importDescriptions), this.addModulesToImportDescriptions(this.reexportDescriptions);
        for (const e3 in this.exports)
          e3 !== "default" && e3 !== this.info.syntheticNamedExports && (this.exportsAll[e3] = this.id);
        const e2 = [];
        for (const t of this.exportAllSources) {
          const s2 = this.graph.modulesById.get(this.resolvedIds[t].id);
          if (s2 instanceof ne)
            e2.push(s2);
          else {
            this.exportAllModules.push(s2);
            for (const e3 in s2.exportsAll)
              e3 in this.exportsAll ? this.options.onwarn(ei(e3, this, s2)) : this.exportsAll[e3] = s2.exportsAll[e3];
          }
        }
        this.exportAllModules.push(...e2);
      }
      render(e2) {
        const t = this.magicString.clone();
        return this.ast.render(t, e2), this.usesTopLevelAwait = this.astContext.usesTopLevelAwait, t;
      }
      setSource(_a2) {
        var _b = _a2, { ast: e2, code: t, customTransformCache: s2, originalCode: i2, originalSourcemap: n3, resolvedIds: r2, sourcemapChain: a2, transformDependencies: o2, transformFiles: h3 } = _b, l2 = __objRest(_b, ["ast", "code", "customTransformCache", "originalCode", "originalSourcemap", "resolvedIds", "sourcemapChain", "transformDependencies", "transformFiles"]);
        this.info.code = t, this.originalCode = i2, this.originalSourcemap = n3, this.sourcemapChain = a2, h3 && (this.transformFiles = h3), this.transformDependencies = o2, this.customTransformCache = s2, this.updateOptions(l2), Vi("generate ast", 3), e2 || (e2 = this.tryParse()), Bi("generate ast", 3), this.resolvedIds = r2 || Object.create(null);
        const c2 = this.id;
        this.magicString = new b(t, { filename: this.excludeFromSourcemap ? null : c2, indentExclusionRanges: [] }), Vi("analyse ast", 3), this.astContext = { addDynamicImport: this.addDynamicImport.bind(this), addExport: this.addExport.bind(this), addImport: this.addImport.bind(this), addImportMeta: this.addImportMeta.bind(this), code: t, deoptimizationTracker: this.graph.deoptimizationTracker, error: this.error.bind(this), fileName: c2, getExports: this.getExports.bind(this), getModuleExecIndex: () => this.execIndex, getModuleName: this.basename.bind(this), getNodeConstructor: (e3) => Ai[e3] || Ai.UnknownNode, getReexports: this.getReexports.bind(this), importDescriptions: this.importDescriptions, includeAllExports: () => this.includeAllExports(true), includeDynamicImport: this.includeDynamicImport.bind(this), includeVariableInModule: this.includeVariableInModule.bind(this), magicString: this.magicString, module: this, moduleContext: this.context, options: this.options, requestTreeshakingPass: () => this.graph.needsTreeshakingPass = true, traceExport: this.getVariableForExportName.bind(this), traceVariable: this.traceVariable.bind(this), usesTopLevelAwait: false, warn: this.warn.bind(this) }, this.scope = new bi(this.graph.scope, this.astContext), this.namespace = new ki(this.astContext), this.ast = new Kt(e2, { context: this.astContext, type: "Module" }, this.scope), this.info.ast = e2, Bi("analyse ast", 3);
      }
      toJSON() {
        return { ast: this.ast.esTreeNode, code: this.info.code, customTransformCache: this.customTransformCache, dependencies: Array.from(this.dependencies, Ii), id: this.id, meta: this.info.meta, moduleSideEffects: this.info.hasModuleSideEffects, originalCode: this.originalCode, originalSourcemap: this.originalSourcemap, resolvedIds: this.resolvedIds, sourcemapChain: this.sourcemapChain, syntheticNamedExports: this.info.syntheticNamedExports, transformDependencies: this.transformDependencies, transformFiles: this.transformFiles };
      }
      traceVariable(e2, t) {
        const s2 = this.scope.variables.get(e2);
        if (s2)
          return s2;
        if (e2 in this.importDescriptions) {
          const s3 = this.importDescriptions[e2], i2 = s3.module;
          if (i2 instanceof Hi && s3.name === "*")
            return i2.namespace;
          const n3 = i2.getVariableForExportName(s3.name, { importerForSideEffects: t || this });
          return n3 || this.error(Zs(s3.name, this.id, i2.id), s3.start);
        }
        return null;
      }
      tryParse() {
        try {
          return this.graph.contextParse(this.info.code);
        } catch (e2) {
          let t = e2.message.replace(/ \(\d+:\d+\)$/, "");
          return this.id.endsWith(".json") ? t += " (Note that you need @rollup/plugin-json to import JSON files)" : this.id.endsWith(".js") || (t += " (Note that you need plugins to import files that are not JavaScript)"), this.error({ code: "PARSE_ERROR", message: t, parserError: e2 }, e2.pos);
        }
      }
      updateOptions({ meta: e2, moduleSideEffects: t, syntheticNamedExports: s2 }) {
        t != null && (this.info.hasModuleSideEffects = t), s2 != null && (this.info.syntheticNamedExports = s2), e2 != null && Object.assign(this.info.meta, e2);
      }
      warn(e2, t) {
        this.addLocationToLogProps(e2, t), this.options.onwarn(e2);
      }
      addDynamicImport(e2) {
        let t = e2.source;
        t instanceof Xt ? t.quasis.length === 1 && t.quasis[0].value.cooked && (t = t.quasis[0].value.cooked) : t instanceof qt && typeof t.value == "string" && (t = t.value), this.dynamicImports.push({ argument: t, id: null, node: e2, resolution: null });
      }
      addExport(e2) {
        if (e2 instanceof Ht)
          this.exports.default = { identifier: e2.variable.getAssignedVariableName(), localName: "default" };
        else if (e2 instanceof Pe) {
          const t = e2.source.value;
          if (this.sources.add(t), e2.exported) {
            const s2 = e2.exported.name;
            this.reexportDescriptions[s2] = { localName: "*", module: null, source: t, start: e2.start };
          } else
            this.exportAllSources.add(t);
        } else if (e2.source instanceof qt) {
          const t = e2.source.value;
          this.sources.add(t);
          for (const s2 of e2.specifiers) {
            const e3 = s2.exported.name;
            this.reexportDescriptions[e3] = { localName: s2.local.name, module: null, source: t, start: s2.start };
          }
        } else if (e2.declaration) {
          const t = e2.declaration;
          if (t instanceof Qt)
            for (const e3 of t.declarations)
              for (const t2 of ae(e3.id))
                this.exports[t2] = { identifier: null, localName: t2 };
          else {
            const e3 = t.id.name;
            this.exports[e3] = { identifier: null, localName: e3 };
          }
        } else
          for (const t of e2.specifiers) {
            const e3 = t.local.name, s2 = t.exported.name;
            this.exports[s2] = { identifier: null, localName: e3 };
          }
      }
      addImport(e2) {
        const t = e2.source.value;
        this.sources.add(t);
        for (const s2 of e2.specifiers) {
          const e3 = s2.type === "ImportDefaultSpecifier", i2 = s2.type === "ImportNamespaceSpecifier", n3 = e3 ? "default" : i2 ? "*" : s2.imported.name;
          this.importDescriptions[s2.local.name] = { module: null, name: n3, source: t, start: s2.start };
        }
      }
      addImportMeta(e2) {
        this.importMetas.push(e2);
      }
      addLocationToLogProps(e2, t) {
        e2.id = this.id, e2.pos = t;
        let s2 = this.info.code;
        const i2 = oe(s2, t, { offsetLine: 1 });
        if (i2) {
          let { column: n3, line: r2 } = i2;
          try {
            ({ column: n3, line: r2 } = function(e3, t2) {
              const s3 = e3.filter((e4) => !!e4.mappings);
              for (; s3.length > 0; ) {
                const e4 = s3.pop(), i3 = e4.mappings[t2.line - 1];
                let n4 = false;
                if (i3 !== void 0) {
                  for (const s4 of i3)
                    if (s4[0] >= t2.column) {
                      if (s4.length === 1)
                        break;
                      t2 = { column: s4[3], line: s4[2] + 1, name: s4.length === 5 ? e4.names[s4[4]] : void 0, source: e4.sources[s4[1]] }, n4 = true;
                      break;
                    }
                }
                if (!n4)
                  throw new Error("Can't resolve original location of error.");
              }
              return t2;
            }(this.sourcemapChain, { column: n3, line: r2 })), s2 = this.originalCode;
          } catch (e3) {
            this.options.onwarn({ code: "SOURCEMAP_ERROR", id: this.id, loc: { column: n3, file: this.id, line: r2 }, message: `Error when using sourcemap for reporting an error: ${e3.message}`, pos: t });
          }
          qs2(e2, { column: n3, line: r2 }, s2, this.id);
        }
      }
      addModulesToImportDescriptions(e2) {
        for (const t of Object.values(e2)) {
          const e3 = this.resolvedIds[t.source].id;
          t.module = this.graph.modulesById.get(e3);
        }
      }
      addRelevantSideEffectDependencies(e2, t, s2) {
        const i2 = new Set(), n3 = (r2) => {
          for (const a2 of r2)
            i2.has(a2) || (i2.add(a2), t.has(a2) ? e2.add(a2) : (a2.info.hasModuleSideEffects || s2.has(a2)) && (a2 instanceof ne || a2.hasEffects() ? e2.add(a2) : n3(a2.dependencies)));
        };
        n3(this.dependencies), n3(s2);
      }
      getVariableFromNamespaceReexports(e2, t, s2, i2 = false) {
        let n3 = null;
        const r2 = [{ searchedNamesAndModules: s2, skipExternalNamespaces: true }];
        if (!i2) {
          const e3 = new Map();
          for (const [t2, i3] of s2 || [])
            e3.set(t2, new Set(i3));
          r2.push({ searchedNamesAndModules: e3, skipExternalNamespaces: false });
        }
        for (const { skipExternalNamespaces: s3, searchedNamesAndModules: i3 } of r2) {
          const r3 = new Set();
          for (const a2 of this.exportAllModules)
            if (a2 instanceof Hi || !s3) {
              const o2 = Gi(a2, e2, t, true, i3, s3);
              o2 && (o2 instanceof wi ? n3 || (n3 = o2) : r3.add(o2));
            }
          if (r3.size === 1)
            return [...r3][0];
          if (r3.size > 1) {
            if (s3)
              return null;
            const t2 = [...r3], i4 = t2[0];
            return this.options.onwarn(ti(e2, this.id, i4.module.id, t2.map((e3) => e3.module.id))), i4;
          }
        }
        return n3 || null;
      }
      includeAndGetAdditionalMergedNamespaces() {
        const e2 = new Set(), t = new Set();
        for (const s2 of [this, ...this.exportAllModules])
          if (s2 instanceof ne) {
            const t2 = s2.getVariableForExportName("*");
            t2.include(), this.imports.add(t2), e2.add(t2);
          } else if (s2.info.syntheticNamedExports) {
            const e3 = s2.getSyntheticNamespace();
            e3.include(), this.imports.add(e3), t.add(e3);
          }
        return [...t, ...e2];
      }
      includeDynamicImport(e2) {
        const t = this.dynamicImports.find((t2) => t2.node === e2).resolution;
        t instanceof Hi && (t.includedDynamicImporters.push(this), t.includeAllExports(true));
      }
      includeVariable(e2) {
        if (!e2.included) {
          e2.include(), this.graph.needsTreeshakingPass = true;
          const t = e2.module;
          if (t && t instanceof Hi && (t.isExecuted || ji(t), t !== this)) {
            const t2 = function(e3, t3) {
              const s2 = T(t3.sideEffectDependenciesByVariable, e3, () => new Set());
              let i2 = e3;
              const n3 = new Set([i2]);
              for (; ; ) {
                const e4 = i2.module;
                if (i2 = i2 instanceof vi ? i2.getDirectOriginalVariable() : i2 instanceof wi ? i2.syntheticNamespace : null, !i2 || n3.has(i2))
                  break;
                n3.add(i2), s2.add(e4);
                const t4 = e4.sideEffectDependenciesByVariable.get(i2);
                if (t4)
                  for (const e5 of t4)
                    s2.add(e5);
              }
              return s2;
            }(e2, this);
            for (const e3 of t2)
              e3.isExecuted || ji(e3);
          }
        }
      }
      includeVariableInModule(e2) {
        this.includeVariable(e2);
        const t = e2.module;
        t && t !== this && this.imports.add(e2);
      }
      shimMissingExport(e2) {
        this.options.onwarn({ code: "SHIMMED_EXPORT", exporter: se(this.id), exportName: e2, message: `Missing export "${e2}" has been shimmed in module ${se(this.id)}.` }), this.exports[e2] = Ui;
      }
    };
    Ji = (e2, t, s2, { _: i2, getDirectReturnFunction: n3, n: r2 }) => {
      if (t) {
        const [t2, a2] = n3([], { functionReturn: true, lineBreakIndent: null, name: null });
        return `Object.defineProperty(exports,${i2}k,${i2}{${r2}${s2}${s2}enumerable:${i2}true,${r2}${s2}${s2}get:${i2}${t2}${e2}[k]${a2}${r2}${s2}})`;
      }
      return `exports[k]${i2}=${i2}${e2}[k]`;
    };
    sn = { assert: true, buffer: true, console: true, constants: true, domain: true, events: true, http: true, https: true, os: true, path: true, process: true, punycode: true, querystring: true, stream: true, string_decoder: true, timers: true, tty: true, url: true, util: true, vm: true, zlib: true };
    rn = (e2, t) => e2.split(".").map(t).join("");
    hn = ({ dependencies: e2, exports: t }) => {
      const s2 = new Set(t.map((e3) => e3.exported));
      s2.add("default");
      for (const { reexports: t2 } of e2)
        if (t2)
          for (const e3 of t2)
            e3.reexported !== "*" && s2.add(e3.reexported);
      return s2;
    };
    ln = (e2, t, { _: s2, cnst: i2, getObject: n3, n: r2 }) => e2 ? `${r2}${t}${i2} _starExcludes${s2}=${s2}${n3([...e2].map((e3) => [e3, "1"]), { lineBreakIndent: { base: t, t } })};` : "";
    cn = (e2, t, { _: s2, n: i2 }) => e2.length ? `${i2}${t}var ${e2.join(`,${s2}`)};` : "";
    un = (e2, t, s2) => dn(e2.filter((e3) => e3.hoisted).map((e3) => ({ name: e3.exported, value: e3.local })), t, s2);
    pn = (e2, t, s2) => dn(e2.filter((e3) => e3.expression).map((e3) => ({ name: e3.exported, value: e3.local })), t, s2);
    fn = (e2, t, s2) => dn(e2.filter((e3) => e3.local === "_missingExportShim").map((e3) => ({ name: e3.exported, value: "_missingExportShim" })), t, s2);
    gn = { amd: function(e2, { accessedGlobals: t, dependencies: s2, exports: i2, hasExports: n3, id: r2, indent: a2, intro: o2, isEntryFacade: h3, isModuleFacade: l2, namedExportsMode: c2, outro: u2, snippets: d3, warn: p2 }, { amd: f2, esModule: m3, externalLiveBindings: g2, freeze: y3, interop: E3, namespaceToStringTag: x2, strict: v2 }) {
      nn(p2, s2);
      const b2 = s2.map((e3) => `'${tn(e3.id)}'`), S2 = s2.map((e3) => e3.name), { n: A3, getNonArrowFunctionIntro: P2, _: k2 } = d3;
      c2 && n3 && (S2.unshift("exports"), b2.unshift("'exports'")), t.has("require") && (S2.unshift("require"), b2.unshift("'require'")), t.has("module") && (S2.unshift("module"), b2.unshift("'module'"));
      const w3 = Xi(f2, r2), C3 = (w3 ? `'${w3}',${k2}` : "") + (b2.length ? `[${b2.join(`,${k2}`)}],${k2}` : ""), I2 = v2 ? `${k2}'use strict';` : "";
      e2.prepend(`${o2}${en(s2, E3, g2, y3, x2, t, a2, d3)}`);
      const N2 = Yi(i2, s2, c2, E3, d3, a2, g2);
      let _2 = Zi(c2 && n3, h3 && m3, l2 && x2, k2, A3);
      return _2 && (_2 = A3 + A3 + _2), e2.append(`${N2}${_2}${u2}`), e2.indent(a2).prepend(`${f2.define}(${C3}(${P2(S2, { isAsync: false, name: null })}{${I2}${A3}${A3}`).append(`${A3}${A3}}));`);
    }, cjs: function(e2, { accessedGlobals: t, dependencies: s2, exports: i2, hasExports: n3, indent: r2, intro: a2, isEntryFacade: o2, isModuleFacade: h3, namedExportsMode: l2, outro: c2, snippets: u2 }, { compact: d3, esModule: p2, externalLiveBindings: f2, freeze: m3, interop: g2, namespaceToStringTag: y3, strict: E3 }) {
      const { _: x2, n: v2 } = u2, b2 = E3 ? `'use strict';${v2}${v2}` : "";
      let S2 = Zi(l2 && n3, o2 && p2, h3 && y3, x2, v2);
      S2 && (S2 += v2 + v2);
      const A3 = function(e3, { _: t2, cnst: s3, n: i3 }, n4) {
        let r3 = "", a3 = false;
        for (const { id: o3, name: h4, reexports: l3, imports: c3 } of e3)
          l3 || c3 ? (r3 += n4 && a3 ? "," : `${r3 ? `;${i3}` : ""}${s3} `, a3 = true, r3 += `${h4}${t2}=${t2}require('${o3}')`) : (r3 && (r3 += n4 && !a3 ? "," : `;${i3}`), a3 = false, r3 += `require('${o3}')`);
        if (r3)
          return `${r3};${i3}${i3}`;
        return "";
      }(s2, u2, d3), P2 = en(s2, g2, f2, m3, y3, t, r2, u2);
      e2.prepend(`${b2}${a2}${S2}${A3}${P2}`);
      const k2 = Yi(i2, s2, l2, g2, u2, r2, f2, `module.exports${x2}=${x2}`);
      return e2.append(`${k2}${c2}`);
    }, es: function(e2, { accessedGlobals: t, indent: s2, intro: i2, outro: n3, dependencies: r2, exports: a2, snippets: o2 }, { externalLiveBindings: h3, freeze: l2, namespaceToStringTag: c2 }) {
      const { _: u2, n: d3 } = o2, p2 = function(e3, t2) {
        const s3 = [];
        for (const { id: i3, reexports: n4, imports: r3, name: a3 } of e3)
          if (n4 || r3) {
            if (r3) {
              let e4 = null, n5 = null;
              const a4 = [];
              for (const t3 of r3)
                t3.imported === "default" ? e4 = t3 : t3.imported === "*" ? n5 = t3 : a4.push(t3);
              n5 && s3.push(`import${t2}*${t2}as ${n5.local} from${t2}'${i3}';`), e4 && a4.length === 0 ? s3.push(`import ${e4.local} from${t2}'${i3}';`) : a4.length > 0 && s3.push(`import ${e4 ? `${e4.local},${t2}` : ""}{${t2}${a4.map((e5) => e5.imported === e5.local ? e5.imported : `${e5.imported} as ${e5.local}`).join(`,${t2}`)}${t2}}${t2}from${t2}'${i3}';`);
            }
            if (n4) {
              let e4 = null;
              const o3 = [], h4 = [];
              for (const t3 of n4)
                t3.reexported === "*" ? e4 = t3 : t3.imported === "*" ? o3.push(t3) : h4.push(t3);
              if (e4 && s3.push(`export${t2}*${t2}from${t2}'${i3}';`), o3.length > 0) {
                r3 && r3.some((e5) => e5.imported === "*" && e5.local === a3) || s3.push(`import${t2}*${t2}as ${a3} from${t2}'${i3}';`);
                for (const e5 of o3)
                  s3.push(`export${t2}{${t2}${a3 === e5.reexported ? a3 : `${a3} as ${e5.reexported}`} };`);
              }
              h4.length > 0 && s3.push(`export${t2}{${t2}${h4.map((e5) => e5.imported === e5.reexported ? e5.imported : `${e5.imported} as ${e5.reexported}`).join(`,${t2}`)}${t2}}${t2}from${t2}'${i3}';`);
            }
          } else
            s3.push(`import${t2}'${i3}';`);
        return s3;
      }(r2, u2);
      p2.length > 0 && (i2 += p2.join(d3) + d3 + d3), (i2 += _s(null, t, s2, o2, h3, l2, c2)) && e2.prepend(i2);
      const f2 = function(e3, { _: t2, cnst: s3 }) {
        const i3 = [], n4 = [];
        for (const r3 of e3)
          r3.expression && i3.push(`${s3} ${r3.local}${t2}=${t2}${r3.expression};`), n4.push(r3.exported === r3.local ? r3.local : `${r3.local} as ${r3.exported}`);
        n4.length && i3.push(`export${t2}{${t2}${n4.join(`,${t2}`)}${t2}};`);
        return i3;
      }(a2, o2);
      return f2.length && e2.append(d3 + d3 + f2.join(d3).trim()), n3 && e2.append(n3), e2.trim();
    }, iife: function(e2, { accessedGlobals: t, dependencies: s2, exports: i2, hasExports: n3, indent: r2, intro: a2, namedExportsMode: o2, outro: h3, snippets: l2, warn: c2 }, { compact: u2, esModule: d3, extend: p2, freeze: f2, externalLiveBindings: m3, globals: g2, interop: y3, name: E3, namespaceToStringTag: x2, strict: v2 }) {
      const { _: b2, cnst: S2, getNonArrowFunctionIntro: A3, getPropertyAccess: P2, n: k2 } = l2, w3 = E3 && E3.indexOf(".") !== -1, C3 = !p2 && !w3;
      if (E3 && C3 && (Z(I2 = E3) || Y.has(I2) || Q2.test(I2)))
        return Hs({ code: "ILLEGAL_IDENTIFIER_AS_NAME", message: `Given name "${E3}" is not a legal JS identifier. If you need this, you can try "output.extend: true".` });
      var I2;
      nn(c2, s2);
      const N2 = on(s2), _2 = N2.map((e3) => e3.globalName || "null"), $2 = N2.map((e3) => e3.name);
      n3 && !E3 && c2({ code: "MISSING_NAME_OPTION_FOR_IIFE_EXPORT", message: 'If you do not supply "output.name", you may not be able to access the exports of an IIFE bundle.' }), o2 && n3 && (p2 ? (_2.unshift(`this${rn(E3, P2)}${b2}=${b2}this${rn(E3, P2)}${b2}||${b2}{}`), $2.unshift("exports")) : (_2.unshift("{}"), $2.unshift("exports")));
      const T2 = v2 ? `${r2}'use strict';${k2}` : "", R2 = en(s2, y3, m3, f2, x2, t, r2, l2);
      e2.prepend(`${a2}${R2}`);
      let M2 = `(${A3($2, { isAsync: false, name: null })}{${k2}${T2}${k2}`;
      n3 && (!E3 || p2 && o2 || (M2 = (C3 ? `${S2} ${E3}` : `this${rn(E3, P2)}`) + `${b2}=${b2}${M2}`), w3 && (M2 = function(e3, t2, s3, { _: i3, getPropertyAccess: n4, s: r3 }, a3) {
        const o3 = e3.split(".");
        o3[0] = (typeof s3 == "function" ? s3(o3[0]) : s3[o3[0]]) || o3[0], o3.pop();
        let h4 = t2;
        return o3.map((e4) => (h4 += n4(e4), `${h4}${i3}=${i3}${h4}${i3}||${i3}{}${r3}`)).join(a3 ? "," : "\n") + (a3 && o3.length ? ";" : "\n");
      }(E3, "this", g2, l2, u2) + M2));
      let D2 = `${k2}${k2}})(${_2.join(`,${b2}`)});`;
      n3 && !p2 && o2 && (D2 = `${k2}${k2}${r2}return exports;${D2}`);
      const L2 = Yi(i2, s2, o2, y3, l2, r2, m3);
      let O2 = Zi(o2 && n3, d3, x2, b2, k2);
      return O2 && (O2 = k2 + k2 + O2), e2.append(`${L2}${O2}${h3}`), e2.indent(r2).prepend(M2).append(D2);
    }, system: function(e2, { accessedGlobals: t, dependencies: s2, exports: i2, hasExports: n3, indent: r2, intro: a2, snippets: o2, outro: h3, usesTopLevelAwait: l2 }, { externalLiveBindings: c2, freeze: u2, name: d3, namespaceToStringTag: p2, strict: f2, systemNullSetters: m3 }) {
      const { _: g2, getFunctionIntro: y3, getNonArrowFunctionIntro: E3, n: x2, s: v2 } = o2, { importBindings: b2, setters: S2, starExcludes: A3 } = function(e3, t2, s3, { _: i3, cnst: n4, getObject: r3, getPropertyAccess: a3, n: o3 }) {
        const h4 = [], l3 = [];
        let c3 = null;
        for (const { imports: u3, reexports: d4 } of e3) {
          const p3 = [];
          if (u3)
            for (const e4 of u3)
              h4.push(e4.local), e4.imported === "*" ? p3.push(`${e4.local}${i3}=${i3}module;`) : p3.push(`${e4.local}${i3}=${i3}module${a3(e4.imported)};`);
          if (d4) {
            const o4 = [];
            let h5 = false;
            for (const { imported: e4, reexported: t3 } of d4)
              t3 === "*" ? h5 = true : o4.push([t3, e4 === "*" ? "module" : `module${a3(e4)}`]);
            if (o4.length > 1 || h5) {
              const a4 = r3(o4, { lineBreakIndent: null });
              h5 ? (c3 || (c3 = hn({ dependencies: e3, exports: t2 })), p3.push(`${n4} setter${i3}=${i3}${a4};`, `for${i3}(${n4} name in module)${i3}{`, `${s3}if${i3}(!_starExcludes[name])${i3}setter[name]${i3}=${i3}module[name];`, "}", "exports(setter);")) : p3.push(`exports(${a4});`);
            } else {
              const [e4, t3] = o4[0];
              p3.push(`exports('${e4}',${i3}${t3});`);
            }
          }
          l3.push(p3.join(`${o3}${s3}${s3}${s3}`));
        }
        return { importBindings: h4, setters: l3, starExcludes: c3 };
      }(s2, i2, r2, o2), P2 = d3 ? `'${d3}',${g2}` : "", k2 = t.has("module") ? ["exports", "module"] : n3 ? ["exports"] : [];
      let w3 = `System.register(${P2}[` + s2.map(({ id: e3 }) => `'${e3}'`).join(`,${g2}`) + `],${g2}(${E3(k2, { isAsync: false, name: null })}{${x2}${r2}${f2 ? "'use strict';" : ""}` + ln(A3, r2, o2) + cn(b2, r2, o2) + `${x2}${r2}return${g2}{${S2.length ? `${x2}${r2}${r2}setters:${g2}[${S2.map((e3) => e3 ? `${y3(["module"], { isAsync: false, name: null })}{${x2}${r2}${r2}${r2}${e3}${x2}${r2}${r2}}` : m3 ? "null" : `${y3([], { isAsync: false, name: null })}{}`).join(`,${g2}`)}],` : ""}${x2}`;
      w3 += `${r2}${r2}execute:${g2}(${E3([], { isAsync: l2, name: null })}{${x2}${x2}`;
      const C3 = `${r2}${r2}})${x2}${r2}}${v2}${x2}}));`;
      return e2.prepend(a2 + _s(null, t, r2, o2, c2, u2, p2) + un(i2, r2, o2)), e2.append(`${h3}${x2}${x2}` + pn(i2, r2, o2) + fn(i2, r2, o2)), e2.indent(`${r2}${r2}${r2}`).append(C3).prepend(w3);
    }, umd: function(e2, { accessedGlobals: t, dependencies: s2, exports: i2, hasExports: n3, id: r2, indent: a2, intro: o2, namedExportsMode: h3, outro: l2, snippets: c2, warn: u2 }, { amd: d3, compact: p2, esModule: f2, extend: m3, externalLiveBindings: g2, freeze: y3, interop: E3, name: x2, namespaceToStringTag: v2, globals: b2, noConflict: S2, strict: A3 }) {
      const { _: P2, cnst: k2, getFunctionIntro: w3, getNonArrowFunctionIntro: C3, getPropertyAccess: I2, n: N2, s: _2 } = c2, $2 = p2 ? "f" : "factory", T2 = p2 ? "g" : "global";
      if (n3 && !x2)
        return Hs({ code: "MISSING_NAME_OPTION_FOR_IIFE_EXPORT", message: 'You must supply "output.name" for UMD bundles that have exports so that the exports are accessible in environments without a module loader.' });
      nn(u2, s2);
      const R2 = s2.map((e3) => `'${tn(e3.id)}'`), M2 = s2.map((e3) => `require('${e3.id}')`), D2 = on(s2), L2 = D2.map((e3) => mn(e3.globalName, T2, I2)), O2 = D2.map((e3) => e3.name);
      h3 && (n3 || S2) && (R2.unshift("'exports'"), M2.unshift("exports"), L2.unshift(an(x2, T2, b2, (m3 ? `${mn(x2, T2, I2)}${P2}||${P2}` : "") + "{}", c2)), O2.unshift("exports"));
      const V2 = Xi(d3, r2), B3 = (V2 ? `'${V2}',${P2}` : "") + (R2.length ? `[${R2.join(`,${P2}`)}],${P2}` : ""), F2 = d3.define, z2 = !h3 && n3 ? `module.exports${P2}=${P2}` : "", W2 = A3 ? `${P2}'use strict';${N2}` : "";
      let j2;
      if (S2) {
        const e3 = p2 ? "e" : "exports";
        let t2;
        if (!h3 && n3)
          t2 = `${k2} ${e3}${P2}=${P2}${an(x2, T2, b2, `${$2}(${L2.join(`,${P2}`)})`, c2)};`;
        else {
          t2 = `${k2} ${e3}${P2}=${P2}${L2.shift()};${N2}${a2}${a2}${$2}(${[e3].concat(L2).join(`,${P2}`)});`;
        }
        j2 = `(${w3([], { isAsync: false, name: null })}{${N2}${a2}${a2}${k2} current${P2}=${P2}${function(e4, t3, { _: s3, getPropertyAccess: i3 }) {
          let n4 = t3;
          return e4.split(".").map((e5) => n4 += i3(e5)).join(`${s3}&&${s3}`);
        }(x2, T2, c2)};${N2}${a2}${a2}${t2}${N2}${a2}${a2}${e3}.noConflict${P2}=${P2}${w3([], { isAsync: false, name: null })}{${P2}${mn(x2, T2, I2)}${P2}=${P2}current;${P2}return ${e3}${_2}${P2}};${N2}${a2}})()`;
      } else
        j2 = `${$2}(${L2.join(`,${P2}`)})`, !h3 && n3 && (j2 = an(x2, T2, b2, j2, c2));
      const U2 = n3 || S2 && h3 || L2.length > 0, G2 = [$2];
      U2 && G2.unshift(T2);
      const H2 = U2 ? `this,${P2}` : "", q2 = U2 ? `(${T2}${P2}=${P2}typeof globalThis${P2}!==${P2}'undefined'${P2}?${P2}globalThis${P2}:${P2}${T2}${P2}||${P2}self,${P2}` : "", K2 = U2 ? ")" : "", X2 = U2 ? `${a2}typeof exports${P2}===${P2}'object'${P2}&&${P2}typeof module${P2}!==${P2}'undefined'${P2}?${P2}${z2}${$2}(${M2.join(`,${P2}`)})${P2}:${N2}` : "", Y2 = `(${C3(G2, { isAsync: false, name: null })}{${N2}` + X2 + `${a2}typeof ${F2}${P2}===${P2}'function'${P2}&&${P2}${F2}.amd${P2}?${P2}${F2}(${B3}${$2})${P2}:${N2}${a2}${q2}${j2}${K2};${N2}})(${H2}(${C3(O2, { isAsync: false, name: null })}{${W2}${N2}`, Q3 = N2 + N2 + "}));";
      e2.prepend(`${o2}${en(s2, E3, g2, y3, v2, t, a2, c2)}`);
      const Z2 = Yi(i2, s2, h3, E3, c2, a2, g2);
      let J2 = Zi(h3 && n3, f2, v2, P2, N2);
      return J2 && (J2 = N2 + N2 + J2), e2.append(`${Z2}${J2}${l2}`), e2.trim().indent(a2).append(Q3).prepend(Y2);
    } };
    yn = class {
      constructor(e2, t) {
        this.isOriginal = true, this.filename = e2, this.content = t;
      }
      traceSegment(e2, t, s2) {
        return { column: t, line: e2, name: s2, source: this };
      }
    };
    En = class {
      constructor(e2, t) {
        this.sources = t, this.names = e2.names, this.mappings = e2.mappings;
      }
      traceMappings() {
        const e2 = [], t = [], s2 = [], i2 = new Map(), n3 = [];
        for (const r2 of this.mappings) {
          const a2 = [];
          for (const n4 of r2) {
            if (n4.length == 1)
              continue;
            const r3 = this.sources[n4[1]];
            if (!r3)
              continue;
            const o2 = r3.traceSegment(n4[2], n4[3], n4.length === 5 ? this.names[n4[4]] : "");
            if (o2) {
              let r4 = e2.lastIndexOf(o2.source.filename);
              if (r4 === -1)
                r4 = e2.length, e2.push(o2.source.filename), t[r4] = o2.source.content;
              else if (t[r4] == null)
                t[r4] = o2.source.content;
              else if (o2.source.content != null && t[r4] !== o2.source.content)
                return Hs({ message: `Multiple conflicting contents for sourcemap source ${o2.source.filename}` });
              const h3 = [n4[0], r4, o2.line, o2.column];
              if (o2.name) {
                let e3 = i2.get(o2.name);
                e3 === void 0 && (e3 = s2.length, s2.push(o2.name), i2.set(o2.name, e3)), h3[4] = e3;
              }
              a2.push(h3);
            }
          }
          n3.push(a2);
        }
        return { mappings: n3, names: s2, sources: e2, sourcesContent: t };
      }
      traceSegment(e2, t, s2) {
        const i2 = this.mappings[e2];
        if (!i2)
          return null;
        let n3 = 0, r2 = i2.length - 1;
        for (; n3 <= r2; ) {
          const e3 = n3 + r2 >> 1, a2 = i2[e3];
          if (a2[0] === t) {
            if (a2.length == 1)
              return null;
            const e4 = this.sources[a2[1]];
            return e4 ? e4.traceSegment(a2[2], a2[3], a2.length === 5 ? this.names[a2[4]] : s2) : null;
          }
          a2[0] > t ? r2 = e3 - 1 : n3 = e3 + 1;
        }
        return null;
      }
    };
    bn = {};
    Sn = An;
    An.equal = function(e2, t, s2) {
      if (e2 != t)
        throw new Error(s2 || "Assertion failed: " + e2 + " != " + t);
    };
    Pn = { exports: {} };
    typeof Object.create == "function" ? Pn.exports = function(e2, t) {
      t && (e2.super_ = t, e2.prototype = Object.create(t.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } }));
    } : Pn.exports = function(e2, t) {
      if (t) {
        e2.super_ = t;
        var s2 = function() {
        };
        s2.prototype = t.prototype, e2.prototype = new s2(), e2.prototype.constructor = e2;
      }
    };
    kn = Sn;
    wn = Pn.exports;
    bn.inherits = wn, bn.toArray = function(e2, t) {
      if (Array.isArray(e2))
        return e2.slice();
      if (!e2)
        return [];
      var s2 = [];
      if (typeof e2 == "string")
        if (t) {
          if (t === "hex")
            for ((e2 = e2.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (e2 = "0" + e2), n3 = 0; n3 < e2.length; n3 += 2)
              s2.push(parseInt(e2[n3] + e2[n3 + 1], 16));
        } else
          for (var i2 = 0, n3 = 0; n3 < e2.length; n3++) {
            var r2 = e2.charCodeAt(n3);
            r2 < 128 ? s2[i2++] = r2 : r2 < 2048 ? (s2[i2++] = r2 >> 6 | 192, s2[i2++] = 63 & r2 | 128) : Cn(e2, n3) ? (r2 = 65536 + ((1023 & r2) << 10) + (1023 & e2.charCodeAt(++n3)), s2[i2++] = r2 >> 18 | 240, s2[i2++] = r2 >> 12 & 63 | 128, s2[i2++] = r2 >> 6 & 63 | 128, s2[i2++] = 63 & r2 | 128) : (s2[i2++] = r2 >> 12 | 224, s2[i2++] = r2 >> 6 & 63 | 128, s2[i2++] = 63 & r2 | 128);
          }
      else
        for (n3 = 0; n3 < e2.length; n3++)
          s2[n3] = 0 | e2[n3];
      return s2;
    }, bn.toHex = function(e2) {
      for (var t = "", s2 = 0; s2 < e2.length; s2++)
        t += Nn(e2[s2].toString(16));
      return t;
    }, bn.htonl = In, bn.toHex32 = function(e2, t) {
      for (var s2 = "", i2 = 0; i2 < e2.length; i2++) {
        var n3 = e2[i2];
        t === "little" && (n3 = In(n3)), s2 += _n(n3.toString(16));
      }
      return s2;
    }, bn.zero2 = Nn, bn.zero8 = _n, bn.join32 = function(e2, t, s2, i2) {
      var n3 = s2 - t;
      kn(n3 % 4 == 0);
      for (var r2 = new Array(n3 / 4), a2 = 0, o2 = t; a2 < r2.length; a2++, o2 += 4) {
        var h3;
        h3 = i2 === "big" ? e2[o2] << 24 | e2[o2 + 1] << 16 | e2[o2 + 2] << 8 | e2[o2 + 3] : e2[o2 + 3] << 24 | e2[o2 + 2] << 16 | e2[o2 + 1] << 8 | e2[o2], r2[a2] = h3 >>> 0;
      }
      return r2;
    }, bn.split32 = function(e2, t) {
      for (var s2 = new Array(4 * e2.length), i2 = 0, n3 = 0; i2 < e2.length; i2++, n3 += 4) {
        var r2 = e2[i2];
        t === "big" ? (s2[n3] = r2 >>> 24, s2[n3 + 1] = r2 >>> 16 & 255, s2[n3 + 2] = r2 >>> 8 & 255, s2[n3 + 3] = 255 & r2) : (s2[n3 + 3] = r2 >>> 24, s2[n3 + 2] = r2 >>> 16 & 255, s2[n3 + 1] = r2 >>> 8 & 255, s2[n3] = 255 & r2);
      }
      return s2;
    }, bn.rotr32 = function(e2, t) {
      return e2 >>> t | e2 << 32 - t;
    }, bn.rotl32 = function(e2, t) {
      return e2 << t | e2 >>> 32 - t;
    }, bn.sum32 = function(e2, t) {
      return e2 + t >>> 0;
    }, bn.sum32_3 = function(e2, t, s2) {
      return e2 + t + s2 >>> 0;
    }, bn.sum32_4 = function(e2, t, s2, i2) {
      return e2 + t + s2 + i2 >>> 0;
    }, bn.sum32_5 = function(e2, t, s2, i2, n3) {
      return e2 + t + s2 + i2 + n3 >>> 0;
    }, bn.sum64 = function(e2, t, s2, i2) {
      var n3 = e2[t], r2 = i2 + e2[t + 1] >>> 0, a2 = (r2 < i2 ? 1 : 0) + s2 + n3;
      e2[t] = a2 >>> 0, e2[t + 1] = r2;
    }, bn.sum64_hi = function(e2, t, s2, i2) {
      return (t + i2 >>> 0 < t ? 1 : 0) + e2 + s2 >>> 0;
    }, bn.sum64_lo = function(e2, t, s2, i2) {
      return t + i2 >>> 0;
    }, bn.sum64_4_hi = function(e2, t, s2, i2, n3, r2, a2, o2) {
      var h3 = 0, l2 = t;
      return h3 += (l2 = l2 + i2 >>> 0) < t ? 1 : 0, h3 += (l2 = l2 + r2 >>> 0) < r2 ? 1 : 0, e2 + s2 + n3 + a2 + (h3 += (l2 = l2 + o2 >>> 0) < o2 ? 1 : 0) >>> 0;
    }, bn.sum64_4_lo = function(e2, t, s2, i2, n3, r2, a2, o2) {
      return t + i2 + r2 + o2 >>> 0;
    }, bn.sum64_5_hi = function(e2, t, s2, i2, n3, r2, a2, o2, h3, l2) {
      var c2 = 0, u2 = t;
      return c2 += (u2 = u2 + i2 >>> 0) < t ? 1 : 0, c2 += (u2 = u2 + r2 >>> 0) < r2 ? 1 : 0, c2 += (u2 = u2 + o2 >>> 0) < o2 ? 1 : 0, e2 + s2 + n3 + a2 + h3 + (c2 += (u2 = u2 + l2 >>> 0) < l2 ? 1 : 0) >>> 0;
    }, bn.sum64_5_lo = function(e2, t, s2, i2, n3, r2, a2, o2, h3, l2) {
      return t + i2 + r2 + o2 + l2 >>> 0;
    }, bn.rotr64_hi = function(e2, t, s2) {
      return (t << 32 - s2 | e2 >>> s2) >>> 0;
    }, bn.rotr64_lo = function(e2, t, s2) {
      return (e2 << 32 - s2 | t >>> s2) >>> 0;
    }, bn.shr64_hi = function(e2, t, s2) {
      return e2 >>> s2;
    }, bn.shr64_lo = function(e2, t, s2) {
      return (e2 << 32 - s2 | t >>> s2) >>> 0;
    };
    $n = {};
    Tn = bn;
    Rn = Sn;
    $n.BlockHash = Mn, Mn.prototype.update = function(e2, t) {
      if (e2 = Tn.toArray(e2, t), this.pending ? this.pending = this.pending.concat(e2) : this.pending = e2, this.pendingTotal += e2.length, this.pending.length >= this._delta8) {
        var s2 = (e2 = this.pending).length % this._delta8;
        this.pending = e2.slice(e2.length - s2, e2.length), this.pending.length === 0 && (this.pending = null), e2 = Tn.join32(e2, 0, e2.length - s2, this.endian);
        for (var i2 = 0; i2 < e2.length; i2 += this._delta32)
          this._update(e2, i2, i2 + this._delta32);
      }
      return this;
    }, Mn.prototype.digest = function(e2) {
      return this.update(this._pad()), Rn(this.pending === null), this._digest(e2);
    }, Mn.prototype._pad = function() {
      var e2 = this.pendingTotal, t = this._delta8, s2 = t - (e2 + this.padLength) % t, i2 = new Array(s2 + this.padLength);
      i2[0] = 128;
      for (var n3 = 1; n3 < s2; n3++)
        i2[n3] = 0;
      if (e2 <<= 3, this.endian === "big") {
        for (var r2 = 8; r2 < this.padLength; r2++)
          i2[n3++] = 0;
        i2[n3++] = 0, i2[n3++] = 0, i2[n3++] = 0, i2[n3++] = 0, i2[n3++] = e2 >>> 24 & 255, i2[n3++] = e2 >>> 16 & 255, i2[n3++] = e2 >>> 8 & 255, i2[n3++] = 255 & e2;
      } else
        for (i2[n3++] = 255 & e2, i2[n3++] = e2 >>> 8 & 255, i2[n3++] = e2 >>> 16 & 255, i2[n3++] = e2 >>> 24 & 255, i2[n3++] = 0, i2[n3++] = 0, i2[n3++] = 0, i2[n3++] = 0, r2 = 8; r2 < this.padLength; r2++)
          i2[n3++] = 0;
      return i2;
    };
    Dn = {};
    Ln = bn.rotr32;
    Dn.ft_1 = function(e2, t, s2, i2) {
      return e2 === 0 ? On(t, s2, i2) : e2 === 1 || e2 === 3 ? Bn(t, s2, i2) : e2 === 2 ? Vn(t, s2, i2) : void 0;
    }, Dn.ch32 = On, Dn.maj32 = Vn, Dn.p32 = Bn, Dn.s0_256 = function(e2) {
      return Ln(e2, 2) ^ Ln(e2, 13) ^ Ln(e2, 22);
    }, Dn.s1_256 = function(e2) {
      return Ln(e2, 6) ^ Ln(e2, 11) ^ Ln(e2, 25);
    }, Dn.g0_256 = function(e2) {
      return Ln(e2, 7) ^ Ln(e2, 18) ^ e2 >>> 3;
    }, Dn.g1_256 = function(e2) {
      return Ln(e2, 17) ^ Ln(e2, 19) ^ e2 >>> 10;
    };
    Fn = bn;
    zn = $n;
    Wn = Dn;
    jn = Sn;
    Un = Fn.sum32;
    Gn = Fn.sum32_4;
    Hn = Fn.sum32_5;
    qn = Wn.ch32;
    Kn = Wn.maj32;
    Xn = Wn.s0_256;
    Yn = Wn.s1_256;
    Qn = Wn.g0_256;
    Zn = Wn.g1_256;
    Jn = zn.BlockHash;
    er = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    Fn.inherits(tr, Jn);
    sr = tr;
    tr.blockSize = 512, tr.outSize = 256, tr.hmacStrength = 192, tr.padLength = 64, tr.prototype._update = function(e2, t) {
      for (var s2 = this.W, i2 = 0; i2 < 16; i2++)
        s2[i2] = e2[t + i2];
      for (; i2 < s2.length; i2++)
        s2[i2] = Gn(Zn(s2[i2 - 2]), s2[i2 - 7], Qn(s2[i2 - 15]), s2[i2 - 16]);
      var n3 = this.h[0], r2 = this.h[1], a2 = this.h[2], o2 = this.h[3], h3 = this.h[4], l2 = this.h[5], c2 = this.h[6], u2 = this.h[7];
      for (jn(this.k.length === s2.length), i2 = 0; i2 < s2.length; i2++) {
        var d3 = Hn(u2, Yn(h3), qn(h3, l2, c2), this.k[i2], s2[i2]), p2 = Un(Xn(n3), Kn(n3, r2, a2));
        u2 = c2, c2 = l2, l2 = h3, h3 = Un(o2, d3), o2 = a2, a2 = r2, r2 = n3, n3 = Un(d3, p2);
      }
      this.h[0] = Un(this.h[0], n3), this.h[1] = Un(this.h[1], r2), this.h[2] = Un(this.h[2], a2), this.h[3] = Un(this.h[3], o2), this.h[4] = Un(this.h[4], h3), this.h[5] = Un(this.h[5], l2), this.h[6] = Un(this.h[6], c2), this.h[7] = Un(this.h[7], u2);
    }, tr.prototype._digest = function(e2) {
      return e2 === "hex" ? Fn.toHex32(this.h, "big") : Fn.split32(this.h, "big");
    };
    ir = sr;
    nr = () => ir();
    rr = { amd: hr, cjs: hr, es: or, iife: hr, system: or, umd: hr };
    lr = /[\\'\r\n\u2028\u2029]/;
    cr = /(['\r\n\u2028\u2029])/g;
    ur = /\\/g;
    xr = [".js", ".jsx", ".ts", ".tsx"];
    br = class {
      constructor(e2, t, s2, i2, n3, r2, a2, o2, h3, l2) {
        this.orderedModules = e2, this.inputOptions = t, this.outputOptions = s2, this.unsetOptions = i2, this.pluginDriver = n3, this.modulesById = r2, this.chunkByModule = a2, this.facadeChunkByModule = o2, this.includedNamespaces = h3, this.manualChunkAlias = l2, this.entryModules = [], this.exportMode = "named", this.facadeModule = null, this.id = null, this.namespaceVariableName = "", this.needsExportsShim = false, this.variableName = "", this.accessedGlobalsByScope = new Map(), this.dependencies = new Set(), this.dynamicDependencies = new Set(), this.dynamicEntryModules = [], this.dynamicName = null, this.exportNamesByVariable = new Map(), this.exports = new Set(), this.exportsByName = Object.create(null), this.fileName = null, this.implicitEntryModules = [], this.implicitlyLoadedBefore = new Set(), this.imports = new Set(), this.indentString = void 0, this.isEmpty = true, this.name = null, this.renderedDependencies = null, this.renderedExports = null, this.renderedHash = void 0, this.renderedModuleSources = new Map(), this.renderedModules = Object.create(null), this.renderedSource = null, this.sortedExportNames = null, this.strictFacade = false, this.usedModules = void 0, this.execIndex = e2.length > 0 ? e2[0].execIndex : 1 / 0;
        const c2 = new Set(e2);
        for (const t2 of e2) {
          t2.namespace.included && h3.add(t2), this.isEmpty && t2.isIncluded() && (this.isEmpty = false), (t2.info.isEntry || s2.preserveModules) && this.entryModules.push(t2);
          for (const e3 of t2.includedDynamicImporters)
            c2.has(e3) || (this.dynamicEntryModules.push(t2), t2.info.syntheticNamedExports && !s2.preserveModules && (h3.add(t2), this.exports.add(t2.namespace)));
          t2.implicitlyLoadedAfter.size > 0 && this.implicitEntryModules.push(t2);
        }
        this.suggestedVariableName = J(this.generateVariableName());
      }
      static generateFacade(e2, t, s2, i2, n3, r2, a2, o2, h3, l2) {
        const c2 = new br([], e2, t, s2, i2, n3, r2, a2, o2, null);
        c2.assignFacadeName(l2, h3), a2.has(h3) || a2.set(h3, c2);
        for (const e3 of h3.getDependenciesToBeIncluded())
          c2.dependencies.add(e3 instanceof Hi ? r2.get(e3) : e3);
        return !c2.dependencies.has(r2.get(h3)) && h3.info.hasModuleSideEffects && h3.hasEffects() && c2.dependencies.add(r2.get(h3)), c2.ensureReexportsAreAvailableForModule(h3), c2.facadeModule = h3, c2.strictFacade = true, c2;
      }
      canModuleBeFacade(e2, t) {
        const s2 = e2.getExportNamesByVariable();
        for (const t2 of this.exports)
          if (!s2.has(t2))
            return s2.size === 0 && e2.isUserDefinedEntryPoint && e2.preserveSignature === "strict" && this.unsetOptions.has("preserveEntrySignatures") && this.inputOptions.onwarn({ code: "EMPTY_FACADE", id: e2.id, message: `To preserve the export signature of the entry module "${se(e2.id)}", an empty facade chunk was created. This often happens when creating a bundle for a web app where chunks are placed in script tags and exports are ignored. In this case it is recommended to set "preserveEntrySignatures: false" to avoid this and reduce the number of chunks. Otherwise if this is intentional, set "preserveEntrySignatures: 'strict'" explicitly to silence this warning.`, url: "https://rollupjs.org/guide/en/#preserveentrysignatures" }), false;
        for (const i2 of t)
          if (!s2.has(i2) && i2.module !== e2)
            return false;
        return true;
      }
      generateExports() {
        this.sortedExportNames = null;
        const e2 = new Set(this.exports);
        if (this.facadeModule !== null && (this.facadeModule.preserveSignature !== false || this.strictFacade)) {
          const t = this.facadeModule.getExportNamesByVariable();
          for (const [s2, i2] of t) {
            this.exportNamesByVariable.set(s2, [...i2]);
            for (const e3 of i2)
              this.exportsByName[e3] = s2;
            e2.delete(s2);
          }
        }
        this.outputOptions.minifyInternalExports ? function(e3, t, s2) {
          let i2 = 0;
          for (const n3 of e3) {
            let [e4] = n3.name;
            if (t[e4])
              do {
                e4 = tt(++i2), e4.charCodeAt(0) === 49 && (i2 += 9 * 64 ** (e4.length - 1), e4 = tt(i2));
              } while (Y.has(e4) || t[e4]);
            t[e4] = n3, s2.set(n3, [e4]);
          }
        }(e2, this.exportsByName, this.exportNamesByVariable) : function(e3, t, s2) {
          for (const i2 of e3) {
            let e4 = 0, n3 = i2.name;
            for (; t[n3]; )
              n3 = i2.name + "$" + ++e4;
            t[n3] = i2, s2.set(i2, [n3]);
          }
        }(e2, this.exportsByName, this.exportNamesByVariable), (this.outputOptions.preserveModules || this.facadeModule && this.facadeModule.info.isEntry) && (this.exportMode = pr(this, this.outputOptions, this.unsetOptions, this.facadeModule.id, this.inputOptions.onwarn));
      }
      generateFacades() {
        var e2;
        const t = [], s2 = new Set([...this.entryModules, ...this.implicitEntryModules]), i2 = new Set(this.dynamicEntryModules.map((e3) => e3.namespace));
        for (const e3 of s2)
          if (e3.preserveSignature)
            for (const t2 of e3.getExportNamesByVariable().keys())
              i2.add(t2);
        for (const e3 of s2) {
          const s3 = Array.from(e3.userChunkNames, (e4) => ({ name: e4 }));
          if (s3.length === 0 && e3.isUserDefinedEntryPoint && s3.push({}), s3.push(...Array.from(e3.chunkFileNames, (e4) => ({ fileName: e4 }))), s3.length === 0 && s3.push({}), !this.facadeModule) {
            const t2 = e3.preserveSignature === "strict" || e3.preserveSignature === "exports-only" && e3.getExportNamesByVariable().size !== 0;
            (!t2 || this.outputOptions.preserveModules || this.canModuleBeFacade(e3, i2)) && (this.facadeModule = e3, this.facadeChunkByModule.set(e3, this), e3.preserveSignature && (this.strictFacade = t2), this.assignFacadeName(s3.shift(), e3));
          }
          for (const i3 of s3)
            t.push(br.generateFacade(this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.modulesById, this.chunkByModule, this.facadeChunkByModule, this.includedNamespaces, e3, i3));
        }
        for (const t2 of this.dynamicEntryModules)
          t2.info.syntheticNamedExports || (!this.facadeModule && this.canModuleBeFacade(t2, i2) ? (this.facadeModule = t2, this.facadeChunkByModule.set(t2, this), this.strictFacade = true, this.dynamicName = Sr(t2)) : this.facadeModule === t2 && !this.strictFacade && this.canModuleBeFacade(t2, i2) ? this.strictFacade = true : ((e2 = this.facadeChunkByModule.get(t2)) === null || e2 === void 0 ? void 0 : e2.strictFacade) || (this.includedNamespaces.add(t2), this.exports.add(t2.namespace)));
        return t;
      }
      generateId(e2, t, s2, i2) {
        if (this.fileName !== null)
          return this.fileName;
        const [n3, r2] = this.facadeModule && this.facadeModule.isUserDefinedEntryPoint ? [t.entryFileNames, "output.entryFileNames"] : [t.chunkFileNames, "output.chunkFileNames"];
        return Er(yr(typeof n3 == "function" ? n3(this.getChunkInfo()) : n3, r2, { format: () => t.format, hash: () => i2 ? this.computeContentHashWithDependencies(e2, t, s2) : "[hash]", name: () => this.getChunkName() }), s2);
      }
      generateIdPreserveModules(e2, t, s2, i2) {
        const n3 = this.orderedModules[0].id, r2 = this.outputOptions.sanitizeFileName(n3);
        let a2;
        const o2 = i2.has("entryFileNames") ? "[name][assetExtname].js" : t.entryFileNames, h3 = typeof o2 == "function" ? o2(this.getChunkInfo()) : o2;
        if (P(n3)) {
          const s3 = I(r2), i3 = N(n3), o3 = `${s3}/${yr(h3, "output.entryFileNames", { assetExtname: () => xr.includes(i3) ? "" : i3, ext: () => i3.substr(1), extname: () => i3, format: () => t.format, name: () => this.getChunkName() })}`, { preserveModulesRoot: l2 } = t;
          a2 = l2 && o3.startsWith(l2) ? o3.slice(l2.length).replace(/^[\\/]/, "") : _(e2, o3);
        } else {
          const e3 = N(r2);
          a2 = `_virtual/${yr(h3, "output.entryFileNames", { assetExtname: () => xr.includes(e3) ? "" : e3, ext: () => e3.substr(1), extname: () => e3, format: () => t.format, name: () => te(r2) })}`;
        }
        return Er(w2(a2), s2);
      }
      getChunkInfo() {
        const e2 = this.facadeModule, t = this.getChunkName.bind(this);
        return { exports: this.getExportNames(), facadeModuleId: e2 && e2.id, isDynamicEntry: this.dynamicEntryModules.length > 0, isEntry: e2 !== null && e2.info.isEntry, isImplicitEntry: this.implicitEntryModules.length > 0, modules: this.renderedModules, get name() {
          return t();
        }, type: "chunk" };
      }
      getChunkInfoWithFileNames() {
        return Object.assign(this.getChunkInfo(), { code: void 0, dynamicImports: Array.from(this.dynamicDependencies, Ii), fileName: this.id, implicitlyLoadedBefore: Array.from(this.implicitlyLoadedBefore, Ii), importedBindings: this.getImportedBindingsPerDependency(), imports: Array.from(this.dependencies, Ii), map: void 0, referencedFiles: this.getReferencedFiles() });
      }
      getChunkName() {
        return this.name || (this.name = this.outputOptions.sanitizeFileName(this.getFallbackChunkName()));
      }
      getExportNames() {
        return this.sortedExportNames || (this.sortedExportNames = Object.keys(this.exportsByName).sort());
      }
      getRenderedHash() {
        if (this.renderedHash)
          return this.renderedHash;
        const e2 = nr(), t = this.pluginDriver.hookReduceValueSync("augmentChunkHash", "", [this.getChunkInfo()], (e3, t2) => (t2 && (e3 += t2), e3));
        return e2.update(t), e2.update(this.renderedSource.toString()), e2.update(this.getExportNames().map((e3) => {
          const t2 = this.exportsByName[e3];
          return `${se(t2.module.id).replace(/\\/g, "/")}:${t2.name}:${e3}`;
        }).join(",")), this.renderedHash = e2.digest("hex");
      }
      getVariableExportName(e2) {
        return this.outputOptions.preserveModules && e2 instanceof ki ? "*" : this.exportNamesByVariable.get(e2)[0];
      }
      link() {
        this.dependencies = function(e2, t, s2) {
          const i2 = [], n3 = new Set();
          for (let r3 = t.length - 1; r3 >= 0; r3--) {
            const a2 = t[r3];
            if (!n3.has(a2)) {
              const t2 = [];
              mr(a2, t2, n3, e2, s2), i2.unshift(t2);
            }
          }
          const r2 = new Set();
          for (const e3 of i2)
            for (const t2 of e3)
              r2.add(t2);
          return r2;
        }(this, this.orderedModules, this.chunkByModule);
        for (const e2 of this.orderedModules)
          this.addDependenciesToChunk(e2.dynamicDependencies, this.dynamicDependencies), this.addDependenciesToChunk(e2.implicitlyLoadedBefore, this.implicitlyLoadedBefore), this.setUpChunkImportsAndExportsForModule(e2);
      }
      preRender(e2, t, s2) {
        const { _: i2, getPropertyAccess: n3, n: r2 } = s2, a2 = new v({ separator: `${r2}${r2}` });
        this.usedModules = [], this.indentString = function(e3, t2) {
          if (t2.indent !== true)
            return t2.indent;
          for (const t3 of e3) {
            const e4 = fr(t3.originalCode);
            if (e4 !== null)
              return e4;
          }
          return "	";
        }(this.orderedModules, e2);
        const o2 = { dynamicImportFunction: e2.dynamicImportFunction, exportNamesByVariable: this.exportNamesByVariable, format: e2.format, freeze: e2.freeze, indent: this.indentString, namespaceToStringTag: e2.namespaceToStringTag, outputPluginDriver: this.pluginDriver, snippets: s2 };
        if (e2.hoistTransitiveImports && !this.outputOptions.preserveModules && this.facadeModule !== null)
          for (const e3 of this.dependencies)
            e3 instanceof br && this.inlineChunkDependencies(e3);
        this.prepareModulesForRendering(s2), this.setIdentifierRenderResolutions(e2);
        let h3 = "";
        const l2 = this.renderedModules;
        for (const t2 of this.orderedModules) {
          let s3 = 0;
          if (t2.isIncluded() || this.includedNamespaces.has(t2)) {
            const i4 = t2.render(o2).trim();
            s3 = i4.length(), s3 && (e2.compact && i4.lastLine().indexOf("//") !== -1 && i4.append("\n"), this.renderedModuleSources.set(t2, i4), a2.addSource(i4), this.usedModules.push(t2));
            const n5 = t2.namespace;
            if (this.includedNamespaces.has(t2) && !this.outputOptions.preserveModules) {
              const e3 = n5.renderBlock(o2);
              n5.renderFirst() ? h3 += r2 + e3 : a2.addSource(new b(e3));
            }
          }
          const { renderedExports: i3, removedExports: n4 } = t2.getRenderedExports(), { renderedModuleSources: c2 } = this;
          l2[t2.id] = { get code() {
            var e3, s4;
            return (s4 = (e3 = c2.get(t2)) === null || e3 === void 0 ? void 0 : e3.toString()) !== null && s4 !== void 0 ? s4 : null;
          }, originalLength: t2.originalCode.length, removedExports: n4, renderedExports: i3, renderedLength: s3 };
        }
        if (h3 && a2.prepend(h3 + r2 + r2), this.needsExportsShim && a2.prepend(`${r2}${s2.cnst} _missingExportShim${i2}=${i2}void 0;${r2}${r2}`), e2.compact ? this.renderedSource = a2 : this.renderedSource = a2.trim(), this.renderedHash = void 0, this.isEmpty && this.getExportNames().length === 0 && this.dependencies.size === 0) {
          const e3 = this.getChunkName();
          this.inputOptions.onwarn({ chunkName: e3, code: "EMPTY_BUNDLE", message: `Generated an empty chunk: "${e3}"` });
        }
        this.setExternalRenderPaths(e2, t), this.renderedDependencies = this.getChunkDependencyDeclarations(e2, n3), this.renderedExports = this.exportMode === "none" ? [] : this.getChunkExportDeclarations(e2.format, n3);
      }
      async render(e2, t, s2, i2) {
        Vi("render format", 2);
        const n3 = e2.format, r2 = gn[n3];
        e2.dynamicImportFunction && n3 !== "es" && this.inputOptions.onwarn(Qs("output.dynamicImportFunction", "outputdynamicImportFunction", 'this option is ignored for formats other than "es"'));
        for (const e3 of this.dependencies) {
          const t2 = this.renderedDependencies.get(e3);
          if (e3 instanceof ne) {
            const s3 = e3.renderPath;
            t2.id = dr(e3.renormalizeRenderPath ? this.getRelativePath(s3, false) : s3);
          } else
            t2.namedExportsMode = e3.exportMode !== "default", t2.id = dr(this.getRelativePath(e3.id, false));
        }
        this.finaliseDynamicImports(e2, i2), this.finaliseImportMetas(n3, i2);
        const a2 = this.renderedExports.length !== 0 || [...this.renderedDependencies.values()].some((e3) => e3.reexports && e3.reexports.length !== 0);
        let o2 = false;
        const h3 = new Set();
        for (const e3 of this.orderedModules) {
          e3.usesTopLevelAwait && (o2 = true);
          const t2 = this.accessedGlobalsByScope.get(e3.scope);
          if (t2)
            for (const e4 of t2)
              h3.add(e4);
        }
        if (o2 && n3 !== "es" && n3 !== "system")
          return Hs({ code: "INVALID_TLA_FORMAT", message: `Module format ${n3} does not support top-level await. Use the "es" or "system" output formats rather.` });
        if (!this.id)
          throw new Error("Internal Error: expecting chunk id");
        const c2 = r2(this.renderedSource, { accessedGlobals: h3, dependencies: [...this.renderedDependencies.values()], exports: this.renderedExports, hasExports: a2, id: this.id, indent: this.indentString, intro: t.intro, isEntryFacade: this.outputOptions.preserveModules || this.facadeModule !== null && this.facadeModule.info.isEntry, isModuleFacade: this.facadeModule !== null, namedExportsMode: this.exportMode !== "default", outro: t.outro, snippets: i2, usesTopLevelAwait: o2, warn: this.inputOptions.onwarn }, e2);
        t.banner && c2.prepend(t.banner), t.footer && c2.append(t.footer);
        const u2 = c2.toString();
        Bi("render format", 2);
        let d3 = null;
        const p2 = [];
        let f2 = await function({ code: e3, options: t2, outputPluginDriver: s3, renderChunk: i3, sourcemapChain: n4 }) {
          return s3.hookReduceArg0("renderChunk", [e3, i3, t2], (e4, t3, s4) => {
            if (t3 == null)
              return e4;
            if (typeof t3 == "string" && (t3 = { code: t3, map: void 0 }), t3.map !== null) {
              const e5 = gr(t3.map);
              n4.push(e5 || { missing: true, plugin: s4.name });
            }
            return t3.code;
          });
        }({ code: u2, options: e2, outputPluginDriver: this.pluginDriver, renderChunk: s2, sourcemapChain: p2 });
        if (e2.sourcemap) {
          let t2;
          Vi("sourcemap", 2), t2 = e2.file ? $(e2.sourcemapFile || e2.file) : e2.dir ? $(e2.dir, this.id) : $(this.id);
          const s3 = c2.generateDecodedMap({});
          d3 = function(e3, t3, s4, i3, n4, r3) {
            const a3 = xn(r3), o3 = s4.filter((e4) => !e4.excludeFromSourcemap).map((e4) => vn(e4.id, e4.originalCode, e4.originalSourcemap, e4.sourcemapChain, a3));
            let h4 = new En(t3, o3);
            h4 = i3.reduce(a3, h4);
            let { sources: c3, sourcesContent: u3, names: d4, mappings: p3 } = h4.traceMappings();
            if (e3) {
              const t4 = I(e3);
              c3 = c3.map((e4) => _(t4, e4)), e3 = C2(e3);
            }
            return u3 = n4 ? null : u3, new l({ file: e3, mappings: p3, names: d4, sources: c3, sourcesContent: u3 });
          }(t2, s3, this.usedModules, p2, e2.sourcemapExcludeSources, this.inputOptions.onwarn), d3.sources = d3.sources.map((s4) => {
            const { sourcemapPathTransform: i3 } = e2;
            if (i3) {
              const e3 = i3(s4, `${t2}.map`);
              return typeof e3 != "string" && Hs(ni("sourcemapPathTransform function must return a string.")), e3;
            }
            return s4;
          }).map(w2), Bi("sourcemap", 2);
        }
        return e2.compact || f2[f2.length - 1] === "\n" || (f2 += "\n"), { code: f2, map: d3 };
      }
      addDependenciesToChunk(e2, t) {
        for (const s2 of e2)
          if (s2 instanceof Hi) {
            const e3 = this.chunkByModule.get(s2);
            e3 && e3 !== this && t.add(e3);
          } else
            t.add(s2);
      }
      assignFacadeName({ fileName: e2, name: t }, s2) {
        e2 ? this.fileName = e2 : this.name = this.outputOptions.sanitizeFileName(t || Sr(s2));
      }
      checkCircularDependencyImport(e2, t) {
        const s2 = e2.module;
        if (s2 instanceof Hi) {
          const o2 = this.chunkByModule.get(s2);
          let h3;
          do {
            if (h3 = t.alternativeReexportModules.get(e2), h3) {
              const l2 = this.chunkByModule.get(h3);
              l2 && l2 !== o2 && this.inputOptions.onwarn((i2 = s2.getExportNamesByVariable().get(e2)[0], n3 = s2.id, r2 = h3.id, a2 = t.id, { code: Ks.CYCLIC_CROSS_CHUNK_REEXPORT, exporter: n3, importer: a2, message: `Export "${i2}" of module ${se(n3)} was reexported through module ${se(r2)} while both modules are dependencies of each other and will end up in different chunks by current Rollup settings. This scenario is not well supported at the moment as it will produce a circular dependency between chunks and will likely lead to broken execution order.
Either change the import in ${se(a2)} to point directly to the exporting module or do not use "preserveModules" to ensure these modules end up in the same chunk.`, reexporter: r2 })), t = h3;
            }
          } while (h3);
        }
        var i2, n3, r2, a2;
      }
      computeContentHashWithDependencies(e2, t, s2) {
        const i2 = nr();
        i2.update([e2.intro, e2.outro, e2.banner, e2.footer].map((e3) => e3 || "").join(":")), i2.update(t.format);
        const n3 = new Set([this]);
        for (const r2 of n3)
          if (r2 instanceof ne ? i2.update(":" + r2.renderPath) : (i2.update(r2.getRenderedHash()), i2.update(r2.generateId(e2, t, s2, false))), !(r2 instanceof ne))
            for (const e3 of [...r2.dependencies, ...r2.dynamicDependencies])
              n3.add(e3);
        return i2.digest("hex").substr(0, 8);
      }
      ensureReexportsAreAvailableForModule(e2) {
        const t = e2.getExportNamesByVariable();
        for (const s2 of t.keys()) {
          const t2 = s2 instanceof wi, i2 = t2 ? s2.getBaseVariable() : s2;
          if (!(i2 instanceof ki && this.outputOptions.preserveModules)) {
            this.checkCircularDependencyImport(i2, e2);
            const s3 = i2.module;
            if (s3 instanceof Hi) {
              const e3 = this.chunkByModule.get(s3);
              e3 && e3 !== this && (e3.exports.add(i2), t2 && this.imports.add(i2));
            }
          }
        }
      }
      finaliseDynamicImports(e2, t) {
        const s2 = e2.format === "amd";
        for (const [e3, i2] of this.renderedModuleSources)
          for (const { node: n3, resolution: r2 } of e3.dynamicImports) {
            const e4 = this.chunkByModule.get(r2), a2 = this.facadeChunkByModule.get(r2);
            if (!r2 || !n3.included || e4 === this)
              continue;
            const o2 = r2 instanceof Hi ? `'${dr(this.getRelativePath((a2 || e4).id, s2))}'` : r2 instanceof ne ? `'${dr(r2.renormalizeRenderPath ? this.getRelativePath(r2.renderPath, s2) : r2.renderPath)}'` : r2;
            n3.renderFinalResolution(i2, o2, r2 instanceof Hi && !(a2 == null ? void 0 : a2.strictFacade) && e4.exportNamesByVariable.get(r2.namespace)[0], t);
          }
      }
      finaliseImportMetas(e2, t) {
        for (const [s2, i2] of this.renderedModuleSources)
          for (const n3 of s2.importMetas)
            n3.renderFinalMechanism(i2, this.id, e2, t, this.pluginDriver);
      }
      generateVariableName() {
        if (this.manualChunkAlias)
          return this.manualChunkAlias;
        const e2 = this.entryModules[0] || this.implicitEntryModules[0] || this.dynamicEntryModules[0] || this.orderedModules[this.orderedModules.length - 1];
        return e2 ? e2.chunkName || te(e2.id) : "chunk";
      }
      getChunkDependencyDeclarations(e2, t) {
        const s2 = this.getImportSpecifiers(t), i2 = this.getReexportSpecifiers(), n3 = new Map();
        for (const t2 of this.dependencies) {
          const r2 = s2.get(t2) || null, a2 = i2.get(t2) || null, o2 = t2 instanceof ne || t2.exportMode !== "default";
          n3.set(t2, { defaultVariableName: t2.defaultVariableName, globalName: t2 instanceof ne && (e2.format === "umd" || e2.format === "iife") && vr(t2, e2.globals, (r2 || a2) !== null, this.inputOptions.onwarn), id: void 0, imports: r2, isChunk: t2 instanceof br, name: t2.variableName, namedExportsMode: o2, namespaceVariableName: t2.namespaceVariableName, reexports: a2 });
        }
        return n3;
      }
      getChunkExportDeclarations(e2, t) {
        const s2 = [];
        for (const i2 of this.getExportNames()) {
          if (i2[0] === "*")
            continue;
          const n3 = this.exportsByName[i2];
          if (!(n3 instanceof wi)) {
            const e3 = n3.module;
            if (e3 && this.chunkByModule.get(e3) !== this)
              continue;
          }
          let r2 = null, a2 = false, o2 = n3.getName(t);
          if (n3 instanceof Qe) {
            for (const e3 of n3.declarations)
              if (e3.parent instanceof Gt || e3 instanceof Ht && e3.declaration instanceof Gt) {
                a2 = true;
                break;
              }
          } else
            n3 instanceof wi && (r2 = o2, e2 === "es" && (o2 = n3.renderName));
          s2.push({ exported: i2, expression: r2, hoisted: a2, local: o2 });
        }
        return s2;
      }
      getDependenciesToBeDeconflicted(e2, t, s2) {
        const i2 = new Set(), n3 = new Set(), r2 = new Set();
        for (const t2 of [...this.exportNamesByVariable.keys(), ...this.imports])
          if (e2 || t2.isNamespace) {
            const a2 = t2.module;
            if (a2 instanceof ne)
              i2.add(a2), e2 && (t2.name === "default" ? ws[String(s2(a2.id))] && n3.add(a2) : t2.name === "*" && Is[String(s2(a2.id))] && r2.add(a2));
            else {
              const s3 = this.chunkByModule.get(a2);
              s3 !== this && (i2.add(s3), e2 && s3.exportMode === "default" && t2.isNamespace && r2.add(s3));
            }
          }
        if (t)
          for (const e3 of this.dependencies)
            i2.add(e3);
        return { deconflictedDefault: n3, deconflictedNamespace: r2, dependencies: i2 };
      }
      getFallbackChunkName() {
        return this.manualChunkAlias ? this.manualChunkAlias : this.dynamicName ? this.dynamicName : this.fileName ? te(this.fileName) : te(this.orderedModules[this.orderedModules.length - 1].id);
      }
      getImportSpecifiers(e2) {
        const { interop: t } = this.outputOptions, s2 = new Map();
        for (const i2 of this.imports) {
          const n3 = i2.module;
          let r2, a2;
          if (n3 instanceof ne) {
            if (r2 = n3, a2 = i2.name, a2 !== "default" && a2 !== "*" && t(n3.id) === "defaultOnly")
              return Hs(si(n3.id, a2, false));
          } else
            r2 = this.chunkByModule.get(n3), a2 = r2.getVariableExportName(i2);
          T(s2, r2, () => []).push({ imported: a2, local: i2.getName(e2) });
        }
        return s2;
      }
      getImportedBindingsPerDependency() {
        const e2 = {};
        for (const [t, s2] of this.renderedDependencies) {
          const i2 = new Set();
          if (s2.imports)
            for (const { imported: e3 } of s2.imports)
              i2.add(e3);
          if (s2.reexports)
            for (const { imported: e3 } of s2.reexports)
              i2.add(e3);
          e2[t.id] = [...i2];
        }
        return e2;
      }
      getReexportSpecifiers() {
        const { externalLiveBindings: e2, interop: t } = this.outputOptions, s2 = new Map();
        for (let i2 of this.getExportNames()) {
          let n3, r2, a2 = false;
          if (i2[0] === "*") {
            const s3 = i2.substr(1);
            t(s3) === "defaultOnly" && this.inputOptions.onwarn(ii(s3)), a2 = e2, n3 = this.modulesById.get(s3), r2 = i2 = "*";
          } else {
            const s3 = this.exportsByName[i2];
            if (s3 instanceof wi)
              continue;
            const o2 = s3.module;
            if (o2 instanceof Hi) {
              if (n3 = this.chunkByModule.get(o2), n3 === this)
                continue;
              r2 = n3.getVariableExportName(s3), a2 = s3.isReassigned;
            } else {
              if (n3 = o2, r2 = s3.name, r2 !== "default" && r2 !== "*" && t(o2.id) === "defaultOnly")
                return Hs(si(o2.id, r2, true));
              a2 = e2 && (r2 !== "default" || Cs(String(t(o2.id)), true));
            }
          }
          T(s2, n3, () => []).push({ imported: r2, needsLiveBinding: a2, reexported: i2 });
        }
        return s2;
      }
      getReferencedFiles() {
        const e2 = [];
        for (const t of this.orderedModules)
          for (const s2 of t.importMetas) {
            const t2 = s2.getReferencedFileName(this.pluginDriver);
            t2 && e2.push(t2);
          }
        return e2;
      }
      getRelativePath(e2, t) {
        let s2 = w2(_(I(this.id), e2));
        return t && s2.endsWith(".js") && (s2 = s2.slice(0, -3)), s2 === ".." ? "../../" + C2(e2) : s2 === "" ? "../" + C2(e2) : s2.startsWith("../") ? s2 : "./" + s2;
      }
      inlineChunkDependencies(e2) {
        for (const t of e2.dependencies)
          this.dependencies.has(t) || (this.dependencies.add(t), t instanceof br && this.inlineChunkDependencies(t));
      }
      prepareModulesForRendering(e2) {
        var t;
        const s2 = this.accessedGlobalsByScope;
        for (const i2 of this.orderedModules) {
          for (const { node: n3, resolution: r2 } of i2.dynamicImports)
            if (n3.included)
              if (r2 instanceof Hi) {
                const i3 = this.chunkByModule.get(r2);
                i3 === this ? n3.setInternalResolution(r2.namespace) : n3.setExternalResolution(((t = this.facadeChunkByModule.get(r2)) === null || t === void 0 ? void 0 : t.exportMode) || i3.exportMode, r2, this.outputOptions, e2, this.pluginDriver, s2);
              } else
                n3.setExternalResolution("external", r2, this.outputOptions, e2, this.pluginDriver, s2);
          for (const e3 of i2.importMetas)
            e3.addAccessedGlobals(this.outputOptions.format, s2);
          this.includedNamespaces.has(i2) && !this.outputOptions.preserveModules && i2.namespace.prepare(s2);
        }
      }
      setExternalRenderPaths(e2, t) {
        for (const s2 of [...this.dependencies, ...this.dynamicDependencies])
          s2 instanceof ne && s2.setRenderPath(e2, t);
      }
      setIdentifierRenderResolutions({ format: e2, interop: t, namespaceToStringTag: s2 }) {
        const i2 = new Set();
        for (const t2 of this.getExportNames()) {
          const s3 = this.exportsByName[t2];
          e2 !== "es" && e2 !== "system" && s3.isReassigned && !s3.isId ? s3.setRenderNames("exports", t2) : s3 instanceof wi ? i2.add(s3) : s3.setRenderNames(null, null);
        }
        for (const e3 of this.orderedModules)
          if (e3.needsExportShim) {
            this.needsExportsShim = true;
            break;
          }
        const n3 = new Set(["Object", "Promise"]);
        switch (this.needsExportsShim && n3.add("_missingExportShim"), s2 && n3.add("Symbol"), e2) {
          case "system":
            n3.add("module").add("exports");
            break;
          case "es":
            break;
          case "cjs":
            n3.add("module").add("require").add("__filename").add("__dirname");
          default:
            n3.add("exports");
            for (const e3 of Ws)
              n3.add(e3);
        }
        ar(this.orderedModules, this.getDependenciesToBeDeconflicted(e2 !== "es" && e2 !== "system", e2 === "amd" || e2 === "umd" || e2 === "iife", t), this.imports, n3, e2, t, this.outputOptions.preserveModules, this.outputOptions.externalLiveBindings, this.chunkByModule, i2, this.exportNamesByVariable, this.accessedGlobalsByScope, this.includedNamespaces);
      }
      setUpChunkImportsAndExportsForModule(e2) {
        const t = new Set(e2.imports);
        if (!this.outputOptions.preserveModules && this.includedNamespaces.has(e2)) {
          const s2 = e2.namespace.getMemberVariables();
          for (const e3 of Object.values(s2))
            t.add(e3);
        }
        for (let s2 of t) {
          s2 instanceof vi && (s2 = s2.getOriginalVariable()), s2 instanceof wi && (s2 = s2.getBaseVariable());
          const t2 = this.chunkByModule.get(s2.module);
          t2 !== this && (this.imports.add(s2), !(s2 instanceof ki && this.outputOptions.preserveModules) && s2.module instanceof Hi && (t2.exports.add(s2), this.checkCircularDependencyImport(s2, e2)));
        }
        (this.includedNamespaces.has(e2) || e2.info.isEntry && e2.preserveSignature !== false || e2.includedDynamicImporters.some((e3) => this.chunkByModule.get(e3) !== this)) && this.ensureReexportsAreAvailableForModule(e2);
        for (const { node: t2, resolution: s2 } of e2.dynamicImports)
          t2.included && s2 instanceof Hi && this.chunkByModule.get(s2) === this && !this.includedNamespaces.has(s2) && (this.includedNamespaces.add(s2), this.ensureReexportsAreAvailableForModule(s2));
      }
    };
    Pr = { type: "placeholder" };
    Ir = class {
      constructor(e2, t, s2) {
        this.graph = e2, this.options = t, this.bundle = null, this.facadeChunkByModule = null, this.outputOptions = null, this.assertAssetsFinalized = () => {
          for (const [t2, s3] of this.filesByReferenceId.entries())
            if (s3.type === "asset" && typeof s3.fileName != "string")
              return Hs((e3 = s3.name || t2, { code: Ks.ASSET_SOURCE_MISSING, message: `Plugin error creating asset "${e3}" - no asset source set.` }));
          var e3;
        }, this.emitFile = (e3) => function(e4) {
          return Boolean(e4 && (e4.type === "asset" || e4.type === "chunk"));
        }(e3) ? function(e4) {
          const t2 = e4.fileName || e4.name;
          return !t2 || typeof t2 == "string" && !ie(t2);
        }(e3) ? e3.type === "chunk" ? this.emitChunk(e3) : this.emitAsset(e3) : Hs(ni(`The "fileName" or "name" properties of emitted files must be strings that are neither absolute nor relative paths, received "${e3.fileName || e3.name}".`)) : Hs(ni(`Emitted files must be of type "asset" or "chunk", received "${e3 && e3.type}".`)), this.getFileName = (e3) => {
          const t2 = this.filesByReferenceId.get(e3);
          return t2 ? t2.type === "chunk" ? Cr(t2, this.facadeChunkByModule) : wr(t2, e3) : Hs((s3 = e3, { code: Ks.FILE_NOT_FOUND, message: `Plugin error - Unable to get file name for unknown file "${s3}".` }));
          var s3;
        }, this.setAssetSource = (e3, t2) => {
          const s3 = this.filesByReferenceId.get(e3);
          if (!s3)
            return Hs((i2 = e3, { code: Ks.ASSET_NOT_FOUND, message: `Plugin error - Unable to set the source for unknown asset "${i2}".` }));
          var i2, n3;
          if (s3.type !== "asset")
            return Hs(ni(`Asset sources can only be set for emitted assets but "${e3}" is an emitted chunk.`));
          if (s3.source !== void 0)
            return Hs((n3 = s3.name || e3, { code: Ks.ASSET_SOURCE_ALREADY_SET, message: `Unable to set the source for asset "${n3}", source already set.` }));
          const r2 = kr(t2, s3, e3);
          this.bundle ? this.finalizeAsset(s3, r2, e3, this.bundle) : s3.source = r2;
        }, this.setOutputBundle = (e3, t2, s3) => {
          this.outputOptions = t2, this.bundle = e3, this.facadeChunkByModule = s3;
          for (const e4 of this.filesByReferenceId.values())
            e4.fileName && Ar(e4.fileName, this.bundle, this.options.onwarn);
          for (const [e4, t3] of this.filesByReferenceId.entries())
            t3.type === "asset" && t3.source !== void 0 && this.finalizeAsset(t3, t3.source, e4, this.bundle);
        }, this.filesByReferenceId = s2 ? new Map(s2.filesByReferenceId) : new Map();
      }
      assignReferenceId(e2, t) {
        let s2;
        do {
          const e3 = nr();
          s2 ? e3.update(s2) : e3.update(t), s2 = e3.digest("hex").substr(0, 8);
        } while (this.filesByReferenceId.has(s2));
        return this.filesByReferenceId.set(s2, e2), s2;
      }
      emitAsset(e2) {
        const t = e2.source !== void 0 ? kr(e2.source, e2, null) : void 0, s2 = { fileName: e2.fileName, name: e2.name, source: t, type: "asset" }, i2 = this.assignReferenceId(s2, e2.fileName || e2.name || e2.type);
        return this.bundle && (e2.fileName && Ar(e2.fileName, this.bundle, this.options.onwarn), t !== void 0 && this.finalizeAsset(s2, t, i2, this.bundle)), i2;
      }
      emitChunk(e2) {
        if (this.graph.phase > Ci.LOAD_AND_PARSE)
          return Hs({ code: Ks.INVALID_ROLLUP_PHASE, message: "Cannot emit chunks after module loading has finished." });
        if (typeof e2.id != "string")
          return Hs(ni(`Emitted chunks need to have a valid string id, received "${e2.id}"`));
        const t = { fileName: e2.fileName, module: null, name: e2.name || e2.id, type: "chunk" };
        return this.graph.moduleLoader.emitChunk(e2).then((e3) => t.module = e3).catch(() => {
        }), this.assignReferenceId(t, e2.id);
      }
      finalizeAsset(e2, t, s2, i2) {
        const n3 = e2.fileName || function(e3, t2) {
          for (const [s3, i3] of Object.entries(e3))
            if (i3.type === "asset" && Nr(t2, i3.source))
              return s3;
          return null;
        }(i2, t) || function(e3, t2, s3, i3) {
          const n4 = s3.sanitizeFileName(e3 || "asset");
          return Er(yr(typeof s3.assetFileNames == "function" ? s3.assetFileNames({ name: e3, source: t2, type: "asset" }) : s3.assetFileNames, "output.assetFileNames", { ext: () => N(n4).substr(1), extname: () => N(n4), hash() {
            const e4 = nr();
            return e4.update(n4), e4.update(":"), e4.update(t2), e4.digest("hex").substr(0, 8);
          }, name: () => n4.substr(0, n4.length - N(n4).length) }), i3);
        }(e2.name, t, this.outputOptions, i2), r2 = __spreadProps2(__spreadValues2({}, e2), { fileName: n3, source: t });
        this.filesByReferenceId.set(s2, r2);
        const { options: a2 } = this;
        i2[n3] = { fileName: n3, get isAsset() {
          return ai(`Accessing "isAsset" on files in the bundle is deprecated, please use "type === 'asset'" instead`, true, a2), true;
        }, name: e2.name, source: t, type: "asset" };
      }
    };
    _r = (e2, t) => t ? `${e2}
${t}` : e2;
    $r = (e2, t) => t ? `${e2}

${t}` : e2;
    Mr = (e2, t) => e2.execIndex > t.execIndex ? 1 : -1;
    Lr = (e2, t) => t ? `(${e2})` : e2;
    Or = /^(?!\d)[\w$]+$/;
    Vr = class {
      constructor(e2, t, s2, i2, n3) {
        this.outputOptions = e2, this.unsetOptions = t, this.inputOptions = s2, this.pluginDriver = i2, this.graph = n3, this.facadeChunkByModule = new Map(), this.includedNamespaces = new Set();
      }
      async generate(e2) {
        Vi("GENERATE", 1);
        const t = Object.create(null);
        this.pluginDriver.setOutputBundle(t, this.outputOptions, this.facadeChunkByModule);
        try {
          await this.pluginDriver.hookParallel("renderStart", [this.outputOptions, this.inputOptions]), Vi("generate chunks", 2);
          const e3 = await this.generateChunks();
          e3.length > 1 && function(e4, t2) {
            if (e4.format === "umd" || e4.format === "iife")
              return Hs(Qs("output.format", "outputformat", "UMD and IIFE output formats are not supported for code-splitting builds", e4.format));
            if (typeof e4.file == "string")
              return Hs(Qs("output.file", "outputdir", 'when building multiple chunks, the "output.dir" option must be used, not "output.file". To inline dynamic imports, set the "inlineDynamicImports" option'));
            if (e4.sourcemapFile)
              return Hs(Qs("output.sourcemapFile", "outputsourcemapfile", '"output.sourcemapFile" is only supported for single-file builds'));
            !e4.amd.autoId && e4.amd.id && t2(Qs("output.amd.id", "outputamd", 'this option is only properly supported for single-file builds. Use "output.amd.autoId" and "output.amd.basePath" instead'));
          }(this.outputOptions, this.inputOptions.onwarn);
          const s2 = function(e4) {
            if (e4.length === 0)
              return "/";
            if (e4.length === 1)
              return I(e4[0]);
            const t2 = e4.slice(1).reduce((e5, t3) => {
              const s3 = t3.split(/\/+|\\+/);
              let i3;
              for (i3 = 0; e5[i3] === s3[i3] && i3 < Math.min(e5.length, s3.length); i3++)
                ;
              return e5.slice(0, i3);
            }, e4[0].split(/\/+|\\+/));
            return t2.length > 1 ? t2.join("/") : "/";
          }(function(e4) {
            const t2 = [];
            for (const s3 of e4)
              for (const e5 of s3.entryModules)
                P(e5.id) && t2.push(e5.id);
            return t2;
          }(e3));
          Bi("generate chunks", 2), Vi("render modules", 2);
          const i2 = await async function(e4, t2) {
            try {
              let [s3, i3, n4, r2] = await Promise.all([t2.hookReduceValue("banner", e4.banner(), [], _r), t2.hookReduceValue("footer", e4.footer(), [], _r), t2.hookReduceValue("intro", e4.intro(), [], $r), t2.hookReduceValue("outro", e4.outro(), [], $r)]);
              return n4 && (n4 += "\n\n"), r2 && (r2 = `

${r2}`), s3.length && (s3 += "\n"), i3.length && (i3 = "\n" + i3), { banner: s3, footer: i3, intro: n4, outro: r2 };
            } catch (e5) {
              return Hs({ code: "ADDON_ERROR", message: `Could not retrieve ${e5.hook}. Check configuration of plugin ${e5.plugin}.
	Error Message: ${e5.message}` });
            }
          }(this.outputOptions, this.pluginDriver), n3 = function({ compact: e4, generatedCode: { arrowFunctions: t2, constBindings: s3, objectShorthand: i3, reservedNamesAsProps: n4 } }) {
            const { _: r2, n: a2, s: o2 } = e4 ? { _: "", n: "", s: "" } : { _: " ", n: "\n", s: ";" }, h3 = s3 ? "const" : "var", l2 = (e5, { isAsync: t3, name: s4 }) => `${t3 ? "async " : ""}function${s4 ? ` ${s4}` : ""}${r2}(${e5.join(`,${r2}`)})${r2}`, c2 = t2 ? (e5, { isAsync: t3, name: s4 }) => {
              const i4 = e5.length === 1;
              return `${s4 ? `${h3} ${s4}${r2}=${r2}` : ""}${t3 ? `async${i4 ? " " : r2}` : ""}${i4 ? e5[0] : `(${e5.join(`,${r2}`)})`}${r2}=>${r2}`;
            } : l2, u2 = (e5, { functionReturn: s4, lineBreakIndent: i4, name: n5 }) => [`${c2(e5, { isAsync: false, name: n5 })}${t2 ? i4 ? `${a2}${i4.base}${i4.t}` : "" : `{${i4 ? `${a2}${i4.base}${i4.t}` : r2}${s4 ? "return " : ""}`}`, t2 ? `${n5 ? ";" : ""}${i4 ? `${a2}${i4.base}` : ""}` : `${o2}${i4 ? `${a2}${i4.base}` : r2}}`], d3 = n4 ? (e5) => Or.test(e5) : (e5) => !Y.has(e5) && Or.test(e5);
            return { _: r2, cnst: h3, getDirectReturnFunction: u2, getDirectReturnIifeLeft: (e5, s4, { needsArrowReturnParens: i4, needsWrappedFunction: n5 }) => {
              const [r3, a3] = u2(e5, { functionReturn: true, lineBreakIndent: null, name: null });
              return `${Lr(`${r3}${Lr(s4, t2 && i4)}${a3}`, t2 || n5)}(`;
            }, getFunctionIntro: c2, getNonArrowFunctionIntro: l2, getObject(e5, { lineBreakIndent: t3 }) {
              const s4 = t3 ? `${a2}${t3.base}${t3.t}` : r2;
              return `{${e5.map(([e6, t4]) => {
                if (e6 === null)
                  return `${s4}${t4}`;
                const n5 = !d3(e6);
                return e6 === t4 && i3 && !n5 ? s4 + e6 : `${s4}${n5 ? `'${e6}'` : e6}:${r2}${t4}`;
              }).join(",")}${e5.length === 0 ? "" : t3 ? `${a2}${t3.base}` : r2}}`;
            }, getPropertyAccess: (e5) => d3(e5) ? `.${e5}` : `[${JSON.stringify(e5)}]`, n: a2, s: o2 };
          }(this.outputOptions);
          this.prerenderChunks(e3, s2, n3), Bi("render modules", 2), await this.addFinalizedChunksToBundle(e3, s2, i2, t, n3);
        } catch (e3) {
          throw await this.pluginDriver.hookParallel("renderError", [e3]), e3;
        }
        return await this.pluginDriver.hookSeq("generateBundle", [this.outputOptions, t, e2]), this.finaliseAssets(t), Bi("GENERATE", 1), t;
      }
      async addFinalizedChunksToBundle(e2, t, s2, i2, n3) {
        this.assignChunkIds(e2, t, s2, i2);
        for (const t2 of e2)
          i2[t2.id] = t2.getChunkInfoWithFileNames();
        await Promise.all(e2.map(async (e3) => {
          const t2 = i2[e3.id];
          Object.assign(t2, await e3.render(this.outputOptions, s2, t2, n3));
        }));
      }
      async addManualChunks(e2) {
        const t = new Map(), s2 = await Promise.all(Object.entries(e2).map(async ([e3, t2]) => ({ alias: e3, entries: await this.graph.moduleLoader.addAdditionalModules(t2) })));
        for (const { alias: e3, entries: i2 } of s2)
          for (const s3 of i2)
            Fr(e3, s3, t);
        return t;
      }
      assignChunkIds(e2, t, s2, i2) {
        const n3 = [], r2 = [];
        for (const t2 of e2)
          (t2.facadeModule && t2.facadeModule.isUserDefinedEntryPoint ? n3 : r2).push(t2);
        const a2 = n3.concat(r2);
        for (const e3 of a2)
          this.outputOptions.file ? e3.id = C2(this.outputOptions.file) : this.outputOptions.preserveModules ? e3.id = e3.generateIdPreserveModules(t, this.outputOptions, i2, this.unsetOptions) : e3.id = e3.generateId(s2, this.outputOptions, i2, true), i2[e3.id] = Pr;
      }
      assignManualChunks(e2) {
        const t = new Map(), s2 = { getModuleIds: () => this.graph.modulesById.keys(), getModuleInfo: this.graph.getModuleInfo };
        for (const i2 of this.graph.modulesById.values())
          if (i2 instanceof Hi) {
            const n3 = e2(i2.id, s2);
            typeof n3 == "string" && Fr(n3, i2, t);
          }
        return t;
      }
      finaliseAssets(e2) {
        for (const t of Object.values(e2))
          if (t.type || (ai('A plugin is directly adding properties to the bundle object in the "generateBundle" hook. This is deprecated and will be removed in a future Rollup version, please use "this.emitFile" instead.', true, this.inputOptions), t.type = "asset"), this.outputOptions.validate && typeof t.code == "string")
            try {
              this.graph.contextParse(t.code, { allowHashBang: true, ecmaVersion: "latest" });
            } catch (e3) {
              this.inputOptions.onwarn(Xs(t, e3));
            }
        this.pluginDriver.finaliseAssets();
      }
      async generateChunks() {
        const { manualChunks: e2 } = this.outputOptions, t = typeof e2 == "object" ? await this.addManualChunks(e2) : this.assignManualChunks(e2), s2 = [], i2 = new Map();
        for (const { alias: e3, modules: n4 } of this.outputOptions.inlineDynamicImports ? [{ alias: null, modules: Br(this.graph.modulesById) }] : this.outputOptions.preserveModules ? Br(this.graph.modulesById).map((e4) => ({ alias: null, modules: [e4] })) : Tr(this.graph.entryModules, t)) {
          n4.sort(Mr);
          const t2 = new br(n4, this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.graph.modulesById, i2, this.facadeChunkByModule, this.includedNamespaces, e3);
          s2.push(t2);
          for (const e4 of n4)
            i2.set(e4, t2);
        }
        for (const e3 of s2)
          e3.link();
        const n3 = [];
        for (const e3 of s2)
          n3.push(...e3.generateFacades());
        return [...s2, ...n3];
      }
      prerenderChunks(e2, t, s2) {
        for (const t2 of e2)
          t2.generateExports();
        for (const i2 of e2)
          i2.preRender(this.outputOptions, t, s2);
      }
    };
    zr = { 3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile", 5: "class enum extends super const export import", 6: "enum", strict: "implements interface let package private protected public static yield", strictBind: "eval arguments" };
    Wr = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
    jr = { 5: Wr, "5module": Wr + " export import", 6: Wr + " const class extends export import super" };
    Ur = /^in(stanceof)?$/;
    Gr = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    Hr = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    qr = new RegExp("[" + Gr + "]");
    Kr = new RegExp("[" + Gr + Hr + "]");
    Gr = Hr = null;
    Xr = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
    Yr = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    ea = function(e2, t) {
      t === void 0 && (t = {}), this.label = e2, this.keyword = t.keyword, this.beforeExpr = !!t.beforeExpr, this.startsExpr = !!t.startsExpr, this.isLoop = !!t.isLoop, this.isAssign = !!t.isAssign, this.prefix = !!t.prefix, this.postfix = !!t.postfix, this.binop = t.binop || null, this.updateContext = null;
    };
    sa = { beforeExpr: true };
    ia = { startsExpr: true };
    na = {};
    aa = { num: new ea("num", ia), regexp: new ea("regexp", ia), string: new ea("string", ia), name: new ea("name", ia), privateId: new ea("privateId", ia), eof: new ea("eof"), bracketL: new ea("[", { beforeExpr: true, startsExpr: true }), bracketR: new ea("]"), braceL: new ea("{", { beforeExpr: true, startsExpr: true }), braceR: new ea("}"), parenL: new ea("(", { beforeExpr: true, startsExpr: true }), parenR: new ea(")"), comma: new ea(",", sa), semi: new ea(";", sa), colon: new ea(":", sa), dot: new ea("."), question: new ea("?", sa), questionDot: new ea("?."), arrow: new ea("=>", sa), template: new ea("template"), invalidTemplate: new ea("invalidTemplate"), ellipsis: new ea("...", sa), backQuote: new ea("`", ia), dollarBraceL: new ea("${", { beforeExpr: true, startsExpr: true }), eq: new ea("=", { beforeExpr: true, isAssign: true }), assign: new ea("_=", { beforeExpr: true, isAssign: true }), incDec: new ea("++/--", { prefix: true, postfix: true, startsExpr: true }), prefix: new ea("!/~", { beforeExpr: true, prefix: true, startsExpr: true }), logicalOR: ta("||", 1), logicalAND: ta("&&", 2), bitwiseOR: ta("|", 3), bitwiseXOR: ta("^", 4), bitwiseAND: ta("&", 5), equality: ta("==/!=/===/!==", 6), relational: ta("</>/<=/>=", 7), bitShift: ta("<</>>/>>>", 8), plusMin: new ea("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }), modulo: ta("%", 10), star: ta("*", 10), slash: ta("/", 10), starstar: new ea("**", { beforeExpr: true }), coalesce: ta("??", 1), _break: ra("break"), _case: ra("case", sa), _catch: ra("catch"), _continue: ra("continue"), _debugger: ra("debugger"), _default: ra("default", sa), _do: ra("do", { isLoop: true, beforeExpr: true }), _else: ra("else", sa), _finally: ra("finally"), _for: ra("for", { isLoop: true }), _function: ra("function", ia), _if: ra("if"), _return: ra("return", sa), _switch: ra("switch"), _throw: ra("throw", sa), _try: ra("try"), _var: ra("var"), _const: ra("const"), _while: ra("while", { isLoop: true }), _with: ra("with"), _new: ra("new", { beforeExpr: true, startsExpr: true }), _this: ra("this", ia), _super: ra("super", ia), _class: ra("class", ia), _extends: ra("extends", sa), _export: ra("export"), _import: ra("import", ia), _null: ra("null", ia), _true: ra("true", ia), _false: ra("false", ia), _in: ra("in", { beforeExpr: true, binop: 7 }), _instanceof: ra("instanceof", { beforeExpr: true, binop: 7 }), _typeof: ra("typeof", { beforeExpr: true, prefix: true, startsExpr: true }), _void: ra("void", { beforeExpr: true, prefix: true, startsExpr: true }), _delete: ra("delete", { beforeExpr: true, prefix: true, startsExpr: true }) };
    oa = /\r\n?|\n|\u2028|\u2029/;
    ha = new RegExp(oa.source, "g");
    ca = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    ua = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    da = Object.prototype;
    pa = da.hasOwnProperty;
    fa = da.toString;
    ga = Array.isArray || function(e2) {
      return fa.call(e2) === "[object Array]";
    };
    Ea = function(e2, t) {
      this.line = e2, this.column = t;
    };
    Ea.prototype.offset = function(e2) {
      return new Ea(this.line, this.column + e2);
    };
    xa = function(e2, t, s2) {
      this.start = t, this.end = s2, e2.sourceFile !== null && (this.source = e2.sourceFile);
    };
    ba = { ecmaVersion: null, sourceType: "script", onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowAwaitOutsideFunction: null, allowSuperOutsideMethod: null, allowHashBang: false, locations: false, onToken: null, onComment: null, ranges: false, program: null, sourceFile: null, directSourceFile: null, preserveParens: false };
    Sa = false;
    ka = function(e2, t, s2) {
      this.options = e2 = Aa(e2), this.sourceFile = e2.sourceFile, this.keywords = ya(jr[e2.ecmaVersion >= 6 ? 6 : e2.sourceType === "module" ? "5module" : 5]);
      var i2 = "";
      e2.allowReserved !== true && (i2 = zr[e2.ecmaVersion >= 6 ? 6 : e2.ecmaVersion === 5 ? 5 : 3], e2.sourceType === "module" && (i2 += " await")), this.reservedWords = ya(i2);
      var n3 = (i2 ? i2 + " " : "") + zr.strict;
      this.reservedWordsStrict = ya(n3), this.reservedWordsStrictBind = ya(n3 + " " + zr.strictBind), this.input = String(t), this.containsEsc = false, s2 ? (this.pos = s2, this.lineStart = this.input.lastIndexOf("\n", s2 - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(oa).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = aa.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = true, this.inModule = e2.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = false, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = Object.create(null), this.pos === 0 && e2.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(1), this.regexpState = null, this.privateNameStack = [];
    };
    wa = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
    ka.prototype.parse = function() {
      var e2 = this.options.program || this.startNode();
      return this.nextToken(), this.parseTopLevel(e2);
    }, wa.inFunction.get = function() {
      return (2 & this.currentVarScope().flags) > 0;
    }, wa.inGenerator.get = function() {
      return (8 & this.currentVarScope().flags) > 0 && !this.currentVarScope().inClassFieldInit;
    }, wa.inAsync.get = function() {
      return (4 & this.currentVarScope().flags) > 0 && !this.currentVarScope().inClassFieldInit;
    }, wa.canAwait.get = function() {
      for (var e2 = this.scopeStack.length - 1; e2 >= 0; e2--) {
        var t = this.scopeStack[e2];
        if (t.inClassFieldInit || 256 & t.flags)
          return false;
        if (2 & t.flags)
          return (4 & t.flags) > 0;
      }
      return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
    }, wa.allowSuper.get = function() {
      var e2 = this.currentThisScope(), t = e2.flags, s2 = e2.inClassFieldInit;
      return (64 & t) > 0 || s2 || this.options.allowSuperOutsideMethod;
    }, wa.allowDirectSuper.get = function() {
      return (128 & this.currentThisScope().flags) > 0;
    }, wa.treatFunctionsAsVar.get = function() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }, wa.allowNewDotTarget.get = function() {
      var e2 = this.currentThisScope(), t = e2.flags, s2 = e2.inClassFieldInit;
      return (258 & t) > 0 || s2;
    }, wa.inClassStaticBlock.get = function() {
      return (256 & this.currentVarScope().flags) > 0;
    }, ka.extend = function() {
      for (var e2 = [], t = arguments.length; t--; )
        e2[t] = arguments[t];
      for (var s2 = this, i2 = 0; i2 < e2.length; i2++)
        s2 = e2[i2](s2);
      return s2;
    }, ka.parse = function(e2, t) {
      return new this(t, e2).parse();
    }, ka.parseExpressionAt = function(e2, t, s2) {
      var i2 = new this(s2, e2, t);
      return i2.nextToken(), i2.parseExpression();
    }, ka.tokenizer = function(e2, t) {
      return new this(t, e2);
    }, Object.defineProperties(ka.prototype, wa);
    Ca = ka.prototype;
    Ia = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
    Ca.strictDirective = function(e2) {
      for (; ; ) {
        ua.lastIndex = e2, e2 += ua.exec(this.input)[0].length;
        var t = Ia.exec(this.input.slice(e2));
        if (!t)
          return false;
        if ((t[1] || t[2]) === "use strict") {
          ua.lastIndex = e2 + t[0].length;
          var s2 = ua.exec(this.input), i2 = s2.index + s2[0].length, n3 = this.input.charAt(i2);
          return n3 === ";" || n3 === "}" || oa.test(s2[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(n3) || n3 === "!" && this.input.charAt(i2 + 1) === "=");
        }
        e2 += t[0].length, ua.lastIndex = e2, e2 += ua.exec(this.input)[0].length, this.input[e2] === ";" && e2++;
      }
    }, Ca.eat = function(e2) {
      return this.type === e2 && (this.next(), true);
    }, Ca.isContextual = function(e2) {
      return this.type === aa.name && this.value === e2 && !this.containsEsc;
    }, Ca.eatContextual = function(e2) {
      return !!this.isContextual(e2) && (this.next(), true);
    }, Ca.expectContextual = function(e2) {
      this.eatContextual(e2) || this.unexpected();
    }, Ca.canInsertSemicolon = function() {
      return this.type === aa.eof || this.type === aa.braceR || oa.test(this.input.slice(this.lastTokEnd, this.start));
    }, Ca.insertSemicolon = function() {
      if (this.canInsertSemicolon())
        return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), true;
    }, Ca.semicolon = function() {
      this.eat(aa.semi) || this.insertSemicolon() || this.unexpected();
    }, Ca.afterTrailingComma = function(e2, t) {
      if (this.type === e2)
        return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t || this.next(), true;
    }, Ca.expect = function(e2) {
      this.eat(e2) || this.unexpected();
    }, Ca.unexpected = function(e2) {
      this.raise(e2 != null ? e2 : this.start, "Unexpected token");
    }, Ca.checkPatternErrors = function(e2, t) {
      if (e2) {
        e2.trailingComma > -1 && this.raiseRecoverable(e2.trailingComma, "Comma is not permitted after the rest element");
        var s2 = t ? e2.parenthesizedAssign : e2.parenthesizedBind;
        s2 > -1 && this.raiseRecoverable(s2, "Parenthesized pattern");
      }
    }, Ca.checkExpressionErrors = function(e2, t) {
      if (!e2)
        return false;
      var s2 = e2.shorthandAssign, i2 = e2.doubleProto;
      if (!t)
        return s2 >= 0 || i2 >= 0;
      s2 >= 0 && this.raise(s2, "Shorthand property assignments are valid only in destructuring patterns"), i2 >= 0 && this.raiseRecoverable(i2, "Redefinition of __proto__ property");
    }, Ca.checkYieldAwaitInDefaultParams = function() {
      this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
    }, Ca.isSimpleAssignTarget = function(e2) {
      return e2.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(e2.expression) : e2.type === "Identifier" || e2.type === "MemberExpression";
    };
    _a = ka.prototype;
    _a.parseTopLevel = function(e2) {
      var t = Object.create(null);
      for (e2.body || (e2.body = []); this.type !== aa.eof; ) {
        var s2 = this.parseStatement(null, true, t);
        e2.body.push(s2);
      }
      if (this.inModule)
        for (var i2 = 0, n3 = Object.keys(this.undefinedExports); i2 < n3.length; i2 += 1) {
          var r2 = n3[i2];
          this.raiseRecoverable(this.undefinedExports[r2].start, "Export '" + r2 + "' is not defined");
        }
      return this.adaptDirectivePrologue(e2.body), this.next(), e2.sourceType = this.options.sourceType, this.finishNode(e2, "Program");
    };
    $a = { kind: "loop" };
    Ta = { kind: "switch" };
    _a.isLet = function(e2) {
      if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
        return false;
      ua.lastIndex = this.pos;
      var t = ua.exec(this.input), s2 = this.pos + t[0].length, i2 = this.input.charCodeAt(s2);
      if (i2 === 91 || i2 === 92 || i2 > 55295 && i2 < 56320)
        return true;
      if (e2)
        return false;
      if (i2 === 123)
        return true;
      if (Zr(i2, true)) {
        for (var n3 = s2 + 1; Jr(i2 = this.input.charCodeAt(n3), true); )
          ++n3;
        if (i2 === 92 || i2 > 55295 && i2 < 56320)
          return true;
        var r2 = this.input.slice(s2, n3);
        if (!Ur.test(r2))
          return true;
      }
      return false;
    }, _a.isAsyncFunction = function() {
      if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
        return false;
      ua.lastIndex = this.pos;
      var e2, t = ua.exec(this.input), s2 = this.pos + t[0].length;
      return !(oa.test(this.input.slice(this.pos, s2)) || this.input.slice(s2, s2 + 8) !== "function" || s2 + 8 !== this.input.length && (Jr(e2 = this.input.charCodeAt(s2 + 8)) || e2 > 55295 && e2 < 56320));
    }, _a.parseStatement = function(e2, t, s2) {
      var i2, n3 = this.type, r2 = this.startNode();
      switch (this.isLet(e2) && (n3 = aa._var, i2 = "let"), n3) {
        case aa._break:
        case aa._continue:
          return this.parseBreakContinueStatement(r2, n3.keyword);
        case aa._debugger:
          return this.parseDebuggerStatement(r2);
        case aa._do:
          return this.parseDoStatement(r2);
        case aa._for:
          return this.parseForStatement(r2);
        case aa._function:
          return e2 && (this.strict || e2 !== "if" && e2 !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(r2, false, !e2);
        case aa._class:
          return e2 && this.unexpected(), this.parseClass(r2, true);
        case aa._if:
          return this.parseIfStatement(r2);
        case aa._return:
          return this.parseReturnStatement(r2);
        case aa._switch:
          return this.parseSwitchStatement(r2);
        case aa._throw:
          return this.parseThrowStatement(r2);
        case aa._try:
          return this.parseTryStatement(r2);
        case aa._const:
        case aa._var:
          return i2 = i2 || this.value, e2 && i2 !== "var" && this.unexpected(), this.parseVarStatement(r2, i2);
        case aa._while:
          return this.parseWhileStatement(r2);
        case aa._with:
          return this.parseWithStatement(r2);
        case aa.braceL:
          return this.parseBlock(true, r2);
        case aa.semi:
          return this.parseEmptyStatement(r2);
        case aa._export:
        case aa._import:
          if (this.options.ecmaVersion > 10 && n3 === aa._import) {
            ua.lastIndex = this.pos;
            var a2 = ua.exec(this.input), o2 = this.pos + a2[0].length, h3 = this.input.charCodeAt(o2);
            if (h3 === 40 || h3 === 46)
              return this.parseExpressionStatement(r2, this.parseExpression());
          }
          return this.options.allowImportExportEverywhere || (t || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), n3 === aa._import ? this.parseImport(r2) : this.parseExport(r2, s2);
        default:
          if (this.isAsyncFunction())
            return e2 && this.unexpected(), this.next(), this.parseFunctionStatement(r2, true, !e2);
          var l2 = this.value, c2 = this.parseExpression();
          return n3 === aa.name && c2.type === "Identifier" && this.eat(aa.colon) ? this.parseLabeledStatement(r2, l2, c2, e2) : this.parseExpressionStatement(r2, c2);
      }
    }, _a.parseBreakContinueStatement = function(e2, t) {
      var s2 = t === "break";
      this.next(), this.eat(aa.semi) || this.insertSemicolon() ? e2.label = null : this.type !== aa.name ? this.unexpected() : (e2.label = this.parseIdent(), this.semicolon());
      for (var i2 = 0; i2 < this.labels.length; ++i2) {
        var n3 = this.labels[i2];
        if (e2.label == null || n3.name === e2.label.name) {
          if (n3.kind != null && (s2 || n3.kind === "loop"))
            break;
          if (e2.label && s2)
            break;
        }
      }
      return i2 === this.labels.length && this.raise(e2.start, "Unsyntactic " + t), this.finishNode(e2, s2 ? "BreakStatement" : "ContinueStatement");
    }, _a.parseDebuggerStatement = function(e2) {
      return this.next(), this.semicolon(), this.finishNode(e2, "DebuggerStatement");
    }, _a.parseDoStatement = function(e2) {
      return this.next(), this.labels.push($a), e2.body = this.parseStatement("do"), this.labels.pop(), this.expect(aa._while), e2.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(aa.semi) : this.semicolon(), this.finishNode(e2, "DoWhileStatement");
    }, _a.parseForStatement = function(e2) {
      this.next();
      var t = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
      if (this.labels.push($a), this.enterScope(0), this.expect(aa.parenL), this.type === aa.semi)
        return t > -1 && this.unexpected(t), this.parseFor(e2, null);
      var s2 = this.isLet();
      if (this.type === aa._var || this.type === aa._const || s2) {
        var i2 = this.startNode(), n3 = s2 ? "let" : this.value;
        return this.next(), this.parseVar(i2, true, n3), this.finishNode(i2, "VariableDeclaration"), (this.type === aa._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && i2.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === aa._in ? t > -1 && this.unexpected(t) : e2.await = t > -1), this.parseForIn(e2, i2)) : (t > -1 && this.unexpected(t), this.parseFor(e2, i2));
      }
      var r2 = this.isContextual("let"), a2 = false, o2 = new Na(), h3 = this.parseExpression(!(t > -1) || "await", o2);
      return this.type === aa._in || (a2 = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (this.options.ecmaVersion >= 9 && (this.type === aa._in ? t > -1 && this.unexpected(t) : e2.await = t > -1), r2 && a2 && this.raise(h3.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(h3, false, o2), this.checkLValPattern(h3), this.parseForIn(e2, h3)) : (this.checkExpressionErrors(o2, true), t > -1 && this.unexpected(t), this.parseFor(e2, h3));
    }, _a.parseFunctionStatement = function(e2, t, s2) {
      return this.next(), this.parseFunction(e2, Ma | (s2 ? 0 : Da), false, t);
    }, _a.parseIfStatement = function(e2) {
      return this.next(), e2.test = this.parseParenExpression(), e2.consequent = this.parseStatement("if"), e2.alternate = this.eat(aa._else) ? this.parseStatement("if") : null, this.finishNode(e2, "IfStatement");
    }, _a.parseReturnStatement = function(e2) {
      return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), this.next(), this.eat(aa.semi) || this.insertSemicolon() ? e2.argument = null : (e2.argument = this.parseExpression(), this.semicolon()), this.finishNode(e2, "ReturnStatement");
    }, _a.parseSwitchStatement = function(e2) {
      var t;
      this.next(), e2.discriminant = this.parseParenExpression(), e2.cases = [], this.expect(aa.braceL), this.labels.push(Ta), this.enterScope(0);
      for (var s2 = false; this.type !== aa.braceR; )
        if (this.type === aa._case || this.type === aa._default) {
          var i2 = this.type === aa._case;
          t && this.finishNode(t, "SwitchCase"), e2.cases.push(t = this.startNode()), t.consequent = [], this.next(), i2 ? t.test = this.parseExpression() : (s2 && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), s2 = true, t.test = null), this.expect(aa.colon);
        } else
          t || this.unexpected(), t.consequent.push(this.parseStatement(null));
      return this.exitScope(), t && this.finishNode(t, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(e2, "SwitchStatement");
    }, _a.parseThrowStatement = function(e2) {
      return this.next(), oa.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), e2.argument = this.parseExpression(), this.semicolon(), this.finishNode(e2, "ThrowStatement");
    };
    Ra = [];
    _a.parseTryStatement = function(e2) {
      if (this.next(), e2.block = this.parseBlock(), e2.handler = null, this.type === aa._catch) {
        var t = this.startNode();
        if (this.next(), this.eat(aa.parenL)) {
          t.param = this.parseBindingAtom();
          var s2 = t.param.type === "Identifier";
          this.enterScope(s2 ? 32 : 0), this.checkLValPattern(t.param, s2 ? 4 : 2), this.expect(aa.parenR);
        } else
          this.options.ecmaVersion < 10 && this.unexpected(), t.param = null, this.enterScope(0);
        t.body = this.parseBlock(false), this.exitScope(), e2.handler = this.finishNode(t, "CatchClause");
      }
      return e2.finalizer = this.eat(aa._finally) ? this.parseBlock() : null, e2.handler || e2.finalizer || this.raise(e2.start, "Missing catch or finally clause"), this.finishNode(e2, "TryStatement");
    }, _a.parseVarStatement = function(e2, t) {
      return this.next(), this.parseVar(e2, false, t), this.semicolon(), this.finishNode(e2, "VariableDeclaration");
    }, _a.parseWhileStatement = function(e2) {
      return this.next(), e2.test = this.parseParenExpression(), this.labels.push($a), e2.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(e2, "WhileStatement");
    }, _a.parseWithStatement = function(e2) {
      return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e2.object = this.parseParenExpression(), e2.body = this.parseStatement("with"), this.finishNode(e2, "WithStatement");
    }, _a.parseEmptyStatement = function(e2) {
      return this.next(), this.finishNode(e2, "EmptyStatement");
    }, _a.parseLabeledStatement = function(e2, t, s2, i2) {
      for (var n3 = 0, r2 = this.labels; n3 < r2.length; n3 += 1) {
        r2[n3].name === t && this.raise(s2.start, "Label '" + t + "' is already declared");
      }
      for (var a2 = this.type.isLoop ? "loop" : this.type === aa._switch ? "switch" : null, o2 = this.labels.length - 1; o2 >= 0; o2--) {
        var h3 = this.labels[o2];
        if (h3.statementStart !== e2.start)
          break;
        h3.statementStart = this.start, h3.kind = a2;
      }
      return this.labels.push({ name: t, kind: a2, statementStart: this.start }), e2.body = this.parseStatement(i2 ? i2.indexOf("label") === -1 ? i2 + "label" : i2 : "label"), this.labels.pop(), e2.label = s2, this.finishNode(e2, "LabeledStatement");
    }, _a.parseExpressionStatement = function(e2, t) {
      return e2.expression = t, this.semicolon(), this.finishNode(e2, "ExpressionStatement");
    }, _a.parseBlock = function(e2, t, s2) {
      for (e2 === void 0 && (e2 = true), t === void 0 && (t = this.startNode()), t.body = [], this.expect(aa.braceL), e2 && this.enterScope(0); this.type !== aa.braceR; ) {
        var i2 = this.parseStatement(null);
        t.body.push(i2);
      }
      return s2 && (this.strict = false), this.next(), e2 && this.exitScope(), this.finishNode(t, "BlockStatement");
    }, _a.parseFor = function(e2, t) {
      return e2.init = t, this.expect(aa.semi), e2.test = this.type === aa.semi ? null : this.parseExpression(), this.expect(aa.semi), e2.update = this.type === aa.parenR ? null : this.parseExpression(), this.expect(aa.parenR), e2.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e2, "ForStatement");
    }, _a.parseForIn = function(e2, t) {
      var s2 = this.type === aa._in;
      return this.next(), t.type === "VariableDeclaration" && t.declarations[0].init != null && (!s2 || this.options.ecmaVersion < 8 || this.strict || t.kind !== "var" || t.declarations[0].id.type !== "Identifier") && this.raise(t.start, (s2 ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"), e2.left = t, e2.right = s2 ? this.parseExpression() : this.parseMaybeAssign(), this.expect(aa.parenR), e2.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e2, s2 ? "ForInStatement" : "ForOfStatement");
    }, _a.parseVar = function(e2, t, s2) {
      for (e2.declarations = [], e2.kind = s2; ; ) {
        var i2 = this.startNode();
        if (this.parseVarId(i2, s2), this.eat(aa.eq) ? i2.init = this.parseMaybeAssign(t) : s2 !== "const" || this.type === aa._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? i2.id.type === "Identifier" || t && (this.type === aa._in || this.isContextual("of")) ? i2.init = null : this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : this.unexpected(), e2.declarations.push(this.finishNode(i2, "VariableDeclarator")), !this.eat(aa.comma))
          break;
      }
      return e2;
    }, _a.parseVarId = function(e2, t) {
      e2.id = this.parseBindingAtom(), this.checkLValPattern(e2.id, t === "var" ? 1 : 2, false);
    };
    Ma = 1;
    Da = 2;
    _a.parseFunction = function(e2, t, s2, i2, n3) {
      this.initFunction(e2), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !i2) && (this.type === aa.star && t & Da && this.unexpected(), e2.generator = this.eat(aa.star)), this.options.ecmaVersion >= 8 && (e2.async = !!i2), t & Ma && (e2.id = 4 & t && this.type !== aa.name ? null : this.parseIdent(), !e2.id || t & Da || this.checkLValSimple(e2.id, this.strict || e2.generator || e2.async ? this.treatFunctionsAsVar ? 1 : 2 : 3));
      var r2 = this.yieldPos, a2 = this.awaitPos, o2 = this.awaitIdentPos;
      return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Pa(e2.async, e2.generator)), t & Ma || (e2.id = this.type === aa.name ? this.parseIdent() : null), this.parseFunctionParams(e2), this.parseFunctionBody(e2, s2, false, n3), this.yieldPos = r2, this.awaitPos = a2, this.awaitIdentPos = o2, this.finishNode(e2, t & Ma ? "FunctionDeclaration" : "FunctionExpression");
    }, _a.parseFunctionParams = function(e2) {
      this.expect(aa.parenL), e2.params = this.parseBindingList(aa.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
    }, _a.parseClass = function(e2, t) {
      this.next();
      var s2 = this.strict;
      this.strict = true, this.parseClassId(e2, t), this.parseClassSuper(e2);
      var i2 = this.enterClassBody(), n3 = this.startNode(), r2 = false;
      for (n3.body = [], this.expect(aa.braceL); this.type !== aa.braceR; ) {
        var a2 = this.parseClassElement(e2.superClass !== null);
        a2 && (n3.body.push(a2), a2.type === "MethodDefinition" && a2.kind === "constructor" ? (r2 && this.raise(a2.start, "Duplicate constructor in the same class"), r2 = true) : a2.key && a2.key.type === "PrivateIdentifier" && La(i2, a2) && this.raiseRecoverable(a2.key.start, "Identifier '#" + a2.key.name + "' has already been declared"));
      }
      return this.strict = s2, this.next(), e2.body = this.finishNode(n3, "ClassBody"), this.exitClassBody(), this.finishNode(e2, t ? "ClassDeclaration" : "ClassExpression");
    }, _a.parseClassElement = function(e2) {
      if (this.eat(aa.semi))
        return null;
      var t = this.options.ecmaVersion, s2 = this.startNode(), i2 = "", n3 = false, r2 = false, a2 = "method", o2 = false;
      if (this.eatContextual("static")) {
        if (t >= 13 && this.eat(aa.braceL))
          return this.parseClassStaticBlock(s2), s2;
        this.isClassElementNameStart() || this.type === aa.star ? o2 = true : i2 = "static";
      }
      if (s2.static = o2, !i2 && t >= 8 && this.eatContextual("async") && (!this.isClassElementNameStart() && this.type !== aa.star || this.canInsertSemicolon() ? i2 = "async" : r2 = true), !i2 && (t >= 9 || !r2) && this.eat(aa.star) && (n3 = true), !i2 && !r2 && !n3) {
        var h3 = this.value;
        (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? a2 = h3 : i2 = h3);
      }
      if (i2 ? (s2.computed = false, s2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), s2.key.name = i2, this.finishNode(s2.key, "Identifier")) : this.parseClassElementName(s2), t < 13 || this.type === aa.parenL || a2 !== "method" || n3 || r2) {
        var l2 = !s2.static && Oa(s2, "constructor"), c2 = l2 && e2;
        l2 && a2 !== "method" && this.raise(s2.key.start, "Constructor can't have get/set modifier"), s2.kind = l2 ? "constructor" : a2, this.parseClassMethod(s2, n3, r2, c2);
      } else
        this.parseClassField(s2);
      return s2;
    }, _a.isClassElementNameStart = function() {
      return this.type === aa.name || this.type === aa.privateId || this.type === aa.num || this.type === aa.string || this.type === aa.bracketL || this.type.keyword;
    }, _a.parseClassElementName = function(e2) {
      this.type === aa.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), e2.computed = false, e2.key = this.parsePrivateIdent()) : this.parsePropertyName(e2);
    }, _a.parseClassMethod = function(e2, t, s2, i2) {
      var n3 = e2.key;
      e2.kind === "constructor" ? (t && this.raise(n3.start, "Constructor can't be a generator"), s2 && this.raise(n3.start, "Constructor can't be an async method")) : e2.static && Oa(e2, "prototype") && this.raise(n3.start, "Classes may not have a static property named prototype");
      var r2 = e2.value = this.parseMethod(t, s2, i2);
      return e2.kind === "get" && r2.params.length !== 0 && this.raiseRecoverable(r2.start, "getter should have no params"), e2.kind === "set" && r2.params.length !== 1 && this.raiseRecoverable(r2.start, "setter should have exactly one param"), e2.kind === "set" && r2.params[0].type === "RestElement" && this.raiseRecoverable(r2.params[0].start, "Setter cannot use rest params"), this.finishNode(e2, "MethodDefinition");
    }, _a.parseClassField = function(e2) {
      if (Oa(e2, "constructor") ? this.raise(e2.key.start, "Classes can't have a field named 'constructor'") : e2.static && Oa(e2, "prototype") && this.raise(e2.key.start, "Classes can't have a static field named 'prototype'"), this.eat(aa.eq)) {
        var t = this.currentThisScope(), s2 = t.inClassFieldInit;
        t.inClassFieldInit = true, e2.value = this.parseMaybeAssign(), t.inClassFieldInit = s2;
      } else
        e2.value = null;
      return this.semicolon(), this.finishNode(e2, "PropertyDefinition");
    }, _a.parseClassStaticBlock = function(e2) {
      e2.body = [];
      var t = this.labels;
      for (this.labels = [], this.enterScope(320); this.type !== aa.braceR; ) {
        var s2 = this.parseStatement(null);
        e2.body.push(s2);
      }
      return this.next(), this.exitScope(), this.labels = t, this.finishNode(e2, "StaticBlock");
    }, _a.parseClassId = function(e2, t) {
      this.type === aa.name ? (e2.id = this.parseIdent(), t && this.checkLValSimple(e2.id, 2, false)) : (t === true && this.unexpected(), e2.id = null);
    }, _a.parseClassSuper = function(e2) {
      e2.superClass = this.eat(aa._extends) ? this.parseExprSubscripts(false) : null;
    }, _a.enterClassBody = function() {
      var e2 = { declared: Object.create(null), used: [] };
      return this.privateNameStack.push(e2), e2.declared;
    }, _a.exitClassBody = function() {
      for (var e2 = this.privateNameStack.pop(), t = e2.declared, s2 = e2.used, i2 = this.privateNameStack.length, n3 = i2 === 0 ? null : this.privateNameStack[i2 - 1], r2 = 0; r2 < s2.length; ++r2) {
        var a2 = s2[r2];
        ma(t, a2.name) || (n3 ? n3.used.push(a2) : this.raiseRecoverable(a2.start, "Private field '#" + a2.name + "' must be declared in an enclosing class"));
      }
    }, _a.parseExport = function(e2, t) {
      if (this.next(), this.eat(aa.star))
        return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (e2.exported = this.parseIdent(true), this.checkExport(t, e2.exported.name, this.lastTokStart)) : e2.exported = null), this.expectContextual("from"), this.type !== aa.string && this.unexpected(), e2.source = this.parseExprAtom(), this.semicolon(), this.finishNode(e2, "ExportAllDeclaration");
      if (this.eat(aa._default)) {
        var s2;
        if (this.checkExport(t, "default", this.lastTokStart), this.type === aa._function || (s2 = this.isAsyncFunction())) {
          var i2 = this.startNode();
          this.next(), s2 && this.next(), e2.declaration = this.parseFunction(i2, 4 | Ma, false, s2);
        } else if (this.type === aa._class) {
          var n3 = this.startNode();
          e2.declaration = this.parseClass(n3, "nullableID");
        } else
          e2.declaration = this.parseMaybeAssign(), this.semicolon();
        return this.finishNode(e2, "ExportDefaultDeclaration");
      }
      if (this.shouldParseExportStatement())
        e2.declaration = this.parseStatement(null), e2.declaration.type === "VariableDeclaration" ? this.checkVariableExport(t, e2.declaration.declarations) : this.checkExport(t, e2.declaration.id.name, e2.declaration.id.start), e2.specifiers = [], e2.source = null;
      else {
        if (e2.declaration = null, e2.specifiers = this.parseExportSpecifiers(t), this.eatContextual("from"))
          this.type !== aa.string && this.unexpected(), e2.source = this.parseExprAtom();
        else {
          for (var r2 = 0, a2 = e2.specifiers; r2 < a2.length; r2 += 1) {
            var o2 = a2[r2];
            this.checkUnreserved(o2.local), this.checkLocalExport(o2.local);
          }
          e2.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(e2, "ExportNamedDeclaration");
    }, _a.checkExport = function(e2, t, s2) {
      e2 && (ma(e2, t) && this.raiseRecoverable(s2, "Duplicate export '" + t + "'"), e2[t] = true);
    }, _a.checkPatternExport = function(e2, t) {
      var s2 = t.type;
      if (s2 === "Identifier")
        this.checkExport(e2, t.name, t.start);
      else if (s2 === "ObjectPattern")
        for (var i2 = 0, n3 = t.properties; i2 < n3.length; i2 += 1) {
          var r2 = n3[i2];
          this.checkPatternExport(e2, r2);
        }
      else if (s2 === "ArrayPattern")
        for (var a2 = 0, o2 = t.elements; a2 < o2.length; a2 += 1) {
          var h3 = o2[a2];
          h3 && this.checkPatternExport(e2, h3);
        }
      else
        s2 === "Property" ? this.checkPatternExport(e2, t.value) : s2 === "AssignmentPattern" ? this.checkPatternExport(e2, t.left) : s2 === "RestElement" ? this.checkPatternExport(e2, t.argument) : s2 === "ParenthesizedExpression" && this.checkPatternExport(e2, t.expression);
    }, _a.checkVariableExport = function(e2, t) {
      if (e2)
        for (var s2 = 0, i2 = t; s2 < i2.length; s2 += 1) {
          var n3 = i2[s2];
          this.checkPatternExport(e2, n3.id);
        }
    }, _a.shouldParseExportStatement = function() {
      return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
    }, _a.parseExportSpecifiers = function(e2) {
      var t = [], s2 = true;
      for (this.expect(aa.braceL); !this.eat(aa.braceR); ) {
        if (s2)
          s2 = false;
        else if (this.expect(aa.comma), this.afterTrailingComma(aa.braceR))
          break;
        var i2 = this.startNode();
        i2.local = this.parseIdent(true), i2.exported = this.eatContextual("as") ? this.parseIdent(true) : i2.local, this.checkExport(e2, i2.exported.name, i2.exported.start), t.push(this.finishNode(i2, "ExportSpecifier"));
      }
      return t;
    }, _a.parseImport = function(e2) {
      return this.next(), this.type === aa.string ? (e2.specifiers = Ra, e2.source = this.parseExprAtom()) : (e2.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), e2.source = this.type === aa.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(e2, "ImportDeclaration");
    }, _a.parseImportSpecifiers = function() {
      var e2 = [], t = true;
      if (this.type === aa.name) {
        var s2 = this.startNode();
        if (s2.local = this.parseIdent(), this.checkLValSimple(s2.local, 2), e2.push(this.finishNode(s2, "ImportDefaultSpecifier")), !this.eat(aa.comma))
          return e2;
      }
      if (this.type === aa.star) {
        var i2 = this.startNode();
        return this.next(), this.expectContextual("as"), i2.local = this.parseIdent(), this.checkLValSimple(i2.local, 2), e2.push(this.finishNode(i2, "ImportNamespaceSpecifier")), e2;
      }
      for (this.expect(aa.braceL); !this.eat(aa.braceR); ) {
        if (t)
          t = false;
        else if (this.expect(aa.comma), this.afterTrailingComma(aa.braceR))
          break;
        var n3 = this.startNode();
        n3.imported = this.parseIdent(true), this.eatContextual("as") ? n3.local = this.parseIdent() : (this.checkUnreserved(n3.imported), n3.local = n3.imported), this.checkLValSimple(n3.local, 2), e2.push(this.finishNode(n3, "ImportSpecifier"));
      }
      return e2;
    }, _a.adaptDirectivePrologue = function(e2) {
      for (var t = 0; t < e2.length && this.isDirectiveCandidate(e2[t]); ++t)
        e2[t].directive = e2[t].expression.raw.slice(1, -1);
    }, _a.isDirectiveCandidate = function(e2) {
      return e2.type === "ExpressionStatement" && e2.expression.type === "Literal" && typeof e2.expression.value == "string" && (this.input[e2.start] === '"' || this.input[e2.start] === "'");
    };
    Va = ka.prototype;
    Va.toAssignable = function(e2, t, s2) {
      if (this.options.ecmaVersion >= 6 && e2)
        switch (e2.type) {
          case "Identifier":
            this.inAsync && e2.name === "await" && this.raise(e2.start, "Cannot use 'await' as identifier inside an async function");
            break;
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            e2.type = "ObjectPattern", s2 && this.checkPatternErrors(s2, true);
            for (var i2 = 0, n3 = e2.properties; i2 < n3.length; i2 += 1) {
              var r2 = n3[i2];
              this.toAssignable(r2, t), r2.type !== "RestElement" || r2.argument.type !== "ArrayPattern" && r2.argument.type !== "ObjectPattern" || this.raise(r2.argument.start, "Unexpected token");
            }
            break;
          case "Property":
            e2.kind !== "init" && this.raise(e2.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e2.value, t);
            break;
          case "ArrayExpression":
            e2.type = "ArrayPattern", s2 && this.checkPatternErrors(s2, true), this.toAssignableList(e2.elements, t);
            break;
          case "SpreadElement":
            e2.type = "RestElement", this.toAssignable(e2.argument, t), e2.argument.type === "AssignmentPattern" && this.raise(e2.argument.start, "Rest elements cannot have a default value");
            break;
          case "AssignmentExpression":
            e2.operator !== "=" && this.raise(e2.left.end, "Only '=' operator can be used for specifying default value."), e2.type = "AssignmentPattern", delete e2.operator, this.toAssignable(e2.left, t);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(e2.expression, t, s2);
            break;
          case "ChainExpression":
            this.raiseRecoverable(e2.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (!t)
              break;
          default:
            this.raise(e2.start, "Assigning to rvalue");
        }
      else
        s2 && this.checkPatternErrors(s2, true);
      return e2;
    }, Va.toAssignableList = function(e2, t) {
      for (var s2 = e2.length, i2 = 0; i2 < s2; i2++) {
        var n3 = e2[i2];
        n3 && this.toAssignable(n3, t);
      }
      if (s2) {
        var r2 = e2[s2 - 1];
        this.options.ecmaVersion === 6 && t && r2 && r2.type === "RestElement" && r2.argument.type !== "Identifier" && this.unexpected(r2.argument.start);
      }
      return e2;
    }, Va.parseSpread = function(e2) {
      var t = this.startNode();
      return this.next(), t.argument = this.parseMaybeAssign(false, e2), this.finishNode(t, "SpreadElement");
    }, Va.parseRestBinding = function() {
      var e2 = this.startNode();
      return this.next(), this.options.ecmaVersion === 6 && this.type !== aa.name && this.unexpected(), e2.argument = this.parseBindingAtom(), this.finishNode(e2, "RestElement");
    }, Va.parseBindingAtom = function() {
      if (this.options.ecmaVersion >= 6)
        switch (this.type) {
          case aa.bracketL:
            var e2 = this.startNode();
            return this.next(), e2.elements = this.parseBindingList(aa.bracketR, true, true), this.finishNode(e2, "ArrayPattern");
          case aa.braceL:
            return this.parseObj(true);
        }
      return this.parseIdent();
    }, Va.parseBindingList = function(e2, t, s2) {
      for (var i2 = [], n3 = true; !this.eat(e2); )
        if (n3 ? n3 = false : this.expect(aa.comma), t && this.type === aa.comma)
          i2.push(null);
        else {
          if (s2 && this.afterTrailingComma(e2))
            break;
          if (this.type === aa.ellipsis) {
            var r2 = this.parseRestBinding();
            this.parseBindingListItem(r2), i2.push(r2), this.type === aa.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.expect(e2);
            break;
          }
          var a2 = this.parseMaybeDefault(this.start, this.startLoc);
          this.parseBindingListItem(a2), i2.push(a2);
        }
      return i2;
    }, Va.parseBindingListItem = function(e2) {
      return e2;
    }, Va.parseMaybeDefault = function(e2, t, s2) {
      if (s2 = s2 || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(aa.eq))
        return s2;
      var i2 = this.startNodeAt(e2, t);
      return i2.left = s2, i2.right = this.parseMaybeAssign(), this.finishNode(i2, "AssignmentPattern");
    }, Va.checkLValSimple = function(e2, t, s2) {
      t === void 0 && (t = 0);
      var i2 = t !== 0;
      switch (e2.type) {
        case "Identifier":
          this.strict && this.reservedWordsStrictBind.test(e2.name) && this.raiseRecoverable(e2.start, (i2 ? "Binding " : "Assigning to ") + e2.name + " in strict mode"), i2 && (t === 2 && e2.name === "let" && this.raiseRecoverable(e2.start, "let is disallowed as a lexically bound name"), s2 && (ma(s2, e2.name) && this.raiseRecoverable(e2.start, "Argument name clash"), s2[e2.name] = true), t !== 5 && this.declareName(e2.name, t, e2.start));
          break;
        case "ChainExpression":
          this.raiseRecoverable(e2.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          i2 && this.raiseRecoverable(e2.start, "Binding member expression");
          break;
        case "ParenthesizedExpression":
          return i2 && this.raiseRecoverable(e2.start, "Binding parenthesized expression"), this.checkLValSimple(e2.expression, t, s2);
        default:
          this.raise(e2.start, (i2 ? "Binding" : "Assigning to") + " rvalue");
      }
    }, Va.checkLValPattern = function(e2, t, s2) {
      switch (t === void 0 && (t = 0), e2.type) {
        case "ObjectPattern":
          for (var i2 = 0, n3 = e2.properties; i2 < n3.length; i2 += 1) {
            var r2 = n3[i2];
            this.checkLValInnerPattern(r2, t, s2);
          }
          break;
        case "ArrayPattern":
          for (var a2 = 0, o2 = e2.elements; a2 < o2.length; a2 += 1) {
            var h3 = o2[a2];
            h3 && this.checkLValInnerPattern(h3, t, s2);
          }
          break;
        default:
          this.checkLValSimple(e2, t, s2);
      }
    }, Va.checkLValInnerPattern = function(e2, t, s2) {
      switch (t === void 0 && (t = 0), e2.type) {
        case "Property":
          this.checkLValInnerPattern(e2.value, t, s2);
          break;
        case "AssignmentPattern":
          this.checkLValPattern(e2.left, t, s2);
          break;
        case "RestElement":
          this.checkLValPattern(e2.argument, t, s2);
          break;
        default:
          this.checkLValPattern(e2, t, s2);
      }
    };
    Ba = function(e2, t, s2, i2, n3) {
      this.token = e2, this.isExpr = !!t, this.preserveSpace = !!s2, this.override = i2, this.generator = !!n3;
    };
    Fa = { b_stat: new Ba("{", false), b_expr: new Ba("{", true), b_tmpl: new Ba("${", false), p_stat: new Ba("(", false), p_expr: new Ba("(", true), q_tmpl: new Ba("`", true, true, function(e2) {
      return e2.tryReadTemplateToken();
    }), f_stat: new Ba("function", false), f_expr: new Ba("function", true), f_expr_gen: new Ba("function", true, false, null, true), f_gen: new Ba("function", false, false, null, true) };
    za = ka.prototype;
    za.initialContext = function() {
      return [Fa.b_stat];
    }, za.curContext = function() {
      return this.context[this.context.length - 1];
    }, za.braceIsBlock = function(e2) {
      var t = this.curContext();
      return t === Fa.f_expr || t === Fa.f_stat || (e2 !== aa.colon || t !== Fa.b_stat && t !== Fa.b_expr ? e2 === aa._return || e2 === aa.name && this.exprAllowed ? oa.test(this.input.slice(this.lastTokEnd, this.start)) : e2 === aa._else || e2 === aa.semi || e2 === aa.eof || e2 === aa.parenR || e2 === aa.arrow || (e2 === aa.braceL ? t === Fa.b_stat : e2 !== aa._var && e2 !== aa._const && e2 !== aa.name && !this.exprAllowed) : !t.isExpr);
    }, za.inGeneratorContext = function() {
      for (var e2 = this.context.length - 1; e2 >= 1; e2--) {
        var t = this.context[e2];
        if (t.token === "function")
          return t.generator;
      }
      return false;
    }, za.updateContext = function(e2) {
      var t, s2 = this.type;
      s2.keyword && e2 === aa.dot ? this.exprAllowed = false : (t = s2.updateContext) ? t.call(this, e2) : this.exprAllowed = s2.beforeExpr;
    }, za.overrideContext = function(e2) {
      this.curContext() !== e2 && (this.context[this.context.length - 1] = e2);
    }, aa.parenR.updateContext = aa.braceR.updateContext = function() {
      if (this.context.length !== 1) {
        var e2 = this.context.pop();
        e2 === Fa.b_stat && this.curContext().token === "function" && (e2 = this.context.pop()), this.exprAllowed = !e2.isExpr;
      } else
        this.exprAllowed = true;
    }, aa.braceL.updateContext = function(e2) {
      this.context.push(this.braceIsBlock(e2) ? Fa.b_stat : Fa.b_expr), this.exprAllowed = true;
    }, aa.dollarBraceL.updateContext = function() {
      this.context.push(Fa.b_tmpl), this.exprAllowed = true;
    }, aa.parenL.updateContext = function(e2) {
      var t = e2 === aa._if || e2 === aa._for || e2 === aa._with || e2 === aa._while;
      this.context.push(t ? Fa.p_stat : Fa.p_expr), this.exprAllowed = true;
    }, aa.incDec.updateContext = function() {
    }, aa._function.updateContext = aa._class.updateContext = function(e2) {
      !e2.beforeExpr || e2 === aa._else || e2 === aa.semi && this.curContext() !== Fa.p_stat || e2 === aa._return && oa.test(this.input.slice(this.lastTokEnd, this.start)) || (e2 === aa.colon || e2 === aa.braceL) && this.curContext() === Fa.b_stat ? this.context.push(Fa.f_stat) : this.context.push(Fa.f_expr), this.exprAllowed = false;
    }, aa.backQuote.updateContext = function() {
      this.curContext() === Fa.q_tmpl ? this.context.pop() : this.context.push(Fa.q_tmpl), this.exprAllowed = false;
    }, aa.star.updateContext = function(e2) {
      if (e2 === aa._function) {
        var t = this.context.length - 1;
        this.context[t] === Fa.f_expr ? this.context[t] = Fa.f_expr_gen : this.context[t] = Fa.f_gen;
      }
      this.exprAllowed = true;
    }, aa.name.updateContext = function(e2) {
      var t = false;
      this.options.ecmaVersion >= 6 && e2 !== aa.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (t = true), this.exprAllowed = t;
    };
    Wa = ka.prototype;
    Wa.checkPropClash = function(e2, t, s2) {
      if (!(this.options.ecmaVersion >= 9 && e2.type === "SpreadElement" || this.options.ecmaVersion >= 6 && (e2.computed || e2.method || e2.shorthand))) {
        var i2, n3 = e2.key;
        switch (n3.type) {
          case "Identifier":
            i2 = n3.name;
            break;
          case "Literal":
            i2 = String(n3.value);
            break;
          default:
            return;
        }
        var r2 = e2.kind;
        if (this.options.ecmaVersion >= 6)
          i2 === "__proto__" && r2 === "init" && (t.proto && (s2 ? s2.doubleProto < 0 && (s2.doubleProto = n3.start) : this.raiseRecoverable(n3.start, "Redefinition of __proto__ property")), t.proto = true);
        else {
          var a2 = t[i2 = "$" + i2];
          if (a2)
            (r2 === "init" ? this.strict && a2.init || a2.get || a2.set : a2.init || a2[r2]) && this.raiseRecoverable(n3.start, "Redefinition of property");
          else
            a2 = t[i2] = { init: false, get: false, set: false };
          a2[r2] = true;
        }
      }
    }, Wa.parseExpression = function(e2, t) {
      var s2 = this.start, i2 = this.startLoc, n3 = this.parseMaybeAssign(e2, t);
      if (this.type === aa.comma) {
        var r2 = this.startNodeAt(s2, i2);
        for (r2.expressions = [n3]; this.eat(aa.comma); )
          r2.expressions.push(this.parseMaybeAssign(e2, t));
        return this.finishNode(r2, "SequenceExpression");
      }
      return n3;
    }, Wa.parseMaybeAssign = function(e2, t, s2) {
      if (this.isContextual("yield")) {
        if (this.inGenerator)
          return this.parseYield(e2);
        this.exprAllowed = false;
      }
      var i2 = false, n3 = -1, r2 = -1, a2 = -1;
      t ? (n3 = t.parenthesizedAssign, r2 = t.trailingComma, a2 = t.doubleProto, t.parenthesizedAssign = t.trailingComma = -1) : (t = new Na(), i2 = true);
      var o2 = this.start, h3 = this.startLoc;
      this.type !== aa.parenL && this.type !== aa.name || (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = e2 === "await");
      var l2 = this.parseMaybeConditional(e2, t);
      if (s2 && (l2 = s2.call(this, l2, o2, h3)), this.type.isAssign) {
        var c2 = this.startNodeAt(o2, h3);
        return c2.operator = this.value, this.type === aa.eq && (l2 = this.toAssignable(l2, false, t)), i2 || (t.parenthesizedAssign = t.trailingComma = t.doubleProto = -1), t.shorthandAssign >= l2.start && (t.shorthandAssign = -1), this.type === aa.eq ? this.checkLValPattern(l2) : this.checkLValSimple(l2), c2.left = l2, this.next(), c2.right = this.parseMaybeAssign(e2), a2 > -1 && (t.doubleProto = a2), this.finishNode(c2, "AssignmentExpression");
      }
      return i2 && this.checkExpressionErrors(t, true), n3 > -1 && (t.parenthesizedAssign = n3), r2 > -1 && (t.trailingComma = r2), l2;
    }, Wa.parseMaybeConditional = function(e2, t) {
      var s2 = this.start, i2 = this.startLoc, n3 = this.parseExprOps(e2, t);
      if (this.checkExpressionErrors(t))
        return n3;
      if (this.eat(aa.question)) {
        var r2 = this.startNodeAt(s2, i2);
        return r2.test = n3, r2.consequent = this.parseMaybeAssign(), this.expect(aa.colon), r2.alternate = this.parseMaybeAssign(e2), this.finishNode(r2, "ConditionalExpression");
      }
      return n3;
    }, Wa.parseExprOps = function(e2, t) {
      var s2 = this.start, i2 = this.startLoc, n3 = this.parseMaybeUnary(t, false, false, e2);
      return this.checkExpressionErrors(t) || n3.start === s2 && n3.type === "ArrowFunctionExpression" ? n3 : this.parseExprOp(n3, s2, i2, -1, e2);
    }, Wa.parseExprOp = function(e2, t, s2, i2, n3) {
      var r2 = this.type.binop;
      if (r2 != null && (!n3 || this.type !== aa._in) && r2 > i2) {
        var a2 = this.type === aa.logicalOR || this.type === aa.logicalAND, o2 = this.type === aa.coalesce;
        o2 && (r2 = aa.logicalAND.binop);
        var h3 = this.value;
        this.next();
        var l2 = this.start, c2 = this.startLoc, u2 = this.parseExprOp(this.parseMaybeUnary(null, false, false, n3), l2, c2, r2, n3), d3 = this.buildBinary(t, s2, e2, u2, h3, a2 || o2);
        return (a2 && this.type === aa.coalesce || o2 && (this.type === aa.logicalOR || this.type === aa.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(d3, t, s2, i2, n3);
      }
      return e2;
    }, Wa.buildBinary = function(e2, t, s2, i2, n3, r2) {
      i2.type === "PrivateIdentifier" && this.raise(i2.start, "Private identifier can only be left side of binary expression");
      var a2 = this.startNodeAt(e2, t);
      return a2.left = s2, a2.operator = n3, a2.right = i2, this.finishNode(a2, r2 ? "LogicalExpression" : "BinaryExpression");
    }, Wa.parseMaybeUnary = function(e2, t, s2, i2) {
      var n3, r2 = this.start, a2 = this.startLoc;
      if (this.isContextual("await") && this.canAwait)
        n3 = this.parseAwait(i2), t = true;
      else if (this.type.prefix) {
        var o2 = this.startNode(), h3 = this.type === aa.incDec;
        o2.operator = this.value, o2.prefix = true, this.next(), o2.argument = this.parseMaybeUnary(null, true, h3, i2), this.checkExpressionErrors(e2, true), h3 ? this.checkLValSimple(o2.argument) : this.strict && o2.operator === "delete" && o2.argument.type === "Identifier" ? this.raiseRecoverable(o2.start, "Deleting local variable in strict mode") : o2.operator === "delete" && ja(o2.argument) ? this.raiseRecoverable(o2.start, "Private fields can not be deleted") : t = true, n3 = this.finishNode(o2, h3 ? "UpdateExpression" : "UnaryExpression");
      } else if (t || this.type !== aa.privateId) {
        if (n3 = this.parseExprSubscripts(e2, i2), this.checkExpressionErrors(e2))
          return n3;
        for (; this.type.postfix && !this.canInsertSemicolon(); ) {
          var l2 = this.startNodeAt(r2, a2);
          l2.operator = this.value, l2.prefix = false, l2.argument = n3, this.checkLValSimple(n3), this.next(), n3 = this.finishNode(l2, "UpdateExpression");
        }
      } else
        (i2 || this.privateNameStack.length === 0) && this.unexpected(), n3 = this.parsePrivateIdent(), this.type !== aa._in && this.unexpected();
      return s2 || !this.eat(aa.starstar) ? n3 : t ? void this.unexpected(this.lastTokStart) : this.buildBinary(r2, a2, n3, this.parseMaybeUnary(null, false, false, i2), "**", false);
    }, Wa.parseExprSubscripts = function(e2, t) {
      var s2 = this.start, i2 = this.startLoc, n3 = this.parseExprAtom(e2, t);
      if (n3.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
        return n3;
      var r2 = this.parseSubscripts(n3, s2, i2, false, t);
      return e2 && r2.type === "MemberExpression" && (e2.parenthesizedAssign >= r2.start && (e2.parenthesizedAssign = -1), e2.parenthesizedBind >= r2.start && (e2.parenthesizedBind = -1), e2.trailingComma >= r2.start && (e2.trailingComma = -1)), r2;
    }, Wa.parseSubscripts = function(e2, t, s2, i2, n3) {
      for (var r2 = this.options.ecmaVersion >= 8 && e2.type === "Identifier" && e2.name === "async" && this.lastTokEnd === e2.end && !this.canInsertSemicolon() && e2.end - e2.start == 5 && this.potentialArrowAt === e2.start, a2 = false; ; ) {
        var o2 = this.parseSubscript(e2, t, s2, i2, r2, a2, n3);
        if (o2.optional && (a2 = true), o2 === e2 || o2.type === "ArrowFunctionExpression") {
          if (a2) {
            var h3 = this.startNodeAt(t, s2);
            h3.expression = o2, o2 = this.finishNode(h3, "ChainExpression");
          }
          return o2;
        }
        e2 = o2;
      }
    }, Wa.parseSubscript = function(e2, t, s2, i2, n3, r2, a2) {
      var o2 = this.options.ecmaVersion >= 11, h3 = o2 && this.eat(aa.questionDot);
      i2 && h3 && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
      var l2 = this.eat(aa.bracketL);
      if (l2 || h3 && this.type !== aa.parenL && this.type !== aa.backQuote || this.eat(aa.dot)) {
        var c2 = this.startNodeAt(t, s2);
        c2.object = e2, l2 ? (c2.property = this.parseExpression(), this.expect(aa.bracketR)) : this.type === aa.privateId && e2.type !== "Super" ? c2.property = this.parsePrivateIdent() : c2.property = this.parseIdent(this.options.allowReserved !== "never"), c2.computed = !!l2, o2 && (c2.optional = h3), e2 = this.finishNode(c2, "MemberExpression");
      } else if (!i2 && this.eat(aa.parenL)) {
        var u2 = new Na(), d3 = this.yieldPos, p2 = this.awaitPos, f2 = this.awaitIdentPos;
        this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
        var m3 = this.parseExprList(aa.parenR, this.options.ecmaVersion >= 8, false, u2);
        if (n3 && !h3 && !this.canInsertSemicolon() && this.eat(aa.arrow))
          return this.checkPatternErrors(u2, false), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = d3, this.awaitPos = p2, this.awaitIdentPos = f2, this.parseArrowExpression(this.startNodeAt(t, s2), m3, true, a2);
        this.checkExpressionErrors(u2, true), this.yieldPos = d3 || this.yieldPos, this.awaitPos = p2 || this.awaitPos, this.awaitIdentPos = f2 || this.awaitIdentPos;
        var g2 = this.startNodeAt(t, s2);
        g2.callee = e2, g2.arguments = m3, o2 && (g2.optional = h3), e2 = this.finishNode(g2, "CallExpression");
      } else if (this.type === aa.backQuote) {
        (h3 || r2) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
        var y3 = this.startNodeAt(t, s2);
        y3.tag = e2, y3.quasi = this.parseTemplate({ isTagged: true }), e2 = this.finishNode(y3, "TaggedTemplateExpression");
      }
      return e2;
    }, Wa.parseExprAtom = function(e2, t) {
      this.type === aa.slash && this.readRegexp();
      var s2, i2 = this.potentialArrowAt === this.start;
      switch (this.type) {
        case aa._super:
          return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), s2 = this.startNode(), this.next(), this.type !== aa.parenL || this.allowDirectSuper || this.raise(s2.start, "super() call outside constructor of a subclass"), this.type !== aa.dot && this.type !== aa.bracketL && this.type !== aa.parenL && this.unexpected(), this.finishNode(s2, "Super");
        case aa._this:
          return s2 = this.startNode(), this.next(), this.finishNode(s2, "ThisExpression");
        case aa.name:
          var n3 = this.start, r2 = this.startLoc, a2 = this.containsEsc, o2 = this.parseIdent(false);
          if (this.options.ecmaVersion >= 8 && !a2 && o2.name === "async" && !this.canInsertSemicolon() && this.eat(aa._function))
            return this.overrideContext(Fa.f_expr), this.parseFunction(this.startNodeAt(n3, r2), 0, false, true, t);
          if (i2 && !this.canInsertSemicolon()) {
            if (this.eat(aa.arrow))
              return this.parseArrowExpression(this.startNodeAt(n3, r2), [o2], false, t);
            if (this.options.ecmaVersion >= 8 && o2.name === "async" && this.type === aa.name && !a2 && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc))
              return o2 = this.parseIdent(false), !this.canInsertSemicolon() && this.eat(aa.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(n3, r2), [o2], true, t);
          }
          return o2;
        case aa.regexp:
          var h3 = this.value;
          return (s2 = this.parseLiteral(h3.value)).regex = { pattern: h3.pattern, flags: h3.flags }, s2;
        case aa.num:
        case aa.string:
          return this.parseLiteral(this.value);
        case aa._null:
        case aa._true:
        case aa._false:
          return (s2 = this.startNode()).value = this.type === aa._null ? null : this.type === aa._true, s2.raw = this.type.keyword, this.next(), this.finishNode(s2, "Literal");
        case aa.parenL:
          var l2 = this.start, c2 = this.parseParenAndDistinguishExpression(i2, t);
          return e2 && (e2.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(c2) && (e2.parenthesizedAssign = l2), e2.parenthesizedBind < 0 && (e2.parenthesizedBind = l2)), c2;
        case aa.bracketL:
          return s2 = this.startNode(), this.next(), s2.elements = this.parseExprList(aa.bracketR, true, true, e2), this.finishNode(s2, "ArrayExpression");
        case aa.braceL:
          return this.overrideContext(Fa.b_expr), this.parseObj(false, e2);
        case aa._function:
          return s2 = this.startNode(), this.next(), this.parseFunction(s2, 0);
        case aa._class:
          return this.parseClass(this.startNode(), false);
        case aa._new:
          return this.parseNew();
        case aa.backQuote:
          return this.parseTemplate();
        case aa._import:
          return this.options.ecmaVersion >= 11 ? this.parseExprImport() : this.unexpected();
        default:
          this.unexpected();
      }
    }, Wa.parseExprImport = function() {
      var e2 = this.startNode();
      this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import");
      var t = this.parseIdent(true);
      switch (this.type) {
        case aa.parenL:
          return this.parseDynamicImport(e2);
        case aa.dot:
          return e2.meta = t, this.parseImportMeta(e2);
        default:
          this.unexpected();
      }
    }, Wa.parseDynamicImport = function(e2) {
      if (this.next(), e2.source = this.parseMaybeAssign(), !this.eat(aa.parenR)) {
        var t = this.start;
        this.eat(aa.comma) && this.eat(aa.parenR) ? this.raiseRecoverable(t, "Trailing comma is not allowed in import()") : this.unexpected(t);
      }
      return this.finishNode(e2, "ImportExpression");
    }, Wa.parseImportMeta = function(e2) {
      this.next();
      var t = this.containsEsc;
      return e2.property = this.parseIdent(true), e2.property.name !== "meta" && this.raiseRecoverable(e2.property.start, "The only valid meta property for import is 'import.meta'"), t && this.raiseRecoverable(e2.start, "'import.meta' must not contain escaped characters"), this.options.sourceType === "module" || this.options.allowImportExportEverywhere || this.raiseRecoverable(e2.start, "Cannot use 'import.meta' outside a module"), this.finishNode(e2, "MetaProperty");
    }, Wa.parseLiteral = function(e2) {
      var t = this.startNode();
      return t.value = e2, t.raw = this.input.slice(this.start, this.end), t.raw.charCodeAt(t.raw.length - 1) === 110 && (t.bigint = t.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(t, "Literal");
    }, Wa.parseParenExpression = function() {
      this.expect(aa.parenL);
      var e2 = this.parseExpression();
      return this.expect(aa.parenR), e2;
    }, Wa.parseParenAndDistinguishExpression = function(e2, t) {
      var s2, i2 = this.start, n3 = this.startLoc, r2 = this.options.ecmaVersion >= 8;
      if (this.options.ecmaVersion >= 6) {
        this.next();
        var a2, o2 = this.start, h3 = this.startLoc, l2 = [], c2 = true, u2 = false, d3 = new Na(), p2 = this.yieldPos, f2 = this.awaitPos;
        for (this.yieldPos = 0, this.awaitPos = 0; this.type !== aa.parenR; ) {
          if (c2 ? c2 = false : this.expect(aa.comma), r2 && this.afterTrailingComma(aa.parenR, true)) {
            u2 = true;
            break;
          }
          if (this.type === aa.ellipsis) {
            a2 = this.start, l2.push(this.parseParenItem(this.parseRestBinding())), this.type === aa.comma && this.raise(this.start, "Comma is not permitted after the rest element");
            break;
          }
          l2.push(this.parseMaybeAssign(false, d3, this.parseParenItem));
        }
        var m3 = this.lastTokEnd, g2 = this.lastTokEndLoc;
        if (this.expect(aa.parenR), e2 && !this.canInsertSemicolon() && this.eat(aa.arrow))
          return this.checkPatternErrors(d3, false), this.checkYieldAwaitInDefaultParams(), this.yieldPos = p2, this.awaitPos = f2, this.parseParenArrowList(i2, n3, l2, t);
        l2.length && !u2 || this.unexpected(this.lastTokStart), a2 && this.unexpected(a2), this.checkExpressionErrors(d3, true), this.yieldPos = p2 || this.yieldPos, this.awaitPos = f2 || this.awaitPos, l2.length > 1 ? ((s2 = this.startNodeAt(o2, h3)).expressions = l2, this.finishNodeAt(s2, "SequenceExpression", m3, g2)) : s2 = l2[0];
      } else
        s2 = this.parseParenExpression();
      if (this.options.preserveParens) {
        var y3 = this.startNodeAt(i2, n3);
        return y3.expression = s2, this.finishNode(y3, "ParenthesizedExpression");
      }
      return s2;
    }, Wa.parseParenItem = function(e2) {
      return e2;
    }, Wa.parseParenArrowList = function(e2, t, s2, i2) {
      return this.parseArrowExpression(this.startNodeAt(e2, t), s2, false, i2);
    };
    Ua = [];
    Wa.parseNew = function() {
      this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
      var e2 = this.startNode(), t = this.parseIdent(true);
      if (this.options.ecmaVersion >= 6 && this.eat(aa.dot)) {
        e2.meta = t;
        var s2 = this.containsEsc;
        return e2.property = this.parseIdent(true), e2.property.name !== "target" && this.raiseRecoverable(e2.property.start, "The only valid meta property for new is 'new.target'"), s2 && this.raiseRecoverable(e2.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(e2.start, "'new.target' can only be used in functions and class static block"), this.finishNode(e2, "MetaProperty");
      }
      var i2 = this.start, n3 = this.startLoc, r2 = this.type === aa._import;
      return e2.callee = this.parseSubscripts(this.parseExprAtom(), i2, n3, true, false), r2 && e2.callee.type === "ImportExpression" && this.raise(i2, "Cannot use new with import()"), this.eat(aa.parenL) ? e2.arguments = this.parseExprList(aa.parenR, this.options.ecmaVersion >= 8, false) : e2.arguments = Ua, this.finishNode(e2, "NewExpression");
    }, Wa.parseTemplateElement = function(e2) {
      var t = e2.isTagged, s2 = this.startNode();
      return this.type === aa.invalidTemplate ? (t || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), s2.value = { raw: this.value, cooked: null }) : s2.value = { raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"), cooked: this.value }, this.next(), s2.tail = this.type === aa.backQuote, this.finishNode(s2, "TemplateElement");
    }, Wa.parseTemplate = function(e2) {
      e2 === void 0 && (e2 = {});
      var t = e2.isTagged;
      t === void 0 && (t = false);
      var s2 = this.startNode();
      this.next(), s2.expressions = [];
      var i2 = this.parseTemplateElement({ isTagged: t });
      for (s2.quasis = [i2]; !i2.tail; )
        this.type === aa.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(aa.dollarBraceL), s2.expressions.push(this.parseExpression()), this.expect(aa.braceR), s2.quasis.push(i2 = this.parseTemplateElement({ isTagged: t }));
      return this.next(), this.finishNode(s2, "TemplateLiteral");
    }, Wa.isAsyncProp = function(e2) {
      return !e2.computed && e2.key.type === "Identifier" && e2.key.name === "async" && (this.type === aa.name || this.type === aa.num || this.type === aa.string || this.type === aa.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === aa.star) && !oa.test(this.input.slice(this.lastTokEnd, this.start));
    }, Wa.parseObj = function(e2, t) {
      var s2 = this.startNode(), i2 = true, n3 = {};
      for (s2.properties = [], this.next(); !this.eat(aa.braceR); ) {
        if (i2)
          i2 = false;
        else if (this.expect(aa.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(aa.braceR))
          break;
        var r2 = this.parseProperty(e2, t);
        e2 || this.checkPropClash(r2, n3, t), s2.properties.push(r2);
      }
      return this.finishNode(s2, e2 ? "ObjectPattern" : "ObjectExpression");
    }, Wa.parseProperty = function(e2, t) {
      var s2, i2, n3, r2, a2 = this.startNode();
      if (this.options.ecmaVersion >= 9 && this.eat(aa.ellipsis))
        return e2 ? (a2.argument = this.parseIdent(false), this.type === aa.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.finishNode(a2, "RestElement")) : (this.type === aa.parenL && t && (t.parenthesizedAssign < 0 && (t.parenthesizedAssign = this.start), t.parenthesizedBind < 0 && (t.parenthesizedBind = this.start)), a2.argument = this.parseMaybeAssign(false, t), this.type === aa.comma && t && t.trailingComma < 0 && (t.trailingComma = this.start), this.finishNode(a2, "SpreadElement"));
      this.options.ecmaVersion >= 6 && (a2.method = false, a2.shorthand = false, (e2 || t) && (n3 = this.start, r2 = this.startLoc), e2 || (s2 = this.eat(aa.star)));
      var o2 = this.containsEsc;
      return this.parsePropertyName(a2), !e2 && !o2 && this.options.ecmaVersion >= 8 && !s2 && this.isAsyncProp(a2) ? (i2 = true, s2 = this.options.ecmaVersion >= 9 && this.eat(aa.star), this.parsePropertyName(a2, t)) : i2 = false, this.parsePropertyValue(a2, e2, s2, i2, n3, r2, t, o2), this.finishNode(a2, "Property");
    }, Wa.parsePropertyValue = function(e2, t, s2, i2, n3, r2, a2, o2) {
      if ((s2 || i2) && this.type === aa.colon && this.unexpected(), this.eat(aa.colon))
        e2.value = t ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, a2), e2.kind = "init";
      else if (this.options.ecmaVersion >= 6 && this.type === aa.parenL)
        t && this.unexpected(), e2.kind = "init", e2.method = true, e2.value = this.parseMethod(s2, i2);
      else if (t || o2 || !(this.options.ecmaVersion >= 5) || e2.computed || e2.key.type !== "Identifier" || e2.key.name !== "get" && e2.key.name !== "set" || this.type === aa.comma || this.type === aa.braceR || this.type === aa.eq)
        this.options.ecmaVersion >= 6 && !e2.computed && e2.key.type === "Identifier" ? ((s2 || i2) && this.unexpected(), this.checkUnreserved(e2.key), e2.key.name !== "await" || this.awaitIdentPos || (this.awaitIdentPos = n3), e2.kind = "init", t ? e2.value = this.parseMaybeDefault(n3, r2, this.copyNode(e2.key)) : this.type === aa.eq && a2 ? (a2.shorthandAssign < 0 && (a2.shorthandAssign = this.start), e2.value = this.parseMaybeDefault(n3, r2, this.copyNode(e2.key))) : e2.value = this.copyNode(e2.key), e2.shorthand = true) : this.unexpected();
      else {
        (s2 || i2) && this.unexpected(), e2.kind = e2.key.name, this.parsePropertyName(e2), e2.value = this.parseMethod(false);
        var h3 = e2.kind === "get" ? 0 : 1;
        if (e2.value.params.length !== h3) {
          var l2 = e2.value.start;
          e2.kind === "get" ? this.raiseRecoverable(l2, "getter should have no params") : this.raiseRecoverable(l2, "setter should have exactly one param");
        } else
          e2.kind === "set" && e2.value.params[0].type === "RestElement" && this.raiseRecoverable(e2.value.params[0].start, "Setter cannot use rest params");
      }
    }, Wa.parsePropertyName = function(e2) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(aa.bracketL))
          return e2.computed = true, e2.key = this.parseMaybeAssign(), this.expect(aa.bracketR), e2.key;
        e2.computed = false;
      }
      return e2.key = this.type === aa.num || this.type === aa.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    }, Wa.initFunction = function(e2) {
      e2.id = null, this.options.ecmaVersion >= 6 && (e2.generator = e2.expression = false), this.options.ecmaVersion >= 8 && (e2.async = false);
    }, Wa.parseMethod = function(e2, t, s2) {
      var i2 = this.startNode(), n3 = this.yieldPos, r2 = this.awaitPos, a2 = this.awaitIdentPos;
      return this.initFunction(i2), this.options.ecmaVersion >= 6 && (i2.generator = e2), this.options.ecmaVersion >= 8 && (i2.async = !!t), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(64 | Pa(t, i2.generator) | (s2 ? 128 : 0)), this.expect(aa.parenL), i2.params = this.parseBindingList(aa.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(i2, false, true, false), this.yieldPos = n3, this.awaitPos = r2, this.awaitIdentPos = a2, this.finishNode(i2, "FunctionExpression");
    }, Wa.parseArrowExpression = function(e2, t, s2, i2) {
      var n3 = this.yieldPos, r2 = this.awaitPos, a2 = this.awaitIdentPos;
      return this.enterScope(16 | Pa(s2, false)), this.initFunction(e2), this.options.ecmaVersion >= 8 && (e2.async = !!s2), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, e2.params = this.toAssignableList(t, true), this.parseFunctionBody(e2, true, false, i2), this.yieldPos = n3, this.awaitPos = r2, this.awaitIdentPos = a2, this.finishNode(e2, "ArrowFunctionExpression");
    }, Wa.parseFunctionBody = function(e2, t, s2, i2) {
      var n3 = t && this.type !== aa.braceL, r2 = this.strict, a2 = false;
      if (n3)
        e2.body = this.parseMaybeAssign(i2), e2.expression = true, this.checkParams(e2, false);
      else {
        var o2 = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e2.params);
        r2 && !o2 || (a2 = this.strictDirective(this.end)) && o2 && this.raiseRecoverable(e2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
        var h3 = this.labels;
        this.labels = [], a2 && (this.strict = true), this.checkParams(e2, !r2 && !a2 && !t && !s2 && this.isSimpleParamList(e2.params)), this.strict && e2.id && this.checkLValSimple(e2.id, 5), e2.body = this.parseBlock(false, void 0, a2 && !r2), e2.expression = false, this.adaptDirectivePrologue(e2.body.body), this.labels = h3;
      }
      this.exitScope();
    }, Wa.isSimpleParamList = function(e2) {
      for (var t = 0, s2 = e2; t < s2.length; t += 1) {
        if (s2[t].type !== "Identifier")
          return false;
      }
      return true;
    }, Wa.checkParams = function(e2, t) {
      for (var s2 = Object.create(null), i2 = 0, n3 = e2.params; i2 < n3.length; i2 += 1) {
        var r2 = n3[i2];
        this.checkLValInnerPattern(r2, 1, t ? null : s2);
      }
    }, Wa.parseExprList = function(e2, t, s2, i2) {
      for (var n3 = [], r2 = true; !this.eat(e2); ) {
        if (r2)
          r2 = false;
        else if (this.expect(aa.comma), t && this.afterTrailingComma(e2))
          break;
        var a2 = void 0;
        s2 && this.type === aa.comma ? a2 = null : this.type === aa.ellipsis ? (a2 = this.parseSpread(i2), i2 && this.type === aa.comma && i2.trailingComma < 0 && (i2.trailingComma = this.start)) : a2 = this.parseMaybeAssign(false, i2), n3.push(a2);
      }
      return n3;
    }, Wa.checkUnreserved = function(e2) {
      var t = e2.start, s2 = e2.end, i2 = e2.name;
      (this.inGenerator && i2 === "yield" && this.raiseRecoverable(t, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && i2 === "await" && this.raiseRecoverable(t, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && i2 === "arguments" && this.raiseRecoverable(t, "Cannot use 'arguments' in class field initializer"), !this.inClassStaticBlock || i2 !== "arguments" && i2 !== "await" || this.raise(t, "Cannot use " + i2 + " in class static initialization block"), this.keywords.test(i2) && this.raise(t, "Unexpected keyword '" + i2 + "'"), this.options.ecmaVersion < 6 && this.input.slice(t, s2).indexOf("\\") !== -1) || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(i2) && (this.inAsync || i2 !== "await" || this.raiseRecoverable(t, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(t, "The keyword '" + i2 + "' is reserved"));
    }, Wa.parseIdent = function(e2, t) {
      var s2 = this.startNode();
      return this.type === aa.name ? s2.name = this.value : this.type.keyword ? (s2.name = this.type.keyword, s2.name !== "class" && s2.name !== "function" || this.lastTokEnd === this.lastTokStart + 1 && this.input.charCodeAt(this.lastTokStart) === 46 || this.context.pop()) : this.unexpected(), this.next(!!e2), this.finishNode(s2, "Identifier"), e2 || (this.checkUnreserved(s2), s2.name !== "await" || this.awaitIdentPos || (this.awaitIdentPos = s2.start)), s2;
    }, Wa.parsePrivateIdent = function() {
      var e2 = this.startNode();
      return this.type === aa.privateId ? e2.name = this.value : this.unexpected(), this.next(), this.finishNode(e2, "PrivateIdentifier"), this.privateNameStack.length === 0 ? this.raise(e2.start, "Private field '#" + e2.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(e2), e2;
    }, Wa.parseYield = function(e2) {
      this.yieldPos || (this.yieldPos = this.start);
      var t = this.startNode();
      return this.next(), this.type === aa.semi || this.canInsertSemicolon() || this.type !== aa.star && !this.type.startsExpr ? (t.delegate = false, t.argument = null) : (t.delegate = this.eat(aa.star), t.argument = this.parseMaybeAssign(e2)), this.finishNode(t, "YieldExpression");
    }, Wa.parseAwait = function(e2) {
      this.awaitPos || (this.awaitPos = this.start);
      var t = this.startNode();
      return this.next(), t.argument = this.parseMaybeUnary(null, true, false, e2), this.finishNode(t, "AwaitExpression");
    };
    Ga = ka.prototype;
    Ga.raise = function(e2, t) {
      var s2 = va(this.input, e2);
      t += " (" + s2.line + ":" + s2.column + ")";
      var i2 = new SyntaxError(t);
      throw i2.pos = e2, i2.loc = s2, i2.raisedAt = this.pos, i2;
    }, Ga.raiseRecoverable = Ga.raise, Ga.curPosition = function() {
      if (this.options.locations)
        return new Ea(this.curLine, this.pos - this.lineStart);
    };
    Ha = ka.prototype;
    qa = function(e2) {
      this.flags = e2, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = false;
    };
    Ha.enterScope = function(e2) {
      this.scopeStack.push(new qa(e2));
    }, Ha.exitScope = function() {
      this.scopeStack.pop();
    }, Ha.treatFunctionsAsVarInScope = function(e2) {
      return 2 & e2.flags || !this.inModule && 1 & e2.flags;
    }, Ha.declareName = function(e2, t, s2) {
      var i2 = false;
      if (t === 2) {
        var n3 = this.currentScope();
        i2 = n3.lexical.indexOf(e2) > -1 || n3.functions.indexOf(e2) > -1 || n3.var.indexOf(e2) > -1, n3.lexical.push(e2), this.inModule && 1 & n3.flags && delete this.undefinedExports[e2];
      } else if (t === 4) {
        this.currentScope().lexical.push(e2);
      } else if (t === 3) {
        var r2 = this.currentScope();
        i2 = this.treatFunctionsAsVar ? r2.lexical.indexOf(e2) > -1 : r2.lexical.indexOf(e2) > -1 || r2.var.indexOf(e2) > -1, r2.functions.push(e2);
      } else
        for (var a2 = this.scopeStack.length - 1; a2 >= 0; --a2) {
          var o2 = this.scopeStack[a2];
          if (o2.lexical.indexOf(e2) > -1 && !(32 & o2.flags && o2.lexical[0] === e2) || !this.treatFunctionsAsVarInScope(o2) && o2.functions.indexOf(e2) > -1) {
            i2 = true;
            break;
          }
          if (o2.var.push(e2), this.inModule && 1 & o2.flags && delete this.undefinedExports[e2], 259 & o2.flags)
            break;
        }
      i2 && this.raiseRecoverable(s2, "Identifier '" + e2 + "' has already been declared");
    }, Ha.checkLocalExport = function(e2) {
      this.scopeStack[0].lexical.indexOf(e2.name) === -1 && this.scopeStack[0].var.indexOf(e2.name) === -1 && (this.undefinedExports[e2.name] = e2);
    }, Ha.currentScope = function() {
      return this.scopeStack[this.scopeStack.length - 1];
    }, Ha.currentVarScope = function() {
      for (var e2 = this.scopeStack.length - 1; ; e2--) {
        var t = this.scopeStack[e2];
        if (259 & t.flags)
          return t;
      }
    }, Ha.currentThisScope = function() {
      for (var e2 = this.scopeStack.length - 1; ; e2--) {
        var t = this.scopeStack[e2];
        if (259 & t.flags && !(16 & t.flags))
          return t;
      }
    };
    Ka = function(e2, t, s2) {
      this.type = "", this.start = t, this.end = 0, e2.options.locations && (this.loc = new xa(e2, s2)), e2.options.directSourceFile && (this.sourceFile = e2.options.directSourceFile), e2.options.ranges && (this.range = [t, 0]);
    };
    Xa = ka.prototype;
    Xa.startNode = function() {
      return new Ka(this, this.start, this.startLoc);
    }, Xa.startNodeAt = function(e2, t) {
      return new Ka(this, e2, t);
    }, Xa.finishNode = function(e2, t) {
      return Ya.call(this, e2, t, this.lastTokEnd, this.lastTokEndLoc);
    }, Xa.finishNodeAt = function(e2, t, s2, i2) {
      return Ya.call(this, e2, t, s2, i2);
    }, Xa.copyNode = function(e2) {
      var t = new Ka(this, e2.start, this.startLoc);
      for (var s2 in e2)
        t[s2] = e2[s2];
      return t;
    };
    Qa = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
    Za = Qa + " Extended_Pictographic";
    Ja = { 9: Qa, 10: Za, 11: Za, 12: "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS Extended_Pictographic EBase EComp EMod EPres ExtPict" };
    eo = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
    to = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
    so = to + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
    io = so + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
    no = { 9: to, 10: so, 11: io, 12: "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi" };
    ro = {};
    ao(9), ao(10), ao(11), ao(12);
    oo = ka.prototype;
    ho = function(e2) {
      this.parser = e2, this.validFlags = "gim" + (e2.options.ecmaVersion >= 6 ? "uy" : "") + (e2.options.ecmaVersion >= 9 ? "s" : "") + (e2.options.ecmaVersion >= 13 ? "d" : ""), this.unicodeProperties = ro[e2.options.ecmaVersion >= 12 ? 12 : e2.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = false, this.switchN = false, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = false, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
    };
    ho.prototype.reset = function(e2, t, s2) {
      var i2 = s2.indexOf("u") !== -1;
      this.start = 0 | e2, this.source = t + "", this.flags = s2, this.switchU = i2 && this.parser.options.ecmaVersion >= 6, this.switchN = i2 && this.parser.options.ecmaVersion >= 9;
    }, ho.prototype.raise = function(e2) {
      this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + e2);
    }, ho.prototype.at = function(e2, t) {
      t === void 0 && (t = false);
      var s2 = this.source, i2 = s2.length;
      if (e2 >= i2)
        return -1;
      var n3 = s2.charCodeAt(e2);
      if (!t && !this.switchU || n3 <= 55295 || n3 >= 57344 || e2 + 1 >= i2)
        return n3;
      var r2 = s2.charCodeAt(e2 + 1);
      return r2 >= 56320 && r2 <= 57343 ? (n3 << 10) + r2 - 56613888 : n3;
    }, ho.prototype.nextIndex = function(e2, t) {
      t === void 0 && (t = false);
      var s2 = this.source, i2 = s2.length;
      if (e2 >= i2)
        return i2;
      var n3, r2 = s2.charCodeAt(e2);
      return !t && !this.switchU || r2 <= 55295 || r2 >= 57344 || e2 + 1 >= i2 || (n3 = s2.charCodeAt(e2 + 1)) < 56320 || n3 > 57343 ? e2 + 1 : e2 + 2;
    }, ho.prototype.current = function(e2) {
      return e2 === void 0 && (e2 = false), this.at(this.pos, e2);
    }, ho.prototype.lookahead = function(e2) {
      return e2 === void 0 && (e2 = false), this.at(this.nextIndex(this.pos, e2), e2);
    }, ho.prototype.advance = function(e2) {
      e2 === void 0 && (e2 = false), this.pos = this.nextIndex(this.pos, e2);
    }, ho.prototype.eat = function(e2, t) {
      return t === void 0 && (t = false), this.current(t) === e2 && (this.advance(t), true);
    }, oo.validateRegExpFlags = function(e2) {
      for (var t = e2.validFlags, s2 = e2.flags, i2 = 0; i2 < s2.length; i2++) {
        var n3 = s2.charAt(i2);
        t.indexOf(n3) === -1 && this.raise(e2.start, "Invalid regular expression flag"), s2.indexOf(n3, i2 + 1) > -1 && this.raise(e2.start, "Duplicate regular expression flag");
      }
    }, oo.validateRegExpPattern = function(e2) {
      this.regexp_pattern(e2), !e2.switchN && this.options.ecmaVersion >= 9 && e2.groupNames.length > 0 && (e2.switchN = true, this.regexp_pattern(e2));
    }, oo.regexp_pattern = function(e2) {
      e2.pos = 0, e2.lastIntValue = 0, e2.lastStringValue = "", e2.lastAssertionIsQuantifiable = false, e2.numCapturingParens = 0, e2.maxBackReference = 0, e2.groupNames.length = 0, e2.backReferenceNames.length = 0, this.regexp_disjunction(e2), e2.pos !== e2.source.length && (e2.eat(41) && e2.raise("Unmatched ')'"), (e2.eat(93) || e2.eat(125)) && e2.raise("Lone quantifier brackets")), e2.maxBackReference > e2.numCapturingParens && e2.raise("Invalid escape");
      for (var t = 0, s2 = e2.backReferenceNames; t < s2.length; t += 1) {
        var i2 = s2[t];
        e2.groupNames.indexOf(i2) === -1 && e2.raise("Invalid named capture referenced");
      }
    }, oo.regexp_disjunction = function(e2) {
      for (this.regexp_alternative(e2); e2.eat(124); )
        this.regexp_alternative(e2);
      this.regexp_eatQuantifier(e2, true) && e2.raise("Nothing to repeat"), e2.eat(123) && e2.raise("Lone quantifier brackets");
    }, oo.regexp_alternative = function(e2) {
      for (; e2.pos < e2.source.length && this.regexp_eatTerm(e2); )
        ;
    }, oo.regexp_eatTerm = function(e2) {
      return this.regexp_eatAssertion(e2) ? (e2.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e2) && e2.switchU && e2.raise("Invalid quantifier"), true) : !!(e2.switchU ? this.regexp_eatAtom(e2) : this.regexp_eatExtendedAtom(e2)) && (this.regexp_eatQuantifier(e2), true);
    }, oo.regexp_eatAssertion = function(e2) {
      var t = e2.pos;
      if (e2.lastAssertionIsQuantifiable = false, e2.eat(94) || e2.eat(36))
        return true;
      if (e2.eat(92)) {
        if (e2.eat(66) || e2.eat(98))
          return true;
        e2.pos = t;
      }
      if (e2.eat(40) && e2.eat(63)) {
        var s2 = false;
        if (this.options.ecmaVersion >= 9 && (s2 = e2.eat(60)), e2.eat(61) || e2.eat(33))
          return this.regexp_disjunction(e2), e2.eat(41) || e2.raise("Unterminated group"), e2.lastAssertionIsQuantifiable = !s2, true;
      }
      return e2.pos = t, false;
    }, oo.regexp_eatQuantifier = function(e2, t) {
      return t === void 0 && (t = false), !!this.regexp_eatQuantifierPrefix(e2, t) && (e2.eat(63), true);
    }, oo.regexp_eatQuantifierPrefix = function(e2, t) {
      return e2.eat(42) || e2.eat(43) || e2.eat(63) || this.regexp_eatBracedQuantifier(e2, t);
    }, oo.regexp_eatBracedQuantifier = function(e2, t) {
      var s2 = e2.pos;
      if (e2.eat(123)) {
        var i2 = 0, n3 = -1;
        if (this.regexp_eatDecimalDigits(e2) && (i2 = e2.lastIntValue, e2.eat(44) && this.regexp_eatDecimalDigits(e2) && (n3 = e2.lastIntValue), e2.eat(125)))
          return n3 !== -1 && n3 < i2 && !t && e2.raise("numbers out of order in {} quantifier"), true;
        e2.switchU && !t && e2.raise("Incomplete quantifier"), e2.pos = s2;
      }
      return false;
    }, oo.regexp_eatAtom = function(e2) {
      return this.regexp_eatPatternCharacters(e2) || e2.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e2) || this.regexp_eatCharacterClass(e2) || this.regexp_eatUncapturingGroup(e2) || this.regexp_eatCapturingGroup(e2);
    }, oo.regexp_eatReverseSolidusAtomEscape = function(e2) {
      var t = e2.pos;
      if (e2.eat(92)) {
        if (this.regexp_eatAtomEscape(e2))
          return true;
        e2.pos = t;
      }
      return false;
    }, oo.regexp_eatUncapturingGroup = function(e2) {
      var t = e2.pos;
      if (e2.eat(40)) {
        if (e2.eat(63) && e2.eat(58)) {
          if (this.regexp_disjunction(e2), e2.eat(41))
            return true;
          e2.raise("Unterminated group");
        }
        e2.pos = t;
      }
      return false;
    }, oo.regexp_eatCapturingGroup = function(e2) {
      if (e2.eat(40)) {
        if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e2) : e2.current() === 63 && e2.raise("Invalid group"), this.regexp_disjunction(e2), e2.eat(41))
          return e2.numCapturingParens += 1, true;
        e2.raise("Unterminated group");
      }
      return false;
    }, oo.regexp_eatExtendedAtom = function(e2) {
      return e2.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e2) || this.regexp_eatCharacterClass(e2) || this.regexp_eatUncapturingGroup(e2) || this.regexp_eatCapturingGroup(e2) || this.regexp_eatInvalidBracedQuantifier(e2) || this.regexp_eatExtendedPatternCharacter(e2);
    }, oo.regexp_eatInvalidBracedQuantifier = function(e2) {
      return this.regexp_eatBracedQuantifier(e2, true) && e2.raise("Nothing to repeat"), false;
    }, oo.regexp_eatSyntaxCharacter = function(e2) {
      var t = e2.current();
      return !!co(t) && (e2.lastIntValue = t, e2.advance(), true);
    }, oo.regexp_eatPatternCharacters = function(e2) {
      for (var t = e2.pos, s2 = 0; (s2 = e2.current()) !== -1 && !co(s2); )
        e2.advance();
      return e2.pos !== t;
    }, oo.regexp_eatExtendedPatternCharacter = function(e2) {
      var t = e2.current();
      return !(t === -1 || t === 36 || t >= 40 && t <= 43 || t === 46 || t === 63 || t === 91 || t === 94 || t === 124) && (e2.advance(), true);
    }, oo.regexp_groupSpecifier = function(e2) {
      if (e2.eat(63)) {
        if (this.regexp_eatGroupName(e2))
          return e2.groupNames.indexOf(e2.lastStringValue) !== -1 && e2.raise("Duplicate capture group name"), void e2.groupNames.push(e2.lastStringValue);
        e2.raise("Invalid group");
      }
    }, oo.regexp_eatGroupName = function(e2) {
      if (e2.lastStringValue = "", e2.eat(60)) {
        if (this.regexp_eatRegExpIdentifierName(e2) && e2.eat(62))
          return true;
        e2.raise("Invalid capture group name");
      }
      return false;
    }, oo.regexp_eatRegExpIdentifierName = function(e2) {
      if (e2.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e2)) {
        for (e2.lastStringValue += lo(e2.lastIntValue); this.regexp_eatRegExpIdentifierPart(e2); )
          e2.lastStringValue += lo(e2.lastIntValue);
        return true;
      }
      return false;
    }, oo.regexp_eatRegExpIdentifierStart = function(e2) {
      var t = e2.pos, s2 = this.options.ecmaVersion >= 11, i2 = e2.current(s2);
      return e2.advance(s2), i2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e2, s2) && (i2 = e2.lastIntValue), function(e3) {
        return Zr(e3, true) || e3 === 36 || e3 === 95;
      }(i2) ? (e2.lastIntValue = i2, true) : (e2.pos = t, false);
    }, oo.regexp_eatRegExpIdentifierPart = function(e2) {
      var t = e2.pos, s2 = this.options.ecmaVersion >= 11, i2 = e2.current(s2);
      return e2.advance(s2), i2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e2, s2) && (i2 = e2.lastIntValue), function(e3) {
        return Jr(e3, true) || e3 === 36 || e3 === 95 || e3 === 8204 || e3 === 8205;
      }(i2) ? (e2.lastIntValue = i2, true) : (e2.pos = t, false);
    }, oo.regexp_eatAtomEscape = function(e2) {
      return !!(this.regexp_eatBackReference(e2) || this.regexp_eatCharacterClassEscape(e2) || this.regexp_eatCharacterEscape(e2) || e2.switchN && this.regexp_eatKGroupName(e2)) || (e2.switchU && (e2.current() === 99 && e2.raise("Invalid unicode escape"), e2.raise("Invalid escape")), false);
    }, oo.regexp_eatBackReference = function(e2) {
      var t = e2.pos;
      if (this.regexp_eatDecimalEscape(e2)) {
        var s2 = e2.lastIntValue;
        if (e2.switchU)
          return s2 > e2.maxBackReference && (e2.maxBackReference = s2), true;
        if (s2 <= e2.numCapturingParens)
          return true;
        e2.pos = t;
      }
      return false;
    }, oo.regexp_eatKGroupName = function(e2) {
      if (e2.eat(107)) {
        if (this.regexp_eatGroupName(e2))
          return e2.backReferenceNames.push(e2.lastStringValue), true;
        e2.raise("Invalid named reference");
      }
      return false;
    }, oo.regexp_eatCharacterEscape = function(e2) {
      return this.regexp_eatControlEscape(e2) || this.regexp_eatCControlLetter(e2) || this.regexp_eatZero(e2) || this.regexp_eatHexEscapeSequence(e2) || this.regexp_eatRegExpUnicodeEscapeSequence(e2, false) || !e2.switchU && this.regexp_eatLegacyOctalEscapeSequence(e2) || this.regexp_eatIdentityEscape(e2);
    }, oo.regexp_eatCControlLetter = function(e2) {
      var t = e2.pos;
      if (e2.eat(99)) {
        if (this.regexp_eatControlLetter(e2))
          return true;
        e2.pos = t;
      }
      return false;
    }, oo.regexp_eatZero = function(e2) {
      return e2.current() === 48 && !mo(e2.lookahead()) && (e2.lastIntValue = 0, e2.advance(), true);
    }, oo.regexp_eatControlEscape = function(e2) {
      var t = e2.current();
      return t === 116 ? (e2.lastIntValue = 9, e2.advance(), true) : t === 110 ? (e2.lastIntValue = 10, e2.advance(), true) : t === 118 ? (e2.lastIntValue = 11, e2.advance(), true) : t === 102 ? (e2.lastIntValue = 12, e2.advance(), true) : t === 114 && (e2.lastIntValue = 13, e2.advance(), true);
    }, oo.regexp_eatControlLetter = function(e2) {
      var t = e2.current();
      return !!uo(t) && (e2.lastIntValue = t % 32, e2.advance(), true);
    }, oo.regexp_eatRegExpUnicodeEscapeSequence = function(e2, t) {
      t === void 0 && (t = false);
      var s2, i2 = e2.pos, n3 = t || e2.switchU;
      if (e2.eat(117)) {
        if (this.regexp_eatFixedHexDigits(e2, 4)) {
          var r2 = e2.lastIntValue;
          if (n3 && r2 >= 55296 && r2 <= 56319) {
            var a2 = e2.pos;
            if (e2.eat(92) && e2.eat(117) && this.regexp_eatFixedHexDigits(e2, 4)) {
              var o2 = e2.lastIntValue;
              if (o2 >= 56320 && o2 <= 57343)
                return e2.lastIntValue = 1024 * (r2 - 55296) + (o2 - 56320) + 65536, true;
            }
            e2.pos = a2, e2.lastIntValue = r2;
          }
          return true;
        }
        if (n3 && e2.eat(123) && this.regexp_eatHexDigits(e2) && e2.eat(125) && ((s2 = e2.lastIntValue) >= 0 && s2 <= 1114111))
          return true;
        n3 && e2.raise("Invalid unicode escape"), e2.pos = i2;
      }
      return false;
    }, oo.regexp_eatIdentityEscape = function(e2) {
      if (e2.switchU)
        return !!this.regexp_eatSyntaxCharacter(e2) || !!e2.eat(47) && (e2.lastIntValue = 47, true);
      var t = e2.current();
      return !(t === 99 || e2.switchN && t === 107) && (e2.lastIntValue = t, e2.advance(), true);
    }, oo.regexp_eatDecimalEscape = function(e2) {
      e2.lastIntValue = 0;
      var t = e2.current();
      if (t >= 49 && t <= 57) {
        do {
          e2.lastIntValue = 10 * e2.lastIntValue + (t - 48), e2.advance();
        } while ((t = e2.current()) >= 48 && t <= 57);
        return true;
      }
      return false;
    }, oo.regexp_eatCharacterClassEscape = function(e2) {
      var t = e2.current();
      if (function(e3) {
        return e3 === 100 || e3 === 68 || e3 === 115 || e3 === 83 || e3 === 119 || e3 === 87;
      }(t))
        return e2.lastIntValue = -1, e2.advance(), true;
      if (e2.switchU && this.options.ecmaVersion >= 9 && (t === 80 || t === 112)) {
        if (e2.lastIntValue = -1, e2.advance(), e2.eat(123) && this.regexp_eatUnicodePropertyValueExpression(e2) && e2.eat(125))
          return true;
        e2.raise("Invalid property name");
      }
      return false;
    }, oo.regexp_eatUnicodePropertyValueExpression = function(e2) {
      var t = e2.pos;
      if (this.regexp_eatUnicodePropertyName(e2) && e2.eat(61)) {
        var s2 = e2.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(e2)) {
          var i2 = e2.lastStringValue;
          return this.regexp_validateUnicodePropertyNameAndValue(e2, s2, i2), true;
        }
      }
      if (e2.pos = t, this.regexp_eatLoneUnicodePropertyNameOrValue(e2)) {
        var n3 = e2.lastStringValue;
        return this.regexp_validateUnicodePropertyNameOrValue(e2, n3), true;
      }
      return false;
    }, oo.regexp_validateUnicodePropertyNameAndValue = function(e2, t, s2) {
      ma(e2.unicodeProperties.nonBinary, t) || e2.raise("Invalid property name"), e2.unicodeProperties.nonBinary[t].test(s2) || e2.raise("Invalid property value");
    }, oo.regexp_validateUnicodePropertyNameOrValue = function(e2, t) {
      e2.unicodeProperties.binary.test(t) || e2.raise("Invalid property name");
    }, oo.regexp_eatUnicodePropertyName = function(e2) {
      var t = 0;
      for (e2.lastStringValue = ""; po(t = e2.current()); )
        e2.lastStringValue += lo(t), e2.advance();
      return e2.lastStringValue !== "";
    }, oo.regexp_eatUnicodePropertyValue = function(e2) {
      var t = 0;
      for (e2.lastStringValue = ""; fo(t = e2.current()); )
        e2.lastStringValue += lo(t), e2.advance();
      return e2.lastStringValue !== "";
    }, oo.regexp_eatLoneUnicodePropertyNameOrValue = function(e2) {
      return this.regexp_eatUnicodePropertyValue(e2);
    }, oo.regexp_eatCharacterClass = function(e2) {
      if (e2.eat(91)) {
        if (e2.eat(94), this.regexp_classRanges(e2), e2.eat(93))
          return true;
        e2.raise("Unterminated character class");
      }
      return false;
    }, oo.regexp_classRanges = function(e2) {
      for (; this.regexp_eatClassAtom(e2); ) {
        var t = e2.lastIntValue;
        if (e2.eat(45) && this.regexp_eatClassAtom(e2)) {
          var s2 = e2.lastIntValue;
          !e2.switchU || t !== -1 && s2 !== -1 || e2.raise("Invalid character class"), t !== -1 && s2 !== -1 && t > s2 && e2.raise("Range out of order in character class");
        }
      }
    }, oo.regexp_eatClassAtom = function(e2) {
      var t = e2.pos;
      if (e2.eat(92)) {
        if (this.regexp_eatClassEscape(e2))
          return true;
        if (e2.switchU) {
          var s2 = e2.current();
          (s2 === 99 || Eo(s2)) && e2.raise("Invalid class escape"), e2.raise("Invalid escape");
        }
        e2.pos = t;
      }
      var i2 = e2.current();
      return i2 !== 93 && (e2.lastIntValue = i2, e2.advance(), true);
    }, oo.regexp_eatClassEscape = function(e2) {
      var t = e2.pos;
      if (e2.eat(98))
        return e2.lastIntValue = 8, true;
      if (e2.switchU && e2.eat(45))
        return e2.lastIntValue = 45, true;
      if (!e2.switchU && e2.eat(99)) {
        if (this.regexp_eatClassControlLetter(e2))
          return true;
        e2.pos = t;
      }
      return this.regexp_eatCharacterClassEscape(e2) || this.regexp_eatCharacterEscape(e2);
    }, oo.regexp_eatClassControlLetter = function(e2) {
      var t = e2.current();
      return !(!mo(t) && t !== 95) && (e2.lastIntValue = t % 32, e2.advance(), true);
    }, oo.regexp_eatHexEscapeSequence = function(e2) {
      var t = e2.pos;
      if (e2.eat(120)) {
        if (this.regexp_eatFixedHexDigits(e2, 2))
          return true;
        e2.switchU && e2.raise("Invalid escape"), e2.pos = t;
      }
      return false;
    }, oo.regexp_eatDecimalDigits = function(e2) {
      var t = e2.pos, s2 = 0;
      for (e2.lastIntValue = 0; mo(s2 = e2.current()); )
        e2.lastIntValue = 10 * e2.lastIntValue + (s2 - 48), e2.advance();
      return e2.pos !== t;
    }, oo.regexp_eatHexDigits = function(e2) {
      var t = e2.pos, s2 = 0;
      for (e2.lastIntValue = 0; go(s2 = e2.current()); )
        e2.lastIntValue = 16 * e2.lastIntValue + yo(s2), e2.advance();
      return e2.pos !== t;
    }, oo.regexp_eatLegacyOctalEscapeSequence = function(e2) {
      if (this.regexp_eatOctalDigit(e2)) {
        var t = e2.lastIntValue;
        if (this.regexp_eatOctalDigit(e2)) {
          var s2 = e2.lastIntValue;
          t <= 3 && this.regexp_eatOctalDigit(e2) ? e2.lastIntValue = 64 * t + 8 * s2 + e2.lastIntValue : e2.lastIntValue = 8 * t + s2;
        } else
          e2.lastIntValue = t;
        return true;
      }
      return false;
    }, oo.regexp_eatOctalDigit = function(e2) {
      var t = e2.current();
      return Eo(t) ? (e2.lastIntValue = t - 48, e2.advance(), true) : (e2.lastIntValue = 0, false);
    }, oo.regexp_eatFixedHexDigits = function(e2, t) {
      var s2 = e2.pos;
      e2.lastIntValue = 0;
      for (var i2 = 0; i2 < t; ++i2) {
        var n3 = e2.current();
        if (!go(n3))
          return e2.pos = s2, false;
        e2.lastIntValue = 16 * e2.lastIntValue + yo(n3), e2.advance();
      }
      return true;
    };
    xo = function(e2) {
      this.type = e2.type, this.value = e2.value, this.start = e2.start, this.end = e2.end, e2.options.locations && (this.loc = new xa(e2, e2.startLoc, e2.endLoc)), e2.options.ranges && (this.range = [e2.start, e2.end]);
    };
    vo = ka.prototype;
    vo.next = function(e2) {
      !e2 && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new xo(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
    }, vo.getToken = function() {
      return this.next(), new xo(this);
    }, typeof Symbol != "undefined" && (vo[Symbol.iterator] = function() {
      var e2 = this;
      return { next: function() {
        var t = e2.getToken();
        return { done: t.type === aa.eof, value: t };
      } };
    }), vo.nextToken = function() {
      var e2 = this.curContext();
      return e2 && e2.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(aa.eof) : e2.override ? e2.override(this) : void this.readToken(this.fullCharCodeAtPos());
    }, vo.readToken = function(e2) {
      return Zr(e2, this.options.ecmaVersion >= 6) || e2 === 92 ? this.readWord() : this.getTokenFromCode(e2);
    }, vo.fullCharCodeAtPos = function() {
      var e2 = this.input.charCodeAt(this.pos);
      if (e2 <= 55295 || e2 >= 56320)
        return e2;
      var t = this.input.charCodeAt(this.pos + 1);
      return t <= 56319 || t >= 57344 ? e2 : (e2 << 10) + t - 56613888;
    }, vo.skipBlockComment = function() {
      var e2, t = this.options.onComment && this.curPosition(), s2 = this.pos, i2 = this.input.indexOf("*/", this.pos += 2);
      if (i2 === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = i2 + 2, this.options.locations)
        for (ha.lastIndex = s2; (e2 = ha.exec(this.input)) && e2.index < this.pos; )
          ++this.curLine, this.lineStart = e2.index + e2[0].length;
      this.options.onComment && this.options.onComment(true, this.input.slice(s2 + 2, i2), s2, this.pos, t, this.curPosition());
    }, vo.skipLineComment = function(e2) {
      for (var t = this.pos, s2 = this.options.onComment && this.curPosition(), i2 = this.input.charCodeAt(this.pos += e2); this.pos < this.input.length && !la(i2); )
        i2 = this.input.charCodeAt(++this.pos);
      this.options.onComment && this.options.onComment(false, this.input.slice(t + e2, this.pos), t, this.pos, s2, this.curPosition());
    }, vo.skipSpace = function() {
      e:
        for (; this.pos < this.input.length; ) {
          var e2 = this.input.charCodeAt(this.pos);
          switch (e2) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break e;
              }
              break;
            default:
              if (!(e2 > 8 && e2 < 14 || e2 >= 5760 && ca.test(String.fromCharCode(e2))))
                break e;
              ++this.pos;
          }
        }
    }, vo.finishToken = function(e2, t) {
      this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
      var s2 = this.type;
      this.type = e2, this.value = t, this.updateContext(s2);
    }, vo.readToken_dot = function() {
      var e2 = this.input.charCodeAt(this.pos + 1);
      if (e2 >= 48 && e2 <= 57)
        return this.readNumber(true);
      var t = this.input.charCodeAt(this.pos + 2);
      return this.options.ecmaVersion >= 6 && e2 === 46 && t === 46 ? (this.pos += 3, this.finishToken(aa.ellipsis)) : (++this.pos, this.finishToken(aa.dot));
    }, vo.readToken_slash = function() {
      var e2 = this.input.charCodeAt(this.pos + 1);
      return this.exprAllowed ? (++this.pos, this.readRegexp()) : e2 === 61 ? this.finishOp(aa.assign, 2) : this.finishOp(aa.slash, 1);
    }, vo.readToken_mult_modulo_exp = function(e2) {
      var t = this.input.charCodeAt(this.pos + 1), s2 = 1, i2 = e2 === 42 ? aa.star : aa.modulo;
      return this.options.ecmaVersion >= 7 && e2 === 42 && t === 42 && (++s2, i2 = aa.starstar, t = this.input.charCodeAt(this.pos + 2)), t === 61 ? this.finishOp(aa.assign, s2 + 1) : this.finishOp(i2, s2);
    }, vo.readToken_pipe_amp = function(e2) {
      var t = this.input.charCodeAt(this.pos + 1);
      if (t === e2) {
        if (this.options.ecmaVersion >= 12) {
          if (this.input.charCodeAt(this.pos + 2) === 61)
            return this.finishOp(aa.assign, 3);
        }
        return this.finishOp(e2 === 124 ? aa.logicalOR : aa.logicalAND, 2);
      }
      return t === 61 ? this.finishOp(aa.assign, 2) : this.finishOp(e2 === 124 ? aa.bitwiseOR : aa.bitwiseAND, 1);
    }, vo.readToken_caret = function() {
      return this.input.charCodeAt(this.pos + 1) === 61 ? this.finishOp(aa.assign, 2) : this.finishOp(aa.bitwiseXOR, 1);
    }, vo.readToken_plus_min = function(e2) {
      var t = this.input.charCodeAt(this.pos + 1);
      return t === e2 ? t !== 45 || this.inModule || this.input.charCodeAt(this.pos + 2) !== 62 || this.lastTokEnd !== 0 && !oa.test(this.input.slice(this.lastTokEnd, this.pos)) ? this.finishOp(aa.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : t === 61 ? this.finishOp(aa.assign, 2) : this.finishOp(aa.plusMin, 1);
    }, vo.readToken_lt_gt = function(e2) {
      var t = this.input.charCodeAt(this.pos + 1), s2 = 1;
      return t === e2 ? (s2 = e2 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + s2) === 61 ? this.finishOp(aa.assign, s2 + 1) : this.finishOp(aa.bitShift, s2)) : t !== 33 || e2 !== 60 || this.inModule || this.input.charCodeAt(this.pos + 2) !== 45 || this.input.charCodeAt(this.pos + 3) !== 45 ? (t === 61 && (s2 = 2), this.finishOp(aa.relational, s2)) : (this.skipLineComment(4), this.skipSpace(), this.nextToken());
    }, vo.readToken_eq_excl = function(e2) {
      var t = this.input.charCodeAt(this.pos + 1);
      return t === 61 ? this.finishOp(aa.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : e2 === 61 && t === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(aa.arrow)) : this.finishOp(e2 === 61 ? aa.eq : aa.prefix, 1);
    }, vo.readToken_question = function() {
      var e2 = this.options.ecmaVersion;
      if (e2 >= 11) {
        var t = this.input.charCodeAt(this.pos + 1);
        if (t === 46) {
          var s2 = this.input.charCodeAt(this.pos + 2);
          if (s2 < 48 || s2 > 57)
            return this.finishOp(aa.questionDot, 2);
        }
        if (t === 63) {
          if (e2 >= 12) {
            if (this.input.charCodeAt(this.pos + 2) === 61)
              return this.finishOp(aa.assign, 3);
          }
          return this.finishOp(aa.coalesce, 2);
        }
      }
      return this.finishOp(aa.question, 1);
    }, vo.readToken_numberSign = function() {
      var e2 = 35;
      if (this.options.ecmaVersion >= 13 && (++this.pos, Zr(e2 = this.fullCharCodeAtPos(), true) || e2 === 92))
        return this.finishToken(aa.privateId, this.readWord1());
      this.raise(this.pos, "Unexpected character '" + So(e2) + "'");
    }, vo.getTokenFromCode = function(e2) {
      switch (e2) {
        case 46:
          return this.readToken_dot();
        case 40:
          return ++this.pos, this.finishToken(aa.parenL);
        case 41:
          return ++this.pos, this.finishToken(aa.parenR);
        case 59:
          return ++this.pos, this.finishToken(aa.semi);
        case 44:
          return ++this.pos, this.finishToken(aa.comma);
        case 91:
          return ++this.pos, this.finishToken(aa.bracketL);
        case 93:
          return ++this.pos, this.finishToken(aa.bracketR);
        case 123:
          return ++this.pos, this.finishToken(aa.braceL);
        case 125:
          return ++this.pos, this.finishToken(aa.braceR);
        case 58:
          return ++this.pos, this.finishToken(aa.colon);
        case 96:
          if (this.options.ecmaVersion < 6)
            break;
          return ++this.pos, this.finishToken(aa.backQuote);
        case 48:
          var t = this.input.charCodeAt(this.pos + 1);
          if (t === 120 || t === 88)
            return this.readRadixNumber(16);
          if (this.options.ecmaVersion >= 6) {
            if (t === 111 || t === 79)
              return this.readRadixNumber(8);
            if (t === 98 || t === 66)
              return this.readRadixNumber(2);
          }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return this.readNumber(false);
        case 34:
        case 39:
          return this.readString(e2);
        case 47:
          return this.readToken_slash();
        case 37:
        case 42:
          return this.readToken_mult_modulo_exp(e2);
        case 124:
        case 38:
          return this.readToken_pipe_amp(e2);
        case 94:
          return this.readToken_caret();
        case 43:
        case 45:
          return this.readToken_plus_min(e2);
        case 60:
        case 62:
          return this.readToken_lt_gt(e2);
        case 61:
        case 33:
          return this.readToken_eq_excl(e2);
        case 63:
          return this.readToken_question();
        case 126:
          return this.finishOp(aa.prefix, 1);
        case 35:
          return this.readToken_numberSign();
      }
      this.raise(this.pos, "Unexpected character '" + So(e2) + "'");
    }, vo.finishOp = function(e2, t) {
      var s2 = this.input.slice(this.pos, this.pos + t);
      return this.pos += t, this.finishToken(e2, s2);
    }, vo.readRegexp = function() {
      for (var e2, t, s2 = this.pos; ; ) {
        this.pos >= this.input.length && this.raise(s2, "Unterminated regular expression");
        var i2 = this.input.charAt(this.pos);
        if (oa.test(i2) && this.raise(s2, "Unterminated regular expression"), e2)
          e2 = false;
        else {
          if (i2 === "[")
            t = true;
          else if (i2 === "]" && t)
            t = false;
          else if (i2 === "/" && !t)
            break;
          e2 = i2 === "\\";
        }
        ++this.pos;
      }
      var n3 = this.input.slice(s2, this.pos);
      ++this.pos;
      var r2 = this.pos, a2 = this.readWord1();
      this.containsEsc && this.unexpected(r2);
      var o2 = this.regexpState || (this.regexpState = new ho(this));
      o2.reset(s2, n3, a2), this.validateRegExpFlags(o2), this.validateRegExpPattern(o2);
      var h3 = null;
      try {
        h3 = new RegExp(n3, a2);
      } catch (e3) {
      }
      return this.finishToken(aa.regexp, { pattern: n3, flags: a2, value: h3 });
    }, vo.readInt = function(e2, t, s2) {
      for (var i2 = this.options.ecmaVersion >= 12 && t === void 0, n3 = s2 && this.input.charCodeAt(this.pos) === 48, r2 = this.pos, a2 = 0, o2 = 0, h3 = 0, l2 = t == null ? 1 / 0 : t; h3 < l2; ++h3, ++this.pos) {
        var c2 = this.input.charCodeAt(this.pos), u2 = void 0;
        if (i2 && c2 === 95)
          n3 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), o2 === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), h3 === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), o2 = c2;
        else {
          if ((u2 = c2 >= 97 ? c2 - 97 + 10 : c2 >= 65 ? c2 - 65 + 10 : c2 >= 48 && c2 <= 57 ? c2 - 48 : 1 / 0) >= e2)
            break;
          o2 = c2, a2 = a2 * e2 + u2;
        }
      }
      return i2 && o2 === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === r2 || t != null && this.pos - r2 !== t ? null : a2;
    }, vo.readRadixNumber = function(e2) {
      var t = this.pos;
      this.pos += 2;
      var s2 = this.readInt(e2);
      return s2 == null && this.raise(this.start + 2, "Expected number in radix " + e2), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (s2 = bo(this.input.slice(t, this.pos)), ++this.pos) : Zr(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(aa.num, s2);
    }, vo.readNumber = function(e2) {
      var t = this.pos;
      e2 || this.readInt(10, void 0, true) !== null || this.raise(t, "Invalid number");
      var s2 = this.pos - t >= 2 && this.input.charCodeAt(t) === 48;
      s2 && this.strict && this.raise(t, "Invalid number");
      var i2 = this.input.charCodeAt(this.pos);
      if (!s2 && !e2 && this.options.ecmaVersion >= 11 && i2 === 110) {
        var n3 = bo(this.input.slice(t, this.pos));
        return ++this.pos, Zr(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(aa.num, n3);
      }
      s2 && /[89]/.test(this.input.slice(t, this.pos)) && (s2 = false), i2 !== 46 || s2 || (++this.pos, this.readInt(10), i2 = this.input.charCodeAt(this.pos)), i2 !== 69 && i2 !== 101 || s2 || ((i2 = this.input.charCodeAt(++this.pos)) !== 43 && i2 !== 45 || ++this.pos, this.readInt(10) === null && this.raise(t, "Invalid number")), Zr(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
      var r2, a2 = (r2 = this.input.slice(t, this.pos), s2 ? parseInt(r2, 8) : parseFloat(r2.replace(/_/g, "")));
      return this.finishToken(aa.num, a2);
    }, vo.readCodePoint = function() {
      var e2;
      if (this.input.charCodeAt(this.pos) === 123) {
        this.options.ecmaVersion < 6 && this.unexpected();
        var t = ++this.pos;
        e2 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, e2 > 1114111 && this.invalidStringToken(t, "Code point out of bounds");
      } else
        e2 = this.readHexChar(4);
      return e2;
    }, vo.readString = function(e2) {
      for (var t = "", s2 = ++this.pos; ; ) {
        this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
        var i2 = this.input.charCodeAt(this.pos);
        if (i2 === e2)
          break;
        i2 === 92 ? (t += this.input.slice(s2, this.pos), t += this.readEscapedChar(false), s2 = this.pos) : i2 === 8232 || i2 === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (la(i2) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
      }
      return t += this.input.slice(s2, this.pos++), this.finishToken(aa.string, t);
    };
    Ao = {};
    vo.tryReadTemplateToken = function() {
      this.inTemplateElement = true;
      try {
        this.readTmplToken();
      } catch (e2) {
        if (e2 !== Ao)
          throw e2;
        this.readInvalidTemplateToken();
      }
      this.inTemplateElement = false;
    }, vo.invalidStringToken = function(e2, t) {
      if (this.inTemplateElement && this.options.ecmaVersion >= 9)
        throw Ao;
      this.raise(e2, t);
    }, vo.readTmplToken = function() {
      for (var e2 = "", t = this.pos; ; ) {
        this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
        var s2 = this.input.charCodeAt(this.pos);
        if (s2 === 96 || s2 === 36 && this.input.charCodeAt(this.pos + 1) === 123)
          return this.pos !== this.start || this.type !== aa.template && this.type !== aa.invalidTemplate ? (e2 += this.input.slice(t, this.pos), this.finishToken(aa.template, e2)) : s2 === 36 ? (this.pos += 2, this.finishToken(aa.dollarBraceL)) : (++this.pos, this.finishToken(aa.backQuote));
        if (s2 === 92)
          e2 += this.input.slice(t, this.pos), e2 += this.readEscapedChar(true), t = this.pos;
        else if (la(s2)) {
          switch (e2 += this.input.slice(t, this.pos), ++this.pos, s2) {
            case 13:
              this.input.charCodeAt(this.pos) === 10 && ++this.pos;
            case 10:
              e2 += "\n";
              break;
            default:
              e2 += String.fromCharCode(s2);
          }
          this.options.locations && (++this.curLine, this.lineStart = this.pos), t = this.pos;
        } else
          ++this.pos;
      }
    }, vo.readInvalidTemplateToken = function() {
      for (; this.pos < this.input.length; this.pos++)
        switch (this.input[this.pos]) {
          case "\\":
            ++this.pos;
            break;
          case "$":
            if (this.input[this.pos + 1] !== "{")
              break;
          case "`":
            return this.finishToken(aa.invalidTemplate, this.input.slice(this.start, this.pos));
        }
      this.raise(this.start, "Unterminated template");
    }, vo.readEscapedChar = function(e2) {
      var t = this.input.charCodeAt(++this.pos);
      switch (++this.pos, t) {
        case 110:
          return "\n";
        case 114:
          return "\r";
        case 120:
          return String.fromCharCode(this.readHexChar(2));
        case 117:
          return So(this.readCodePoint());
        case 116:
          return "	";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          this.input.charCodeAt(this.pos) === 10 && ++this.pos;
        case 10:
          return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
        case 56:
        case 57:
          if (this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), e2) {
            var s2 = this.pos - 1;
            return this.invalidStringToken(s2, "Invalid escape sequence in template string"), null;
          }
        default:
          if (t >= 48 && t <= 55) {
            var i2 = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], n3 = parseInt(i2, 8);
            return n3 > 255 && (i2 = i2.slice(0, -1), n3 = parseInt(i2, 8)), this.pos += i2.length - 1, t = this.input.charCodeAt(this.pos), i2 === "0" && t !== 56 && t !== 57 || !this.strict && !e2 || this.invalidStringToken(this.pos - 1 - i2.length, e2 ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(n3);
          }
          return la(t) ? "" : String.fromCharCode(t);
      }
    }, vo.readHexChar = function(e2) {
      var t = this.pos, s2 = this.readInt(16, e2);
      return s2 === null && this.invalidStringToken(t, "Bad character escape sequence"), s2;
    }, vo.readWord1 = function() {
      this.containsEsc = false;
      for (var e2 = "", t = true, s2 = this.pos, i2 = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
        var n3 = this.fullCharCodeAtPos();
        if (Jr(n3, i2))
          this.pos += n3 <= 65535 ? 1 : 2;
        else {
          if (n3 !== 92)
            break;
          this.containsEsc = true, e2 += this.input.slice(s2, this.pos);
          var r2 = this.pos;
          this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
          var a2 = this.readCodePoint();
          (t ? Zr : Jr)(a2, i2) || this.invalidStringToken(r2, "Invalid Unicode escape"), e2 += So(a2), s2 = this.pos;
        }
        t = false;
      }
      return e2 + this.input.slice(s2, this.pos);
    }, vo.readWord = function() {
      var e2 = this.readWord1(), t = aa.name;
      return this.keywords.test(e2) && (t = na[e2]), this.finishToken(t, e2);
    };
    ka.acorn = { Parser: ka, version: "8.6.0", defaultOptions: ba, Position: Ea, SourceLocation: xa, getLineInfo: va, Node: Ka, TokenType: ea, tokTypes: aa, keywordTypes: na, TokContext: Ba, tokContexts: Fa, isIdentifierChar: Jr, isIdentifierStart: Zr, Token: xo, isNewLine: la, lineBreak: oa, lineBreakG: ha, nonASCIIwhitespace: ca };
    Po = (e2) => () => {
      Hs({ code: "NO_FS_IN_BROWSER", message: `Cannot access the file system (via "${e2}") when using the browser build of Rollup. Make sure you supply a plugin with custom resolveId and load hooks to Rollup.`, url: "https://rollupjs.org/guide/en/#a-simple-example" });
    };
    ko = Po("fs.readFile");
    wo = Po("fs.writeFile");
    Co = class {
      constructor(e2 = 1) {
        this.maxParallel = e2, this.queue = new Array(), this.workerCount = 0;
      }
      run(e2) {
        return new Promise((t, s2) => {
          this.queue.push({ reject: s2, resolve: t, task: e2 }), this.work();
        });
      }
      async work() {
        if (this.workerCount >= this.maxParallel)
          return;
        let e2;
        for (this.workerCount++; e2 = this.queue.shift(); ) {
          const { reject: t, resolve: s2, task: i2 } = e2;
          try {
            s2(await i2());
          } catch (e3) {
            t(e3);
          }
        }
        this.workerCount--;
      }
    };
    _o = [{ active: true, deprecated: "resolveAssetUrl", replacement: "resolveFileUrl" }];
    $o = { delete: () => false, get() {
    }, has: () => false, set() {
    } };
    Mo = class {
      constructor(e2, t, s2, i2) {
        this.graph = e2, this.modulesById = t, this.options = s2, this.pluginDriver = i2, this.implicitEntryModules = new Set(), this.indexedEntryModules = [], this.latestLoadModulesPromise = Promise.resolve(), this.moduleLoadPromises = new Map(), this.modulesWithLoadedDependencies = new Set(), this.nextEntryModuleIndex = 0, this.readQueue = new Co(), this.resolveId = async (e3, t2, s3, i3, n3 = null) => this.addDefaultsToResolvedId(this.getNormalizedResolvedIdWithoutDefaults(!this.options.external(e3, t2, false) && await Io(e3, t2, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, n3, s3, typeof i3 == "boolean" ? i3 : !t2), t2, e3)), this.hasModuleSideEffects = s2.treeshake ? s2.treeshake.moduleSideEffects : () => true, this.readQueue.maxParallel = s2.maxParallelFileReads;
      }
      async addAdditionalModules(e2) {
        const t = this.extendLoadModulesPromise(Promise.all(e2.map((e3) => this.loadEntryModule(e3, false, void 0, null))));
        return await this.awaitLoadModulesPromise(), t;
      }
      async addEntryModules(e2, t) {
        const s2 = this.nextEntryModuleIndex;
        this.nextEntryModuleIndex += e2.length;
        const i2 = await this.extendLoadModulesPromise(Promise.all(e2.map(({ id: e3, importer: t2 }) => this.loadEntryModule(e3, true, t2, null))).then((i3) => {
          let n3 = s2;
          for (let s3 = 0; s3 < i3.length; s3++) {
            const r2 = i3[s3];
            r2.isUserDefinedEntryPoint = r2.isUserDefinedEntryPoint || t, Lo(r2, e2[s3], t);
            const a2 = this.indexedEntryModules.find((e3) => e3.module === r2);
            a2 ? a2.index = Math.min(a2.index, n3) : this.indexedEntryModules.push({ index: n3, module: r2 }), n3++;
          }
          return this.indexedEntryModules.sort(({ index: e3 }, { index: t2 }) => e3 > t2 ? 1 : -1), i3;
        }));
        return await this.awaitLoadModulesPromise(), { entryModules: this.indexedEntryModules.map(({ module: e3 }) => e3), implicitEntryModules: [...this.implicitEntryModules], newEntryModules: i2 };
      }
      async emitChunk({ fileName: e2, id: t, importer: s2, name: i2, implicitlyLoadedAfterOneOf: n3, preserveSignature: r2 }) {
        const a2 = { fileName: e2 || null, id: t, importer: s2, name: i2 || null }, o2 = n3 ? await this.addEntryWithImplicitDependants(a2, n3) : (await this.addEntryModules([a2], false)).newEntryModules[0];
        return r2 != null && (o2.preserveSignature = r2), o2;
      }
      preloadModule(e2) {
        return this.fetchModule(this.addDefaultsToResolvedId(e2), void 0, false, true).then((e3) => e3.info);
      }
      addDefaultsToResolvedId(e2) {
        var t, s2;
        if (!e2)
          return null;
        const i2 = e2.external || false;
        return { external: i2, id: e2.id, meta: e2.meta || {}, moduleSideEffects: (t = e2.moduleSideEffects) !== null && t !== void 0 ? t : this.hasModuleSideEffects(e2.id, !!i2), syntheticNamedExports: (s2 = e2.syntheticNamedExports) !== null && s2 !== void 0 && s2 };
      }
      addEntryWithImplicitDependants(e2, t) {
        return this.extendLoadModulesPromise(this.loadEntryModule(e2.id, false, e2.importer, null).then(async (s2) => {
          if (Lo(s2, e2, false), !s2.info.isEntry) {
            this.implicitEntryModules.add(s2);
            const i2 = await Promise.all(t.map((t2) => this.loadEntryModule(t2, false, e2.importer, s2.id)));
            for (const e3 of i2)
              s2.implicitlyLoadedAfter.add(e3);
            for (const e3 of s2.implicitlyLoadedAfter)
              e3.implicitlyLoadedBefore.add(s2);
          }
          return s2;
        }));
      }
      async addModuleSource(e2, t, s2) {
        let i2;
        Vi("load modules", 3);
        try {
          i2 = await this.readQueue.run(async () => {
            var t2;
            return (t2 = await this.pluginDriver.hookFirst("load", [e2])) !== null && t2 !== void 0 ? t2 : await ko(e2);
          });
        } catch (s3) {
          Bi("load modules", 3);
          let i3 = `Could not load ${e2}`;
          throw t && (i3 += ` (imported by ${se(t)})`), i3 += `: ${s3.message}`, s3.message = i3, s3;
        }
        Bi("load modules", 3);
        const n3 = typeof i2 == "string" ? { code: i2 } : typeof i2 == "object" && typeof i2.code == "string" ? i2 : Hs(function(e3) {
          return { code: Ks.BAD_LOADER, message: `Error loading ${se(e3)}: plugin load hook should return a string, a { code, map } object, or nothing/null` };
        }(e2)), r2 = this.graph.cachedModules.get(e2);
        if (r2 && !r2.customTransformCache && r2.originalCode === n3.code) {
          if (r2.transformFiles)
            for (const e3 of r2.transformFiles)
              this.pluginDriver.emitFile(e3);
          s2.setSource(r2);
        } else
          s2.updateOptions(n3), s2.setSource(await Ro(n3, s2, this.pluginDriver, this.options.onwarn));
      }
      async awaitLoadModulesPromise() {
        let e2;
        do {
          e2 = this.latestLoadModulesPromise, await e2;
        } while (e2 !== this.latestLoadModulesPromise);
      }
      extendLoadModulesPromise(e2) {
        return this.latestLoadModulesPromise = Promise.all([e2, this.latestLoadModulesPromise]), this.latestLoadModulesPromise.catch(() => {
        }), e2;
      }
      async fetchDynamicDependencies(e2, t) {
        const s2 = await Promise.all(t.map((t2) => t2.then(async ([t3, s3]) => s3 === null ? null : typeof s3 == "string" ? (t3.resolution = s3, null) : t3.resolution = await this.fetchResolvedDependency(se(s3.id), e2.id, s3))));
        for (const t2 of s2)
          t2 && (e2.dynamicDependencies.add(t2), t2.dynamicImporters.push(e2.id));
      }
      async fetchModule({ id: e2, meta: t, moduleSideEffects: s2, syntheticNamedExports: i2 }, n3, r2, a2) {
        const o2 = this.modulesById.get(e2);
        if (o2 instanceof Hi)
          return await this.handleExistingModule(o2, r2, a2), o2;
        const h3 = new Hi(this.graph, e2, this.options, r2, s2, i2, t);
        this.modulesById.set(e2, h3), this.graph.watchFiles[e2] = true;
        const l2 = this.addModuleSource(e2, n3, h3).then(() => [this.getResolveStaticDependencyPromises(h3), this.getResolveDynamicImportPromises(h3), c2]), c2 = l2.then(([e3, t2]) => Promise.all([...e3, ...t2])).then(() => this.pluginDriver.hookParallel("moduleParsed", [h3.info]));
        c2.catch(() => {
        }), this.moduleLoadPromises.set(h3, l2);
        const u2 = await l2;
        return a2 || await this.fetchModuleDependencies(h3, ...u2), h3;
      }
      async fetchModuleDependencies(e2, t, s2, i2) {
        this.modulesWithLoadedDependencies.has(e2) || (this.modulesWithLoadedDependencies.add(e2), await Promise.all([this.fetchStaticDependencies(e2, t), this.fetchDynamicDependencies(e2, s2)]), e2.linkImports(), await i2);
      }
      fetchResolvedDependency(e2, t, s2) {
        if (s2.external) {
          const { external: i2, id: n3, moduleSideEffects: r2, meta: a2 } = s2;
          this.modulesById.has(n3) || this.modulesById.set(n3, new ne(this.options, n3, r2, a2, i2 !== "absolute" && P(n3)));
          const o2 = this.modulesById.get(n3);
          return o2 instanceof ne ? Promise.resolve(o2) : Hs(function(e3, t2) {
            return { code: Ks.INVALID_EXTERNAL_ID, message: `'${e3}' is imported as an external by ${se(t2)}, but is already an existing non-external module id.` };
          }(e2, t));
        }
        return this.fetchModule(s2, t, false, false);
      }
      async fetchStaticDependencies(e2, t) {
        for (const s2 of await Promise.all(t.map((t2) => t2.then(([t3, s3]) => this.fetchResolvedDependency(t3, e2.id, s3)))))
          e2.dependencies.add(s2), s2.importers.push(e2.id);
        if (!this.options.treeshake || e2.info.hasModuleSideEffects === "no-treeshake")
          for (const t2 of e2.dependencies)
            t2 instanceof Hi && (t2.importedFromNotTreeshaken = true);
      }
      getNormalizedResolvedIdWithoutDefaults(e2, t, s2) {
        const { makeAbsoluteExternalsRelative: i2 } = this.options;
        if (e2) {
          if (typeof e2 == "object") {
            const n5 = e2.external || this.options.external(e2.id, t, true);
            return __spreadProps2(__spreadValues2({}, e2), { external: n5 && (n5 === "relative" || !P(e2.id) || n5 === true && Oo(e2.id, s2, i2) || "absolute") });
          }
          const n4 = this.options.external(e2, t, true);
          return { external: n4 && (Oo(e2, s2, i2) || "absolute"), id: n4 && i2 ? Do(e2, t) : e2 };
        }
        const n3 = i2 ? Do(s2, t) : s2;
        return e2 === false || this.options.external(n3, t, true) ? { external: Oo(n3, s2, i2) || "absolute", id: n3 } : null;
      }
      getResolveDynamicImportPromises(e2) {
        return e2.dynamicImports.map(async (t) => {
          const s2 = await this.resolveDynamicImport(e2, typeof t.argument == "string" ? t.argument : t.argument.esTreeNode, e2.id);
          return s2 && typeof s2 == "object" && (t.id = s2.id), [t, s2];
        });
      }
      getResolveStaticDependencyPromises(e2) {
        return Array.from(e2.sources, async (t) => [t, e2.resolvedIds[t] = e2.resolvedIds[t] || this.handleResolveId(await this.resolveId(t, e2.id, K, false), t, e2.id)]);
      }
      async handleExistingModule(e2, t, s2) {
        const i2 = this.moduleLoadPromises.get(e2);
        if (s2)
          return i2;
        if (t) {
          e2.info.isEntry = true, this.implicitEntryModules.delete(e2);
          for (const t2 of e2.implicitlyLoadedAfter)
            t2.implicitlyLoadedBefore.delete(e2);
          e2.implicitlyLoadedAfter.clear();
        }
        return this.fetchModuleDependencies(e2, ...await i2);
      }
      handleResolveId(e2, t, s2) {
        return e2 === null ? k(t) ? Hs(function(e3, t2) {
          return { code: Ks.UNRESOLVED_IMPORT, message: `Could not resolve '${e3}' from ${se(t2)}` };
        }(t, s2)) : (this.options.onwarn(function(e3, t2) {
          return { code: Ks.UNRESOLVED_IMPORT, importer: se(t2), message: `'${e3}' is imported by ${se(t2)}, but could not be resolved \u2013 treating it as an external dependency`, source: e3, url: "https://rollupjs.org/guide/en/#warning-treating-module-as-external-dependency" };
        }(t, s2)), { external: true, id: t, meta: {}, moduleSideEffects: this.hasModuleSideEffects(t, true), syntheticNamedExports: false }) : (e2.external && e2.syntheticNamedExports && this.options.onwarn(function(e3, t2) {
          return { code: Ks.EXTERNAL_SYNTHETIC_EXPORTS, importer: se(t2), message: `External '${e3}' can not have 'syntheticNamedExports' enabled.`, source: e3 };
        }(t, s2)), e2);
      }
      async loadEntryModule(e2, t, s2, i2) {
        const n3 = await Io(e2, s2, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, null, K, true);
        return n3 == null ? Hs(i2 === null ? function(e3) {
          return { code: Ks.UNRESOLVED_ENTRY, message: `Could not resolve entry module (${se(e3)}).` };
        }(e2) : function(e3, t2) {
          return { code: Ks.MISSING_IMPLICIT_DEPENDANT, message: `Module "${se(e3)}" that should be implicitly loaded before "${se(t2)}" could not be resolved.` };
        }(e2, i2)) : n3 === false || typeof n3 == "object" && n3.external ? Hs(i2 === null ? function(e3) {
          return { code: Ks.UNRESOLVED_ENTRY, message: `Entry module cannot be external (${se(e3)}).` };
        }(e2) : function(e3, t2) {
          return { code: Ks.MISSING_IMPLICIT_DEPENDANT, message: `Module "${se(e3)}" that should be implicitly loaded before "${se(t2)}" cannot be external.` };
        }(e2, i2)) : this.fetchModule(this.addDefaultsToResolvedId(typeof n3 == "object" ? n3 : { id: n3 }), void 0, t, false);
      }
      async resolveDynamicImport(e2, t, s2) {
        const i2 = await this.pluginDriver.hookFirst("resolveDynamicImport", [t, s2]);
        return typeof t != "string" ? typeof i2 == "string" ? i2 : i2 ? __spreadValues2({ external: false, moduleSideEffects: true }, i2) : null : i2 == null ? e2.resolvedIds[t] = e2.resolvedIds[t] || this.handleResolveId(await this.resolveId(t, e2.id, K, false), t, e2.id) : this.handleResolveId(this.addDefaultsToResolvedId(this.getNormalizedResolvedIdWithoutDefaults(i2, s2, t)), t, s2);
      }
    };
    Vo = class extends xt {
      constructor() {
        super(), this.parent = null, this.variables.set("undefined", new xi());
      }
      findVariable(e2) {
        let t = this.variables.get(e2);
        return t || (t = new Ye(e2), this.variables.set(e2, t)), t;
      }
    };
    zo = Object.keys({ buildEnd: 1, buildStart: 1, closeBundle: 1, closeWatcher: 1, load: 1, moduleParsed: 1, options: 1, resolveDynamicImport: 1, resolveId: 1, transform: 1, watchChange: 1 });
    jo = class {
      constructor(e2, t, s2, i2, n3) {
        this.graph = e2, this.options = t, this.pluginContexts = new Map(), function(e3, t2) {
          for (const { active: s3, deprecated: i3, replacement: n4 } of _o)
            for (const r3 of e3)
              i3 in r3 && ai({ message: `The "${i3}" hook used by plugin ${r3.name} is deprecated. The "${n4}" hook should be used instead.`, plugin: r3.name }, s3, t2);
        }(s2, t), this.pluginCache = i2, this.fileEmitter = new Ir(e2, t, n3 && n3.fileEmitter), this.emitFile = this.fileEmitter.emitFile.bind(this.fileEmitter), this.getFileName = this.fileEmitter.getFileName.bind(this.fileEmitter), this.finaliseAssets = this.fileEmitter.assertAssetsFinalized.bind(this.fileEmitter), this.setOutputBundle = this.fileEmitter.setOutputBundle.bind(this.fileEmitter), this.plugins = s2.concat(n3 ? n3.plugins : []);
        const r2 = new Set();
        for (const s3 of this.plugins)
          this.pluginContexts.set(s3, Fo(s3, i2, e2, t, this.fileEmitter, r2));
        if (n3)
          for (const e3 of s2)
            for (const s3 of zo)
              s3 in e3 && t.onwarn((a2 = e3.name, o2 = s3, { code: Ks.INPUT_HOOK_IN_OUTPUT_PLUGIN, message: `The "${o2}" hook used by the output plugin ${a2} is a build time hook and will not be run for that plugin. Either this plugin cannot be used as an output plugin, or it should have an option to configure it as an output plugin.` }));
        var a2, o2;
      }
      createOutputPluginDriver(e2) {
        return new jo(this.graph, this.options, e2, this.pluginCache, this);
      }
      hookFirst(e2, t, s2, i2) {
        let n3 = Promise.resolve(void 0);
        for (const r2 of this.plugins)
          i2 && i2.has(r2) || (n3 = n3.then((i3) => i3 != null ? i3 : this.runHook(e2, t, r2, false, s2)));
        return n3;
      }
      hookFirstSync(e2, t, s2) {
        for (const i2 of this.plugins) {
          const n3 = this.runHookSync(e2, t, i2, s2);
          if (n3 != null)
            return n3;
        }
        return null;
      }
      hookParallel(e2, t, s2) {
        const i2 = [];
        for (const n3 of this.plugins) {
          const r2 = this.runHook(e2, t, n3, false, s2);
          r2 && i2.push(r2);
        }
        return Promise.all(i2).then(() => {
        });
      }
      hookReduceArg0(e2, [t, ...s2], i2, n3) {
        let r2 = Promise.resolve(t);
        for (const t2 of this.plugins)
          r2 = r2.then((r3) => {
            const a2 = [r3, ...s2], o2 = this.runHook(e2, a2, t2, false, n3);
            return o2 ? o2.then((e3) => i2.call(this.pluginContexts.get(t2), r3, e3, t2)) : r3;
          });
        return r2;
      }
      hookReduceArg0Sync(e2, [t, ...s2], i2, n3) {
        for (const r2 of this.plugins) {
          const a2 = [t, ...s2], o2 = this.runHookSync(e2, a2, r2, n3);
          t = i2.call(this.pluginContexts.get(r2), t, o2, r2);
        }
        return t;
      }
      hookReduceValue(e2, t, s2, i2, n3) {
        let r2 = Promise.resolve(t);
        for (const t2 of this.plugins)
          r2 = r2.then((r3) => {
            const a2 = this.runHook(e2, s2, t2, true, n3);
            return a2 ? a2.then((e3) => i2.call(this.pluginContexts.get(t2), r3, e3, t2)) : r3;
          });
        return r2;
      }
      hookReduceValueSync(e2, t, s2, i2, n3) {
        let r2 = t;
        for (const t2 of this.plugins) {
          const a2 = this.runHookSync(e2, s2, t2, n3);
          r2 = i2.call(this.pluginContexts.get(t2), r2, a2, t2);
        }
        return r2;
      }
      hookSeq(e2, t, s2) {
        let i2 = Promise.resolve();
        for (const n3 of this.plugins)
          i2 = i2.then(() => this.runHook(e2, t, n3, false, s2));
        return i2;
      }
      hookSeqSync(e2, t, s2) {
        for (const i2 of this.plugins)
          this.runHookSync(e2, t, i2, s2);
      }
      runHook(e2, t, s2, i2, n3) {
        const r2 = s2[e2];
        if (!r2)
          return;
        let a2 = this.pluginContexts.get(s2);
        return n3 && (a2 = n3(a2, s2)), Promise.resolve().then(() => {
          if (typeof r2 != "function")
            return i2 ? r2 : Wo(e2, s2.name);
          const n4 = r2.apply(a2, t);
          if (!n4 || !n4.then)
            return n4;
          const o2 = Promise.resolve(n4);
          return o2.then(() => o2);
        }).catch((t2) => No(t2, s2.name, { hook: e2 }));
      }
      runHookSync(e2, t, s2, i2) {
        const n3 = s2[e2];
        if (!n3)
          return;
        let r2 = this.pluginContexts.get(s2);
        i2 && (r2 = i2(r2, s2));
        try {
          return typeof n3 != "function" ? Wo(e2, s2.name) : n3.apply(r2, t);
        } catch (t2) {
          return No(t2, s2.name, { hook: e2 });
        }
      }
    };
    Uo = class {
      constructor(e2, t) {
        var s2, i2;
        if (this.options = e2, this.cachedModules = new Map(), this.deoptimizationTracker = new B2(), this.entryModules = [], this.modulesById = new Map(), this.needsTreeshakingPass = false, this.phase = Ci.LOAD_AND_PARSE, this.scope = new Vo(), this.watchFiles = Object.create(null), this.watchMode = false, this.externalModules = [], this.implicitEntryModules = [], this.modules = [], this.getModuleInfo = (e3) => {
          const t2 = this.modulesById.get(e3);
          return t2 ? t2.info : null;
        }, e2.cache !== false) {
          if ((s2 = e2.cache) === null || s2 === void 0 ? void 0 : s2.modules)
            for (const t2 of e2.cache.modules)
              this.cachedModules.set(t2.id, t2);
          this.pluginCache = ((i2 = e2.cache) === null || i2 === void 0 ? void 0 : i2.plugins) || Object.create(null);
          for (const e3 in this.pluginCache) {
            const t2 = this.pluginCache[e3];
            for (const e4 of Object.values(t2))
              e4[0]++;
          }
        }
        if (t) {
          this.watchMode = true;
          const e3 = (...e4) => this.pluginDriver.hookSeqSync("watchChange", e4), s3 = () => this.pluginDriver.hookSeqSync("closeWatcher", []);
          t.on("change", e3), t.on("close", s3), t.once("restart", () => {
            t.removeListener("change", e3), t.removeListener("close", s3);
          });
        }
        this.pluginDriver = new jo(this, e2, e2.plugins, this.pluginCache), this.acornParser = ka.extend(...e2.acornInjectPlugins), this.moduleLoader = new Mo(this, this.modulesById, this.options, this.pluginDriver);
      }
      async build() {
        Vi("generate module graph", 2), await this.generateModuleGraph(), Bi("generate module graph", 2), Vi("sort modules", 2), this.phase = Ci.ANALYSE, this.sortModules(), Bi("sort modules", 2), Vi("mark included statements", 2), this.includeStatements(), Bi("mark included statements", 2), this.phase = Ci.GENERATE;
      }
      contextParse(e2, t = {}) {
        const s2 = t.onComment, i2 = [];
        t.onComment = s2 && typeof s2 == "function" ? (e3, n4, r2, a2, ...o2) => (i2.push({ end: a2, start: r2, type: e3 ? "Block" : "Line", value: n4 }), s2.call(t, e3, n4, r2, a2, ...o2)) : i2;
        const n3 = this.acornParser.parse(e2, __spreadValues2(__spreadValues2({}, this.options.acorn), t));
        return typeof s2 == "object" && s2.push(...i2), t.onComment = s2, function(e3, t2, s3) {
          const i3 = [], n4 = [];
          for (const t3 of e3)
            ve.test(t3.value) ? i3.push(t3) : fe.test(t3.value) && n4.push(t3);
          for (const e4 of n4)
            be(t2, e4, false);
          me(t2, { annotationIndex: 0, annotations: i3, code: s3 });
        }(i2, n3, e2), n3;
      }
      getCache() {
        for (const e2 in this.pluginCache) {
          const t = this.pluginCache[e2];
          let s2 = true;
          for (const [e3, i2] of Object.entries(t))
            i2[0] >= this.options.experimentalCacheExpiry ? delete t[e3] : s2 = false;
          s2 && delete this.pluginCache[e2];
        }
        return { modules: this.modules.map((e2) => e2.toJSON()), plugins: this.pluginCache };
      }
      async generateModuleGraph() {
        var e2;
        if ({ entryModules: this.entryModules, implicitEntryModules: this.implicitEntryModules } = await this.moduleLoader.addEntryModules((e2 = this.options.input, Array.isArray(e2) ? e2.map((e3) => ({ fileName: null, id: e3, implicitlyLoadedAfter: [], importer: void 0, name: null })) : Object.entries(e2).map(([e3, t]) => ({ fileName: null, id: t, implicitlyLoadedAfter: [], importer: void 0, name: e3 }))), true), this.entryModules.length === 0)
          throw new Error("You must supply options.input to rollup");
        for (const e3 of this.modulesById.values())
          e3 instanceof Hi ? this.modules.push(e3) : this.externalModules.push(e3);
      }
      includeStatements() {
        for (const e2 of [...this.entryModules, ...this.implicitEntryModules])
          ji(e2);
        if (this.options.treeshake) {
          let e2 = 1;
          do {
            Vi(`treeshaking pass ${e2}`, 3), this.needsTreeshakingPass = false;
            for (const e3 of this.modules)
              e3.isExecuted && (e3.info.hasModuleSideEffects === "no-treeshake" ? e3.includeAllInBundle() : e3.include());
            if (e2 === 1)
              for (const e3 of [...this.entryModules, ...this.implicitEntryModules])
                e3.preserveSignature !== false && (e3.includeAllExports(false), this.needsTreeshakingPass = true);
            Bi("treeshaking pass " + e2++, 3);
          } while (this.needsTreeshakingPass);
        } else
          for (const e2 of this.modules)
            e2.includeAllInBundle();
        for (const e2 of this.externalModules)
          e2.warnUnusedImports();
        for (const e2 of this.implicitEntryModules)
          for (const t of e2.implicitlyLoadedAfter)
            t.info.isEntry || t.isIncluded() || Hs(Js(t));
      }
      sortModules() {
        const { orderedModules: e2, cyclePaths: t } = function(e3) {
          let t2 = 0;
          const s2 = [], i2 = new Set(), n3 = new Set(), r2 = new Map(), a2 = [], o2 = (e4) => {
            if (e4 instanceof Hi) {
              for (const t3 of e4.dependencies)
                r2.has(t3) ? i2.has(t3) || s2.push(Dr(t3, e4, r2)) : (r2.set(t3, e4), o2(t3));
              for (const t3 of e4.implicitlyLoadedBefore)
                n3.add(t3);
              for (const { resolution: t3 } of e4.dynamicImports)
                t3 instanceof Hi && n3.add(t3);
              a2.push(e4);
            }
            e4.execIndex = t2++, i2.add(e4);
          };
          for (const t3 of e3)
            r2.has(t3) || (r2.set(t3, null), o2(t3));
          for (const e4 of n3)
            r2.has(e4) || (r2.set(e4, null), o2(e4));
          return { cyclePaths: s2, orderedModules: a2 };
        }(this.entryModules);
        for (const e3 of t)
          this.options.onwarn({ code: "CIRCULAR_DEPENDENCY", cycle: e3, importer: e3[0], message: `Circular dependency: ${e3.join(" -> ")}` });
        this.modules = e2;
        for (const e3 of this.modules)
          e3.bindReferences();
        this.warnForMissingExports();
      }
      warnForMissingExports() {
        for (const e2 of this.modules)
          for (const t of Object.values(e2.importDescriptions))
            t.name === "*" || t.module.getVariableForExportName(t.name) || e2.warn({ code: "NON_EXISTENT_EXPORT", message: `Non-existent export '${t.name}' is imported from ${se(t.module.id)}`, name: t.name, source: t.module.id }, t.start);
      }
    };
    Ho = (e2) => console.warn(e2.message || e2);
    Ko = { recommended: { annotations: true, correctVarValueBeforeDeclaration: false, moduleSideEffects: () => true, propertyReadSideEffects: true, tryCatchDeoptimization: true, unknownGlobalSideEffects: false }, safest: { annotations: true, correctVarValueBeforeDeclaration: true, moduleSideEffects: () => true, propertyReadSideEffects: true, tryCatchDeoptimization: true, unknownGlobalSideEffects: true }, smallest: { annotations: true, correctVarValueBeforeDeclaration: false, moduleSideEffects: () => false, propertyReadSideEffects: false, tryCatchDeoptimization: false, unknownGlobalSideEffects: false } };
    Xo = { es2015: { arrowFunctions: true, constBindings: true, objectShorthand: true, reservedNamesAsProps: true }, es5: { arrowFunctions: false, constBindings: false, objectShorthand: false, reservedNamesAsProps: true } };
    Yo = (e2, t, s2, i2) => {
      var n3;
      const r2 = (n3 = e2) === null || n3 === void 0 ? void 0 : n3.preset;
      if (r2) {
        const i3 = t[r2];
        if (i3)
          return __spreadValues2(__spreadValues2({}, i3), e2);
        Hs(Qs(`${s2}.preset`, Qo(s2), `valid values are ${ee(Object.keys(t))}`, r2));
      }
      return ((e3, t2, s3) => (i3) => {
        if (typeof i3 == "string") {
          const n4 = e3[i3];
          if (n4)
            return n4;
          Hs(Qs(t2, Qo(t2), `valid values are ${s3}${ee(Object.keys(e3))}. You can also supply an object for more fine-grained control`, i3));
        }
        return ((e4) => e4 && typeof e4 == "object" ? e4 : {})(i3);
      })(t, s2, i2)(e2);
    };
    Qo = (e2) => e2.split(".").join("").toLowerCase();
    Zo = (e2) => {
      const { onwarn: t } = e2;
      return t ? (e3) => {
        e3.toString = () => {
          let t2 = "";
          return e3.plugin && (t2 += `(${e3.plugin} plugin) `), e3.loc && (t2 += `${se(e3.loc.file)} (${e3.loc.line}:${e3.loc.column}) `), t2 += e3.message, t2;
        }, t(e3, Ho);
      } : Ho;
    };
    Jo = (e2) => __spreadValues2({ allowAwaitOutsideFunction: true, ecmaVersion: "latest", preserveParens: false, sourceType: "module" }, e2.acorn);
    eh = (e2) => Go(e2.acornInjectPlugins);
    th = (e2) => {
      var t;
      return ((t = e2.cache) === null || t === void 0 ? void 0 : t.cache) || e2.cache;
    };
    sh = (e2) => {
      if (e2 === true)
        return () => true;
      if (typeof e2 == "function")
        return (t, ...s2) => !t.startsWith("\0") && e2(t, ...s2) || false;
      if (e2) {
        const t = new Set(), s2 = [];
        for (const i2 of Go(e2))
          i2 instanceof RegExp ? s2.push(i2) : t.add(i2);
        return (e3, ...i2) => t.has(e3) || s2.some((t2) => t2.test(e3));
      }
      return () => false;
    };
    ih = (e2, t, s2) => {
      const i2 = e2.inlineDynamicImports;
      return i2 && oi('The "inlineDynamicImports" option is deprecated. Use the "output.inlineDynamicImports" option instead.', false, t, s2), i2;
    };
    nh = (e2) => {
      const t = e2.input;
      return t == null ? [] : typeof t == "string" ? [t] : t;
    };
    rh = (e2, t, s2) => {
      const i2 = e2.manualChunks;
      return i2 && oi('The "manualChunks" option is deprecated. Use the "output.manualChunks" option instead.', false, t, s2), i2;
    };
    ah = (e2) => {
      const t = e2.maxParallelFileReads;
      return typeof t == "number" ? t <= 0 ? 1 / 0 : t : 20;
    };
    oh = (e2, t) => {
      const s2 = e2.moduleContext;
      if (typeof s2 == "function")
        return (e3) => {
          var i2;
          return (i2 = s2(e3)) !== null && i2 !== void 0 ? i2 : t;
        };
      if (s2) {
        const e3 = Object.create(null);
        for (const [t2, i2] of Object.entries(s2))
          e3[$(t2)] = i2;
        return (s3) => e3[s3] || t;
      }
      return () => t;
    };
    hh = (e2, t) => {
      const s2 = e2.preserveEntrySignatures;
      return s2 == null && t.add("preserveEntrySignatures"), s2 != null ? s2 : "strict";
    };
    lh = (e2, t, s2) => {
      const i2 = e2.preserveModules;
      return i2 && oi('The "preserveModules" option is deprecated. Use the "output.preserveModules" option instead.', false, t, s2), i2;
    };
    ch = (e2, t, s2) => {
      const i2 = e2.treeshake;
      if (i2 === false)
        return false;
      const n3 = Yo(e2.treeshake, Ko, "treeshake", "false, true, ");
      return n3.pureExternalModules !== void 0 && oi(`The "treeshake.pureExternalModules" option is deprecated. The "treeshake.moduleSideEffects" option should be used instead. "treeshake.pureExternalModules: true" is equivalent to "treeshake.moduleSideEffects: 'no-external'"`, true, t, s2), { annotations: n3.annotations !== false, correctVarValueBeforeDeclaration: n3.correctVarValueBeforeDeclaration === true, moduleSideEffects: typeof i2 == "object" && i2.pureExternalModules ? uh(i2.moduleSideEffects, i2.pureExternalModules) : uh(n3.moduleSideEffects, void 0), propertyReadSideEffects: n3.propertyReadSideEffects === "always" ? "always" : n3.propertyReadSideEffects !== false, tryCatchDeoptimization: n3.tryCatchDeoptimization !== false, unknownGlobalSideEffects: n3.unknownGlobalSideEffects !== false };
    };
    uh = (e2, t) => {
      if (typeof e2 == "boolean")
        return () => e2;
      if (e2 === "no-external")
        return (e3, t2) => !t2;
      if (typeof e2 == "function")
        return (t2, s3) => !!t2.startsWith("\0") || e2(t2, s3) !== false;
      if (Array.isArray(e2)) {
        const t2 = new Set(e2);
        return (e3) => t2.has(e3);
      }
      e2 && Hs(Qs("treeshake.moduleSideEffects", "treeshake", 'please use one of false, "no-external", a function or an array'));
      const s2 = sh(t);
      return (e3, t2) => !(t2 && s2(e3));
    };
    dh = /[\x00-\x1F\x7F<>*#"{}|^[\]`;?:&=+$,]/g;
    fh = (e2, t, s2) => {
      const { file: i2 } = e2;
      if (typeof i2 == "string") {
        if (t)
          return Hs(Qs("output.file", "outputdir", 'you must set "output.dir" instead of "output.file" when using the "output.preserveModules" option'));
        if (!Array.isArray(s2.input))
          return Hs(Qs("output.file", "outputdir", 'you must set "output.dir" instead of "output.file" when providing named inputs'));
      }
      return i2;
    };
    mh = (e2) => {
      const t = e2.format;
      switch (t) {
        case void 0:
        case "es":
        case "esm":
        case "module":
          return "es";
        case "cjs":
        case "commonjs":
          return "cjs";
        case "system":
        case "systemjs":
          return "system";
        case "amd":
        case "iife":
        case "umd":
          return t;
        default:
          return Hs({ message: 'You must specify "output.format", which can be one of "amd", "cjs", "system", "es", "iife" or "umd".', url: "https://rollupjs.org/guide/en/#outputformat" });
      }
    };
    gh = (e2, t) => {
      var s2;
      const i2 = ((s2 = e2.inlineDynamicImports) !== null && s2 !== void 0 ? s2 : t.inlineDynamicImports) || false, { input: n3 } = t;
      return i2 && (Array.isArray(n3) ? n3 : Object.keys(n3)).length > 1 ? Hs(Qs("output.inlineDynamicImports", "outputinlinedynamicimports", 'multiple inputs are not supported when "output.inlineDynamicImports" is true')) : i2;
    };
    yh = (e2, t, s2) => {
      var i2;
      const n3 = ((i2 = e2.preserveModules) !== null && i2 !== void 0 ? i2 : s2.preserveModules) || false;
      if (n3) {
        if (t)
          return Hs(Qs("output.inlineDynamicImports", "outputinlinedynamicimports", 'this option is not supported for "output.preserveModules"'));
        if (s2.preserveEntrySignatures === false)
          return Hs(Qs("preserveEntrySignatures", "preserveentrysignatures", 'setting this option to false is not supported for "output.preserveModules"'));
      }
      return n3;
    };
    Eh = (e2, t) => {
      const s2 = e2.preferConst;
      return s2 != null && ai('The "output.preferConst" option is deprecated. Use the "output.generatedCode.constBindings" option instead.', false, t), !!s2;
    };
    xh = (e2) => {
      const { preserveModulesRoot: t } = e2;
      if (t != null)
        return $(t);
    };
    vh = (e2) => {
      const t = __spreadValues2({ autoId: false, basePath: "", define: "define" }, e2.amd);
      if ((t.autoId || t.basePath) && t.id)
        return Hs(Qs("output.amd.id", "outputamd", 'this option cannot be used together with "output.amd.autoId"/"output.amd.basePath"'));
      if (t.basePath && !t.autoId)
        return Hs(Qs("output.amd.basePath", "outputamd", 'this option only works with "output.amd.autoId"'));
      let s2;
      return s2 = t.autoId ? { autoId: true, basePath: t.basePath, define: t.define } : { autoId: false, define: t.define, id: t.id }, s2;
    };
    bh = (e2, t) => {
      const s2 = e2[t];
      return typeof s2 == "function" ? s2 : () => s2 || "";
    };
    Sh = (e2, t) => {
      const { dir: s2 } = e2;
      return typeof s2 == "string" && typeof t == "string" ? Hs(Qs("output.dir", "outputdir", 'you must set either "output.file" for a single-file build or "output.dir" when generating multiple chunks')) : s2;
    };
    Ah = (e2, t) => {
      const s2 = e2.dynamicImportFunction;
      return s2 && ai('The "output.dynamicImportFunction" option is deprecated. Use the "renderDynamicImport" plugin hook instead.', false, t), s2;
    };
    Ph = (e2, t) => {
      const s2 = e2.entryFileNames;
      return s2 == null && t.add("entryFileNames"), s2 != null ? s2 : "[name].js";
    };
    wh = (e2, t) => {
      const s2 = Yo(e2.generatedCode, Xo, "output.generatedCode", "");
      return { arrowFunctions: s2.arrowFunctions === true, constBindings: s2.constBindings === true || t, objectShorthand: s2.objectShorthand === true, reservedNamesAsProps: s2.reservedNamesAsProps === true };
    };
    Ch = (e2, t) => {
      if (t)
        return "";
      const s2 = e2.indent;
      return s2 === false ? "" : s2 == null || s2;
    };
    Ih = new Set(["auto", "esModule", "default", "defaultOnly", true, false]);
    Nh = (e2, t) => {
      const s2 = e2.interop, i2 = new Set(), n3 = (e3) => {
        if (!i2.has(e3)) {
          if (i2.add(e3), !Ih.has(e3))
            return Hs(Qs("output.interop", "outputinterop", `use one of ${Array.from(Ih.values(), (e4) => JSON.stringify(e4)).join(", ")}`, e3));
          typeof e3 == "boolean" && ai({ message: `The boolean value "${e3}" for the "output.interop" option is deprecated. Use ${e3 ? '"auto"' : '"esModule", "default" or "defaultOnly"'} instead.`, url: "https://rollupjs.org/guide/en/#outputinterop" }, false, t);
        }
        return e3;
      };
      if (typeof s2 == "function") {
        const e3 = Object.create(null);
        let t2 = null;
        return (i3) => i3 === null ? t2 || n3(t2 = s2(i3)) : i3 in e3 ? e3[i3] : n3(e3[i3] = s2(i3));
      }
      return s2 === void 0 ? () => true : () => n3(s2);
    };
    _h = (e2, t, s2, i2) => {
      const n3 = e2.manualChunks || i2.manualChunks;
      if (n3) {
        if (t)
          return Hs(Qs("output.manualChunks", "outputmanualchunks", 'this option is not supported for "output.inlineDynamicImports"'));
        if (s2)
          return Hs(Qs("output.manualChunks", "outputmanualchunks", 'this option is not supported for "output.preserveModules"'));
      }
      return n3 || {};
    };
    $h = (e2, t, s2) => {
      var i2;
      return (i2 = e2.minifyInternalExports) !== null && i2 !== void 0 ? i2 : s2 || t === "es" || t === "system";
    };
    !function(e2) {
      e2[e2.ENTRY_CHUNK = 0] = "ENTRY_CHUNK", e2[e2.SECONDARY_CHUNK = 1] = "SECONDARY_CHUNK", e2[e2.ASSET = 2] = "ASSET";
    }(Lh || (Lh = {}));
  }
});

// browser-external:http2
var http2_exports = {};
__export(http2_exports, {
  default: () => http2_default
});
var http2_default;
var init_http2 = __esm({
  "browser-external:http2"() {
    http2_default = new Proxy({}, {
      get() {
        throw new Error('Module "http2" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/vite/dist/node/chunks/dep-5a0fbe99.js
var require_dep_5a0fbe99 = __commonJS({
  "node_modules/vite/dist/node/chunks/dep-5a0fbe99.js"(exports2) {
    "use strict";
    var build2 = require_dep_76613303();
    var require$$12 = (init_crypto(), crypto_exports);
    function _interopDefaultLegacy2(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2["default"] : e2;
    }
    function _mergeNamespaces2(n3, m3) {
      for (var i3 = 0; i3 < m3.length; i3++) {
        var e2 = m3[i3];
        if (typeof e2 !== "string" && !Array.isArray(e2)) {
          for (var k2 in e2) {
            if (k2 !== "default" && !(k2 in n3)) {
              n3[k2] = e2[k2];
            }
          }
        }
      }
      return n3;
    }
    var require$$1__default2 = _interopDefaultLegacy2(require$$12);
    var selfsigned = {};
    var forge$F = {
      options: {
        usePureJavaScript: false
      }
    };
    var api = {};
    var baseN$1 = api;
    var _reverseAlphabets = {};
    api.encode = function(input, alphabet, maxline) {
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      if (maxline !== void 0 && typeof maxline !== "number") {
        throw new TypeError('"maxline" must be a number.');
      }
      var output = "";
      if (!(input instanceof Uint8Array)) {
        output = _encodeWithByteBuffer(input, alphabet);
      } else {
        var i3 = 0;
        var base2 = alphabet.length;
        var first2 = alphabet.charAt(0);
        var digits = [0];
        for (i3 = 0; i3 < input.length; ++i3) {
          for (var j2 = 0, carry = input[i3]; j2 < digits.length; ++j2) {
            carry += digits[j2] << 8;
            digits[j2] = carry % base2;
            carry = carry / base2 | 0;
          }
          while (carry > 0) {
            digits.push(carry % base2);
            carry = carry / base2 | 0;
          }
        }
        for (i3 = 0; input[i3] === 0 && i3 < input.length - 1; ++i3) {
          output += first2;
        }
        for (i3 = digits.length - 1; i3 >= 0; --i3) {
          output += alphabet[digits[i3]];
        }
      }
      if (maxline) {
        var regex = new RegExp(".{1," + maxline + "}", "g");
        output = output.match(regex).join("\r\n");
      }
      return output;
    };
    api.decode = function(input, alphabet) {
      if (typeof input !== "string") {
        throw new TypeError('"input" must be a string.');
      }
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      var table = _reverseAlphabets[alphabet];
      if (!table) {
        table = _reverseAlphabets[alphabet] = [];
        for (var i3 = 0; i3 < alphabet.length; ++i3) {
          table[alphabet.charCodeAt(i3)] = i3;
        }
      }
      input = input.replace(/\s/g, "");
      var base2 = alphabet.length;
      var first2 = alphabet.charAt(0);
      var bytes2 = [0];
      for (var i3 = 0; i3 < input.length; i3++) {
        var value = table[input.charCodeAt(i3)];
        if (value === void 0) {
          return;
        }
        for (var j2 = 0, carry = value; j2 < bytes2.length; ++j2) {
          carry += bytes2[j2] * base2;
          bytes2[j2] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes2.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k2 = 0; input[k2] === first2 && k2 < input.length - 1; ++k2) {
        bytes2.push(0);
      }
      if (typeof Buffer !== "undefined") {
        return Buffer.from(bytes2.reverse());
      }
      return new Uint8Array(bytes2.reverse());
    };
    function _encodeWithByteBuffer(input, alphabet) {
      var i3 = 0;
      var base2 = alphabet.length;
      var first2 = alphabet.charAt(0);
      var digits = [0];
      for (i3 = 0; i3 < input.length(); ++i3) {
        for (var j2 = 0, carry = input.at(i3); j2 < digits.length; ++j2) {
          carry += digits[j2] << 8;
          digits[j2] = carry % base2;
          carry = carry / base2 | 0;
        }
        while (carry > 0) {
          digits.push(carry % base2);
          carry = carry / base2 | 0;
        }
      }
      var output = "";
      for (i3 = 0; input.at(i3) === 0 && i3 < input.length() - 1; ++i3) {
        output += first2;
      }
      for (i3 = digits.length - 1; i3 >= 0; --i3) {
        output += alphabet[digits[i3]];
      }
      return output;
    }
    var forge$E = forge$F;
    var baseN = baseN$1;
    var util$12 = forge$E.util = forge$E.util || {};
    (function() {
      if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        util$12.nextTick = process.nextTick;
        if (typeof setImmediate === "function") {
          util$12.setImmediate = setImmediate;
        } else {
          util$12.setImmediate = util$12.nextTick;
        }
        return;
      }
      if (typeof setImmediate === "function") {
        util$12.setImmediate = function() {
          return setImmediate.apply(void 0, arguments);
        };
        util$12.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util$12.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        let handler = function(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        };
        var msg = "forge.setImmediate";
        var callbacks = [];
        util$12.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, "*");
          }
        };
        window.addEventListener("message", handler, true);
      }
      if (typeof MutationObserver !== "undefined") {
        var now = Date.now();
        var attr = true;
        var div = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div, { attributes: true });
        var oldSetImmediate = util$12.setImmediate;
        util$12.setImmediate = function(callback) {
          if (Date.now() - now > 15) {
            now = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div.setAttribute("a", attr = !attr);
            }
          }
        };
      }
      util$12.nextTick = util$12.setImmediate;
    })();
    util$12.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    util$12.globalScope = function() {
      if (util$12.isNodejs) {
        return build2.commonjsGlobal;
      }
      return typeof self === "undefined" ? window : self;
    }();
    util$12.isArray = Array.isArray || function(x2) {
      return Object.prototype.toString.call(x2) === "[object Array]";
    };
    util$12.isArrayBuffer = function(x2) {
      return typeof ArrayBuffer !== "undefined" && x2 instanceof ArrayBuffer;
    };
    util$12.isArrayBufferView = function(x2) {
      return x2 && util$12.isArrayBuffer(x2.buffer) && x2.byteLength !== void 0;
    };
    function _checkBitsParam(n3) {
      if (!(n3 === 8 || n3 === 16 || n3 === 24 || n3 === 32)) {
        throw new Error("Only 8, 16, 24, or 32 bits supported: " + n3);
      }
    }
    util$12.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b2) {
      this.data = "";
      this.read = 0;
      if (typeof b2 === "string") {
        this.data = b2;
      } else if (util$12.isArrayBuffer(b2) || util$12.isArrayBufferView(b2)) {
        if (typeof Buffer !== "undefined" && b2 instanceof Buffer) {
          this.data = b2.toString("binary");
        } else {
          var arr = new Uint8Array(b2);
          try {
            this.data = String.fromCharCode.apply(null, arr);
          } catch (e2) {
            for (var i3 = 0; i3 < arr.length; ++i3) {
              this.putByte(arr[i3]);
            }
          }
        }
      } else if (b2 instanceof ByteStringBuffer || typeof b2 === "object" && typeof b2.data === "string" && typeof b2.read === "number") {
        this.data = b2.data;
        this.read = b2.read;
      }
      this._constructedStringLength = 0;
    }
    util$12.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util$12.ByteStringBuffer.prototype._optimizeConstructedString = function(x2) {
      this._constructedStringLength += x2;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util$12.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util$12.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util$12.ByteStringBuffer.prototype.putByte = function(b2) {
      return this.putBytes(String.fromCharCode(b2));
    };
    util$12.ByteStringBuffer.prototype.fillWithByte = function(b2, n3) {
      b2 = String.fromCharCode(b2);
      var d3 = this.data;
      while (n3 > 0) {
        if (n3 & 1) {
          d3 += b2;
        }
        n3 >>>= 1;
        if (n3 > 0) {
          b2 += b2;
        }
      }
      this.data = d3;
      this._optimizeConstructedString(n3);
      return this;
    };
    util$12.ByteStringBuffer.prototype.putBytes = function(bytes2) {
      this.data += bytes2;
      this._optimizeConstructedString(bytes2.length);
      return this;
    };
    util$12.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util$12.encodeUtf8(str));
    };
    util$12.ByteStringBuffer.prototype.putInt16 = function(i3) {
      return this.putBytes(String.fromCharCode(i3 >> 8 & 255) + String.fromCharCode(i3 & 255));
    };
    util$12.ByteStringBuffer.prototype.putInt24 = function(i3) {
      return this.putBytes(String.fromCharCode(i3 >> 16 & 255) + String.fromCharCode(i3 >> 8 & 255) + String.fromCharCode(i3 & 255));
    };
    util$12.ByteStringBuffer.prototype.putInt32 = function(i3) {
      return this.putBytes(String.fromCharCode(i3 >> 24 & 255) + String.fromCharCode(i3 >> 16 & 255) + String.fromCharCode(i3 >> 8 & 255) + String.fromCharCode(i3 & 255));
    };
    util$12.ByteStringBuffer.prototype.putInt16Le = function(i3) {
      return this.putBytes(String.fromCharCode(i3 & 255) + String.fromCharCode(i3 >> 8 & 255));
    };
    util$12.ByteStringBuffer.prototype.putInt24Le = function(i3) {
      return this.putBytes(String.fromCharCode(i3 & 255) + String.fromCharCode(i3 >> 8 & 255) + String.fromCharCode(i3 >> 16 & 255));
    };
    util$12.ByteStringBuffer.prototype.putInt32Le = function(i3) {
      return this.putBytes(String.fromCharCode(i3 & 255) + String.fromCharCode(i3 >> 8 & 255) + String.fromCharCode(i3 >> 16 & 255) + String.fromCharCode(i3 >> 24 & 255));
    };
    util$12.ByteStringBuffer.prototype.putInt = function(i3, n3) {
      _checkBitsParam(n3);
      var bytes2 = "";
      do {
        n3 -= 8;
        bytes2 += String.fromCharCode(i3 >> n3 & 255);
      } while (n3 > 0);
      return this.putBytes(bytes2);
    };
    util$12.ByteStringBuffer.prototype.putSignedInt = function(i3, n3) {
      if (i3 < 0) {
        i3 += 2 << n3 - 1;
      }
      return this.putInt(i3, n3);
    };
    util$12.ByteStringBuffer.prototype.putBuffer = function(buffer) {
      return this.putBytes(buffer.getBytes());
    };
    util$12.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util$12.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      this.read += 2;
      return rval;
    };
    util$12.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      this.read += 3;
      return rval;
    };
    util$12.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      this.read += 4;
      return rval;
    };
    util$12.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      this.read += 2;
      return rval;
    };
    util$12.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      this.read += 3;
      return rval;
    };
    util$12.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      this.read += 4;
      return rval;
    };
    util$12.ByteStringBuffer.prototype.getInt = function(n3) {
      _checkBitsParam(n3);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n3 -= 8;
      } while (n3 > 0);
      return rval;
    };
    util$12.ByteStringBuffer.prototype.getSignedInt = function(n3) {
      var x2 = this.getInt(n3);
      var max = 2 << n3 - 2;
      if (x2 >= max) {
        x2 -= max << 1;
      }
      return x2;
    };
    util$12.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util$12.ByteStringBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util$12.ByteStringBuffer.prototype.at = function(i3) {
      return this.data.charCodeAt(this.read + i3);
    };
    util$12.ByteStringBuffer.prototype.setAt = function(i3, b2) {
      this.data = this.data.substr(0, this.read + i3) + String.fromCharCode(b2) + this.data.substr(this.read + i3 + 1);
      return this;
    };
    util$12.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util$12.ByteStringBuffer.prototype.copy = function() {
      var c2 = util$12.createBuffer(this.data);
      c2.read = this.read;
      return c2;
    };
    util$12.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util$12.ByteStringBuffer.prototype.clear = function() {
      this.data = "";
      this.read = 0;
      return this;
    };
    util$12.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util$12.ByteStringBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i3 = this.read; i3 < this.data.length; ++i3) {
        var b2 = this.data.charCodeAt(i3);
        if (b2 < 16) {
          rval += "0";
        }
        rval += b2.toString(16);
      }
      return rval;
    };
    util$12.ByteStringBuffer.prototype.toString = function() {
      return util$12.decodeUtf8(this.bytes());
    };
    function DataBuffer(b2, options2) {
      options2 = options2 || {};
      this.read = options2.readOffset || 0;
      this.growSize = options2.growSize || 1024;
      var isArrayBuffer = util$12.isArrayBuffer(b2);
      var isArrayBufferView = util$12.isArrayBufferView(b2);
      if (isArrayBuffer || isArrayBufferView) {
        if (isArrayBuffer) {
          this.data = new DataView(b2);
        } else {
          this.data = new DataView(b2.buffer, b2.byteOffset, b2.byteLength);
        }
        this.write = "writeOffset" in options2 ? options2.writeOffset : this.data.byteLength;
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b2 !== null && b2 !== void 0) {
        this.putBytes(b2);
      }
      if ("writeOffset" in options2) {
        this.write = options2.writeOffset;
      }
    }
    util$12.DataBuffer = DataBuffer;
    util$12.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util$12.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util$12.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src2 = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src2);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util$12.DataBuffer.prototype.putByte = function(b2) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b2);
      return this;
    };
    util$12.DataBuffer.prototype.fillWithByte = function(b2, n3) {
      this.accommodate(n3);
      for (var i3 = 0; i3 < n3; ++i3) {
        this.data.setUint8(b2);
      }
      return this;
    };
    util$12.DataBuffer.prototype.putBytes = function(bytes2, encoding2) {
      if (util$12.isArrayBufferView(bytes2)) {
        var src2 = new Uint8Array(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
        var len = src2.byteLength - src2.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src2);
        this.write += len;
        return this;
      }
      if (util$12.isArrayBuffer(bytes2)) {
        var src2 = new Uint8Array(bytes2);
        this.accommodate(src2.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src2, this.write);
        this.write += src2.byteLength;
        return this;
      }
      if (bytes2 instanceof util$12.DataBuffer || typeof bytes2 === "object" && typeof bytes2.read === "number" && typeof bytes2.write === "number" && util$12.isArrayBufferView(bytes2.data)) {
        var src2 = new Uint8Array(bytes2.data.byteLength, bytes2.read, bytes2.length());
        this.accommodate(src2.byteLength);
        var dst = new Uint8Array(bytes2.data.byteLength, this.write);
        dst.set(src2);
        this.write += src2.byteLength;
        return this;
      }
      if (bytes2 instanceof util$12.ByteStringBuffer) {
        bytes2 = bytes2.data;
        encoding2 = "binary";
      }
      encoding2 = encoding2 || "binary";
      if (typeof bytes2 === "string") {
        var view;
        if (encoding2 === "hex") {
          this.accommodate(Math.ceil(bytes2.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util$12.binary.hex.decode(bytes2, view, this.write);
          return this;
        }
        if (encoding2 === "base64") {
          this.accommodate(Math.ceil(bytes2.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util$12.binary.base64.decode(bytes2, view, this.write);
          return this;
        }
        if (encoding2 === "utf8") {
          bytes2 = util$12.encodeUtf8(bytes2);
          encoding2 = "binary";
        }
        if (encoding2 === "binary" || encoding2 === "raw") {
          this.accommodate(bytes2.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util$12.binary.raw.decode(view);
          return this;
        }
        if (encoding2 === "utf16") {
          this.accommodate(bytes2.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util$12.text.utf16.encode(view);
          return this;
        }
        throw new Error("Invalid encoding: " + encoding2);
      }
      throw Error("Invalid parameter: " + bytes2);
    };
    util$12.DataBuffer.prototype.putBuffer = function(buffer) {
      this.putBytes(buffer);
      buffer.clear();
      return this;
    };
    util$12.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, "utf16");
    };
    util$12.DataBuffer.prototype.putInt16 = function(i3) {
      this.accommodate(2);
      this.data.setInt16(this.write, i3);
      this.write += 2;
      return this;
    };
    util$12.DataBuffer.prototype.putInt24 = function(i3) {
      this.accommodate(3);
      this.data.setInt16(this.write, i3 >> 8 & 65535);
      this.data.setInt8(this.write, i3 >> 16 & 255);
      this.write += 3;
      return this;
    };
    util$12.DataBuffer.prototype.putInt32 = function(i3) {
      this.accommodate(4);
      this.data.setInt32(this.write, i3);
      this.write += 4;
      return this;
    };
    util$12.DataBuffer.prototype.putInt16Le = function(i3) {
      this.accommodate(2);
      this.data.setInt16(this.write, i3, true);
      this.write += 2;
      return this;
    };
    util$12.DataBuffer.prototype.putInt24Le = function(i3) {
      this.accommodate(3);
      this.data.setInt8(this.write, i3 >> 16 & 255);
      this.data.setInt16(this.write, i3 >> 8 & 65535, true);
      this.write += 3;
      return this;
    };
    util$12.DataBuffer.prototype.putInt32Le = function(i3) {
      this.accommodate(4);
      this.data.setInt32(this.write, i3, true);
      this.write += 4;
      return this;
    };
    util$12.DataBuffer.prototype.putInt = function(i3, n3) {
      _checkBitsParam(n3);
      this.accommodate(n3 / 8);
      do {
        n3 -= 8;
        this.data.setInt8(this.write++, i3 >> n3 & 255);
      } while (n3 > 0);
      return this;
    };
    util$12.DataBuffer.prototype.putSignedInt = function(i3, n3) {
      _checkBitsParam(n3);
      this.accommodate(n3 / 8);
      if (i3 < 0) {
        i3 += 2 << n3 - 1;
      }
      return this.putInt(i3, n3);
    };
    util$12.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util$12.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util$12.DataBuffer.prototype.getInt24 = function() {
      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      this.read += 3;
      return rval;
    };
    util$12.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util$12.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util$12.DataBuffer.prototype.getInt24Le = function() {
      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
      this.read += 3;
      return rval;
    };
    util$12.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util$12.DataBuffer.prototype.getInt = function(n3) {
      _checkBitsParam(n3);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n3 -= 8;
      } while (n3 > 0);
      return rval;
    };
    util$12.DataBuffer.prototype.getSignedInt = function(n3) {
      var x2 = this.getInt(n3);
      var max = 2 << n3 - 2;
      if (x2 >= max) {
        x2 -= max << 1;
      }
      return x2;
    };
    util$12.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util$12.DataBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util$12.DataBuffer.prototype.at = function(i3) {
      return this.data.getUint8(this.read + i3);
    };
    util$12.DataBuffer.prototype.setAt = function(i3, b2) {
      this.data.setUint8(i3, b2);
      return this;
    };
    util$12.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util$12.DataBuffer.prototype.copy = function() {
      return new util$12.DataBuffer(this);
    };
    util$12.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src2 = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src2.byteLength);
        dst.set(src2);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util$12.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util$12.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util$12.DataBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i3 = this.read; i3 < this.data.byteLength; ++i3) {
        var b2 = this.data.getUint8(i3);
        if (b2 < 16) {
          rval += "0";
        }
        rval += b2.toString(16);
      }
      return rval;
    };
    util$12.DataBuffer.prototype.toString = function(encoding2) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding2 = encoding2 || "utf8";
      if (encoding2 === "binary" || encoding2 === "raw") {
        return util$12.binary.raw.encode(view);
      }
      if (encoding2 === "hex") {
        return util$12.binary.hex.encode(view);
      }
      if (encoding2 === "base64") {
        return util$12.binary.base64.encode(view);
      }
      if (encoding2 === "utf8") {
        return util$12.text.utf8.decode(view);
      }
      if (encoding2 === "utf16") {
        return util$12.text.utf16.decode(view);
      }
      throw new Error("Invalid encoding: " + encoding2);
    };
    util$12.createBuffer = function(input, encoding2) {
      encoding2 = encoding2 || "raw";
      if (input !== void 0 && encoding2 === "utf8") {
        input = util$12.encodeUtf8(input);
      }
      return new util$12.ByteBuffer(input);
    };
    util$12.fillString = function(c2, n3) {
      var s3 = "";
      while (n3 > 0) {
        if (n3 & 1) {
          s3 += c2;
        }
        n3 >>>= 1;
        if (n3 > 0) {
          c2 += c2;
        }
      }
      return s3;
    };
    util$12.xorBytes = function(s1, s22, n3) {
      var s3 = "";
      var b2 = "";
      var t = "";
      var i3 = 0;
      var c2 = 0;
      for (; n3 > 0; --n3, ++i3) {
        b2 = s1.charCodeAt(i3) ^ s22.charCodeAt(i3);
        if (c2 >= 10) {
          s3 += t;
          t = "";
          c2 = 0;
        }
        t += String.fromCharCode(b2);
        ++c2;
      }
      s3 += t;
      return s3;
    };
    util$12.hexToBytes = function(hex) {
      var rval = "";
      var i3 = 0;
      if (hex.length & true) {
        i3 = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
      }
      for (; i3 < hex.length; i3 += 2) {
        rval += String.fromCharCode(parseInt(hex.substr(i3, 2), 16));
      }
      return rval;
    };
    util$12.bytesToHex = function(bytes2) {
      return util$12.createBuffer(bytes2).toHex();
    };
    util$12.int32ToBytes = function(i3) {
      return String.fromCharCode(i3 >> 24 & 255) + String.fromCharCode(i3 >> 16 & 255) + String.fromCharCode(i3 >> 8 & 255) + String.fromCharCode(i3 & 255);
    };
    var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var _base64Idx = [
      62,
      -1,
      -1,
      -1,
      63,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      -1,
      -1,
      -1,
      64,
      -1,
      -1,
      -1,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    util$12.encode64 = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i3 = 0;
      while (i3 < input.length) {
        chr1 = input.charCodeAt(i3++);
        chr2 = input.charCodeAt(i3++);
        chr3 = input.charCodeAt(i3++);
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util$12.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var output = "";
      var enc1, enc2, enc3, enc4;
      var i3 = 0;
      while (i3 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i3++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i3++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i3++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i3++) - 43];
        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
        if (enc3 !== 64) {
          output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
          if (enc4 !== 64) {
            output += String.fromCharCode((enc3 & 3) << 6 | enc4);
          }
        }
      }
      return output;
    };
    util$12.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util$12.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util$12.binary = {
      raw: {},
      hex: {},
      base64: {},
      base58: {},
      baseN: {
        encode: baseN.encode,
        decode: baseN.decode
      }
    };
    util$12.binary.raw.encode = function(bytes2) {
      return String.fromCharCode.apply(null, bytes2);
    };
    util$12.binary.raw.decode = function(str, output, offset2) {
      var out2 = output;
      if (!out2) {
        out2 = new Uint8Array(str.length);
      }
      offset2 = offset2 || 0;
      var j2 = offset2;
      for (var i3 = 0; i3 < str.length; ++i3) {
        out2[j2++] = str.charCodeAt(i3);
      }
      return output ? j2 - offset2 : out2;
    };
    util$12.binary.hex.encode = util$12.bytesToHex;
    util$12.binary.hex.decode = function(hex, output, offset2) {
      var out2 = output;
      if (!out2) {
        out2 = new Uint8Array(Math.ceil(hex.length / 2));
      }
      offset2 = offset2 || 0;
      var i3 = 0, j2 = offset2;
      if (hex.length & 1) {
        i3 = 1;
        out2[j2++] = parseInt(hex[0], 16);
      }
      for (; i3 < hex.length; i3 += 2) {
        out2[j2++] = parseInt(hex.substr(i3, 2), 16);
      }
      return output ? j2 - offset2 : out2;
    };
    util$12.binary.base64.encode = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i3 = 0;
      while (i3 < input.byteLength) {
        chr1 = input[i3++];
        chr2 = input[i3++];
        chr3 = input[i3++];
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util$12.binary.base64.decode = function(input, output, offset2) {
      var out2 = output;
      if (!out2) {
        out2 = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      offset2 = offset2 || 0;
      var enc1, enc2, enc3, enc4;
      var i3 = 0, j2 = offset2;
      while (i3 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i3++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i3++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i3++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i3++) - 43];
        out2[j2++] = enc1 << 2 | enc2 >> 4;
        if (enc3 !== 64) {
          out2[j2++] = (enc2 & 15) << 4 | enc3 >> 2;
          if (enc4 !== 64) {
            out2[j2++] = (enc3 & 3) << 6 | enc4;
          }
        }
      }
      return output ? j2 - offset2 : out2.subarray(0, j2);
    };
    util$12.binary.base58.encode = function(input, maxline) {
      return util$12.binary.baseN.encode(input, _base58, maxline);
    };
    util$12.binary.base58.decode = function(input, maxline) {
      return util$12.binary.baseN.decode(input, _base58, maxline);
    };
    util$12.text = {
      utf8: {},
      utf16: {}
    };
    util$12.text.utf8.encode = function(str, output, offset2) {
      str = util$12.encodeUtf8(str);
      var out2 = output;
      if (!out2) {
        out2 = new Uint8Array(str.length);
      }
      offset2 = offset2 || 0;
      var j2 = offset2;
      for (var i3 = 0; i3 < str.length; ++i3) {
        out2[j2++] = str.charCodeAt(i3);
      }
      return output ? j2 - offset2 : out2;
    };
    util$12.text.utf8.decode = function(bytes2) {
      return util$12.decodeUtf8(String.fromCharCode.apply(null, bytes2));
    };
    util$12.text.utf16.encode = function(str, output, offset2) {
      var out2 = output;
      if (!out2) {
        out2 = new Uint8Array(str.length * 2);
      }
      var view = new Uint16Array(out2.buffer);
      offset2 = offset2 || 0;
      var j2 = offset2;
      var k2 = offset2;
      for (var i3 = 0; i3 < str.length; ++i3) {
        view[k2++] = str.charCodeAt(i3);
        j2 += 2;
      }
      return output ? j2 - offset2 : out2;
    };
    util$12.text.utf16.decode = function(bytes2) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes2.buffer));
    };
    util$12.deflate = function(api2, bytes2, raw) {
      bytes2 = util$12.decode64(api2.deflate(util$12.encode64(bytes2)).rval);
      if (raw) {
        var start2 = 2;
        var flg = bytes2.charCodeAt(1);
        if (flg & 32) {
          start2 = 6;
        }
        bytes2 = bytes2.substring(start2, bytes2.length - 4);
      }
      return bytes2;
    };
    util$12.inflate = function(api2, bytes2, raw) {
      var rval = api2.inflate(util$12.encode64(bytes2)).rval;
      return rval === null ? null : util$12.decode64(rval);
    };
    var _setStorageObject = function(api2, id, obj) {
      if (!api2) {
        throw new Error("WebStorage not available.");
      }
      var rval;
      if (obj === null) {
        rval = api2.removeItem(id);
      } else {
        obj = util$12.encode64(JSON.stringify(obj));
        rval = api2.setItem(id, obj);
      }
      if (typeof rval !== "undefined" && rval.rval !== true) {
        var error2 = new Error(rval.error.message);
        error2.id = rval.error.id;
        error2.name = rval.error.name;
        throw error2;
      }
    };
    var _getStorageObject = function(api2, id) {
      if (!api2) {
        throw new Error("WebStorage not available.");
      }
      var rval = api2.getItem(id);
      if (api2.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error2 = new Error(rval.error.message);
            error2.id = rval.error.id;
            error2.name = rval.error.name;
            throw error2;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util$12.decode64(rval));
      }
      return rval;
    };
    var _setItem = function(api2, id, key2, data2) {
      var obj = _getStorageObject(api2, id);
      if (obj === null) {
        obj = {};
      }
      obj[key2] = data2;
      _setStorageObject(api2, id, obj);
    };
    var _getItem = function(api2, id, key2) {
      var rval = _getStorageObject(api2, id);
      if (rval !== null) {
        rval = key2 in rval ? rval[key2] : null;
      }
      return rval;
    };
    var _removeItem = function(api2, id, key2) {
      var obj = _getStorageObject(api2, id);
      if (obj !== null && key2 in obj) {
        delete obj[key2];
        var empty2 = true;
        for (var prop in obj) {
          empty2 = false;
          break;
        }
        if (empty2) {
          obj = null;
        }
        _setStorageObject(api2, id, obj);
      }
    };
    var _clearItems = function(api2, id) {
      _setStorageObject(api2, id, null);
    };
    var _callStorageFunction = function(func, args, location) {
      var rval = null;
      if (typeof location === "undefined") {
        location = ["web", "flash"];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location) {
        type = location[idx];
        try {
          if (type === "flash" || type === "both") {
            if (args[0] === null) {
              throw new Error("Flash local storage not available.");
            }
            rval = func.apply(this, args);
            done = type === "flash";
          }
          if (type === "web" || type === "both") {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    };
    util$12.setItem = function(api2, id, key2, data2, location) {
      _callStorageFunction(_setItem, arguments, location);
    };
    util$12.getItem = function(api2, id, key2, location) {
      return _callStorageFunction(_getItem, arguments, location);
    };
    util$12.removeItem = function(api2, id, key2, location) {
      _callStorageFunction(_removeItem, arguments, location);
    };
    util$12.clearItems = function(api2, id, location) {
      _callStorageFunction(_clearItems, arguments, location);
    };
    util$12.parseUrl = function(str) {
      var regex = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
      regex.lastIndex = 0;
      var m3 = regex.exec(str);
      var url2 = m3 === null ? null : {
        full: str,
        scheme: m3[1],
        host: m3[2],
        port: m3[3],
        path: m3[4]
      };
      if (url2) {
        url2.fullHost = url2.host;
        if (url2.port) {
          if (url2.port !== 80 && url2.scheme === "http") {
            url2.fullHost += ":" + url2.port;
          } else if (url2.port !== 443 && url2.scheme === "https") {
            url2.fullHost += ":" + url2.port;
          }
        } else if (url2.scheme === "http") {
          url2.port = 80;
        } else if (url2.scheme === "https") {
          url2.port = 443;
        }
        url2.full = url2.scheme + "://" + url2.fullHost;
      }
      return url2;
    };
    var _queryVariables = null;
    util$12.getQueryVariables = function(query2) {
      var parse2 = function(q2) {
        var rval2 = {};
        var kvpairs = q2.split("&");
        for (var i3 = 0; i3 < kvpairs.length; i3++) {
          var pos = kvpairs[i3].indexOf("=");
          var key2;
          var val;
          if (pos > 0) {
            key2 = kvpairs[i3].substring(0, pos);
            val = kvpairs[i3].substring(pos + 1);
          } else {
            key2 = kvpairs[i3];
            val = null;
          }
          if (!(key2 in rval2)) {
            rval2[key2] = [];
          }
          if (!(key2 in Object.prototype) && val !== null) {
            rval2[key2].push(unescape(val));
          }
        }
        return rval2;
      };
      var rval;
      if (typeof query2 === "undefined") {
        if (_queryVariables === null) {
          if (typeof window !== "undefined" && window.location && window.location.search) {
            _queryVariables = parse2(window.location.search.substring(1));
          } else {
            _queryVariables = {};
          }
        }
        rval = _queryVariables;
      } else {
        rval = parse2(query2);
      }
      return rval;
    };
    util$12.parseFragment = function(fragment) {
      var fp = fragment;
      var fq = "";
      var pos = fragment.indexOf("?");
      if (pos > 0) {
        fp = fragment.substring(0, pos);
        fq = fragment.substring(pos + 1);
      }
      var path2 = fp.split("/");
      if (path2.length > 0 && path2[0] === "") {
        path2.shift();
      }
      var query2 = fq === "" ? {} : util$12.getQueryVariables(fq);
      return {
        pathString: fp,
        queryString: fq,
        path: path2,
        query: query2
      };
    };
    util$12.makeRequest = function(reqString) {
      var frag = util$12.parseFragment(reqString);
      var req2 = {
        path: frag.pathString,
        query: frag.queryString,
        getPath: function(i3) {
          return typeof i3 === "undefined" ? frag.path : frag.path[i3];
        },
        getQuery: function(k2, i3) {
          var rval;
          if (typeof k2 === "undefined") {
            rval = frag.query;
          } else {
            rval = frag.query[k2];
            if (rval && typeof i3 !== "undefined") {
              rval = rval[i3];
            }
          }
          return rval;
        },
        getQueryLast: function(k2, _default) {
          var rval;
          var vals = req2.getQuery(k2);
          if (vals) {
            rval = vals[vals.length - 1];
          } else {
            rval = _default;
          }
          return rval;
        }
      };
      return req2;
    };
    util$12.makeLink = function(path2, query2, fragment) {
      path2 = jQuery.isArray(path2) ? path2.join("/") : path2;
      var qstr = jQuery.param(query2 || {});
      fragment = fragment || "";
      return path2 + (qstr.length > 0 ? "?" + qstr : "") + (fragment.length > 0 ? "#" + fragment : "");
    };
    util$12.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util$12.format = function(format2) {
      var re2 = /%./g;
      var match2;
      var part;
      var argi = 0;
      var parts = [];
      var last = 0;
      while (match2 = re2.exec(format2)) {
        part = format2.substring(last, re2.lastIndex - 2);
        if (part.length > 0) {
          parts.push(part);
        }
        last = re2.lastIndex;
        var code = match2[0][1];
        switch (code) {
          case "s":
          case "o":
            if (argi < arguments.length) {
              parts.push(arguments[argi++ + 1]);
            } else {
              parts.push("<?>");
            }
            break;
          case "%":
            parts.push("%");
            break;
          default:
            parts.push("<%" + code + "?>");
        }
      }
      parts.push(format2.substring(last));
      return parts.join("");
    };
    util$12.formatNumber = function(number, decimals, dec_point, thousands_sep) {
      var n3 = number, c2 = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d3 = dec_point === void 0 ? "," : dec_point;
      var t = thousands_sep === void 0 ? "." : thousands_sep, s3 = n3 < 0 ? "-" : "";
      var i3 = parseInt(n3 = Math.abs(+n3 || 0).toFixed(c2), 10) + "";
      var j2 = i3.length > 3 ? i3.length % 3 : 0;
      return s3 + (j2 ? i3.substr(0, j2) + t : "") + i3.substr(j2).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c2 ? d3 + Math.abs(n3 - i3).toFixed(c2).slice(2) : "");
    };
    util$12.formatSize = function(size) {
      if (size >= 1073741824) {
        size = util$12.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
      } else if (size >= 1048576) {
        size = util$12.formatNumber(size / 1048576, 2, ".", "") + " MiB";
      } else if (size >= 1024) {
        size = util$12.formatNumber(size / 1024, 0) + " KiB";
      } else {
        size = util$12.formatNumber(size, 0) + " bytes";
      }
      return size;
    };
    util$12.bytesFromIP = function(ip) {
      if (ip.indexOf(".") !== -1) {
        return util$12.bytesFromIPv4(ip);
      }
      if (ip.indexOf(":") !== -1) {
        return util$12.bytesFromIPv6(ip);
      }
      return null;
    };
    util$12.bytesFromIPv4 = function(ip) {
      ip = ip.split(".");
      if (ip.length !== 4) {
        return null;
      }
      var b2 = util$12.createBuffer();
      for (var i3 = 0; i3 < ip.length; ++i3) {
        var num = parseInt(ip[i3], 10);
        if (isNaN(num)) {
          return null;
        }
        b2.putByte(num);
      }
      return b2.getBytes();
    };
    util$12.bytesFromIPv6 = function(ip) {
      var blanks = 0;
      ip = ip.split(":").filter(function(e2) {
        if (e2.length === 0)
          ++blanks;
        return true;
      });
      var zeros2 = (8 - ip.length + blanks) * 2;
      var b2 = util$12.createBuffer();
      for (var i3 = 0; i3 < 8; ++i3) {
        if (!ip[i3] || ip[i3].length === 0) {
          b2.fillWithByte(0, zeros2);
          zeros2 = 0;
          continue;
        }
        var bytes2 = util$12.hexToBytes(ip[i3]);
        if (bytes2.length < 2) {
          b2.putByte(0);
        }
        b2.putBytes(bytes2);
      }
      return b2.getBytes();
    };
    util$12.bytesToIP = function(bytes2) {
      if (bytes2.length === 4) {
        return util$12.bytesToIPv4(bytes2);
      }
      if (bytes2.length === 16) {
        return util$12.bytesToIPv6(bytes2);
      }
      return null;
    };
    util$12.bytesToIPv4 = function(bytes2) {
      if (bytes2.length !== 4) {
        return null;
      }
      var ip = [];
      for (var i3 = 0; i3 < bytes2.length; ++i3) {
        ip.push(bytes2.charCodeAt(i3));
      }
      return ip.join(".");
    };
    util$12.bytesToIPv6 = function(bytes2) {
      if (bytes2.length !== 16) {
        return null;
      }
      var ip = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i3 = 0; i3 < bytes2.length; i3 += 2) {
        var hex = util$12.bytesToHex(bytes2[i3] + bytes2[i3 + 1]);
        while (hex[0] === "0" && hex !== "0") {
          hex = hex.substr(1);
        }
        if (hex === "0") {
          var last = zeroGroups[zeroGroups.length - 1];
          var idx = ip.length;
          if (!last || idx !== last.end + 1) {
            zeroGroups.push({ start: idx, end: idx });
          } else {
            last.end = idx;
            if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip.push(hex);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip.splice(group.start, group.end - group.start + 1, "");
          if (group.start === 0) {
            ip.unshift("");
          }
          if (group.end === 7) {
            ip.push("");
          }
        }
      }
      return ip.join(":");
    };
    util$12.estimateCores = function(options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      if ("cores" in util$12 && !options2.update) {
        return callback(null, util$12.cores);
      }
      if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
        util$12.cores = navigator.hardwareConcurrency;
        return callback(null, util$12.cores);
      }
      if (typeof Worker === "undefined") {
        util$12.cores = 1;
        return callback(null, util$12.cores);
      }
      if (typeof Blob === "undefined") {
        util$12.cores = 2;
        return callback(null, util$12.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob([
        "(",
        function() {
          self.addEventListener("message", function(e2) {
            var st2 = Date.now();
            var et2 = st2 + 4;
            self.postMessage({ st: st2, et: et2 });
          });
        }.toString(),
        ")()"
      ], { type: "application/javascript" }));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg2, x2) {
            return avg2 + x2;
          }, 0) / max.length);
          util$12.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util$12.cores);
        }
        map2(numWorkers, function(err, results) {
          max.push(reduce2(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      function map2(numWorkers, callback2) {
        var workers = [];
        var results = [];
        for (var i3 = 0; i3 < numWorkers; ++i3) {
          var worker = new Worker(blobUrl);
          worker.addEventListener("message", function(e2) {
            results.push(e2.data);
            if (results.length === numWorkers) {
              for (var i4 = 0; i4 < numWorkers; ++i4) {
                workers[i4].terminate();
              }
              callback2(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i3 = 0; i3 < numWorkers; ++i3) {
          workers[i3].postMessage(i3);
        }
      }
      function reduce2(numWorkers, results) {
        var overlaps = [];
        for (var n3 = 0; n3 < numWorkers; ++n3) {
          var r1 = results[n3];
          var overlap = overlaps[n3] = [];
          for (var i3 = 0; i3 < numWorkers; ++i3) {
            if (n3 === i3) {
              continue;
            }
            var r2 = results[i3];
            if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
              overlap.push(i3);
            }
          }
        }
        return overlaps.reduce(function(max, overlap2) {
          return Math.max(max, overlap2.length);
        }, 0);
      }
    };
    var forge$D = forge$F;
    forge$D.cipher = forge$D.cipher || {};
    forge$D.cipher.algorithms = forge$D.cipher.algorithms || {};
    forge$D.cipher.createCipher = function(algorithm, key2) {
      var api2 = algorithm;
      if (typeof api2 === "string") {
        api2 = forge$D.cipher.getAlgorithm(api2);
        if (api2) {
          api2 = api2();
        }
      }
      if (!api2) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge$D.cipher.BlockCipher({
        algorithm: api2,
        key: key2,
        decrypt: false
      });
    };
    forge$D.cipher.createDecipher = function(algorithm, key2) {
      var api2 = algorithm;
      if (typeof api2 === "string") {
        api2 = forge$D.cipher.getAlgorithm(api2);
        if (api2) {
          api2 = api2();
        }
      }
      if (!api2) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge$D.cipher.BlockCipher({
        algorithm: api2,
        key: key2,
        decrypt: true
      });
    };
    forge$D.cipher.registerAlgorithm = function(name, algorithm) {
      name = name.toUpperCase();
      forge$D.cipher.algorithms[name] = algorithm;
    };
    forge$D.cipher.getAlgorithm = function(name) {
      name = name.toUpperCase();
      if (name in forge$D.cipher.algorithms) {
        return forge$D.cipher.algorithms[name];
      }
      return null;
    };
    var BlockCipher = forge$D.cipher.BlockCipher = function(options2) {
      this.algorithm = options2.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options2.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options2.decrypt;
      this.algorithm.initialize(options2);
    };
    BlockCipher.prototype.start = function(options2) {
      options2 = options2 || {};
      var opts = {};
      for (var key2 in options2) {
        opts[key2] = options2[key2];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge$D.util.createBuffer();
      this.output = options2.output || forge$D.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
      }
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad2) {
      if (pad2 && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
        this.mode.pad = function(input) {
          return pad2(this.blockSize, input, false);
        };
        this.mode.unpad = function(output) {
          return pad2(this.blockSize, output, true);
        };
      }
      var options2 = {};
      options2.decrypt = this._decrypt;
      options2.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options2)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options2)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options2)) {
          return false;
        }
      }
      return true;
    };
    var forge$C = forge$F;
    forge$C.cipher = forge$C.cipher || {};
    var modes = forge$C.cipher.modes = forge$C.cipher.modes || {};
    modes.ecb = function(options2) {
      options2 = options2 || {};
      this.name = "ECB";
      this.cipher = options2.cipher;
      this.blockSize = options2.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options2) {
    };
    modes.ecb.prototype.encrypt = function(input, output, finish3) {
      if (input.length() < this.blockSize && !(finish3 && input.length() > 0)) {
        return true;
      }
      for (var i3 = 0; i3 < this._ints; ++i3) {
        this._inBlock[i3] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i3 = 0; i3 < this._ints; ++i3) {
        output.putInt32(this._outBlock[i3]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output, finish3) {
      if (input.length() < this.blockSize && !(finish3 && input.length() > 0)) {
        return true;
      }
      for (var i3 = 0; i3 < this._ints; ++i3) {
        this._inBlock[i3] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i3 = 0; i3 < this._ints; ++i3) {
        output.putInt32(this._outBlock[i3]);
      }
    };
    modes.ecb.prototype.pad = function(input, options2) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.ecb.prototype.unpad = function(output, options2) {
      if (options2.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cbc = function(options2) {
      options2 = options2 || {};
      this.name = "CBC";
      this.cipher = options2.cipher;
      this.blockSize = options2.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options2) {
      if (options2.iv === null) {
        if (!this._prev) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = this._prev.slice(0);
      } else if (!("iv" in options2)) {
        throw new Error("Invalid IV parameter.");
      } else {
        this._iv = transformIV(options2.iv, this.blockSize);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output, finish3) {
      if (input.length() < this.blockSize && !(finish3 && input.length() > 0)) {
        return true;
      }
      for (var i3 = 0; i3 < this._ints; ++i3) {
        this._inBlock[i3] = this._prev[i3] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i3 = 0; i3 < this._ints; ++i3) {
        output.putInt32(this._outBlock[i3]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output, finish3) {
      if (input.length() < this.blockSize && !(finish3 && input.length() > 0)) {
        return true;
      }
      for (var i3 = 0; i3 < this._ints; ++i3) {
        this._inBlock[i3] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i3 = 0; i3 < this._ints; ++i3) {
        output.putInt32(this._prev[i3] ^ this._outBlock[i3]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options2) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.cbc.prototype.unpad = function(output, options2) {
      if (options2.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cfb = function(options2) {
      options2 = options2 || {};
      this.name = "CFB";
      this.cipher = options2.cipher;
      this.blockSize = options2.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge$C.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options2) {
      if (!("iv" in options2)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options2.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output, finish3) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i3 = 0; i3 < this._ints; ++i3) {
          this._inBlock[i3] = input.getInt32() ^ this._outBlock[i3];
          output.putInt32(this._inBlock[i3]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i3 = 0; i3 < this._ints; ++i3) {
        this._partialBlock[i3] = input.getInt32() ^ this._outBlock[i3];
        this._partialOutput.putInt32(this._partialBlock[i3]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i3 = 0; i3 < this._ints; ++i3) {
          this._inBlock[i3] = this._partialBlock[i3];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish3) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output, finish3) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i3 = 0; i3 < this._ints; ++i3) {
          this._inBlock[i3] = input.getInt32();
          output.putInt32(this._inBlock[i3] ^ this._outBlock[i3]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i3 = 0; i3 < this._ints; ++i3) {
        this._partialBlock[i3] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i3] ^ this._outBlock[i3]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i3 = 0; i3 < this._ints; ++i3) {
          this._inBlock[i3] = this._partialBlock[i3];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish3) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    };
    modes.ofb = function(options2) {
      options2 = options2 || {};
      this.name = "OFB";
      this.cipher = options2.cipher;
      this.blockSize = options2.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge$C.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options2) {
      if (!("iv" in options2)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options2.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output, finish3) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i3 = 0; i3 < this._ints; ++i3) {
          output.putInt32(input.getInt32() ^ this._outBlock[i3]);
          this._inBlock[i3] = this._outBlock[i3];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i3 = 0; i3 < this._ints; ++i3) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i3]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i3 = 0; i3 < this._ints; ++i3) {
          this._inBlock[i3] = this._outBlock[i3];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish3) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options2) {
      options2 = options2 || {};
      this.name = "CTR";
      this.cipher = options2.cipher;
      this.blockSize = options2.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge$C.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options2) {
      if (!("iv" in options2)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options2.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output, finish3) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i3 = 0; i3 < this._ints; ++i3) {
          output.putInt32(input.getInt32() ^ this._outBlock[i3]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i3 = 0; i3 < this._ints; ++i3) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i3]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish3) {
          output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options2) {
      options2 = options2 || {};
      this.name = "GCM";
      this.cipher = options2.cipher;
      this.blockSize = options2.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge$C.util.createBuffer();
      this._partialBytes = 0;
      this._R = 3774873600;
    };
    modes.gcm.prototype.start = function(options2) {
      if (!("iv" in options2)) {
        throw new Error("Invalid IV parameter.");
      }
      var iv = forge$C.util.createBuffer(options2.iv);
      this._cipherLength = 0;
      var additionalData;
      if ("additionalData" in options2) {
        additionalData = forge$C.util.createBuffer(options2.additionalData);
      } else {
        additionalData = forge$C.util.createBuffer();
      }
      if ("tagLength" in options2) {
        this._tagLength = options2.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options2.decrypt) {
        this._tag = forge$C.util.createBuffer(options2.tag).getBytes();
        if (this._tag.length !== this._tagLength / 8) {
          throw new Error("Authentication tag does not match tag length.");
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv.length();
      if (ivLength === 12) {
        this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv.length() > 0) {
          this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
        }
        this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge$C.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32()
        ]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output, finish3) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i3 = 0; i3 < this._ints; ++i3) {
          output.putInt32(this._outBlock[i3] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i3 = 0; i3 < this._ints; ++i3) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i3]);
        }
        if (partialBytes <= 0 || finish3) {
          if (finish3) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i3 = 0; i3 < this._ints; ++i3) {
            this._outBlock[i3] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish3) {
          input.read -= this.blockSize;
          output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output, finish3) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish3 && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i3 = 0; i3 < this._ints; ++i3) {
        output.putInt32(this._outBlock[i3] ^ this._hashBlock[i3]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output, options2) {
      var rval = true;
      if (options2.decrypt && options2.overflow) {
        output.truncate(this.blockSize - options2.overflow);
      }
      this.tag = forge$C.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag = [];
      this.cipher.encrypt(this._j0, tag);
      for (var i3 = 0; i3 < this._ints; ++i3) {
        this.tag.putInt32(this._s[i3] ^ tag[i3]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options2.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x2, y3) {
      var z_i = [0, 0, 0, 0];
      var v_i = y3.slice(0);
      for (var i3 = 0; i3 < 128; ++i3) {
        var x_i = x2[i3 / 32 | 0] & 1 << 31 - i3 % 32;
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x2, out2) {
      var lsb = x2[3] & 1;
      for (var i3 = 3; i3 > 0; --i3) {
        out2[i3] = x2[i3] >>> 1 | (x2[i3 - 1] & 1) << 31;
      }
      out2[0] = x2[0] >>> 1;
      if (lsb) {
        out2[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x2) {
      var z2 = [0, 0, 0, 0];
      for (var i3 = 0; i3 < 32; ++i3) {
        var idx = i3 / 8 | 0;
        var x_i = x2[idx] >>> (7 - i3 % 8) * 4 & 15;
        var ah2 = this._m[i3][x_i];
        z2[0] ^= ah2[0];
        z2[1] ^= ah2[1];
        z2[2] ^= ah2[2];
        z2[3] ^= ah2[3];
      }
      return z2;
    };
    modes.gcm.prototype.ghash = function(h3, y3, x2) {
      y3[0] ^= x2[0];
      y3[1] ^= x2[1];
      y3[2] ^= x2[2];
      y3[3] ^= x2[3];
      return this.tableMultiply(y3);
    };
    modes.gcm.prototype.generateHashTable = function(h3, bits) {
      var multiplier = 8 / bits;
      var perInt = 4 * multiplier;
      var size = 16 * multiplier;
      var m3 = new Array(size);
      for (var i3 = 0; i3 < size; ++i3) {
        var tmp = [0, 0, 0, 0];
        var idx = i3 / perInt | 0;
        var shft = (perInt - 1 - i3 % perInt) * bits;
        tmp[idx] = 1 << bits - 1 << shft;
        m3[i3] = this.generateSubHashTable(this.multiply(tmp, h3), bits);
      }
      return m3;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
      var size = 1 << bits;
      var half = size >>> 1;
      var m3 = new Array(size);
      m3[half] = mid.slice(0);
      var i3 = half >>> 1;
      while (i3 > 0) {
        this.pow(m3[2 * i3], m3[i3] = []);
        i3 >>= 1;
      }
      i3 = 2;
      while (i3 < half) {
        for (var j2 = 1; j2 < i3; ++j2) {
          var m_i = m3[i3];
          var m_j = m3[j2];
          m3[i3 + j2] = [
            m_i[0] ^ m_j[0],
            m_i[1] ^ m_j[1],
            m_i[2] ^ m_j[2],
            m_i[3] ^ m_j[3]
          ];
        }
        i3 *= 2;
      }
      m3[0] = [0, 0, 0, 0];
      for (i3 = half + 1; i3 < size; ++i3) {
        var c2 = m3[i3 ^ half];
        m3[i3] = [mid[0] ^ c2[0], mid[1] ^ c2[1], mid[2] ^ c2[2], mid[3] ^ c2[3]];
      }
      return m3;
    };
    function transformIV(iv, blockSize) {
      if (typeof iv === "string") {
        iv = forge$C.util.createBuffer(iv);
      }
      if (forge$C.util.isArray(iv) && iv.length > 4) {
        var tmp = iv;
        iv = forge$C.util.createBuffer();
        for (var i3 = 0; i3 < tmp.length; ++i3) {
          iv.putByte(tmp[i3]);
        }
      }
      if (iv.length() < blockSize) {
        throw new Error("Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes.");
      }
      if (!forge$C.util.isArray(iv)) {
        var ints = [];
        var blocks = blockSize / 4;
        for (var i3 = 0; i3 < blocks; ++i3) {
          ints.push(iv.getInt32());
        }
        iv = ints;
      }
      return iv;
    }
    function inc32(block) {
      block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
    }
    function from64To32(num) {
      return [num / 4294967296 | 0, num & 4294967295];
    }
    var forge$B = forge$F;
    forge$B.aes = forge$B.aes || {};
    forge$B.aes.startEncrypting = function(key2, iv, output, mode2) {
      var cipher = _createCipher$1({
        key: key2,
        output,
        decrypt: false,
        mode: mode2
      });
      cipher.start(iv);
      return cipher;
    };
    forge$B.aes.createEncryptionCipher = function(key2, mode2) {
      return _createCipher$1({
        key: key2,
        output: null,
        decrypt: false,
        mode: mode2
      });
    };
    forge$B.aes.startDecrypting = function(key2, iv, output, mode2) {
      var cipher = _createCipher$1({
        key: key2,
        output,
        decrypt: true,
        mode: mode2
      });
      cipher.start(iv);
      return cipher;
    };
    forge$B.aes.createDecryptionCipher = function(key2, mode2) {
      return _createCipher$1({
        key: key2,
        output: null,
        decrypt: true,
        mode: mode2
      });
    };
    forge$B.aes.Algorithm = function(name, mode2) {
      if (!init2) {
        initialize();
      }
      var self2 = this;
      self2.name = name;
      self2.mode = new mode2({
        blockSize: 16,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock$1(self2._w, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock$1(self2._w, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge$B.aes.Algorithm.prototype.initialize = function(options2) {
      if (this._init) {
        return;
      }
      var key2 = options2.key;
      var tmp;
      if (typeof key2 === "string" && (key2.length === 16 || key2.length === 24 || key2.length === 32)) {
        key2 = forge$B.util.createBuffer(key2);
      } else if (forge$B.util.isArray(key2) && (key2.length === 16 || key2.length === 24 || key2.length === 32)) {
        tmp = key2;
        key2 = forge$B.util.createBuffer();
        for (var i3 = 0; i3 < tmp.length; ++i3) {
          key2.putByte(tmp[i3]);
        }
      }
      if (!forge$B.util.isArray(key2)) {
        tmp = key2;
        key2 = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i3 = 0; i3 < len; ++i3) {
            key2.push(tmp.getInt32());
          }
        }
      }
      if (!forge$B.util.isArray(key2) || !(key2.length === 4 || key2.length === 6 || key2.length === 8)) {
        throw new Error("Invalid key parameter.");
      }
      var mode2 = this.mode.name;
      var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode2) !== -1;
      this._w = _expandKey(key2, options2.decrypt && !encryptOp);
      this._init = true;
    };
    forge$B.aes._expandKey = function(key2, decrypt) {
      if (!init2) {
        initialize();
      }
      return _expandKey(key2, decrypt);
    };
    forge$B.aes._updateBlock = _updateBlock$1;
    registerAlgorithm$1("AES-ECB", forge$B.cipher.modes.ecb);
    registerAlgorithm$1("AES-CBC", forge$B.cipher.modes.cbc);
    registerAlgorithm$1("AES-CFB", forge$B.cipher.modes.cfb);
    registerAlgorithm$1("AES-OFB", forge$B.cipher.modes.ofb);
    registerAlgorithm$1("AES-CTR", forge$B.cipher.modes.ctr);
    registerAlgorithm$1("AES-GCM", forge$B.cipher.modes.gcm);
    function registerAlgorithm$1(name, mode2) {
      var factory2 = function() {
        return new forge$B.aes.Algorithm(name, mode2);
      };
      forge$B.cipher.registerAlgorithm(name, factory2);
    }
    var init2 = false;
    var Nb = 4;
    var sbox;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize() {
      init2 = true;
      rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var xtime = new Array(256);
      for (var i3 = 0; i3 < 128; ++i3) {
        xtime[i3] = i3 << 1;
        xtime[i3 + 128] = i3 + 128 << 1 ^ 283;
      }
      sbox = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i3 = 0; i3 < 4; ++i3) {
        mix[i3] = new Array(256);
        imix[i3] = new Array(256);
      }
      var e2 = 0, ei2 = 0, e22, e4, e8, sx, sx2, me2, ime;
      for (var i3 = 0; i3 < 256; ++i3) {
        sx = ei2 ^ ei2 << 1 ^ ei2 << 2 ^ ei2 << 3 ^ ei2 << 4;
        sx = sx >> 8 ^ sx & 255 ^ 99;
        sbox[e2] = sx;
        isbox[sx] = e2;
        sx2 = xtime[sx];
        e22 = xtime[e2];
        e4 = xtime[e22];
        e8 = xtime[e4];
        me2 = sx2 << 24 ^ sx << 16 ^ sx << 8 ^ (sx ^ sx2);
        ime = (e22 ^ e4 ^ e8) << 24 ^ (e2 ^ e8) << 16 ^ (e2 ^ e4 ^ e8) << 8 ^ (e2 ^ e22 ^ e8);
        for (var n3 = 0; n3 < 4; ++n3) {
          mix[n3][e2] = me2;
          imix[n3][sx] = ime;
          me2 = me2 << 24 | me2 >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e2 === 0) {
          e2 = ei2 = 1;
        } else {
          e2 = e22 ^ xtime[xtime[xtime[e22 ^ e8]]];
          ei2 ^= xtime[xtime[ei2]];
        }
      }
    }
    function _expandKey(key2, decrypt) {
      var w3 = key2.slice(0);
      var temp, iNk = 1;
      var Nk = w3.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb * Nr1;
      for (var i3 = Nk; i3 < end; ++i3) {
        temp = w3[i3 - 1];
        if (i3 % Nk === 0) {
          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
          iNk++;
        } else if (Nk > 6 && i3 % Nk === 4) {
          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
        }
        w3[i3] = w3[i3 - Nk] ^ temp;
      }
      if (decrypt) {
        var tmp;
        var m0 = imix[0];
        var m1 = imix[1];
        var m22 = imix[2];
        var m3 = imix[3];
        var wnew = w3.slice(0);
        end = w3.length;
        for (var i3 = 0, wi2 = end - Nb; i3 < end; i3 += Nb, wi2 -= Nb) {
          if (i3 === 0 || i3 === end - Nb) {
            wnew[i3] = w3[wi2];
            wnew[i3 + 1] = w3[wi2 + 3];
            wnew[i3 + 2] = w3[wi2 + 2];
            wnew[i3 + 3] = w3[wi2 + 1];
          } else {
            for (var n3 = 0; n3 < Nb; ++n3) {
              tmp = w3[wi2 + n3];
              wnew[i3 + (3 & -n3)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m22[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
            }
          }
        }
        w3 = wnew;
      }
      return w3;
    }
    function _updateBlock$1(w3, input, output, decrypt) {
      var Nr2 = w3.length / 4 - 1;
      var m0, m1, m22, m3, sub;
      if (decrypt) {
        m0 = imix[0];
        m1 = imix[1];
        m22 = imix[2];
        m3 = imix[3];
        sub = isbox;
      } else {
        m0 = mix[0];
        m1 = mix[1];
        m22 = mix[2];
        m3 = mix[3];
        sub = sbox;
      }
      var a2, b2, c2, d3, a22, b22, c22;
      a2 = input[0] ^ w3[0];
      b2 = input[decrypt ? 3 : 1] ^ w3[1];
      c2 = input[2] ^ w3[2];
      d3 = input[decrypt ? 1 : 3] ^ w3[3];
      var i3 = 3;
      for (var round = 1; round < Nr2; ++round) {
        a22 = m0[a2 >>> 24] ^ m1[b2 >>> 16 & 255] ^ m22[c2 >>> 8 & 255] ^ m3[d3 & 255] ^ w3[++i3];
        b22 = m0[b2 >>> 24] ^ m1[c2 >>> 16 & 255] ^ m22[d3 >>> 8 & 255] ^ m3[a2 & 255] ^ w3[++i3];
        c22 = m0[c2 >>> 24] ^ m1[d3 >>> 16 & 255] ^ m22[a2 >>> 8 & 255] ^ m3[b2 & 255] ^ w3[++i3];
        d3 = m0[d3 >>> 24] ^ m1[a2 >>> 16 & 255] ^ m22[b2 >>> 8 & 255] ^ m3[c2 & 255] ^ w3[++i3];
        a2 = a22;
        b2 = b22;
        c2 = c22;
      }
      output[0] = sub[a2 >>> 24] << 24 ^ sub[b2 >>> 16 & 255] << 16 ^ sub[c2 >>> 8 & 255] << 8 ^ sub[d3 & 255] ^ w3[++i3];
      output[decrypt ? 3 : 1] = sub[b2 >>> 24] << 24 ^ sub[c2 >>> 16 & 255] << 16 ^ sub[d3 >>> 8 & 255] << 8 ^ sub[a2 & 255] ^ w3[++i3];
      output[2] = sub[c2 >>> 24] << 24 ^ sub[d3 >>> 16 & 255] << 16 ^ sub[a2 >>> 8 & 255] << 8 ^ sub[b2 & 255] ^ w3[++i3];
      output[decrypt ? 1 : 3] = sub[d3 >>> 24] << 24 ^ sub[a2 >>> 16 & 255] << 16 ^ sub[b2 >>> 8 & 255] << 8 ^ sub[c2 & 255] ^ w3[++i3];
    }
    function _createCipher$1(options2) {
      options2 = options2 || {};
      var mode2 = (options2.mode || "CBC").toUpperCase();
      var algorithm = "AES-" + mode2;
      var cipher;
      if (options2.decrypt) {
        cipher = forge$B.cipher.createDecipher(algorithm, options2.key);
      } else {
        cipher = forge$B.cipher.createCipher(algorithm, options2.key);
      }
      var start2 = cipher.start;
      cipher.start = function(iv, options3) {
        var output = null;
        if (options3 instanceof forge$B.util.ByteBuffer) {
          output = options3;
          options3 = {};
        }
        options3 = options3 || {};
        options3.output = output;
        options3.iv = iv;
        start2.call(cipher, options3);
      };
      return cipher;
    }
    var forge$A = forge$F;
    forge$A.pki = forge$A.pki || {};
    var oids$2 = forge$A.pki.oids = forge$A.oids = forge$A.oids || {};
    function _IN(id, name) {
      oids$2[id] = name;
      oids$2[name] = id;
    }
    function _I_(id, name) {
      oids$2[id] = name;
    }
    _IN("1.2.840.113549.1.1.1", "rsaEncryption");
    _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
    _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
    _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
    _IN("1.2.840.113549.1.1.8", "mgf1");
    _IN("1.2.840.113549.1.1.9", "pSpecified");
    _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
    _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
    _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
    _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
    _IN("1.3.101.112", "EdDSA25519");
    _IN("1.2.840.10040.4.3", "dsa-with-sha1");
    _IN("1.3.14.3.2.7", "desCBC");
    _IN("1.3.14.3.2.26", "sha1");
    _IN("2.16.840.1.101.3.4.2.1", "sha256");
    _IN("2.16.840.1.101.3.4.2.2", "sha384");
    _IN("2.16.840.1.101.3.4.2.3", "sha512");
    _IN("1.2.840.113549.2.5", "md5");
    _IN("1.2.840.113549.1.7.1", "data");
    _IN("1.2.840.113549.1.7.2", "signedData");
    _IN("1.2.840.113549.1.7.3", "envelopedData");
    _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
    _IN("1.2.840.113549.1.7.5", "digestedData");
    _IN("1.2.840.113549.1.7.6", "encryptedData");
    _IN("1.2.840.113549.1.9.1", "emailAddress");
    _IN("1.2.840.113549.1.9.2", "unstructuredName");
    _IN("1.2.840.113549.1.9.3", "contentType");
    _IN("1.2.840.113549.1.9.4", "messageDigest");
    _IN("1.2.840.113549.1.9.5", "signingTime");
    _IN("1.2.840.113549.1.9.6", "counterSignature");
    _IN("1.2.840.113549.1.9.7", "challengePassword");
    _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
    _IN("1.2.840.113549.1.9.14", "extensionRequest");
    _IN("1.2.840.113549.1.9.20", "friendlyName");
    _IN("1.2.840.113549.1.9.21", "localKeyId");
    _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
    _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
    _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
    _IN("1.2.840.113549.1.12.10.1.3", "certBag");
    _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
    _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
    _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
    _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
    _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
    _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
    _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
    _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
    _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
    _IN("1.2.840.113549.2.7", "hmacWithSHA1");
    _IN("1.2.840.113549.2.8", "hmacWithSHA224");
    _IN("1.2.840.113549.2.9", "hmacWithSHA256");
    _IN("1.2.840.113549.2.10", "hmacWithSHA384");
    _IN("1.2.840.113549.2.11", "hmacWithSHA512");
    _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
    _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
    _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
    _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
    _IN("2.5.4.3", "commonName");
    _IN("2.5.4.5", "serialName");
    _IN("2.5.4.6", "countryName");
    _IN("2.5.4.7", "localityName");
    _IN("2.5.4.8", "stateOrProvinceName");
    _IN("2.5.4.9", "streetAddress");
    _IN("2.5.4.10", "organizationName");
    _IN("2.5.4.11", "organizationalUnitName");
    _IN("2.5.4.13", "description");
    _IN("2.5.4.15", "businessCategory");
    _IN("2.5.4.17", "postalCode");
    _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
    _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
    _IN("2.16.840.1.113730.1.1", "nsCertType");
    _IN("2.16.840.1.113730.1.13", "nsComment");
    _I_("2.5.29.1", "authorityKeyIdentifier");
    _I_("2.5.29.2", "keyAttributes");
    _I_("2.5.29.3", "certificatePolicies");
    _I_("2.5.29.4", "keyUsageRestriction");
    _I_("2.5.29.5", "policyMapping");
    _I_("2.5.29.6", "subtreesConstraint");
    _I_("2.5.29.7", "subjectAltName");
    _I_("2.5.29.8", "issuerAltName");
    _I_("2.5.29.9", "subjectDirectoryAttributes");
    _I_("2.5.29.10", "basicConstraints");
    _I_("2.5.29.11", "nameConstraints");
    _I_("2.5.29.12", "policyConstraints");
    _I_("2.5.29.13", "basicConstraints");
    _IN("2.5.29.14", "subjectKeyIdentifier");
    _IN("2.5.29.15", "keyUsage");
    _I_("2.5.29.16", "privateKeyUsagePeriod");
    _IN("2.5.29.17", "subjectAltName");
    _IN("2.5.29.18", "issuerAltName");
    _IN("2.5.29.19", "basicConstraints");
    _I_("2.5.29.20", "cRLNumber");
    _I_("2.5.29.21", "cRLReason");
    _I_("2.5.29.22", "expirationDate");
    _I_("2.5.29.23", "instructionCode");
    _I_("2.5.29.24", "invalidityDate");
    _I_("2.5.29.25", "cRLDistributionPoints");
    _I_("2.5.29.26", "issuingDistributionPoint");
    _I_("2.5.29.27", "deltaCRLIndicator");
    _I_("2.5.29.28", "issuingDistributionPoint");
    _I_("2.5.29.29", "certificateIssuer");
    _I_("2.5.29.30", "nameConstraints");
    _IN("2.5.29.31", "cRLDistributionPoints");
    _IN("2.5.29.32", "certificatePolicies");
    _I_("2.5.29.33", "policyMappings");
    _I_("2.5.29.34", "policyConstraints");
    _IN("2.5.29.35", "authorityKeyIdentifier");
    _I_("2.5.29.36", "policyConstraints");
    _IN("2.5.29.37", "extKeyUsage");
    _I_("2.5.29.46", "freshestCRL");
    _I_("2.5.29.54", "inhibitAnyPolicy");
    _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
    _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
    _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
    _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
    _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
    _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
    _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
    var forge$z = forge$F;
    var asn1$8 = forge$z.asn1 = forge$z.asn1 || {};
    asn1$8.Class = {
      UNIVERSAL: 0,
      APPLICATION: 64,
      CONTEXT_SPECIFIC: 128,
      PRIVATE: 192
    };
    asn1$8.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn1$8.create = function(tagClass, type, constructed, value, options2) {
      if (forge$z.util.isArray(value)) {
        var tmp = [];
        for (var i3 = 0; i3 < value.length; ++i3) {
          if (value[i3] !== void 0) {
            tmp.push(value[i3]);
          }
        }
        value = tmp;
      }
      var obj = {
        tagClass,
        type,
        constructed,
        composed: constructed || forge$z.util.isArray(value),
        value
      };
      if (options2 && "bitStringContents" in options2) {
        obj.bitStringContents = options2.bitStringContents;
        obj.original = asn1$8.copy(obj);
      }
      return obj;
    };
    asn1$8.copy = function(obj, options2) {
      var copy;
      if (forge$z.util.isArray(obj)) {
        copy = [];
        for (var i3 = 0; i3 < obj.length; ++i3) {
          copy.push(asn1$8.copy(obj[i3], options2));
        }
        return copy;
      }
      if (typeof obj === "string") {
        return obj;
      }
      copy = {
        tagClass: obj.tagClass,
        type: obj.type,
        constructed: obj.constructed,
        composed: obj.composed,
        value: asn1$8.copy(obj.value, options2)
      };
      if (options2 && !options2.excludeBitStringContents) {
        copy.bitStringContents = obj.bitStringContents;
      }
      return copy;
    };
    asn1$8.equals = function(obj1, obj2, options2) {
      if (forge$z.util.isArray(obj1)) {
        if (!forge$z.util.isArray(obj2)) {
          return false;
        }
        if (obj1.length !== obj2.length) {
          return false;
        }
        for (var i3 = 0; i3 < obj1.length; ++i3) {
          if (!asn1$8.equals(obj1[i3], obj2[i3])) {
            return false;
          }
        }
        return true;
      }
      if (typeof obj1 !== typeof obj2) {
        return false;
      }
      if (typeof obj1 === "string") {
        return obj1 === obj2;
      }
      var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1$8.equals(obj1.value, obj2.value);
      if (options2 && options2.includeBitStringContents) {
        equal = equal && obj1.bitStringContents === obj2.bitStringContents;
      }
      return equal;
    };
    asn1$8.getBerValueLength = function(b2) {
      var b22 = b2.getByte();
      if (b22 === 128) {
        return void 0;
      }
      var length;
      var longForm = b22 & 128;
      if (!longForm) {
        length = b22;
      } else {
        length = b2.getInt((b22 & 127) << 3);
      }
      return length;
    };
    function _checkBufferLength(bytes2, remaining, n3) {
      if (n3 > remaining) {
        var error2 = new Error("Too few bytes to parse DER.");
        error2.available = bytes2.length();
        error2.remaining = remaining;
        error2.requested = n3;
        throw error2;
      }
    }
    var _getValueLength = function(bytes2, remaining) {
      var b2 = bytes2.getByte();
      remaining--;
      if (b2 === 128) {
        return void 0;
      }
      var length;
      var longForm = b2 & 128;
      if (!longForm) {
        length = b2;
      } else {
        var longFormBytes = b2 & 127;
        _checkBufferLength(bytes2, remaining, longFormBytes);
        length = bytes2.getInt(longFormBytes << 3);
      }
      if (length < 0) {
        throw new Error("Negative length: " + length);
      }
      return length;
    };
    asn1$8.fromDer = function(bytes2, options2) {
      if (options2 === void 0) {
        options2 = {
          strict: true,
          decodeBitStrings: true
        };
      }
      if (typeof options2 === "boolean") {
        options2 = {
          strict: options2,
          decodeBitStrings: true
        };
      }
      if (!("strict" in options2)) {
        options2.strict = true;
      }
      if (!("decodeBitStrings" in options2)) {
        options2.decodeBitStrings = true;
      }
      if (typeof bytes2 === "string") {
        bytes2 = forge$z.util.createBuffer(bytes2);
      }
      return _fromDer(bytes2, bytes2.length(), 0, options2);
    };
    function _fromDer(bytes2, remaining, depth2, options2) {
      var start2;
      _checkBufferLength(bytes2, remaining, 2);
      var b1 = bytes2.getByte();
      remaining--;
      var tagClass = b1 & 192;
      var type = b1 & 31;
      start2 = bytes2.length();
      var length = _getValueLength(bytes2, remaining);
      remaining -= start2 - bytes2.length();
      if (length !== void 0 && length > remaining) {
        if (options2.strict) {
          var error2 = new Error("Too few bytes to read ASN.1 value.");
          error2.available = bytes2.length();
          error2.remaining = remaining;
          error2.requested = length;
          throw error2;
        }
        length = remaining;
      }
      var value;
      var bitStringContents;
      var constructed = (b1 & 32) === 32;
      if (constructed) {
        value = [];
        if (length === void 0) {
          for (; ; ) {
            _checkBufferLength(bytes2, remaining, 2);
            if (bytes2.bytes(2) === String.fromCharCode(0, 0)) {
              bytes2.getBytes(2);
              remaining -= 2;
              break;
            }
            start2 = bytes2.length();
            value.push(_fromDer(bytes2, remaining, depth2 + 1, options2));
            remaining -= start2 - bytes2.length();
          }
        } else {
          while (length > 0) {
            start2 = bytes2.length();
            value.push(_fromDer(bytes2, length, depth2 + 1, options2));
            remaining -= start2 - bytes2.length();
            length -= start2 - bytes2.length();
          }
        }
      }
      if (value === void 0 && tagClass === asn1$8.Class.UNIVERSAL && type === asn1$8.Type.BITSTRING) {
        bitStringContents = bytes2.bytes(length);
      }
      if (value === void 0 && options2.decodeBitStrings && tagClass === asn1$8.Class.UNIVERSAL && type === asn1$8.Type.BITSTRING && length > 1) {
        var savedRead = bytes2.read;
        var savedRemaining = remaining;
        var unused = 0;
        if (type === asn1$8.Type.BITSTRING) {
          _checkBufferLength(bytes2, remaining, 1);
          unused = bytes2.getByte();
          remaining--;
        }
        if (unused === 0) {
          try {
            start2 = bytes2.length();
            var subOptions = {
              verbose: options2.verbose,
              strict: true,
              decodeBitStrings: true
            };
            var composed = _fromDer(bytes2, remaining, depth2 + 1, subOptions);
            var used = start2 - bytes2.length();
            remaining -= used;
            if (type == asn1$8.Type.BITSTRING) {
              used++;
            }
            var tc = composed.tagClass;
            if (used === length && (tc === asn1$8.Class.UNIVERSAL || tc === asn1$8.Class.CONTEXT_SPECIFIC)) {
              value = [composed];
            }
          } catch (ex) {
          }
        }
        if (value === void 0) {
          bytes2.read = savedRead;
          remaining = savedRemaining;
        }
      }
      if (value === void 0) {
        if (length === void 0) {
          if (options2.strict) {
            throw new Error("Non-constructed ASN.1 object of indefinite length.");
          }
          length = remaining;
        }
        if (type === asn1$8.Type.BMPSTRING) {
          value = "";
          for (; length > 0; length -= 2) {
            _checkBufferLength(bytes2, remaining, 2);
            value += String.fromCharCode(bytes2.getInt16());
            remaining -= 2;
          }
        } else {
          value = bytes2.getBytes(length);
        }
      }
      var asn1Options = bitStringContents === void 0 ? null : {
        bitStringContents
      };
      return asn1$8.create(tagClass, type, constructed, value, asn1Options);
    }
    asn1$8.toDer = function(obj) {
      var bytes2 = forge$z.util.createBuffer();
      var b1 = obj.tagClass | obj.type;
      var value = forge$z.util.createBuffer();
      var useBitStringContents = false;
      if ("bitStringContents" in obj) {
        useBitStringContents = true;
        if (obj.original) {
          useBitStringContents = asn1$8.equals(obj, obj.original);
        }
      }
      if (useBitStringContents) {
        value.putBytes(obj.bitStringContents);
      } else if (obj.composed) {
        if (obj.constructed) {
          b1 |= 32;
        } else {
          value.putByte(0);
        }
        for (var i3 = 0; i3 < obj.value.length; ++i3) {
          if (obj.value[i3] !== void 0) {
            value.putBuffer(asn1$8.toDer(obj.value[i3]));
          }
        }
      } else {
        if (obj.type === asn1$8.Type.BMPSTRING) {
          for (var i3 = 0; i3 < obj.value.length; ++i3) {
            value.putInt16(obj.value.charCodeAt(i3));
          }
        } else {
          if (obj.type === asn1$8.Type.INTEGER && obj.value.length > 1 && (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
            value.putBytes(obj.value.substr(1));
          } else {
            value.putBytes(obj.value);
          }
        }
      }
      bytes2.putByte(b1);
      if (value.length() <= 127) {
        bytes2.putByte(value.length() & 127);
      } else {
        var len = value.length();
        var lenBytes = "";
        do {
          lenBytes += String.fromCharCode(len & 255);
          len = len >>> 8;
        } while (len > 0);
        bytes2.putByte(lenBytes.length | 128);
        for (var i3 = lenBytes.length - 1; i3 >= 0; --i3) {
          bytes2.putByte(lenBytes.charCodeAt(i3));
        }
      }
      bytes2.putBuffer(value);
      return bytes2;
    };
    asn1$8.oidToDer = function(oid) {
      var values = oid.split(".");
      var bytes2 = forge$z.util.createBuffer();
      bytes2.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
      var last, valueBytes, value, b2;
      for (var i3 = 2; i3 < values.length; ++i3) {
        last = true;
        valueBytes = [];
        value = parseInt(values[i3], 10);
        do {
          b2 = value & 127;
          value = value >>> 7;
          if (!last) {
            b2 |= 128;
          }
          valueBytes.push(b2);
          last = false;
        } while (value > 0);
        for (var n3 = valueBytes.length - 1; n3 >= 0; --n3) {
          bytes2.putByte(valueBytes[n3]);
        }
      }
      return bytes2;
    };
    asn1$8.derToOid = function(bytes2) {
      var oid;
      if (typeof bytes2 === "string") {
        bytes2 = forge$z.util.createBuffer(bytes2);
      }
      var b2 = bytes2.getByte();
      oid = Math.floor(b2 / 40) + "." + b2 % 40;
      var value = 0;
      while (bytes2.length() > 0) {
        b2 = bytes2.getByte();
        value = value << 7;
        if (b2 & 128) {
          value += b2 & 127;
        } else {
          oid += "." + (value + b2);
          value = 0;
        }
      }
      return oid;
    };
    asn1$8.utcTimeToDate = function(utc) {
      var date = new Date();
      var year = parseInt(utc.substr(0, 2), 10);
      year = year >= 50 ? 1900 + year : 2e3 + year;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh2 = parseInt(utc.substr(6, 2), 10);
      var mm = parseInt(utc.substr(8, 2), 10);
      var ss2 = 0;
      if (utc.length > 11) {
        var c2 = utc.charAt(10);
        var end = 10;
        if (c2 !== "+" && c2 !== "-") {
          ss2 = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year, MM, DD);
      date.setUTCHours(hh2, mm, ss2, 0);
      if (end) {
        c2 = utc.charAt(end);
        if (c2 === "+" || c2 === "-") {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset2 = hhoffset * 60 + mmoffset;
          offset2 *= 6e4;
          if (c2 === "+") {
            date.setTime(+date - offset2);
          } else {
            date.setTime(+date + offset2);
          }
        }
      }
      return date;
    };
    asn1$8.generalizedTimeToDate = function(gentime) {
      var date = new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh2 = parseInt(gentime.substr(8, 2), 10);
      var mm = parseInt(gentime.substr(10, 2), 10);
      var ss2 = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset2 = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === "Z") {
        isUTC = true;
      }
      var end = gentime.length - 5, c2 = gentime.charAt(end);
      if (c2 === "+" || c2 === "-") {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset2 = hhoffset * 60 + mmoffset;
        offset2 *= 6e4;
        if (c2 === "+") {
          offset2 *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === ".") {
        fff = parseFloat(gentime.substr(14), 10) * 1e3;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh2, mm, ss2, fff);
        date.setTime(+date + offset2);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh2, mm, ss2, fff);
      }
      return date;
    };
    asn1$8.dateToUtcTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format2 = [];
      format2.push(("" + date.getUTCFullYear()).substr(2));
      format2.push("" + (date.getUTCMonth() + 1));
      format2.push("" + date.getUTCDate());
      format2.push("" + date.getUTCHours());
      format2.push("" + date.getUTCMinutes());
      format2.push("" + date.getUTCSeconds());
      for (var i3 = 0; i3 < format2.length; ++i3) {
        if (format2[i3].length < 2) {
          rval += "0";
        }
        rval += format2[i3];
      }
      rval += "Z";
      return rval;
    };
    asn1$8.dateToGeneralizedTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format2 = [];
      format2.push("" + date.getUTCFullYear());
      format2.push("" + (date.getUTCMonth() + 1));
      format2.push("" + date.getUTCDate());
      format2.push("" + date.getUTCHours());
      format2.push("" + date.getUTCMinutes());
      format2.push("" + date.getUTCSeconds());
      for (var i3 = 0; i3 < format2.length; ++i3) {
        if (format2[i3].length < 2) {
          rval += "0";
        }
        rval += format2[i3];
      }
      rval += "Z";
      return rval;
    };
    asn1$8.integerToDer = function(x2) {
      var rval = forge$z.util.createBuffer();
      if (x2 >= -128 && x2 < 128) {
        return rval.putSignedInt(x2, 8);
      }
      if (x2 >= -32768 && x2 < 32768) {
        return rval.putSignedInt(x2, 16);
      }
      if (x2 >= -8388608 && x2 < 8388608) {
        return rval.putSignedInt(x2, 24);
      }
      if (x2 >= -2147483648 && x2 < 2147483648) {
        return rval.putSignedInt(x2, 32);
      }
      var error2 = new Error("Integer too large; max is 32-bits.");
      error2.integer = x2;
      throw error2;
    };
    asn1$8.derToInteger = function(bytes2) {
      if (typeof bytes2 === "string") {
        bytes2 = forge$z.util.createBuffer(bytes2);
      }
      var n3 = bytes2.length() * 8;
      if (n3 > 32) {
        throw new Error("Integer too large; max is 32-bits.");
      }
      return bytes2.getSignedInt(n3);
    };
    asn1$8.validate = function(obj, v2, capture, errors) {
      var rval = false;
      if ((obj.tagClass === v2.tagClass || typeof v2.tagClass === "undefined") && (obj.type === v2.type || typeof v2.type === "undefined")) {
        if (obj.constructed === v2.constructed || typeof v2.constructed === "undefined") {
          rval = true;
          if (v2.value && forge$z.util.isArray(v2.value)) {
            var j2 = 0;
            for (var i3 = 0; rval && i3 < v2.value.length; ++i3) {
              rval = v2.value[i3].optional || false;
              if (obj.value[j2]) {
                rval = asn1$8.validate(obj.value[j2], v2.value[i3], capture, errors);
                if (rval) {
                  ++j2;
                } else if (v2.value[i3].optional) {
                  rval = true;
                }
              }
              if (!rval && errors) {
                errors.push("[" + v2.name + '] Tag class "' + v2.tagClass + '", type "' + v2.type + '" expected value length "' + v2.value.length + '", got "' + obj.value.length + '"');
              }
            }
          }
          if (rval && capture) {
            if (v2.capture) {
              capture[v2.capture] = obj.value;
            }
            if (v2.captureAsn1) {
              capture[v2.captureAsn1] = obj;
            }
            if (v2.captureBitStringContents && "bitStringContents" in obj) {
              capture[v2.captureBitStringContents] = obj.bitStringContents;
            }
            if (v2.captureBitStringValue && "bitStringContents" in obj) {
              if (obj.bitStringContents.length < 2) {
                capture[v2.captureBitStringValue] = "";
              } else {
                var unused = obj.bitStringContents.charCodeAt(0);
                if (unused !== 0) {
                  throw new Error("captureBitStringValue only supported for zero unused bits");
                }
                capture[v2.captureBitStringValue] = obj.bitStringContents.slice(1);
              }
            }
          }
        } else if (errors) {
          errors.push("[" + v2.name + '] Expected constructed "' + v2.constructed + '", got "' + obj.constructed + '"');
        }
      } else if (errors) {
        if (obj.tagClass !== v2.tagClass) {
          errors.push("[" + v2.name + '] Expected tag class "' + v2.tagClass + '", got "' + obj.tagClass + '"');
        }
        if (obj.type !== v2.type) {
          errors.push("[" + v2.name + '] Expected type "' + v2.type + '", got "' + obj.type + '"');
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn1$8.prettyPrint = function(obj, level2, indentation) {
      var rval = "";
      level2 = level2 || 0;
      indentation = indentation || 2;
      if (level2 > 0) {
        rval += "\n";
      }
      var indent = "";
      for (var i3 = 0; i3 < level2 * indentation; ++i3) {
        indent += " ";
      }
      rval += indent + "Tag: ";
      switch (obj.tagClass) {
        case asn1$8.Class.UNIVERSAL:
          rval += "Universal:";
          break;
        case asn1$8.Class.APPLICATION:
          rval += "Application:";
          break;
        case asn1$8.Class.CONTEXT_SPECIFIC:
          rval += "Context-Specific:";
          break;
        case asn1$8.Class.PRIVATE:
          rval += "Private:";
          break;
      }
      if (obj.tagClass === asn1$8.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn1$8.Type.NONE:
            rval += " (None)";
            break;
          case asn1$8.Type.BOOLEAN:
            rval += " (Boolean)";
            break;
          case asn1$8.Type.INTEGER:
            rval += " (Integer)";
            break;
          case asn1$8.Type.BITSTRING:
            rval += " (Bit string)";
            break;
          case asn1$8.Type.OCTETSTRING:
            rval += " (Octet string)";
            break;
          case asn1$8.Type.NULL:
            rval += " (Null)";
            break;
          case asn1$8.Type.OID:
            rval += " (Object Identifier)";
            break;
          case asn1$8.Type.ODESC:
            rval += " (Object Descriptor)";
            break;
          case asn1$8.Type.EXTERNAL:
            rval += " (External or Instance of)";
            break;
          case asn1$8.Type.REAL:
            rval += " (Real)";
            break;
          case asn1$8.Type.ENUMERATED:
            rval += " (Enumerated)";
            break;
          case asn1$8.Type.EMBEDDED:
            rval += " (Embedded PDV)";
            break;
          case asn1$8.Type.UTF8:
            rval += " (UTF8)";
            break;
          case asn1$8.Type.ROID:
            rval += " (Relative Object Identifier)";
            break;
          case asn1$8.Type.SEQUENCE:
            rval += " (Sequence)";
            break;
          case asn1$8.Type.SET:
            rval += " (Set)";
            break;
          case asn1$8.Type.PRINTABLESTRING:
            rval += " (Printable String)";
            break;
          case asn1$8.Type.IA5String:
            rval += " (IA5String (ASCII))";
            break;
          case asn1$8.Type.UTCTIME:
            rval += " (UTC time)";
            break;
          case asn1$8.Type.GENERALIZEDTIME:
            rval += " (Generalized time)";
            break;
          case asn1$8.Type.BMPSTRING:
            rval += " (BMP String)";
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += "\n";
      rval += indent + "Constructed: " + obj.constructed + "\n";
      if (obj.composed) {
        var subvalues = 0;
        var sub = "";
        for (var i3 = 0; i3 < obj.value.length; ++i3) {
          if (obj.value[i3] !== void 0) {
            subvalues += 1;
            sub += asn1$8.prettyPrint(obj.value[i3], level2 + 1, indentation);
            if (i3 + 1 < obj.value.length) {
              sub += ",";
            }
          }
        }
        rval += indent + "Sub values: " + subvalues + sub;
      } else {
        rval += indent + "Value: ";
        if (obj.type === asn1$8.Type.OID) {
          var oid = asn1$8.derToOid(obj.value);
          rval += oid;
          if (forge$z.pki && forge$z.pki.oids) {
            if (oid in forge$z.pki.oids) {
              rval += " (" + forge$z.pki.oids[oid] + ") ";
            }
          }
        }
        if (obj.type === asn1$8.Type.INTEGER) {
          try {
            rval += asn1$8.derToInteger(obj.value);
          } catch (ex) {
            rval += "0x" + forge$z.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn1$8.Type.BITSTRING) {
          if (obj.value.length > 1) {
            rval += "0x" + forge$z.util.bytesToHex(obj.value.slice(1));
          } else {
            rval += "(none)";
          }
          if (obj.value.length > 0) {
            var unused = obj.value.charCodeAt(0);
            if (unused == 1) {
              rval += " (1 unused bit shown)";
            } else if (unused > 1) {
              rval += " (" + unused + " unused bits shown)";
            }
          }
        } else if (obj.type === asn1$8.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += "(" + obj.value + ") ";
          }
          rval += "0x" + forge$z.util.bytesToHex(obj.value);
        } else if (obj.type === asn1$8.Type.UTF8) {
          rval += forge$z.util.decodeUtf8(obj.value);
        } else if (obj.type === asn1$8.Type.PRINTABLESTRING || obj.type === asn1$8.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += "0x" + forge$z.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += "[null]";
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
    var forge$y = forge$F;
    forge$y.md = forge$y.md || {};
    forge$y.md.algorithms = forge$y.md.algorithms || {};
    var forge$x = forge$F;
    var hmac = forge$x.hmac = forge$x.hmac || {};
    hmac.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md, key2) {
        if (md !== null) {
          if (typeof md === "string") {
            md = md.toLowerCase();
            if (md in forge$x.md.algorithms) {
              _md = forge$x.md.algorithms[md].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md + '"');
            }
          } else {
            _md = md;
          }
        }
        if (key2 === null) {
          key2 = _key;
        } else {
          if (typeof key2 === "string") {
            key2 = forge$x.util.createBuffer(key2);
          } else if (forge$x.util.isArray(key2)) {
            var tmp = key2;
            key2 = forge$x.util.createBuffer();
            for (var i3 = 0; i3 < tmp.length; ++i3) {
              key2.putByte(tmp[i3]);
            }
          }
          var keylen = key2.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key2.bytes());
            key2 = _md.digest();
          }
          _ipadding = forge$x.util.createBuffer();
          _opadding = forge$x.util.createBuffer();
          keylen = key2.length();
          for (var i3 = 0; i3 < keylen; ++i3) {
            var tmp = key2.at(i3);
            _ipadding.putByte(54 ^ tmp);
            _opadding.putByte(92 ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i3 = 0; i3 < tmp; ++i3) {
              _ipadding.putByte(54);
              _opadding.putByte(92);
            }
          }
          _key = key2;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes2) {
        _md.update(bytes2);
      };
      ctx.getMac = function() {
        var inner = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
    var forge$w = forge$F;
    var md5 = forge$w.md5 = forge$w.md5 || {};
    forge$w.md.md5 = forge$w.md.algorithms.md5 = md5;
    md5.create = function() {
      if (!_initialized$3) {
        _init$3();
      }
      var _state = null;
      var _input = forge$w.util.createBuffer();
      var _w = new Array(16);
      var md = {
        algorithm: "md5",
        blockLength: 64,
        digestLength: 16,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i3 = 0; i3 < int32s; ++i3) {
          md.fullMessageLength.push(0);
        }
        _input = forge$w.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding2) {
        if (encoding2 === "utf8") {
          msg = forge$w.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i3 = md.fullMessageLength.length - 1; i3 >= 0; --i3) {
          md.fullMessageLength[i3] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i3] / 4294967296 >>> 0);
          md.fullMessageLength[i3] = md.fullMessageLength[i3] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update$3(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge$w.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding$3.substr(0, md.blockLength - overflow));
        var bits, carry = 0;
        for (var i3 = md.fullMessageLength.length - 1; i3 >= 0; --i3) {
          bits = md.fullMessageLength[i3] * 8 + carry;
          carry = bits / 4294967296 >>> 0;
          finalBlock.putInt32Le(bits >>> 0);
        }
        var s22 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3
        };
        _update$3(s22, _w, finalBlock);
        var rval = forge$w.util.createBuffer();
        rval.putInt32Le(s22.h0);
        rval.putInt32Le(s22.h1);
        rval.putInt32Le(s22.h2);
        rval.putInt32Le(s22.h3);
        return rval;
      };
      return md;
    };
    var _padding$3 = null;
    var _g = null;
    var _r2 = null;
    var _k$2 = null;
    var _initialized$3 = false;
    function _init$3() {
      _padding$3 = String.fromCharCode(128);
      _padding$3 += forge$w.util.fillString(String.fromCharCode(0), 64);
      _g = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        1,
        6,
        11,
        0,
        5,
        10,
        15,
        4,
        9,
        14,
        3,
        8,
        13,
        2,
        7,
        12,
        5,
        8,
        11,
        14,
        1,
        4,
        7,
        10,
        13,
        0,
        3,
        6,
        9,
        12,
        15,
        2,
        0,
        7,
        14,
        5,
        12,
        3,
        10,
        1,
        8,
        15,
        6,
        13,
        4,
        11,
        2,
        9
      ];
      _r2 = [
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21
      ];
      _k$2 = new Array(64);
      for (var i3 = 0; i3 < 64; ++i3) {
        _k$2[i3] = Math.floor(Math.abs(Math.sin(i3 + 1)) * 4294967296);
      }
      _initialized$3 = true;
    }
    function _update$3(s3, w3, bytes2) {
      var t, a2, b2, c2, d3, f3, r2, i3;
      var len = bytes2.length();
      while (len >= 64) {
        a2 = s3.h0;
        b2 = s3.h1;
        c2 = s3.h2;
        d3 = s3.h3;
        for (i3 = 0; i3 < 16; ++i3) {
          w3[i3] = bytes2.getInt32Le();
          f3 = d3 ^ b2 & (c2 ^ d3);
          t = a2 + f3 + _k$2[i3] + w3[i3];
          r2 = _r2[i3];
          a2 = d3;
          d3 = c2;
          c2 = b2;
          b2 += t << r2 | t >>> 32 - r2;
        }
        for (; i3 < 32; ++i3) {
          f3 = c2 ^ d3 & (b2 ^ c2);
          t = a2 + f3 + _k$2[i3] + w3[_g[i3]];
          r2 = _r2[i3];
          a2 = d3;
          d3 = c2;
          c2 = b2;
          b2 += t << r2 | t >>> 32 - r2;
        }
        for (; i3 < 48; ++i3) {
          f3 = b2 ^ c2 ^ d3;
          t = a2 + f3 + _k$2[i3] + w3[_g[i3]];
          r2 = _r2[i3];
          a2 = d3;
          d3 = c2;
          c2 = b2;
          b2 += t << r2 | t >>> 32 - r2;
        }
        for (; i3 < 64; ++i3) {
          f3 = c2 ^ (b2 | ~d3);
          t = a2 + f3 + _k$2[i3] + w3[_g[i3]];
          r2 = _r2[i3];
          a2 = d3;
          d3 = c2;
          c2 = b2;
          b2 += t << r2 | t >>> 32 - r2;
        }
        s3.h0 = s3.h0 + a2 | 0;
        s3.h1 = s3.h1 + b2 | 0;
        s3.h2 = s3.h2 + c2 | 0;
        s3.h3 = s3.h3 + d3 | 0;
        len -= 64;
      }
    }
    var forge$v = forge$F;
    var pem = forge$v.pem = forge$v.pem || {};
    pem.encode = function(msg, options2) {
      options2 = options2 || {};
      var rval = "-----BEGIN " + msg.type + "-----\r\n";
      var header;
      if (msg.procType) {
        header = {
          name: "Proc-Type",
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = { name: "Content-Domain", values: [msg.contentDomain] };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i3 = 0; i3 < msg.headers.length; ++i3) {
          rval += foldHeader(msg.headers[i3]);
        }
      }
      if (msg.procType) {
        rval += "\r\n";
      }
      rval += forge$v.util.encode64(msg.body, options2.maxline || 64) + "\r\n";
      rval += "-----END " + msg.type + "-----\r\n";
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match2;
      while (true) {
        match2 = rMessage.exec(str);
        if (!match2) {
          break;
        }
        var msg = {
          type: match2[1],
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge$v.util.decode64(match2[3])
        };
        rval.push(msg);
        if (!match2[2]) {
          continue;
        }
        var lines = match2[2].split(rCRLF);
        var li2 = 0;
        while (match2 && li2 < lines.length) {
          var line = lines[li2].replace(/\s+$/, "");
          for (var nl = li2 + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) {
              break;
            }
            line += next;
            li2 = nl;
          }
          match2 = line.match(rHeader);
          if (match2) {
            var header = { name: match2[1], values: [] };
            var values = match2[2].split(",");
            for (var vi2 = 0; vi2 < values.length; ++vi2) {
              header.values.push(ltrim(values[vi2]));
            }
            if (!msg.procType) {
              if (header.name !== "Proc-Type") {
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              }
              msg.procType = { version: values[0], type: values[1] };
            } else if (!msg.contentDomain && header.name === "Content-Domain") {
              msg.contentDomain = values[0] || "";
            } else if (!msg.dekInfo && header.name === "DEK-Info") {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              }
              msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
            } else {
              msg.headers.push(header);
            }
          }
          ++li2;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error("Invalid PEM formatted message.");
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ": ";
      var values = [];
      var insertSpace = function(match2, $1) {
        return " " + $1;
      };
      for (var i3 = 0; i3 < header.values.length; ++i3) {
        values.push(header.values[i3].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values.join(",") + "\r\n";
      var length = 0;
      var candidate = -1;
      for (var i3 = 0; i3 < rval.length; ++i3, ++length) {
        if (length > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ",") {
            ++candidate;
            rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
          }
          length = i3 - candidate - 1;
          candidate = -1;
          ++i3;
        } else if (rval[i3] === " " || rval[i3] === "	" || rval[i3] === ",") {
          candidate = i3;
        }
      }
      return rval;
    }
    function ltrim(str) {
      return str.replace(/^\s+/, "");
    }
    var forge$u = forge$F;
    forge$u.des = forge$u.des || {};
    forge$u.des.startEncrypting = function(key2, iv, output, mode2) {
      var cipher = _createCipher({
        key: key2,
        output,
        decrypt: false,
        mode: mode2 || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge$u.des.createEncryptionCipher = function(key2, mode2) {
      return _createCipher({
        key: key2,
        output: null,
        decrypt: false,
        mode: mode2
      });
    };
    forge$u.des.startDecrypting = function(key2, iv, output, mode2) {
      var cipher = _createCipher({
        key: key2,
        output,
        decrypt: true,
        mode: mode2 || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge$u.des.createDecryptionCipher = function(key2, mode2) {
      return _createCipher({
        key: key2,
        output: null,
        decrypt: true,
        mode: mode2
      });
    };
    forge$u.des.Algorithm = function(name, mode2) {
      var self2 = this;
      self2.name = name;
      self2.mode = new mode2({
        blockSize: 8,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge$u.des.Algorithm.prototype.initialize = function(options2) {
      if (this._init) {
        return;
      }
      var key2 = forge$u.util.createBuffer(options2.key);
      if (this.name.indexOf("3DES") === 0) {
        if (key2.length() !== 24) {
          throw new Error("Invalid Triple-DES key size: " + key2.length() * 8);
        }
      }
      this._keys = _createKeys(key2);
      this._init = true;
    };
    registerAlgorithm("DES-ECB", forge$u.cipher.modes.ecb);
    registerAlgorithm("DES-CBC", forge$u.cipher.modes.cbc);
    registerAlgorithm("DES-CFB", forge$u.cipher.modes.cfb);
    registerAlgorithm("DES-OFB", forge$u.cipher.modes.ofb);
    registerAlgorithm("DES-CTR", forge$u.cipher.modes.ctr);
    registerAlgorithm("3DES-ECB", forge$u.cipher.modes.ecb);
    registerAlgorithm("3DES-CBC", forge$u.cipher.modes.cbc);
    registerAlgorithm("3DES-CFB", forge$u.cipher.modes.cfb);
    registerAlgorithm("3DES-OFB", forge$u.cipher.modes.ofb);
    registerAlgorithm("3DES-CTR", forge$u.cipher.modes.ctr);
    function registerAlgorithm(name, mode2) {
      var factory2 = function() {
        return new forge$u.des.Algorithm(name, mode2);
      };
      forge$u.cipher.registerAlgorithm(name, factory2);
    }
    var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
    var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
    var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
    var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
    var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
    var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
    var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
    var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
    function _createKeys(key2) {
      var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
      var iterations = key2.length() > 8 ? 3 : 1;
      var keys = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n3 = 0, tmp;
      for (var j2 = 0; j2 < iterations; j2++) {
        var left = key2.getInt32();
        var right = key2.getInt32();
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 2 ^ right) & 858993459;
        right ^= tmp;
        left ^= tmp << 2;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = left << 8 | right >>> 20 & 240;
        left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
        right = tmp;
        for (var i3 = 0; i3 < shifts.length; ++i3) {
          if (shifts[i3]) {
            left = left << 2 | left >>> 26;
            right = right << 2 | right >>> 26;
          } else {
            left = left << 1 | left >>> 27;
            right = right << 1 | right >>> 27;
          }
          left &= -15;
          right &= -15;
          var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
          var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
          tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
          keys[n3++] = lefttmp ^ tmp;
          keys[n3++] = righttmp ^ tmp << 16;
        }
      }
      return keys;
    }
    function _updateBlock(keys, input, output, decrypt) {
      var iterations = keys.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
      }
      var tmp;
      var left = input[0];
      var right = input[1];
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      left = left << 1 | left >>> 31;
      right = right << 1 | right >>> 31;
      for (var j2 = 0; j2 < iterations; j2 += 3) {
        var endloop = looping[j2 + 1];
        var loopinc = looping[j2 + 2];
        for (var i3 = looping[j2]; i3 != endloop; i3 += loopinc) {
          var right1 = right ^ keys[i3];
          var right2 = (right >>> 4 | right << 28) ^ keys[i3 + 1];
          tmp = left;
          left = right;
          right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
        }
        tmp = left;
        left = right;
        right = tmp;
      }
      left = left >>> 1 | left << 31;
      right = right >>> 1 | right << 31;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      output[0] = left;
      output[1] = right;
    }
    function _createCipher(options2) {
      options2 = options2 || {};
      var mode2 = (options2.mode || "CBC").toUpperCase();
      var algorithm = "DES-" + mode2;
      var cipher;
      if (options2.decrypt) {
        cipher = forge$u.cipher.createDecipher(algorithm, options2.key);
      } else {
        cipher = forge$u.cipher.createCipher(algorithm, options2.key);
      }
      var start2 = cipher.start;
      cipher.start = function(iv, options3) {
        var output = null;
        if (options3 instanceof forge$u.util.ByteBuffer) {
          output = options3;
          options3 = {};
        }
        options3 = options3 || {};
        options3.output = output;
        options3.iv = iv;
        start2.call(cipher, options3);
      };
      return cipher;
    }
    var forge$t = forge$F;
    var pkcs5 = forge$t.pkcs5 = forge$t.pkcs5 || {};
    var crypto2;
    if (forge$t.util.isNodejs && !forge$t.options.usePureJavaScript) {
      crypto2 = require$$1__default2;
    }
    forge$t.pbkdf2 = pkcs5.pbkdf2 = function(p2, s3, c2, dkLen, md, callback) {
      if (typeof md === "function") {
        callback = md;
        md = null;
      }
      if (forge$t.util.isNodejs && !forge$t.options.usePureJavaScript && crypto2.pbkdf2 && (md === null || typeof md !== "object") && (crypto2.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
        if (typeof md !== "string") {
          md = "sha1";
        }
        p2 = Buffer.from(p2, "binary");
        s3 = Buffer.from(s3, "binary");
        if (!callback) {
          if (crypto2.pbkdf2Sync.length === 4) {
            return crypto2.pbkdf2Sync(p2, s3, c2, dkLen).toString("binary");
          }
          return crypto2.pbkdf2Sync(p2, s3, c2, dkLen, md).toString("binary");
        }
        if (crypto2.pbkdf2Sync.length === 4) {
          return crypto2.pbkdf2(p2, s3, c2, dkLen, function(err2, key2) {
            if (err2) {
              return callback(err2);
            }
            callback(null, key2.toString("binary"));
          });
        }
        return crypto2.pbkdf2(p2, s3, c2, dkLen, md, function(err2, key2) {
          if (err2) {
            return callback(err2);
          }
          callback(null, key2.toString("binary"));
        });
      }
      if (typeof md === "undefined" || md === null) {
        md = "sha1";
      }
      if (typeof md === "string") {
        if (!(md in forge$t.md.algorithms)) {
          throw new Error("Unknown hash algorithm: " + md);
        }
        md = forge$t.md[md].create();
      }
      var hLen = md.digestLength;
      if (dkLen > 4294967295 * hLen) {
        var err = new Error("Derived key is too long.");
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      var len = Math.ceil(dkLen / hLen);
      var r2 = dkLen - (len - 1) * hLen;
      var prf = forge$t.hmac.create();
      prf.start(md, p2);
      var dk = "";
      var xor, u_c, u_c1;
      if (!callback) {
        for (var i3 = 1; i3 <= len; ++i3) {
          prf.start(null, null);
          prf.update(s3);
          prf.update(forge$t.util.int32ToBytes(i3));
          xor = u_c1 = prf.digest().getBytes();
          for (var j2 = 2; j2 <= c2; ++j2) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor = forge$t.util.xorBytes(xor, u_c, hLen);
            u_c1 = u_c;
          }
          dk += i3 < len ? xor : xor.substr(0, r2);
        }
        return dk;
      }
      var i3 = 1, j2;
      function outer() {
        if (i3 > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s3);
        prf.update(forge$t.util.int32ToBytes(i3));
        xor = u_c1 = prf.digest().getBytes();
        j2 = 2;
        inner();
      }
      function inner() {
        if (j2 <= c2) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor = forge$t.util.xorBytes(xor, u_c, hLen);
          u_c1 = u_c;
          ++j2;
          return forge$t.util.setImmediate(inner);
        }
        dk += i3 < len ? xor : xor.substr(0, r2);
        ++i3;
        outer();
      }
      outer();
    };
    var forge$s = forge$F;
    var sha256 = forge$s.sha256 = forge$s.sha256 || {};
    forge$s.md.sha256 = forge$s.md.algorithms.sha256 = sha256;
    sha256.create = function() {
      if (!_initialized$2) {
        _init$2();
      }
      var _state = null;
      var _input = forge$s.util.createBuffer();
      var _w = new Array(64);
      var md = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i3 = 0; i3 < int32s; ++i3) {
          md.fullMessageLength.push(0);
        }
        _input = forge$s.util.createBuffer();
        _state = {
          h0: 1779033703,
          h1: 3144134277,
          h2: 1013904242,
          h3: 2773480762,
          h4: 1359893119,
          h5: 2600822924,
          h6: 528734635,
          h7: 1541459225
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding2) {
        if (encoding2 === "utf8") {
          msg = forge$s.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i3 = md.fullMessageLength.length - 1; i3 >= 0; --i3) {
          md.fullMessageLength[i3] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i3] / 4294967296 >>> 0);
          md.fullMessageLength[i3] = md.fullMessageLength[i3] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update$2(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge$s.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding$2.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i3 = 0; i3 < md.fullMessageLength.length - 1; ++i3) {
          next = md.fullMessageLength[i3 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s22 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update$2(s22, _w, finalBlock);
        var rval = forge$s.util.createBuffer();
        rval.putInt32(s22.h0);
        rval.putInt32(s22.h1);
        rval.putInt32(s22.h2);
        rval.putInt32(s22.h3);
        rval.putInt32(s22.h4);
        rval.putInt32(s22.h5);
        rval.putInt32(s22.h6);
        rval.putInt32(s22.h7);
        return rval;
      };
      return md;
    };
    var _padding$2 = null;
    var _initialized$2 = false;
    var _k$1 = null;
    function _init$2() {
      _padding$2 = String.fromCharCode(128);
      _padding$2 += forge$s.util.fillString(String.fromCharCode(0), 64);
      _k$1 = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      _initialized$2 = true;
    }
    function _update$2(s3, w3, bytes2) {
      var t1, t2, s0, s1, ch2, maj2, i3, a2, b2, c2, d3, e2, f3, g2, h3;
      var len = bytes2.length();
      while (len >= 64) {
        for (i3 = 0; i3 < 16; ++i3) {
          w3[i3] = bytes2.getInt32();
        }
        for (; i3 < 64; ++i3) {
          t1 = w3[i3 - 2];
          t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          t2 = w3[i3 - 15];
          t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
          w3[i3] = t1 + w3[i3 - 7] + t2 + w3[i3 - 16] | 0;
        }
        a2 = s3.h0;
        b2 = s3.h1;
        c2 = s3.h2;
        d3 = s3.h3;
        e2 = s3.h4;
        f3 = s3.h5;
        g2 = s3.h6;
        h3 = s3.h7;
        for (i3 = 0; i3 < 64; ++i3) {
          s1 = (e2 >>> 6 | e2 << 26) ^ (e2 >>> 11 | e2 << 21) ^ (e2 >>> 25 | e2 << 7);
          ch2 = g2 ^ e2 & (f3 ^ g2);
          s0 = (a2 >>> 2 | a2 << 30) ^ (a2 >>> 13 | a2 << 19) ^ (a2 >>> 22 | a2 << 10);
          maj2 = a2 & b2 | c2 & (a2 ^ b2);
          t1 = h3 + s1 + ch2 + _k$1[i3] + w3[i3];
          t2 = s0 + maj2;
          h3 = g2;
          g2 = f3;
          f3 = e2;
          e2 = d3 + t1 >>> 0;
          d3 = c2;
          c2 = b2;
          b2 = a2;
          a2 = t1 + t2 >>> 0;
        }
        s3.h0 = s3.h0 + a2 | 0;
        s3.h1 = s3.h1 + b2 | 0;
        s3.h2 = s3.h2 + c2 | 0;
        s3.h3 = s3.h3 + d3 | 0;
        s3.h4 = s3.h4 + e2 | 0;
        s3.h5 = s3.h5 + f3 | 0;
        s3.h6 = s3.h6 + g2 | 0;
        s3.h7 = s3.h7 + h3 | 0;
        len -= 64;
      }
    }
    var forge$r = forge$F;
    var _crypto$1 = null;
    if (forge$r.util.isNodejs && !forge$r.options.usePureJavaScript && !process.versions["node-webkit"]) {
      _crypto$1 = require$$1__default2;
    }
    var prng = forge$r.prng = forge$r.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin,
        key: null,
        seed: null,
        time: null,
        reseeds: 0,
        generated: 0,
        keyBytes: ""
      };
      var md = plugin.md;
      var pools = new Array(32);
      for (var i3 = 0; i3 < 32; ++i3) {
        pools[i3] = md.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count, callback) {
        if (!callback) {
          return ctx.generateSync(count);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b2 = forge$r.util.createBuffer();
        ctx.key = null;
        generate3();
        function generate3(err) {
          if (err) {
            return callback(err);
          }
          if (b2.length() >= count) {
            return callback(null, b2.getBytes(count));
          }
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge$r.util.nextTick(function() {
              _reseed(generate3);
            });
          }
          var bytes2 = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes2.length;
          b2.putBytes(bytes2);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge$r.util.setImmediate(generate3);
        }
      };
      ctx.generateSync = function(count) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b2 = forge$r.util.createBuffer();
        while (b2.length() < count) {
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes2 = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes2.length;
          b2.putBytes(bytes2);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b2.getBytes(count);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.seedFile(needed, function(err, bytes2) {
          if (err) {
            return callback(err);
          }
          ctx.collect(bytes2);
          _seed();
          callback();
        });
      }
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      function _seed() {
        ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
        var md2 = ctx.plugin.md.create();
        md2.update(ctx.keyBytes);
        var _2powK = 1;
        for (var k2 = 0; k2 < 32; ++k2) {
          if (ctx.reseeds % _2powK === 0) {
            md2.update(ctx.pools[k2].digest().getBytes());
            ctx.pools[k2].start();
          }
          _2powK = _2powK << 1;
        }
        ctx.keyBytes = md2.digest().getBytes();
        md2.start();
        md2.update(ctx.keyBytes);
        var seedBytes = md2.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.generated = 0;
      }
      function defaultSeedFile(needed) {
        var getRandomValues = null;
        var globalScope = forge$r.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto2.getRandomValues(arr);
          };
        }
        var b2 = forge$r.util.createBuffer();
        if (getRandomValues) {
          while (b2.length() < needed) {
            var count = Math.max(1, Math.min(needed - b2.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count));
            try {
              getRandomValues(entropy);
              for (var i4 = 0; i4 < entropy.length; ++i4) {
                b2.putInt32(entropy[i4]);
              }
            } catch (e2) {
              if (!(typeof QuotaExceededError !== "undefined" && e2 instanceof QuotaExceededError)) {
                throw e2;
              }
            }
          }
        }
        if (b2.length() < needed) {
          var hi2, lo2, next;
          var seed = Math.floor(Math.random() * 65536);
          while (b2.length() < needed) {
            lo2 = 16807 * (seed & 65535);
            hi2 = 16807 * (seed >> 16);
            lo2 += (hi2 & 32767) << 16;
            lo2 += hi2 >> 15;
            lo2 = (lo2 & 2147483647) + (lo2 >> 31);
            seed = lo2 & 4294967295;
            for (var i4 = 0; i4 < 3; ++i4) {
              next = seed >>> (i4 << 3);
              next ^= Math.floor(Math.random() * 256);
              b2.putByte(String.fromCharCode(next & 255));
            }
          }
        }
        return b2.getBytes(needed);
      }
      if (_crypto$1) {
        ctx.seedFile = function(needed, callback) {
          _crypto$1.randomBytes(needed, function(err, bytes2) {
            if (err) {
              return callback(err);
            }
            callback(null, bytes2.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto$1.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e2) {
            callback(e2);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes2) {
        var count = bytes2.length;
        for (var i4 = 0; i4 < count; ++i4) {
          ctx.pools[ctx.pool].update(bytes2.substr(i4, 1));
          ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i4, n3) {
        var bytes2 = "";
        for (var x2 = 0; x2 < n3; x2 += 8) {
          bytes2 += String.fromCharCode(i4 >> x2 & 255);
        }
        ctx.collect(bytes2);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener3(e2) {
              var data2 = e2.data;
              if (data2.forge && data2.forge.prng) {
                self.removeEventListener("message", listener3);
                callback(data2.forge.prng.err, data2.forge.prng.bytes);
              }
            }
            self.addEventListener("message", listener3);
            self.postMessage({ forge: { prng: { needed } } });
          };
        } else {
          var listener2 = function(e2) {
            var data2 = e2.data;
            if (data2.forge && data2.forge.prng) {
              ctx.seedFile(data2.forge.prng.needed, function(err, bytes2) {
                worker.postMessage({ forge: { prng: { err, bytes: bytes2 } } });
              });
            }
          };
          worker.addEventListener("message", listener2);
        }
      };
      return ctx;
    };
    var forge$q = forge$F;
    (function() {
      if (forge$q.random && forge$q.random.getBytes) {
        return;
      }
      (function(jQuery2) {
        var prng_aes = {};
        var _prng_aes_output = new Array(4);
        var _prng_aes_buffer = forge$q.util.createBuffer();
        prng_aes.formatKey = function(key3) {
          var tmp = forge$q.util.createBuffer(key3);
          key3 = new Array(4);
          key3[0] = tmp.getInt32();
          key3[1] = tmp.getInt32();
          key3[2] = tmp.getInt32();
          key3[3] = tmp.getInt32();
          return forge$q.aes._expandKey(key3, false);
        };
        prng_aes.formatSeed = function(seed) {
          var tmp = forge$q.util.createBuffer(seed);
          seed = new Array(4);
          seed[0] = tmp.getInt32();
          seed[1] = tmp.getInt32();
          seed[2] = tmp.getInt32();
          seed[3] = tmp.getInt32();
          return seed;
        };
        prng_aes.cipher = function(key3, seed) {
          forge$q.aes._updateBlock(key3, seed, _prng_aes_output, false);
          _prng_aes_buffer.putInt32(_prng_aes_output[0]);
          _prng_aes_buffer.putInt32(_prng_aes_output[1]);
          _prng_aes_buffer.putInt32(_prng_aes_output[2]);
          _prng_aes_buffer.putInt32(_prng_aes_output[3]);
          return _prng_aes_buffer.getBytes();
        };
        prng_aes.increment = function(seed) {
          ++seed[3];
          return seed;
        };
        prng_aes.md = forge$q.md.sha256;
        function spawnPrng() {
          var ctx = forge$q.prng.create(prng_aes);
          ctx.getBytes = function(count, callback) {
            return ctx.generate(count, callback);
          };
          ctx.getBytesSync = function(count) {
            return ctx.generate(count);
          };
          return ctx;
        }
        var _ctx = spawnPrng();
        var getRandomValues = null;
        var globalScope = forge$q.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto2.getRandomValues(arr);
          };
        }
        if (!forge$q.util.isNodejs && !getRandomValues) {
          _ctx.collectInt(+new Date(), 32);
          if (typeof navigator !== "undefined") {
            var _navBytes = "";
            for (var key2 in navigator) {
              try {
                if (typeof navigator[key2] == "string") {
                  _navBytes += navigator[key2];
                }
              } catch (e2) {
              }
            }
            _ctx.collect(_navBytes);
            _navBytes = null;
          }
          if (jQuery2) {
            jQuery2().mousemove(function(e2) {
              _ctx.collectInt(e2.clientX, 16);
              _ctx.collectInt(e2.clientY, 16);
            });
            jQuery2().keypress(function(e2) {
              _ctx.collectInt(e2.charCode, 8);
            });
          }
        }
        if (!forge$q.random) {
          forge$q.random = _ctx;
        } else {
          for (var key2 in _ctx) {
            forge$q.random[key2] = _ctx[key2];
          }
        }
        forge$q.random.createInstance = spawnPrng;
      })(typeof jQuery !== "undefined" ? jQuery : null);
    })();
    var forge$p = forge$F;
    var piTable = [
      217,
      120,
      249,
      196,
      25,
      221,
      181,
      237,
      40,
      233,
      253,
      121,
      74,
      160,
      216,
      157,
      198,
      126,
      55,
      131,
      43,
      118,
      83,
      142,
      98,
      76,
      100,
      136,
      68,
      139,
      251,
      162,
      23,
      154,
      89,
      245,
      135,
      179,
      79,
      19,
      97,
      69,
      109,
      141,
      9,
      129,
      125,
      50,
      189,
      143,
      64,
      235,
      134,
      183,
      123,
      11,
      240,
      149,
      33,
      34,
      92,
      107,
      78,
      130,
      84,
      214,
      101,
      147,
      206,
      96,
      178,
      28,
      115,
      86,
      192,
      20,
      167,
      140,
      241,
      220,
      18,
      117,
      202,
      31,
      59,
      190,
      228,
      209,
      66,
      61,
      212,
      48,
      163,
      60,
      182,
      38,
      111,
      191,
      14,
      218,
      70,
      105,
      7,
      87,
      39,
      242,
      29,
      155,
      188,
      148,
      67,
      3,
      248,
      17,
      199,
      246,
      144,
      239,
      62,
      231,
      6,
      195,
      213,
      47,
      200,
      102,
      30,
      215,
      8,
      232,
      234,
      222,
      128,
      82,
      238,
      247,
      132,
      170,
      114,
      172,
      53,
      77,
      106,
      42,
      150,
      26,
      210,
      113,
      90,
      21,
      73,
      116,
      75,
      159,
      208,
      94,
      4,
      24,
      164,
      236,
      194,
      224,
      65,
      110,
      15,
      81,
      203,
      204,
      36,
      145,
      175,
      80,
      161,
      244,
      112,
      57,
      153,
      124,
      58,
      133,
      35,
      184,
      180,
      122,
      252,
      2,
      54,
      91,
      37,
      85,
      151,
      49,
      45,
      93,
      250,
      152,
      227,
      138,
      146,
      174,
      5,
      223,
      41,
      16,
      103,
      108,
      186,
      201,
      211,
      0,
      230,
      207,
      225,
      158,
      168,
      44,
      99,
      22,
      1,
      63,
      88,
      226,
      137,
      169,
      13,
      56,
      52,
      27,
      171,
      51,
      255,
      176,
      187,
      72,
      12,
      95,
      185,
      177,
      205,
      46,
      197,
      243,
      219,
      71,
      229,
      165,
      156,
      119,
      10,
      166,
      32,
      104,
      254,
      127,
      193,
      173
    ];
    var s2 = [1, 2, 3, 5];
    var rol = function(word, bits) {
      return word << bits & 65535 | (word & 65535) >> 16 - bits;
    };
    var ror = function(word, bits) {
      return (word & 65535) >> bits | word << 16 - bits & 65535;
    };
    forge$p.rc2 = forge$p.rc2 || {};
    forge$p.rc2.expandKey = function(key2, effKeyBits) {
      if (typeof key2 === "string") {
        key2 = forge$p.util.createBuffer(key2);
      }
      effKeyBits = effKeyBits || 128;
      var L3 = key2;
      var T2 = key2.length();
      var T1 = effKeyBits;
      var T8 = Math.ceil(T1 / 8);
      var TM = 255 >> (T1 & 7);
      var i3;
      for (i3 = T2; i3 < 128; i3++) {
        L3.putByte(piTable[L3.at(i3 - 1) + L3.at(i3 - T2) & 255]);
      }
      L3.setAt(128 - T8, piTable[L3.at(128 - T8) & TM]);
      for (i3 = 127 - T8; i3 >= 0; i3--) {
        L3.setAt(i3, piTable[L3.at(i3 + 1) ^ L3.at(i3 + T8)]);
      }
      return L3;
    };
    var createCipher = function(key2, bits, encrypt) {
      var _finish = false, _input = null, _output = null, _iv = null;
      var mixRound, mashRound;
      var i3, j2, K2 = [];
      key2 = forge$p.rc2.expandKey(key2, bits);
      for (i3 = 0; i3 < 64; i3++) {
        K2.push(key2.getInt16Le());
      }
      if (encrypt) {
        mixRound = function(R5) {
          for (i3 = 0; i3 < 4; i3++) {
            R5[i3] += K2[j2] + (R5[(i3 + 3) % 4] & R5[(i3 + 2) % 4]) + (~R5[(i3 + 3) % 4] & R5[(i3 + 1) % 4]);
            R5[i3] = rol(R5[i3], s2[i3]);
            j2++;
          }
        };
        mashRound = function(R5) {
          for (i3 = 0; i3 < 4; i3++) {
            R5[i3] += K2[R5[(i3 + 3) % 4] & 63];
          }
        };
      } else {
        mixRound = function(R5) {
          for (i3 = 3; i3 >= 0; i3--) {
            R5[i3] = ror(R5[i3], s2[i3]);
            R5[i3] -= K2[j2] + (R5[(i3 + 3) % 4] & R5[(i3 + 2) % 4]) + (~R5[(i3 + 3) % 4] & R5[(i3 + 1) % 4]);
            j2--;
          }
        };
        mashRound = function(R5) {
          for (i3 = 3; i3 >= 0; i3--) {
            R5[i3] -= K2[R5[(i3 + 3) % 4] & 63];
          }
        };
      }
      var runPlan = function(plan) {
        var R5 = [];
        for (i3 = 0; i3 < 4; i3++) {
          var val = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt) {
              val ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val);
            }
          }
          R5.push(val & 65535);
        }
        j2 = encrypt ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
            plan[ptr][1](R5);
          }
        }
        for (i3 = 0; i3 < 4; i3++) {
          if (_iv !== null) {
            if (encrypt) {
              _iv.putInt16Le(R5[i3]);
            } else {
              R5[i3] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R5[i3]);
        }
      };
      var cipher = null;
      cipher = {
        start: function(iv, output) {
          if (iv) {
            if (typeof iv === "string") {
              iv = forge$p.util.createBuffer(iv);
            }
          }
          _finish = false;
          _input = forge$p.util.createBuffer();
          _output = output || new forge$p.util.createBuffer();
          _iv = iv;
          cipher.output = _output;
        },
        update: function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([
              [5, mixRound],
              [1, mashRound],
              [6, mixRound],
              [1, mashRound],
              [5, mixRound]
            ]);
          }
        },
        finish: function(pad2) {
          var rval = true;
          if (encrypt) {
            if (pad2) {
              rval = pad2(8, _input, !encrypt);
            } else {
              var padding = _input.length() === 8 ? 8 : 8 - _input.length();
              _input.fillWithByte(padding, padding);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt) {
            rval = _input.length() === 0;
            if (rval) {
              if (pad2) {
                rval = pad2(8, _output, !encrypt);
              } else {
                var len = _output.length();
                var count = _output.at(len - 1);
                if (count > len) {
                  rval = false;
                } else {
                  _output.truncate(count);
                }
              }
            }
          }
          return rval;
        }
      };
      return cipher;
    };
    forge$p.rc2.startEncrypting = function(key2, iv, output) {
      var cipher = forge$p.rc2.createEncryptionCipher(key2, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge$p.rc2.createEncryptionCipher = function(key2, bits) {
      return createCipher(key2, bits, true);
    };
    forge$p.rc2.startDecrypting = function(key2, iv, output) {
      var cipher = forge$p.rc2.createDecryptionCipher(key2, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge$p.rc2.createDecryptionCipher = function(key2, bits) {
      return createCipher(key2, bits, false);
    };
    var forge$o = forge$F;
    forge$o.jsbn = forge$o.jsbn || {};
    var dbits;
    function BigInteger$2(a2, b2, c2) {
      this.data = [];
      if (a2 != null)
        if (typeof a2 == "number")
          this.fromNumber(a2, b2, c2);
        else if (b2 == null && typeof a2 != "string")
          this.fromString(a2, 256);
        else
          this.fromString(a2, b2);
    }
    forge$o.jsbn.BigInteger = BigInteger$2;
    function nbi() {
      return new BigInteger$2(null);
    }
    function am1(i3, x2, w3, j2, c2, n3) {
      while (--n3 >= 0) {
        var v2 = x2 * this.data[i3++] + w3.data[j2] + c2;
        c2 = Math.floor(v2 / 67108864);
        w3.data[j2++] = v2 & 67108863;
      }
      return c2;
    }
    function am2(i3, x2, w3, j2, c2, n3) {
      var xl = x2 & 32767, xh2 = x2 >> 15;
      while (--n3 >= 0) {
        var l2 = this.data[i3] & 32767;
        var h3 = this.data[i3++] >> 15;
        var m3 = xh2 * l2 + h3 * xl;
        l2 = xl * l2 + ((m3 & 32767) << 15) + w3.data[j2] + (c2 & 1073741823);
        c2 = (l2 >>> 30) + (m3 >>> 15) + xh2 * h3 + (c2 >>> 30);
        w3.data[j2++] = l2 & 1073741823;
      }
      return c2;
    }
    function am3(i3, x2, w3, j2, c2, n3) {
      var xl = x2 & 16383, xh2 = x2 >> 14;
      while (--n3 >= 0) {
        var l2 = this.data[i3] & 16383;
        var h3 = this.data[i3++] >> 14;
        var m3 = xh2 * l2 + h3 * xl;
        l2 = xl * l2 + ((m3 & 16383) << 14) + w3.data[j2] + c2;
        c2 = (l2 >> 28) + (m3 >> 14) + xh2 * h3;
        w3.data[j2++] = l2 & 268435455;
      }
      return c2;
    }
    if (typeof navigator === "undefined") {
      BigInteger$2.prototype.am = am3;
      dbits = 28;
    } else if (navigator.appName == "Microsoft Internet Explorer") {
      BigInteger$2.prototype.am = am2;
      dbits = 30;
    } else if (navigator.appName != "Netscape") {
      BigInteger$2.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger$2.prototype.am = am3;
      dbits = 28;
    }
    BigInteger$2.prototype.DB = dbits;
    BigInteger$2.prototype.DM = (1 << dbits) - 1;
    BigInteger$2.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger$2.prototype.FV = Math.pow(2, BI_FP);
    BigInteger$2.prototype.F1 = BI_FP - dbits;
    BigInteger$2.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr2;
    var vv;
    rr2 = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv)
      BI_RC[rr2++] = vv;
    rr2 = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr2++] = vv;
    rr2 = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr2++] = vv;
    function int2char(n3) {
      return BI_RM.charAt(n3);
    }
    function intAt(s3, i3) {
      var c2 = BI_RC[s3.charCodeAt(i3)];
      return c2 == null ? -1 : c2;
    }
    function bnpCopyTo(r2) {
      for (var i3 = this.t - 1; i3 >= 0; --i3)
        r2.data[i3] = this.data[i3];
      r2.t = this.t;
      r2.s = this.s;
    }
    function bnpFromInt(x2) {
      this.t = 1;
      this.s = x2 < 0 ? -1 : 0;
      if (x2 > 0)
        this.data[0] = x2;
      else if (x2 < -1)
        this.data[0] = x2 + this.DV;
      else
        this.t = 0;
    }
    function nbv(i3) {
      var r2 = nbi();
      r2.fromInt(i3);
      return r2;
    }
    function bnpFromString(s3, b2) {
      var k2;
      if (b2 == 16)
        k2 = 4;
      else if (b2 == 8)
        k2 = 3;
      else if (b2 == 256)
        k2 = 8;
      else if (b2 == 2)
        k2 = 1;
      else if (b2 == 32)
        k2 = 5;
      else if (b2 == 4)
        k2 = 2;
      else {
        this.fromRadix(s3, b2);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i3 = s3.length, mi2 = false, sh2 = 0;
      while (--i3 >= 0) {
        var x2 = k2 == 8 ? s3[i3] & 255 : intAt(s3, i3);
        if (x2 < 0) {
          if (s3.charAt(i3) == "-")
            mi2 = true;
          continue;
        }
        mi2 = false;
        if (sh2 == 0)
          this.data[this.t++] = x2;
        else if (sh2 + k2 > this.DB) {
          this.data[this.t - 1] |= (x2 & (1 << this.DB - sh2) - 1) << sh2;
          this.data[this.t++] = x2 >> this.DB - sh2;
        } else
          this.data[this.t - 1] |= x2 << sh2;
        sh2 += k2;
        if (sh2 >= this.DB)
          sh2 -= this.DB;
      }
      if (k2 == 8 && (s3[0] & 128) != 0) {
        this.s = -1;
        if (sh2 > 0)
          this.data[this.t - 1] |= (1 << this.DB - sh2) - 1 << sh2;
      }
      this.clamp();
      if (mi2)
        BigInteger$2.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c2 = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c2)
        --this.t;
    }
    function bnToString(b2) {
      if (this.s < 0)
        return "-" + this.negate().toString(b2);
      var k2;
      if (b2 == 16)
        k2 = 4;
      else if (b2 == 8)
        k2 = 3;
      else if (b2 == 2)
        k2 = 1;
      else if (b2 == 32)
        k2 = 5;
      else if (b2 == 4)
        k2 = 2;
      else
        return this.toRadix(b2);
      var km = (1 << k2) - 1, d3, m3 = false, r2 = "", i3 = this.t;
      var p2 = this.DB - i3 * this.DB % k2;
      if (i3-- > 0) {
        if (p2 < this.DB && (d3 = this.data[i3] >> p2) > 0) {
          m3 = true;
          r2 = int2char(d3);
        }
        while (i3 >= 0) {
          if (p2 < k2) {
            d3 = (this.data[i3] & (1 << p2) - 1) << k2 - p2;
            d3 |= this.data[--i3] >> (p2 += this.DB - k2);
          } else {
            d3 = this.data[i3] >> (p2 -= k2) & km;
            if (p2 <= 0) {
              p2 += this.DB;
              --i3;
            }
          }
          if (d3 > 0)
            m3 = true;
          if (m3)
            r2 += int2char(d3);
        }
      }
      return m3 ? r2 : "0";
    }
    function bnNegate() {
      var r2 = nbi();
      BigInteger$2.ZERO.subTo(this, r2);
      return r2;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a2) {
      var r2 = this.s - a2.s;
      if (r2 != 0)
        return r2;
      var i3 = this.t;
      r2 = i3 - a2.t;
      if (r2 != 0)
        return this.s < 0 ? -r2 : r2;
      while (--i3 >= 0)
        if ((r2 = this.data[i3] - a2.data[i3]) != 0)
          return r2;
      return 0;
    }
    function nbits(x2) {
      var r2 = 1, t;
      if ((t = x2 >>> 16) != 0) {
        x2 = t;
        r2 += 16;
      }
      if ((t = x2 >> 8) != 0) {
        x2 = t;
        r2 += 8;
      }
      if ((t = x2 >> 4) != 0) {
        x2 = t;
        r2 += 4;
      }
      if ((t = x2 >> 2) != 0) {
        x2 = t;
        r2 += 2;
      }
      if ((t = x2 >> 1) != 0) {
        x2 = t;
        r2 += 1;
      }
      return r2;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n3, r2) {
      var i3;
      for (i3 = this.t - 1; i3 >= 0; --i3)
        r2.data[i3 + n3] = this.data[i3];
      for (i3 = n3 - 1; i3 >= 0; --i3)
        r2.data[i3] = 0;
      r2.t = this.t + n3;
      r2.s = this.s;
    }
    function bnpDRShiftTo(n3, r2) {
      for (var i3 = n3; i3 < this.t; ++i3)
        r2.data[i3 - n3] = this.data[i3];
      r2.t = Math.max(this.t - n3, 0);
      r2.s = this.s;
    }
    function bnpLShiftTo(n3, r2) {
      var bs2 = n3 % this.DB;
      var cbs = this.DB - bs2;
      var bm = (1 << cbs) - 1;
      var ds2 = Math.floor(n3 / this.DB), c2 = this.s << bs2 & this.DM, i3;
      for (i3 = this.t - 1; i3 >= 0; --i3) {
        r2.data[i3 + ds2 + 1] = this.data[i3] >> cbs | c2;
        c2 = (this.data[i3] & bm) << bs2;
      }
      for (i3 = ds2 - 1; i3 >= 0; --i3)
        r2.data[i3] = 0;
      r2.data[ds2] = c2;
      r2.t = this.t + ds2 + 1;
      r2.s = this.s;
      r2.clamp();
    }
    function bnpRShiftTo(n3, r2) {
      r2.s = this.s;
      var ds2 = Math.floor(n3 / this.DB);
      if (ds2 >= this.t) {
        r2.t = 0;
        return;
      }
      var bs2 = n3 % this.DB;
      var cbs = this.DB - bs2;
      var bm = (1 << bs2) - 1;
      r2.data[0] = this.data[ds2] >> bs2;
      for (var i3 = ds2 + 1; i3 < this.t; ++i3) {
        r2.data[i3 - ds2 - 1] |= (this.data[i3] & bm) << cbs;
        r2.data[i3 - ds2] = this.data[i3] >> bs2;
      }
      if (bs2 > 0)
        r2.data[this.t - ds2 - 1] |= (this.s & bm) << cbs;
      r2.t = this.t - ds2;
      r2.clamp();
    }
    function bnpSubTo(a2, r2) {
      var i3 = 0, c2 = 0, m3 = Math.min(a2.t, this.t);
      while (i3 < m3) {
        c2 += this.data[i3] - a2.data[i3];
        r2.data[i3++] = c2 & this.DM;
        c2 >>= this.DB;
      }
      if (a2.t < this.t) {
        c2 -= a2.s;
        while (i3 < this.t) {
          c2 += this.data[i3];
          r2.data[i3++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 += this.s;
      } else {
        c2 += this.s;
        while (i3 < a2.t) {
          c2 -= a2.data[i3];
          r2.data[i3++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 -= a2.s;
      }
      r2.s = c2 < 0 ? -1 : 0;
      if (c2 < -1)
        r2.data[i3++] = this.DV + c2;
      else if (c2 > 0)
        r2.data[i3++] = c2;
      r2.t = i3;
      r2.clamp();
    }
    function bnpMultiplyTo(a2, r2) {
      var x2 = this.abs(), y3 = a2.abs();
      var i3 = x2.t;
      r2.t = i3 + y3.t;
      while (--i3 >= 0)
        r2.data[i3] = 0;
      for (i3 = 0; i3 < y3.t; ++i3)
        r2.data[i3 + x2.t] = x2.am(0, y3.data[i3], r2, i3, 0, x2.t);
      r2.s = 0;
      r2.clamp();
      if (this.s != a2.s)
        BigInteger$2.ZERO.subTo(r2, r2);
    }
    function bnpSquareTo(r2) {
      var x2 = this.abs();
      var i3 = r2.t = 2 * x2.t;
      while (--i3 >= 0)
        r2.data[i3] = 0;
      for (i3 = 0; i3 < x2.t - 1; ++i3) {
        var c2 = x2.am(i3, x2.data[i3], r2, 2 * i3, 0, 1);
        if ((r2.data[i3 + x2.t] += x2.am(i3 + 1, 2 * x2.data[i3], r2, 2 * i3 + 1, c2, x2.t - i3 - 1)) >= x2.DV) {
          r2.data[i3 + x2.t] -= x2.DV;
          r2.data[i3 + x2.t + 1] = 1;
        }
      }
      if (r2.t > 0)
        r2.data[r2.t - 1] += x2.am(i3, x2.data[i3], r2, 2 * i3, 0, 1);
      r2.s = 0;
      r2.clamp();
    }
    function bnpDivRemTo(m3, q2, r2) {
      var pm = m3.abs();
      if (pm.t <= 0)
        return;
      var pt2 = this.abs();
      if (pt2.t < pm.t) {
        if (q2 != null)
          q2.fromInt(0);
        if (r2 != null)
          this.copyTo(r2);
        return;
      }
      if (r2 == null)
        r2 = nbi();
      var y3 = nbi(), ts2 = this.s, ms3 = m3.s;
      var nsh = this.DB - nbits(pm.data[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y3);
        pt2.lShiftTo(nsh, r2);
      } else {
        pm.copyTo(y3);
        pt2.copyTo(r2);
      }
      var ys2 = y3.t;
      var y0 = y3.data[ys2 - 1];
      if (y0 == 0)
        return;
      var yt2 = y0 * (1 << this.F1) + (ys2 > 1 ? y3.data[ys2 - 2] >> this.F2 : 0);
      var d1 = this.FV / yt2, d22 = (1 << this.F1) / yt2, e2 = 1 << this.F2;
      var i3 = r2.t, j2 = i3 - ys2, t = q2 == null ? nbi() : q2;
      y3.dlShiftTo(j2, t);
      if (r2.compareTo(t) >= 0) {
        r2.data[r2.t++] = 1;
        r2.subTo(t, r2);
      }
      BigInteger$2.ONE.dlShiftTo(ys2, t);
      t.subTo(y3, y3);
      while (y3.t < ys2)
        y3.data[y3.t++] = 0;
      while (--j2 >= 0) {
        var qd = r2.data[--i3] == y0 ? this.DM : Math.floor(r2.data[i3] * d1 + (r2.data[i3 - 1] + e2) * d22);
        if ((r2.data[i3] += y3.am(0, qd, r2, j2, 0, ys2)) < qd) {
          y3.dlShiftTo(j2, t);
          r2.subTo(t, r2);
          while (r2.data[i3] < --qd)
            r2.subTo(t, r2);
        }
      }
      if (q2 != null) {
        r2.drShiftTo(ys2, q2);
        if (ts2 != ms3)
          BigInteger$2.ZERO.subTo(q2, q2);
      }
      r2.t = ys2;
      r2.clamp();
      if (nsh > 0)
        r2.rShiftTo(nsh, r2);
      if (ts2 < 0)
        BigInteger$2.ZERO.subTo(r2, r2);
    }
    function bnMod(a2) {
      var r2 = nbi();
      this.abs().divRemTo(a2, null, r2);
      if (this.s < 0 && r2.compareTo(BigInteger$2.ZERO) > 0)
        a2.subTo(r2, r2);
      return r2;
    }
    function Classic(m3) {
      this.m = m3;
    }
    function cConvert(x2) {
      if (x2.s < 0 || x2.compareTo(this.m) >= 0)
        return x2.mod(this.m);
      else
        return x2;
    }
    function cRevert(x2) {
      return x2;
    }
    function cReduce(x2) {
      x2.divRemTo(this.m, null, x2);
    }
    function cMulTo(x2, y3, r2) {
      x2.multiplyTo(y3, r2);
      this.reduce(r2);
    }
    function cSqrTo(x2, r2) {
      x2.squareTo(r2);
      this.reduce(r2);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x2 = this.data[0];
      if ((x2 & 1) == 0)
        return 0;
      var y3 = x2 & 3;
      y3 = y3 * (2 - (x2 & 15) * y3) & 15;
      y3 = y3 * (2 - (x2 & 255) * y3) & 255;
      y3 = y3 * (2 - ((x2 & 65535) * y3 & 65535)) & 65535;
      y3 = y3 * (2 - x2 * y3 % this.DV) % this.DV;
      return y3 > 0 ? this.DV - y3 : -y3;
    }
    function Montgomery(m3) {
      this.m = m3;
      this.mp = m3.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m3.DB - 15) - 1;
      this.mt2 = 2 * m3.t;
    }
    function montConvert(x2) {
      var r2 = nbi();
      x2.abs().dlShiftTo(this.m.t, r2);
      r2.divRemTo(this.m, null, r2);
      if (x2.s < 0 && r2.compareTo(BigInteger$2.ZERO) > 0)
        this.m.subTo(r2, r2);
      return r2;
    }
    function montRevert(x2) {
      var r2 = nbi();
      x2.copyTo(r2);
      this.reduce(r2);
      return r2;
    }
    function montReduce(x2) {
      while (x2.t <= this.mt2)
        x2.data[x2.t++] = 0;
      for (var i3 = 0; i3 < this.m.t; ++i3) {
        var j2 = x2.data[i3] & 32767;
        var u0 = j2 * this.mpl + ((j2 * this.mph + (x2.data[i3] >> 15) * this.mpl & this.um) << 15) & x2.DM;
        j2 = i3 + this.m.t;
        x2.data[j2] += this.m.am(0, u0, x2, i3, 0, this.m.t);
        while (x2.data[j2] >= x2.DV) {
          x2.data[j2] -= x2.DV;
          x2.data[++j2]++;
        }
      }
      x2.clamp();
      x2.drShiftTo(this.m.t, x2);
      if (x2.compareTo(this.m) >= 0)
        x2.subTo(this.m, x2);
    }
    function montSqrTo(x2, r2) {
      x2.squareTo(r2);
      this.reduce(r2);
    }
    function montMulTo(x2, y3, r2) {
      x2.multiplyTo(y3, r2);
      this.reduce(r2);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
    }
    function bnpExp(e2, z2) {
      if (e2 > 4294967295 || e2 < 1)
        return BigInteger$2.ONE;
      var r2 = nbi(), r22 = nbi(), g2 = z2.convert(this), i3 = nbits(e2) - 1;
      g2.copyTo(r2);
      while (--i3 >= 0) {
        z2.sqrTo(r2, r22);
        if ((e2 & 1 << i3) > 0)
          z2.mulTo(r22, g2, r2);
        else {
          var t = r2;
          r2 = r22;
          r22 = t;
        }
      }
      return z2.revert(r2);
    }
    function bnModPowInt(e2, m3) {
      var z2;
      if (e2 < 256 || m3.isEven())
        z2 = new Classic(m3);
      else
        z2 = new Montgomery(m3);
      return this.exp(e2, z2);
    }
    BigInteger$2.prototype.copyTo = bnpCopyTo;
    BigInteger$2.prototype.fromInt = bnpFromInt;
    BigInteger$2.prototype.fromString = bnpFromString;
    BigInteger$2.prototype.clamp = bnpClamp;
    BigInteger$2.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger$2.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger$2.prototype.lShiftTo = bnpLShiftTo;
    BigInteger$2.prototype.rShiftTo = bnpRShiftTo;
    BigInteger$2.prototype.subTo = bnpSubTo;
    BigInteger$2.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger$2.prototype.squareTo = bnpSquareTo;
    BigInteger$2.prototype.divRemTo = bnpDivRemTo;
    BigInteger$2.prototype.invDigit = bnpInvDigit;
    BigInteger$2.prototype.isEven = bnpIsEven;
    BigInteger$2.prototype.exp = bnpExp;
    BigInteger$2.prototype.toString = bnToString;
    BigInteger$2.prototype.negate = bnNegate;
    BigInteger$2.prototype.abs = bnAbs;
    BigInteger$2.prototype.compareTo = bnCompareTo;
    BigInteger$2.prototype.bitLength = bnBitLength;
    BigInteger$2.prototype.mod = bnMod;
    BigInteger$2.prototype.modPowInt = bnModPowInt;
    BigInteger$2.ZERO = nbv(0);
    BigInteger$2.ONE = nbv(1);
    function bnClone() {
      var r2 = nbi();
      this.copyTo(r2);
      return r2;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this.data[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this.data[0];
      else if (this.t == 0)
        return 0;
      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
    }
    function bnpChunkSize(r2) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r2));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b2) {
      if (b2 == null)
        b2 = 10;
      if (this.signum() == 0 || b2 < 2 || b2 > 36)
        return "0";
      var cs2 = this.chunkSize(b2);
      var a2 = Math.pow(b2, cs2);
      var d3 = nbv(a2), y3 = nbi(), z2 = nbi(), r2 = "";
      this.divRemTo(d3, y3, z2);
      while (y3.signum() > 0) {
        r2 = (a2 + z2.intValue()).toString(b2).substr(1) + r2;
        y3.divRemTo(d3, y3, z2);
      }
      return z2.intValue().toString(b2) + r2;
    }
    function bnpFromRadix(s3, b2) {
      this.fromInt(0);
      if (b2 == null)
        b2 = 10;
      var cs2 = this.chunkSize(b2);
      var d3 = Math.pow(b2, cs2), mi2 = false, j2 = 0, w3 = 0;
      for (var i3 = 0; i3 < s3.length; ++i3) {
        var x2 = intAt(s3, i3);
        if (x2 < 0) {
          if (s3.charAt(i3) == "-" && this.signum() == 0)
            mi2 = true;
          continue;
        }
        w3 = b2 * w3 + x2;
        if (++j2 >= cs2) {
          this.dMultiply(d3);
          this.dAddOffset(w3, 0);
          j2 = 0;
          w3 = 0;
        }
      }
      if (j2 > 0) {
        this.dMultiply(Math.pow(b2, j2));
        this.dAddOffset(w3, 0);
      }
      if (mi2)
        BigInteger$2.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a2, b2, c2) {
      if (typeof b2 == "number") {
        if (a2 < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a2, c2);
          if (!this.testBit(a2 - 1))
            this.bitwiseTo(BigInteger$2.ONE.shiftLeft(a2 - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b2)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a2)
              this.subTo(BigInteger$2.ONE.shiftLeft(a2 - 1), this);
          }
        }
      } else {
        var x2 = new Array(), t = a2 & 7;
        x2.length = (a2 >> 3) + 1;
        b2.nextBytes(x2);
        if (t > 0)
          x2[0] &= (1 << t) - 1;
        else
          x2[0] = 0;
        this.fromString(x2, 256);
      }
    }
    function bnToByteArray() {
      var i3 = this.t, r2 = new Array();
      r2[0] = this.s;
      var p2 = this.DB - i3 * this.DB % 8, d3, k2 = 0;
      if (i3-- > 0) {
        if (p2 < this.DB && (d3 = this.data[i3] >> p2) != (this.s & this.DM) >> p2)
          r2[k2++] = d3 | this.s << this.DB - p2;
        while (i3 >= 0) {
          if (p2 < 8) {
            d3 = (this.data[i3] & (1 << p2) - 1) << 8 - p2;
            d3 |= this.data[--i3] >> (p2 += this.DB - 8);
          } else {
            d3 = this.data[i3] >> (p2 -= 8) & 255;
            if (p2 <= 0) {
              p2 += this.DB;
              --i3;
            }
          }
          if ((d3 & 128) != 0)
            d3 |= -256;
          if (k2 == 0 && (this.s & 128) != (d3 & 128))
            ++k2;
          if (k2 > 0 || d3 != this.s)
            r2[k2++] = d3;
        }
      }
      return r2;
    }
    function bnEquals(a2) {
      return this.compareTo(a2) == 0;
    }
    function bnMin(a2) {
      return this.compareTo(a2) < 0 ? this : a2;
    }
    function bnMax(a2) {
      return this.compareTo(a2) > 0 ? this : a2;
    }
    function bnpBitwiseTo(a2, op, r2) {
      var i3, f3, m3 = Math.min(a2.t, this.t);
      for (i3 = 0; i3 < m3; ++i3)
        r2.data[i3] = op(this.data[i3], a2.data[i3]);
      if (a2.t < this.t) {
        f3 = a2.s & this.DM;
        for (i3 = m3; i3 < this.t; ++i3)
          r2.data[i3] = op(this.data[i3], f3);
        r2.t = this.t;
      } else {
        f3 = this.s & this.DM;
        for (i3 = m3; i3 < a2.t; ++i3)
          r2.data[i3] = op(f3, a2.data[i3]);
        r2.t = a2.t;
      }
      r2.s = op(this.s, a2.s);
      r2.clamp();
    }
    function op_and(x2, y3) {
      return x2 & y3;
    }
    function bnAnd(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_and, r2);
      return r2;
    }
    function op_or(x2, y3) {
      return x2 | y3;
    }
    function bnOr(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_or, r2);
      return r2;
    }
    function op_xor(x2, y3) {
      return x2 ^ y3;
    }
    function bnXor(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_xor, r2);
      return r2;
    }
    function op_andnot(x2, y3) {
      return x2 & ~y3;
    }
    function bnAndNot(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_andnot, r2);
      return r2;
    }
    function bnNot() {
      var r2 = nbi();
      for (var i3 = 0; i3 < this.t; ++i3)
        r2.data[i3] = this.DM & ~this.data[i3];
      r2.t = this.t;
      r2.s = ~this.s;
      return r2;
    }
    function bnShiftLeft(n3) {
      var r2 = nbi();
      if (n3 < 0)
        this.rShiftTo(-n3, r2);
      else
        this.lShiftTo(n3, r2);
      return r2;
    }
    function bnShiftRight(n3) {
      var r2 = nbi();
      if (n3 < 0)
        this.lShiftTo(-n3, r2);
      else
        this.rShiftTo(n3, r2);
      return r2;
    }
    function lbit(x2) {
      if (x2 == 0)
        return -1;
      var r2 = 0;
      if ((x2 & 65535) == 0) {
        x2 >>= 16;
        r2 += 16;
      }
      if ((x2 & 255) == 0) {
        x2 >>= 8;
        r2 += 8;
      }
      if ((x2 & 15) == 0) {
        x2 >>= 4;
        r2 += 4;
      }
      if ((x2 & 3) == 0) {
        x2 >>= 2;
        r2 += 2;
      }
      if ((x2 & 1) == 0)
        ++r2;
      return r2;
    }
    function bnGetLowestSetBit() {
      for (var i3 = 0; i3 < this.t; ++i3)
        if (this.data[i3] != 0)
          return i3 * this.DB + lbit(this.data[i3]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x2) {
      var r2 = 0;
      while (x2 != 0) {
        x2 &= x2 - 1;
        ++r2;
      }
      return r2;
    }
    function bnBitCount() {
      var r2 = 0, x2 = this.s & this.DM;
      for (var i3 = 0; i3 < this.t; ++i3)
        r2 += cbit(this.data[i3] ^ x2);
      return r2;
    }
    function bnTestBit(n3) {
      var j2 = Math.floor(n3 / this.DB);
      if (j2 >= this.t)
        return this.s != 0;
      return (this.data[j2] & 1 << n3 % this.DB) != 0;
    }
    function bnpChangeBit(n3, op) {
      var r2 = BigInteger$2.ONE.shiftLeft(n3);
      this.bitwiseTo(r2, op, r2);
      return r2;
    }
    function bnSetBit(n3) {
      return this.changeBit(n3, op_or);
    }
    function bnClearBit(n3) {
      return this.changeBit(n3, op_andnot);
    }
    function bnFlipBit(n3) {
      return this.changeBit(n3, op_xor);
    }
    function bnpAddTo(a2, r2) {
      var i3 = 0, c2 = 0, m3 = Math.min(a2.t, this.t);
      while (i3 < m3) {
        c2 += this.data[i3] + a2.data[i3];
        r2.data[i3++] = c2 & this.DM;
        c2 >>= this.DB;
      }
      if (a2.t < this.t) {
        c2 += a2.s;
        while (i3 < this.t) {
          c2 += this.data[i3];
          r2.data[i3++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 += this.s;
      } else {
        c2 += this.s;
        while (i3 < a2.t) {
          c2 += a2.data[i3];
          r2.data[i3++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 += a2.s;
      }
      r2.s = c2 < 0 ? -1 : 0;
      if (c2 > 0)
        r2.data[i3++] = c2;
      else if (c2 < -1)
        r2.data[i3++] = this.DV + c2;
      r2.t = i3;
      r2.clamp();
    }
    function bnAdd(a2) {
      var r2 = nbi();
      this.addTo(a2, r2);
      return r2;
    }
    function bnSubtract(a2) {
      var r2 = nbi();
      this.subTo(a2, r2);
      return r2;
    }
    function bnMultiply(a2) {
      var r2 = nbi();
      this.multiplyTo(a2, r2);
      return r2;
    }
    function bnDivide(a2) {
      var r2 = nbi();
      this.divRemTo(a2, r2, null);
      return r2;
    }
    function bnRemainder(a2) {
      var r2 = nbi();
      this.divRemTo(a2, null, r2);
      return r2;
    }
    function bnDivideAndRemainder(a2) {
      var q2 = nbi(), r2 = nbi();
      this.divRemTo(a2, q2, r2);
      return new Array(q2, r2);
    }
    function bnpDMultiply(n3) {
      this.data[this.t] = this.am(0, n3 - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n3, w3) {
      if (n3 == 0)
        return;
      while (this.t <= w3)
        this.data[this.t++] = 0;
      this.data[w3] += n3;
      while (this.data[w3] >= this.DV) {
        this.data[w3] -= this.DV;
        if (++w3 >= this.t)
          this.data[this.t++] = 0;
        ++this.data[w3];
      }
    }
    function NullExp() {
    }
    function nNop(x2) {
      return x2;
    }
    function nMulTo(x2, y3, r2) {
      x2.multiplyTo(y3, r2);
    }
    function nSqrTo(x2, r2) {
      x2.squareTo(r2);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e2) {
      return this.exp(e2, new NullExp());
    }
    function bnpMultiplyLowerTo(a2, n3, r2) {
      var i3 = Math.min(this.t + a2.t, n3);
      r2.s = 0;
      r2.t = i3;
      while (i3 > 0)
        r2.data[--i3] = 0;
      var j2;
      for (j2 = r2.t - this.t; i3 < j2; ++i3)
        r2.data[i3 + this.t] = this.am(0, a2.data[i3], r2, i3, 0, this.t);
      for (j2 = Math.min(a2.t, n3); i3 < j2; ++i3)
        this.am(0, a2.data[i3], r2, i3, 0, n3 - i3);
      r2.clamp();
    }
    function bnpMultiplyUpperTo(a2, n3, r2) {
      --n3;
      var i3 = r2.t = this.t + a2.t - n3;
      r2.s = 0;
      while (--i3 >= 0)
        r2.data[i3] = 0;
      for (i3 = Math.max(n3 - this.t, 0); i3 < a2.t; ++i3)
        r2.data[this.t + i3 - n3] = this.am(n3 - i3, a2.data[i3], r2, 0, 0, this.t + i3 - n3);
      r2.clamp();
      r2.drShiftTo(1, r2);
    }
    function Barrett(m3) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger$2.ONE.dlShiftTo(2 * m3.t, this.r2);
      this.mu = this.r2.divide(m3);
      this.m = m3;
    }
    function barrettConvert(x2) {
      if (x2.s < 0 || x2.t > 2 * this.m.t)
        return x2.mod(this.m);
      else if (x2.compareTo(this.m) < 0)
        return x2;
      else {
        var r2 = nbi();
        x2.copyTo(r2);
        this.reduce(r2);
        return r2;
      }
    }
    function barrettRevert(x2) {
      return x2;
    }
    function barrettReduce(x2) {
      x2.drShiftTo(this.m.t - 1, this.r2);
      if (x2.t > this.m.t + 1) {
        x2.t = this.m.t + 1;
        x2.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x2.compareTo(this.r2) < 0)
        x2.dAddOffset(1, this.m.t + 1);
      x2.subTo(this.r2, x2);
      while (x2.compareTo(this.m) >= 0)
        x2.subTo(this.m, x2);
    }
    function barrettSqrTo(x2, r2) {
      x2.squareTo(r2);
      this.reduce(r2);
    }
    function barrettMulTo(x2, y3, r2) {
      x2.multiplyTo(y3, r2);
      this.reduce(r2);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e2, m3) {
      var i3 = e2.bitLength(), k2, r2 = nbv(1), z2;
      if (i3 <= 0)
        return r2;
      else if (i3 < 18)
        k2 = 1;
      else if (i3 < 48)
        k2 = 3;
      else if (i3 < 144)
        k2 = 4;
      else if (i3 < 768)
        k2 = 5;
      else
        k2 = 6;
      if (i3 < 8)
        z2 = new Classic(m3);
      else if (m3.isEven())
        z2 = new Barrett(m3);
      else
        z2 = new Montgomery(m3);
      var g2 = new Array(), n3 = 3, k1 = k2 - 1, km = (1 << k2) - 1;
      g2[1] = z2.convert(this);
      if (k2 > 1) {
        var g22 = nbi();
        z2.sqrTo(g2[1], g22);
        while (n3 <= km) {
          g2[n3] = nbi();
          z2.mulTo(g22, g2[n3 - 2], g2[n3]);
          n3 += 2;
        }
      }
      var j2 = e2.t - 1, w3, is1 = true, r22 = nbi(), t;
      i3 = nbits(e2.data[j2]) - 1;
      while (j2 >= 0) {
        if (i3 >= k1)
          w3 = e2.data[j2] >> i3 - k1 & km;
        else {
          w3 = (e2.data[j2] & (1 << i3 + 1) - 1) << k1 - i3;
          if (j2 > 0)
            w3 |= e2.data[j2 - 1] >> this.DB + i3 - k1;
        }
        n3 = k2;
        while ((w3 & 1) == 0) {
          w3 >>= 1;
          --n3;
        }
        if ((i3 -= n3) < 0) {
          i3 += this.DB;
          --j2;
        }
        if (is1) {
          g2[w3].copyTo(r2);
          is1 = false;
        } else {
          while (n3 > 1) {
            z2.sqrTo(r2, r22);
            z2.sqrTo(r22, r2);
            n3 -= 2;
          }
          if (n3 > 0)
            z2.sqrTo(r2, r22);
          else {
            t = r2;
            r2 = r22;
            r22 = t;
          }
          z2.mulTo(r22, g2[w3], r2);
        }
        while (j2 >= 0 && (e2.data[j2] & 1 << i3) == 0) {
          z2.sqrTo(r2, r22);
          t = r2;
          r2 = r22;
          r22 = t;
          if (--i3 < 0) {
            i3 = this.DB - 1;
            --j2;
          }
        }
      }
      return z2.revert(r2);
    }
    function bnGCD(a2) {
      var x2 = this.s < 0 ? this.negate() : this.clone();
      var y3 = a2.s < 0 ? a2.negate() : a2.clone();
      if (x2.compareTo(y3) < 0) {
        var t = x2;
        x2 = y3;
        y3 = t;
      }
      var i3 = x2.getLowestSetBit(), g2 = y3.getLowestSetBit();
      if (g2 < 0)
        return x2;
      if (i3 < g2)
        g2 = i3;
      if (g2 > 0) {
        x2.rShiftTo(g2, x2);
        y3.rShiftTo(g2, y3);
      }
      while (x2.signum() > 0) {
        if ((i3 = x2.getLowestSetBit()) > 0)
          x2.rShiftTo(i3, x2);
        if ((i3 = y3.getLowestSetBit()) > 0)
          y3.rShiftTo(i3, y3);
        if (x2.compareTo(y3) >= 0) {
          x2.subTo(y3, x2);
          x2.rShiftTo(1, x2);
        } else {
          y3.subTo(x2, y3);
          y3.rShiftTo(1, y3);
        }
      }
      if (g2 > 0)
        y3.lShiftTo(g2, y3);
      return y3;
    }
    function bnpModInt(n3) {
      if (n3 <= 0)
        return 0;
      var d3 = this.DV % n3, r2 = this.s < 0 ? n3 - 1 : 0;
      if (this.t > 0)
        if (d3 == 0)
          r2 = this.data[0] % n3;
        else
          for (var i3 = this.t - 1; i3 >= 0; --i3)
            r2 = (d3 * r2 + this.data[i3]) % n3;
      return r2;
    }
    function bnModInverse(m3) {
      var ac = m3.isEven();
      if (this.isEven() && ac || m3.signum() == 0)
        return BigInteger$2.ZERO;
      var u2 = m3.clone(), v2 = this.clone();
      var a2 = nbv(1), b2 = nbv(0), c2 = nbv(0), d3 = nbv(1);
      while (u2.signum() != 0) {
        while (u2.isEven()) {
          u2.rShiftTo(1, u2);
          if (ac) {
            if (!a2.isEven() || !b2.isEven()) {
              a2.addTo(this, a2);
              b2.subTo(m3, b2);
            }
            a2.rShiftTo(1, a2);
          } else if (!b2.isEven())
            b2.subTo(m3, b2);
          b2.rShiftTo(1, b2);
        }
        while (v2.isEven()) {
          v2.rShiftTo(1, v2);
          if (ac) {
            if (!c2.isEven() || !d3.isEven()) {
              c2.addTo(this, c2);
              d3.subTo(m3, d3);
            }
            c2.rShiftTo(1, c2);
          } else if (!d3.isEven())
            d3.subTo(m3, d3);
          d3.rShiftTo(1, d3);
        }
        if (u2.compareTo(v2) >= 0) {
          u2.subTo(v2, u2);
          if (ac)
            a2.subTo(c2, a2);
          b2.subTo(d3, b2);
        } else {
          v2.subTo(u2, v2);
          if (ac)
            c2.subTo(a2, c2);
          d3.subTo(b2, d3);
        }
      }
      if (v2.compareTo(BigInteger$2.ONE) != 0)
        return BigInteger$2.ZERO;
      if (d3.compareTo(m3) >= 0)
        return d3.subtract(m3);
      if (d3.signum() < 0)
        d3.addTo(m3, d3);
      else
        return d3;
      if (d3.signum() < 0)
        return d3.add(m3);
      else
        return d3;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t) {
      var i3, x2 = this.abs();
      if (x2.t == 1 && x2.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i3 = 0; i3 < lowprimes.length; ++i3)
          if (x2.data[0] == lowprimes[i3])
            return true;
        return false;
      }
      if (x2.isEven())
        return false;
      i3 = 1;
      while (i3 < lowprimes.length) {
        var m3 = lowprimes[i3], j2 = i3 + 1;
        while (j2 < lowprimes.length && m3 < lplim)
          m3 *= lowprimes[j2++];
        m3 = x2.modInt(m3);
        while (i3 < j2)
          if (m3 % lowprimes[i3++] == 0)
            return false;
      }
      return x2.millerRabin(t);
    }
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger$2.ONE);
      var k2 = n1.getLowestSetBit();
      if (k2 <= 0)
        return false;
      var r2 = n1.shiftRight(k2);
      var prng2 = bnGetPrng();
      var a2;
      for (var i3 = 0; i3 < t; ++i3) {
        do {
          a2 = new BigInteger$2(this.bitLength(), prng2);
        } while (a2.compareTo(BigInteger$2.ONE) <= 0 || a2.compareTo(n1) >= 0);
        var y3 = a2.modPow(r2, this);
        if (y3.compareTo(BigInteger$2.ONE) != 0 && y3.compareTo(n1) != 0) {
          var j2 = 1;
          while (j2++ < k2 && y3.compareTo(n1) != 0) {
            y3 = y3.modPowInt(2, this);
            if (y3.compareTo(BigInteger$2.ONE) == 0)
              return false;
          }
          if (y3.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    function bnGetPrng() {
      return {
        nextBytes: function(x2) {
          for (var i3 = 0; i3 < x2.length; ++i3) {
            x2[i3] = Math.floor(Math.random() * 256);
          }
        }
      };
    }
    BigInteger$2.prototype.chunkSize = bnpChunkSize;
    BigInteger$2.prototype.toRadix = bnpToRadix;
    BigInteger$2.prototype.fromRadix = bnpFromRadix;
    BigInteger$2.prototype.fromNumber = bnpFromNumber;
    BigInteger$2.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger$2.prototype.changeBit = bnpChangeBit;
    BigInteger$2.prototype.addTo = bnpAddTo;
    BigInteger$2.prototype.dMultiply = bnpDMultiply;
    BigInteger$2.prototype.dAddOffset = bnpDAddOffset;
    BigInteger$2.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger$2.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger$2.prototype.modInt = bnpModInt;
    BigInteger$2.prototype.millerRabin = bnpMillerRabin;
    BigInteger$2.prototype.clone = bnClone;
    BigInteger$2.prototype.intValue = bnIntValue;
    BigInteger$2.prototype.byteValue = bnByteValue;
    BigInteger$2.prototype.shortValue = bnShortValue;
    BigInteger$2.prototype.signum = bnSigNum;
    BigInteger$2.prototype.toByteArray = bnToByteArray;
    BigInteger$2.prototype.equals = bnEquals;
    BigInteger$2.prototype.min = bnMin;
    BigInteger$2.prototype.max = bnMax;
    BigInteger$2.prototype.and = bnAnd;
    BigInteger$2.prototype.or = bnOr;
    BigInteger$2.prototype.xor = bnXor;
    BigInteger$2.prototype.andNot = bnAndNot;
    BigInteger$2.prototype.not = bnNot;
    BigInteger$2.prototype.shiftLeft = bnShiftLeft;
    BigInteger$2.prototype.shiftRight = bnShiftRight;
    BigInteger$2.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger$2.prototype.bitCount = bnBitCount;
    BigInteger$2.prototype.testBit = bnTestBit;
    BigInteger$2.prototype.setBit = bnSetBit;
    BigInteger$2.prototype.clearBit = bnClearBit;
    BigInteger$2.prototype.flipBit = bnFlipBit;
    BigInteger$2.prototype.add = bnAdd;
    BigInteger$2.prototype.subtract = bnSubtract;
    BigInteger$2.prototype.multiply = bnMultiply;
    BigInteger$2.prototype.divide = bnDivide;
    BigInteger$2.prototype.remainder = bnRemainder;
    BigInteger$2.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger$2.prototype.modPow = bnModPow;
    BigInteger$2.prototype.modInverse = bnModInverse;
    BigInteger$2.prototype.pow = bnPow;
    BigInteger$2.prototype.gcd = bnGCD;
    BigInteger$2.prototype.isProbablePrime = bnIsProbablePrime;
    var forge$n = forge$F;
    var sha1 = forge$n.sha1 = forge$n.sha1 || {};
    forge$n.md.sha1 = forge$n.md.algorithms.sha1 = sha1;
    sha1.create = function() {
      if (!_initialized$1) {
        _init$1();
      }
      var _state = null;
      var _input = forge$n.util.createBuffer();
      var _w = new Array(80);
      var md = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i3 = 0; i3 < int32s; ++i3) {
          md.fullMessageLength.push(0);
        }
        _input = forge$n.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878,
          h4: 3285377520
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding2) {
        if (encoding2 === "utf8") {
          msg = forge$n.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i3 = md.fullMessageLength.length - 1; i3 >= 0; --i3) {
          md.fullMessageLength[i3] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i3] / 4294967296 >>> 0);
          md.fullMessageLength[i3] = md.fullMessageLength[i3] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update$1(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge$n.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding$1.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i3 = 0; i3 < md.fullMessageLength.length - 1; ++i3) {
          next = md.fullMessageLength[i3 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s22 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update$1(s22, _w, finalBlock);
        var rval = forge$n.util.createBuffer();
        rval.putInt32(s22.h0);
        rval.putInt32(s22.h1);
        rval.putInt32(s22.h2);
        rval.putInt32(s22.h3);
        rval.putInt32(s22.h4);
        return rval;
      };
      return md;
    };
    var _padding$1 = null;
    var _initialized$1 = false;
    function _init$1() {
      _padding$1 = String.fromCharCode(128);
      _padding$1 += forge$n.util.fillString(String.fromCharCode(0), 64);
      _initialized$1 = true;
    }
    function _update$1(s3, w3, bytes2) {
      var t, a2, b2, c2, d3, e2, f3, i3;
      var len = bytes2.length();
      while (len >= 64) {
        a2 = s3.h0;
        b2 = s3.h1;
        c2 = s3.h2;
        d3 = s3.h3;
        e2 = s3.h4;
        for (i3 = 0; i3 < 16; ++i3) {
          t = bytes2.getInt32();
          w3[i3] = t;
          f3 = d3 ^ b2 & (c2 ^ d3);
          t = (a2 << 5 | a2 >>> 27) + f3 + e2 + 1518500249 + t;
          e2 = d3;
          d3 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i3 < 20; ++i3) {
          t = w3[i3 - 3] ^ w3[i3 - 8] ^ w3[i3 - 14] ^ w3[i3 - 16];
          t = t << 1 | t >>> 31;
          w3[i3] = t;
          f3 = d3 ^ b2 & (c2 ^ d3);
          t = (a2 << 5 | a2 >>> 27) + f3 + e2 + 1518500249 + t;
          e2 = d3;
          d3 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i3 < 32; ++i3) {
          t = w3[i3 - 3] ^ w3[i3 - 8] ^ w3[i3 - 14] ^ w3[i3 - 16];
          t = t << 1 | t >>> 31;
          w3[i3] = t;
          f3 = b2 ^ c2 ^ d3;
          t = (a2 << 5 | a2 >>> 27) + f3 + e2 + 1859775393 + t;
          e2 = d3;
          d3 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i3 < 40; ++i3) {
          t = w3[i3 - 6] ^ w3[i3 - 16] ^ w3[i3 - 28] ^ w3[i3 - 32];
          t = t << 2 | t >>> 30;
          w3[i3] = t;
          f3 = b2 ^ c2 ^ d3;
          t = (a2 << 5 | a2 >>> 27) + f3 + e2 + 1859775393 + t;
          e2 = d3;
          d3 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i3 < 60; ++i3) {
          t = w3[i3 - 6] ^ w3[i3 - 16] ^ w3[i3 - 28] ^ w3[i3 - 32];
          t = t << 2 | t >>> 30;
          w3[i3] = t;
          f3 = b2 & c2 | d3 & (b2 ^ c2);
          t = (a2 << 5 | a2 >>> 27) + f3 + e2 + 2400959708 + t;
          e2 = d3;
          d3 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i3 < 80; ++i3) {
          t = w3[i3 - 6] ^ w3[i3 - 16] ^ w3[i3 - 28] ^ w3[i3 - 32];
          t = t << 2 | t >>> 30;
          w3[i3] = t;
          f3 = b2 ^ c2 ^ d3;
          t = (a2 << 5 | a2 >>> 27) + f3 + e2 + 3395469782 + t;
          e2 = d3;
          d3 = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        s3.h0 = s3.h0 + a2 | 0;
        s3.h1 = s3.h1 + b2 | 0;
        s3.h2 = s3.h2 + c2 | 0;
        s3.h3 = s3.h3 + d3 | 0;
        s3.h4 = s3.h4 + e2 | 0;
        len -= 64;
      }
    }
    var forge$m = forge$F;
    var pkcs1 = forge$m.pkcs1 = forge$m.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key2, message, options2) {
      var label;
      var seed;
      var md;
      var mgf1Md;
      if (typeof options2 === "string") {
        label = options2;
        seed = arguments[3] || void 0;
        md = arguments[4] || void 0;
      } else if (options2) {
        label = options2.label || void 0;
        seed = options2.seed || void 0;
        md = options2.md || void 0;
        if (options2.mgf1 && options2.mgf1.md) {
          mgf1Md = options2.mgf1.md;
        }
      }
      if (!md) {
        md = forge$m.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      var keyLength = Math.ceil(key2.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md.digestLength - 2;
      if (message.length > maxLength) {
        var error2 = new Error("RSAES-OAEP input message length is too long.");
        error2.length = message.length;
        error2.maxLength = maxLength;
        throw error2;
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest();
      var PS = "";
      var PS_length = maxLength - message.length;
      for (var i3 = 0; i3 < PS_length; i3++) {
        PS += "\0";
      }
      var DB = lHash.getBytes() + PS + "" + message;
      if (!seed) {
        seed = forge$m.random.getBytes(md.digestLength);
      } else if (seed.length !== md.digestLength) {
        var error2 = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
        error2.seedLength = seed.length;
        error2.digestLength = md.digestLength;
        throw error2;
      }
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var maskedDB = forge$m.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var maskedSeed = forge$m.util.xorBytes(seed, seedMask, seed.length);
      return "\0" + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key2, em, options2) {
      var label;
      var md;
      var mgf1Md;
      if (typeof options2 === "string") {
        label = options2;
        md = arguments[3] || void 0;
      } else if (options2) {
        label = options2.label || void 0;
        md = options2.md || void 0;
        if (options2.mgf1 && options2.mgf1.md) {
          mgf1Md = options2.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key2.n.bitLength() / 8);
      if (em.length !== keyLength) {
        var error2 = new Error("RSAES-OAEP encoded message length is invalid.");
        error2.length = em.length;
        error2.expectedLength = keyLength;
        throw error2;
      }
      if (md === void 0) {
        md = forge$m.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      if (keyLength < 2 * md.digestLength + 2) {
        throw new Error("RSAES-OAEP key is too short for the hash function.");
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest().getBytes();
      var y3 = em.charAt(0);
      var maskedSeed = em.substring(1, md.digestLength + 1);
      var maskedDB = em.substring(1 + md.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var seed = forge$m.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var db2 = forge$m.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db2.substring(0, md.digestLength);
      var error2 = y3 !== "\0";
      for (var i3 = 0; i3 < md.digestLength; ++i3) {
        error2 |= lHash.charAt(i3) !== lHashPrime.charAt(i3);
      }
      var in_ps = 1;
      var index3 = md.digestLength;
      for (var j2 = md.digestLength; j2 < db2.length; j2++) {
        var code = db2.charCodeAt(j2);
        var is_0 = code & 1 ^ 1;
        var error_mask = in_ps ? 65534 : 0;
        error2 |= code & error_mask;
        in_ps = in_ps & is_0;
        index3 += in_ps;
      }
      if (error2 || db2.charCodeAt(index3) !== 1) {
        throw new Error("Invalid RSAES-OAEP padding.");
      }
      return db2.substring(index3 + 1);
    };
    function rsa_mgf1(seed, maskLength, hash2) {
      if (!hash2) {
        hash2 = forge$m.md.sha1.create();
      }
      var t = "";
      var count = Math.ceil(maskLength / hash2.digestLength);
      for (var i3 = 0; i3 < count; ++i3) {
        var c2 = String.fromCharCode(i3 >> 24 & 255, i3 >> 16 & 255, i3 >> 8 & 255, i3 & 255);
        hash2.start();
        hash2.update(seed + c2);
        t += hash2.digest().getBytes();
      }
      return t.substring(0, maskLength);
    }
    var forge$l = forge$F;
    (function() {
      if (forge$l.prime) {
        return;
      }
      var prime = forge$l.prime = forge$l.prime || {};
      var BigInteger2 = forge$l.jsbn.BigInteger;
      var GCD_30_DELTA2 = [6, 4, 2, 4, 2, 4, 6, 2];
      var THIRTY = new BigInteger2(null);
      THIRTY.fromInt(30);
      var op_or2 = function(x2, y3) {
        return x2 | y3;
      };
      prime.generateProbablePrime = function(bits, options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        options2 = options2 || {};
        var algorithm = options2.algorithm || "PRIMEINC";
        if (typeof algorithm === "string") {
          algorithm = { name: algorithm };
        }
        algorithm.options = algorithm.options || {};
        var prng2 = options2.prng || forge$l.random;
        var rng = {
          nextBytes: function(x2) {
            var b2 = prng2.getBytesSync(x2.length);
            for (var i3 = 0; i3 < x2.length; ++i3) {
              x2[i3] = b2.charCodeAt(i3);
            }
          }
        };
        if (algorithm.name === "PRIMEINC") {
          return primeincFindPrime(bits, rng, algorithm.options, callback);
        }
        throw new Error("Invalid prime generation algorithm: " + algorithm.name);
      };
      function primeincFindPrime(bits, rng, options2, callback) {
        if ("workers" in options2) {
          return primeincFindPrimeWithWorkers(bits, rng, options2, callback);
        }
        return primeincFindPrimeWithoutWorkers(bits, rng, options2, callback);
      }
      function primeincFindPrimeWithoutWorkers(bits, rng, options2, callback) {
        var num = generateRandom(bits, rng);
        var deltaIdx = 0;
        var mrTests = getMillerRabinTests(num.bitLength());
        if ("millerRabinTests" in options2) {
          mrTests = options2.millerRabinTests;
        }
        var maxBlockTime = 10;
        if ("maxBlockTime" in options2) {
          maxBlockTime = options2.maxBlockTime;
        }
        _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
      }
      function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
        var start2 = +new Date();
        do {
          if (num.bitLength() > bits) {
            num = generateRandom(bits, rng);
          }
          if (num.isProbablePrime(mrTests)) {
            return callback(null, num);
          }
          num.dAddOffset(GCD_30_DELTA2[deltaIdx++ % 8], 0);
        } while (maxBlockTime < 0 || +new Date() - start2 < maxBlockTime);
        forge$l.util.setImmediate(function() {
          _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
        });
      }
      function primeincFindPrimeWithWorkers(bits, rng, options2, callback) {
        if (typeof Worker === "undefined") {
          return primeincFindPrimeWithoutWorkers(bits, rng, options2, callback);
        }
        var num = generateRandom(bits, rng);
        var numWorkers = options2.workers;
        var workLoad = options2.workLoad || 100;
        var range2 = workLoad * 30 / 8;
        var workerScript = options2.workerScript || "forge/prime.worker.js";
        if (numWorkers === -1) {
          return forge$l.util.estimateCores(function(err, cores) {
            if (err) {
              cores = 2;
            }
            numWorkers = cores - 1;
            generate3();
          });
        }
        generate3();
        function generate3() {
          numWorkers = Math.max(1, numWorkers);
          var workers = [];
          for (var i3 = 0; i3 < numWorkers; ++i3) {
            workers[i3] = new Worker(workerScript);
          }
          for (var i3 = 0; i3 < numWorkers; ++i3) {
            workers[i3].addEventListener("message", workerMessage);
          }
          var found = false;
          function workerMessage(e2) {
            if (found) {
              return;
            }
            var data2 = e2.data;
            if (data2.found) {
              for (var i4 = 0; i4 < workers.length; ++i4) {
                workers[i4].terminate();
              }
              found = true;
              return callback(null, new BigInteger2(data2.prime, 16));
            }
            if (num.bitLength() > bits) {
              num = generateRandom(bits, rng);
            }
            var hex = num.toString(16);
            e2.target.postMessage({
              hex,
              workLoad
            });
            num.dAddOffset(range2, 0);
          }
        }
      }
      function generateRandom(bits, rng) {
        var num = new BigInteger2(bits, rng);
        var bits1 = bits - 1;
        if (!num.testBit(bits1)) {
          num.bitwiseTo(BigInteger2.ONE.shiftLeft(bits1), op_or2, num);
        }
        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
        return num;
      }
      function getMillerRabinTests(bits) {
        if (bits <= 100)
          return 27;
        if (bits <= 150)
          return 18;
        if (bits <= 200)
          return 15;
        if (bits <= 250)
          return 12;
        if (bits <= 300)
          return 9;
        if (bits <= 350)
          return 8;
        if (bits <= 400)
          return 7;
        if (bits <= 500)
          return 6;
        if (bits <= 600)
          return 5;
        if (bits <= 800)
          return 4;
        if (bits <= 1250)
          return 3;
        return 2;
      }
    })();
    var forge$k = forge$F;
    if (typeof BigInteger$1 === "undefined") {
      BigInteger$1 = forge$k.jsbn.BigInteger;
    }
    var BigInteger$1;
    var _crypto = forge$k.util.isNodejs ? require$$1__default2 : null;
    var asn1$7 = forge$k.asn1;
    var util2 = forge$k.util;
    forge$k.pki = forge$k.pki || {};
    forge$k.pki.rsa = forge$k.rsa = forge$k.rsa || {};
    var pki$4 = forge$k.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator$1 = {
      name: "PrivateKeyInfo",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PrivateKeyInfo.version",
        tagClass: asn1$7.Class.UNIVERSAL,
        type: asn1$7.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1$7.Class.UNIVERSAL,
        type: asn1$7.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1$7.Class.UNIVERSAL,
          type: asn1$7.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        name: "PrivateKeyInfo",
        tagClass: asn1$7.Class.UNIVERSAL,
        type: asn1$7.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    var rsaPrivateKeyValidator = {
      name: "RSAPrivateKey",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RSAPrivateKey.version",
        tagClass: asn1$7.Class.UNIVERSAL,
        type: asn1$7.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        name: "RSAPrivateKey.modulus",
        tagClass: asn1$7.Class.UNIVERSAL,
        type: asn1$7.Type.INTEGER,
        constructed: false,
        capture: "privateKeyModulus"
      }, {
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn1$7.Class.UNIVERSAL,
        type: asn1$7.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPublicExponent"
      }, {
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn1$7.Class.UNIVERSAL,
        type: asn1$7.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrivateExponent"
      }, {
        name: "RSAPrivateKey.prime1",
        tagClass: asn1$7.Class.UNIVERSAL,
        type: asn1$7.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime1"
      }, {
        name: "RSAPrivateKey.prime2",
        tagClass: asn1$7.Class.UNIVERSAL,
        type: asn1$7.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime2"
      }, {
        name: "RSAPrivateKey.exponent1",
        tagClass: asn1$7.Class.UNIVERSAL,
        type: asn1$7.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent1"
      }, {
        name: "RSAPrivateKey.exponent2",
        tagClass: asn1$7.Class.UNIVERSAL,
        type: asn1$7.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent2"
      }, {
        name: "RSAPrivateKey.coefficient",
        tagClass: asn1$7.Class.UNIVERSAL,
        type: asn1$7.Type.INTEGER,
        constructed: false,
        capture: "privateKeyCoefficient"
      }]
    };
    var rsaPublicKeyValidator = {
      name: "RSAPublicKey",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RSAPublicKey.modulus",
        tagClass: asn1$7.Class.UNIVERSAL,
        type: asn1$7.Type.INTEGER,
        constructed: false,
        capture: "publicKeyModulus"
      }, {
        name: "RSAPublicKey.exponent",
        tagClass: asn1$7.Class.UNIVERSAL,
        type: asn1$7.Type.INTEGER,
        constructed: false,
        capture: "publicKeyExponent"
      }]
    };
    var publicKeyValidator$2 = forge$k.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1$7.Class.UNIVERSAL,
        type: asn1$7.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1$7.Class.UNIVERSAL,
          type: asn1$7.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      }, {
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn1$7.Class.UNIVERSAL,
        type: asn1$7.Type.BITSTRING,
        constructed: false,
        value: [{
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn1$7.Class.UNIVERSAL,
          type: asn1$7.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    };
    var emsaPkcs1v15encode = function(md) {
      var oid;
      if (md.algorithm in pki$4.oids) {
        oid = pki$4.oids[md.algorithm];
      } else {
        var error2 = new Error("Unknown message digest algorithm.");
        error2.algorithm = md.algorithm;
        throw error2;
      }
      var oidBytes = asn1$7.oidToDer(oid).getBytes();
      var digestInfo = asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, []);
      var digestAlgorithm = asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, []);
      digestAlgorithm.value.push(asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.OID, false, oidBytes));
      digestAlgorithm.value.push(asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.NULL, false, ""));
      var digest = asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.OCTETSTRING, false, md.digest().getBytes());
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest);
      return asn1$7.toDer(digestInfo).getBytes();
    };
    var _modPow = function(x2, key2, pub) {
      if (pub) {
        return x2.modPow(key2.e, key2.n);
      }
      if (!key2.p || !key2.q) {
        return x2.modPow(key2.d, key2.n);
      }
      if (!key2.dP) {
        key2.dP = key2.d.mod(key2.p.subtract(BigInteger$1.ONE));
      }
      if (!key2.dQ) {
        key2.dQ = key2.d.mod(key2.q.subtract(BigInteger$1.ONE));
      }
      if (!key2.qInv) {
        key2.qInv = key2.q.modInverse(key2.p);
      }
      var r2;
      do {
        r2 = new BigInteger$1(forge$k.util.bytesToHex(forge$k.random.getBytes(key2.n.bitLength() / 8)), 16);
      } while (r2.compareTo(key2.n) >= 0 || !r2.gcd(key2.n).equals(BigInteger$1.ONE));
      x2 = x2.multiply(r2.modPow(key2.e, key2.n)).mod(key2.n);
      var xp = x2.mod(key2.p).modPow(key2.dP, key2.p);
      var xq = x2.mod(key2.q).modPow(key2.dQ, key2.q);
      while (xp.compareTo(xq) < 0) {
        xp = xp.add(key2.p);
      }
      var y3 = xp.subtract(xq).multiply(key2.qInv).mod(key2.p).multiply(key2.q).add(xq);
      y3 = y3.multiply(r2.modInverse(key2.n)).mod(key2.n);
      return y3;
    };
    pki$4.rsa.encrypt = function(m3, key2, bt2) {
      var pub = bt2;
      var eb;
      var k2 = Math.ceil(key2.n.bitLength() / 8);
      if (bt2 !== false && bt2 !== true) {
        pub = bt2 === 2;
        eb = _encodePkcs1_v1_5(m3, key2, bt2);
      } else {
        eb = forge$k.util.createBuffer();
        eb.putBytes(m3);
      }
      var x2 = new BigInteger$1(eb.toHex(), 16);
      var y3 = _modPow(x2, key2, pub);
      var yhex = y3.toString(16);
      var ed = forge$k.util.createBuffer();
      var zeros2 = k2 - Math.ceil(yhex.length / 2);
      while (zeros2 > 0) {
        ed.putByte(0);
        --zeros2;
      }
      ed.putBytes(forge$k.util.hexToBytes(yhex));
      return ed.getBytes();
    };
    pki$4.rsa.decrypt = function(ed, key2, pub, ml) {
      var k2 = Math.ceil(key2.n.bitLength() / 8);
      if (ed.length !== k2) {
        var error2 = new Error("Encrypted message length is invalid.");
        error2.length = ed.length;
        error2.expected = k2;
        throw error2;
      }
      var y3 = new BigInteger$1(forge$k.util.createBuffer(ed).toHex(), 16);
      if (y3.compareTo(key2.n) >= 0) {
        throw new Error("Encrypted message is invalid.");
      }
      var x2 = _modPow(y3, key2, pub);
      var xhex = x2.toString(16);
      var eb = forge$k.util.createBuffer();
      var zeros2 = k2 - Math.ceil(xhex.length / 2);
      while (zeros2 > 0) {
        eb.putByte(0);
        --zeros2;
      }
      eb.putBytes(forge$k.util.hexToBytes(xhex));
      if (ml !== false) {
        return _decodePkcs1_v1_5(eb.getBytes(), key2, pub);
      }
      return eb.getBytes();
    };
    pki$4.rsa.createKeyPairGenerationState = function(bits, e2, options2) {
      if (typeof bits === "string") {
        bits = parseInt(bits, 10);
      }
      bits = bits || 2048;
      options2 = options2 || {};
      var prng2 = options2.prng || forge$k.random;
      var rng = {
        nextBytes: function(x2) {
          var b2 = prng2.getBytesSync(x2.length);
          for (var i3 = 0; i3 < x2.length; ++i3) {
            x2[i3] = b2.charCodeAt(i3);
          }
        }
      };
      var algorithm = options2.algorithm || "PRIMEINC";
      var rval;
      if (algorithm === "PRIMEINC") {
        rval = {
          algorithm,
          state: 0,
          bits,
          rng,
          eInt: e2 || 65537,
          e: new BigInteger$1(null),
          p: null,
          q: null,
          qBits: bits >> 1,
          pBits: bits - (bits >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error("Invalid key generation algorithm: " + algorithm);
      }
      return rval;
    };
    pki$4.rsa.stepKeyPairGenerationState = function(state, n3) {
      if (!("algorithm" in state)) {
        state.algorithm = "PRIMEINC";
      }
      var THIRTY = new BigInteger$1(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or2 = function(x2, y3) {
        return x2 | y3;
      };
      var t1 = +new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n3 <= 0 || total < n3)) {
        if (state.state === 0) {
          var bits = state.p === null ? state.pBits : state.qBits;
          var bits1 = bits - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger$1(bits, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(BigInteger$1.ONE.shiftLeft(bits1), op_or2, state.num);
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = state.num.subtract(BigInteger$1.ONE).gcd(state.e).compareTo(BigInteger$1.ONE) === 0 ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger$1.ONE);
          state.q1 = state.q.subtract(BigInteger$1.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger$1.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d3 = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki$4.rsa.setPrivateKey(state.n, state.e, d3, state.p, state.q, d3.mod(state.p1), d3.mod(state.q1), state.q.modInverse(state.p)),
            publicKey: pki$4.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +new Date();
        total += t2 - t1;
        t1 = t2;
      }
      return state.keys !== null;
    };
    pki$4.rsa.generateKeyPair = function(bits, e2, options2, callback) {
      if (arguments.length === 1) {
        if (typeof bits === "object") {
          options2 = bits;
          bits = void 0;
        } else if (typeof bits === "function") {
          callback = bits;
          bits = void 0;
        }
      } else if (arguments.length === 2) {
        if (typeof bits === "number") {
          if (typeof e2 === "function") {
            callback = e2;
            e2 = void 0;
          } else if (typeof e2 !== "number") {
            options2 = e2;
            e2 = void 0;
          }
        } else {
          options2 = bits;
          callback = e2;
          bits = void 0;
          e2 = void 0;
        }
      } else if (arguments.length === 3) {
        if (typeof e2 === "number") {
          if (typeof options2 === "function") {
            callback = options2;
            options2 = void 0;
          }
        } else {
          callback = options2;
          options2 = e2;
          e2 = void 0;
        }
      }
      options2 = options2 || {};
      if (bits === void 0) {
        bits = options2.bits || 2048;
      }
      if (e2 === void 0) {
        e2 = options2.e || 65537;
      }
      if (!options2.prng && bits >= 256 && bits <= 16384 && (e2 === 65537 || e2 === 3)) {
        if (callback) {
          if (_detectNodeCrypto("generateKeyPair")) {
            return _crypto.generateKeyPair("rsa", {
              modulusLength: bits,
              publicExponent: e2,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            }, function(err, pub, priv) {
              if (err) {
                return callback(err);
              }
              callback(null, {
                privateKey: pki$4.privateKeyFromPem(priv),
                publicKey: pki$4.publicKeyFromPem(pub)
              });
            });
          }
          if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
            return util2.globalScope.crypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e2),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]).then(function(pair) {
              return util2.globalScope.crypto.subtle.exportKey("pkcs8", pair.privateKey);
            }).then(void 0, function(err) {
              callback(err);
            }).then(function(pkcs8) {
              if (pkcs8) {
                var privateKey = pki$4.privateKeyFromAsn1(asn1$7.fromDer(forge$k.util.createBuffer(pkcs8)));
                callback(null, {
                  privateKey,
                  publicKey: pki$4.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              }
            });
          }
          if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
            var genOp = util2.globalScope.msCrypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e2),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]);
            genOp.oncomplete = function(e3) {
              var pair = e3.target.result;
              var exportOp = util2.globalScope.msCrypto.subtle.exportKey("pkcs8", pair.privateKey);
              exportOp.oncomplete = function(e4) {
                var pkcs8 = e4.target.result;
                var privateKey = pki$4.privateKeyFromAsn1(asn1$7.fromDer(forge$k.util.createBuffer(pkcs8)));
                callback(null, {
                  privateKey,
                  publicKey: pki$4.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              };
              exportOp.onerror = function(err) {
                callback(err);
              };
            };
            genOp.onerror = function(err) {
              callback(err);
            };
            return;
          }
        } else {
          if (_detectNodeCrypto("generateKeyPairSync")) {
            var keypair = _crypto.generateKeyPairSync("rsa", {
              modulusLength: bits,
              publicExponent: e2,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            });
            return {
              privateKey: pki$4.privateKeyFromPem(keypair.privateKey),
              publicKey: pki$4.publicKeyFromPem(keypair.publicKey)
            };
          }
        }
      }
      var state = pki$4.rsa.createKeyPairGenerationState(bits, e2, options2);
      if (!callback) {
        pki$4.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options2, callback);
    };
    pki$4.setRsaPublicKey = pki$4.rsa.setPublicKey = function(n3, e2) {
      var key2 = {
        n: n3,
        e: e2
      };
      key2.encrypt = function(data2, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = {
            encode: function(m3, key3, pub) {
              return _encodePkcs1_v1_5(m3, key3, 2).getBytes();
            }
          };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            encode: function(m3, key3) {
              return forge$k.pkcs1.encode_rsa_oaep(key3, m3, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { encode: function(e4) {
            return e4;
          } };
        } else if (typeof scheme === "string") {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e3 = scheme.encode(data2, key2, true);
        return pki$4.rsa.encrypt(e3, key2, true);
      };
      key2.verify = function(digest, signature, scheme) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSASSA-PKCS1-V1_5";
        }
        if (scheme === "RSASSA-PKCS1-V1_5") {
          scheme = {
            verify: function(digest2, d4) {
              d4 = _decodePkcs1_v1_5(d4, key2, true);
              var obj = asn1$7.fromDer(d4);
              return digest2 === obj.value[1].value;
            }
          };
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = {
            verify: function(digest2, d4) {
              d4 = _decodePkcs1_v1_5(d4, key2, true);
              return digest2 === d4;
            }
          };
        }
        var d3 = pki$4.rsa.decrypt(signature, key2, true, false);
        return scheme.verify(digest, d3, key2.n.bitLength());
      };
      return key2;
    };
    pki$4.setRsaPrivateKey = pki$4.rsa.setPrivateKey = function(n3, e2, d3, p2, q2, dP, dQ, qInv) {
      var key2 = {
        n: n3,
        e: e2,
        d: d3,
        p: p2,
        q: q2,
        dP,
        dQ,
        qInv
      };
      key2.decrypt = function(data2, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        var d4 = pki$4.rsa.decrypt(data2, key2, false, false);
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = { decode: _decodePkcs1_v1_5 };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            decode: function(d5, key3) {
              return forge$k.pkcs1.decode_rsa_oaep(key3, d5, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { decode: function(d5) {
            return d5;
          } };
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d4, key2, false);
      };
      key2.sign = function(md, scheme) {
        var bt2 = false;
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        }
        if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
          scheme = { encode: emsaPkcs1v15encode };
          bt2 = 1;
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = { encode: function() {
            return md;
          } };
          bt2 = 1;
        }
        var d4 = scheme.encode(md, key2.n.bitLength());
        return pki$4.rsa.encrypt(d4, key2, bt2);
      };
      return key2;
    };
    pki$4.wrapRsaPrivateKey = function(rsaKey) {
      return asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, [
        asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.INTEGER, false, asn1$7.integerToDer(0).getBytes()),
        asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, [
          asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.OID, false, asn1$7.oidToDer(pki$4.oids.rsaEncryption).getBytes()),
          asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.NULL, false, "")
        ]),
        asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.OCTETSTRING, false, asn1$7.toDer(rsaKey).getBytes())
      ]);
    };
    pki$4.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1$7.validate(obj, privateKeyValidator$1, capture, errors)) {
        obj = asn1$7.fromDer(forge$k.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors = [];
      if (!asn1$7.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
        var error2 = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
        error2.errors = errors;
        throw error2;
      }
      var n3, e2, d3, p2, q2, dP, dQ, qInv;
      n3 = forge$k.util.createBuffer(capture.privateKeyModulus).toHex();
      e2 = forge$k.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d3 = forge$k.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p2 = forge$k.util.createBuffer(capture.privateKeyPrime1).toHex();
      q2 = forge$k.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge$k.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge$k.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge$k.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki$4.setRsaPrivateKey(new BigInteger$1(n3, 16), new BigInteger$1(e2, 16), new BigInteger$1(d3, 16), new BigInteger$1(p2, 16), new BigInteger$1(q2, 16), new BigInteger$1(dP, 16), new BigInteger$1(dQ, 16), new BigInteger$1(qInv, 16));
    };
    pki$4.privateKeyToAsn1 = pki$4.privateKeyToRSAPrivateKey = function(key2) {
      return asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, [
        asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.INTEGER, false, asn1$7.integerToDer(0).getBytes()),
        asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.INTEGER, false, _bnToBytes(key2.n)),
        asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.INTEGER, false, _bnToBytes(key2.e)),
        asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.INTEGER, false, _bnToBytes(key2.d)),
        asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.INTEGER, false, _bnToBytes(key2.p)),
        asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.INTEGER, false, _bnToBytes(key2.q)),
        asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.INTEGER, false, _bnToBytes(key2.dP)),
        asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.INTEGER, false, _bnToBytes(key2.dQ)),
        asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.INTEGER, false, _bnToBytes(key2.qInv))
      ]);
    };
    pki$4.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1$7.validate(obj, publicKeyValidator$2, capture, errors)) {
        var oid = asn1$7.derToOid(capture.publicKeyOid);
        if (oid !== pki$4.oids.rsaEncryption) {
          var error2 = new Error("Cannot read public key. Unknown OID.");
          error2.oid = oid;
          throw error2;
        }
        obj = capture.rsaPublicKey;
      }
      errors = [];
      if (!asn1$7.validate(obj, rsaPublicKeyValidator, capture, errors)) {
        var error2 = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
        error2.errors = errors;
        throw error2;
      }
      var n3 = forge$k.util.createBuffer(capture.publicKeyModulus).toHex();
      var e2 = forge$k.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki$4.setRsaPublicKey(new BigInteger$1(n3, 16), new BigInteger$1(e2, 16));
    };
    pki$4.publicKeyToAsn1 = pki$4.publicKeyToSubjectPublicKeyInfo = function(key2) {
      return asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, [
        asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, [
          asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.OID, false, asn1$7.oidToDer(pki$4.oids.rsaEncryption).getBytes()),
          asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.NULL, false, "")
        ]),
        asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.BITSTRING, false, [
          pki$4.publicKeyToRSAPublicKey(key2)
        ])
      ]);
    };
    pki$4.publicKeyToRSAPublicKey = function(key2) {
      return asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, [
        asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.INTEGER, false, _bnToBytes(key2.n)),
        asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.INTEGER, false, _bnToBytes(key2.e))
      ]);
    };
    function _encodePkcs1_v1_5(m3, key2, bt2) {
      var eb = forge$k.util.createBuffer();
      var k2 = Math.ceil(key2.n.bitLength() / 8);
      if (m3.length > k2 - 11) {
        var error2 = new Error("Message is too long for PKCS#1 v1.5 padding.");
        error2.length = m3.length;
        error2.max = k2 - 11;
        throw error2;
      }
      eb.putByte(0);
      eb.putByte(bt2);
      var padNum = k2 - 3 - m3.length;
      var padByte;
      if (bt2 === 0 || bt2 === 1) {
        padByte = bt2 === 0 ? 0 : 255;
        for (var i3 = 0; i3 < padNum; ++i3) {
          eb.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes = forge$k.random.getBytes(padNum);
          for (var i3 = 0; i3 < padNum; ++i3) {
            padByte = padBytes.charCodeAt(i3);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb.putByte(0);
      eb.putBytes(m3);
      return eb;
    }
    function _decodePkcs1_v1_5(em, key2, pub, ml) {
      var k2 = Math.ceil(key2.n.bitLength() / 8);
      var eb = forge$k.util.createBuffer(em);
      var first2 = eb.getByte();
      var bt2 = eb.getByte();
      if (first2 !== 0 || pub && bt2 !== 0 && bt2 !== 1 || !pub && bt2 != 2 || pub && bt2 === 0 && typeof ml === "undefined") {
        throw new Error("Encryption block is invalid.");
      }
      var padNum = 0;
      if (bt2 === 0) {
        padNum = k2 - 3 - ml;
        for (var i3 = 0; i3 < padNum; ++i3) {
          if (eb.getByte() !== 0) {
            throw new Error("Encryption block is invalid.");
          }
        }
      } else if (bt2 === 1) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() !== 255) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      } else if (bt2 === 2) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() === 0) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      }
      var zero = eb.getByte();
      if (zero !== 0 || padNum !== k2 - 3 - eb.length()) {
        throw new Error("Encryption block is invalid.");
      }
      return eb.getBytes();
    }
    function _generateKeyPair(state, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      var opts = {
        algorithm: {
          name: options2.algorithm || "PRIMEINC",
          options: {
            workers: options2.workers || 2,
            workLoad: options2.workLoad || 100,
            workerScript: options2.workerScript
          }
        }
      };
      if ("prng" in options2) {
        opts.prng = options2.prng;
      }
      generate3();
      function generate3() {
        getPrime(state.pBits, function(err, num) {
          if (err) {
            return callback(err);
          }
          state.p = num;
          if (state.q !== null) {
            return finish3(err, state.q);
          }
          getPrime(state.qBits, finish3);
        });
      }
      function getPrime(bits, callback2) {
        forge$k.prime.generateProbablePrime(bits, opts, callback2);
      }
      function finish3(err, num) {
        if (err) {
          return callback(err);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger$1.ONE).gcd(state.e).compareTo(BigInteger$1.ONE) !== 0) {
          state.p = null;
          generate3();
          return;
        }
        if (state.q.subtract(BigInteger$1.ONE).gcd(state.e).compareTo(BigInteger$1.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish3);
          return;
        }
        state.p1 = state.p.subtract(BigInteger$1.ONE);
        state.q1 = state.q.subtract(BigInteger$1.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger$1.ONE) !== 0) {
          state.p = state.q = null;
          generate3();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish3);
          return;
        }
        var d3 = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki$4.rsa.setPrivateKey(state.n, state.e, d3, state.p, state.q, d3.mod(state.p1), d3.mod(state.q1), state.q.modInverse(state.p)),
          publicKey: pki$4.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
    }
    function _bnToBytes(b2) {
      var hex = b2.toString(16);
      if (hex[0] >= "8") {
        hex = "00" + hex;
      }
      var bytes2 = forge$k.util.hexToBytes(hex);
      if (bytes2.length > 1 && (bytes2.charCodeAt(0) === 0 && (bytes2.charCodeAt(1) & 128) === 0 || bytes2.charCodeAt(0) === 255 && (bytes2.charCodeAt(1) & 128) === 128)) {
        return bytes2.substr(1);
      }
      return bytes2;
    }
    function _getMillerRabinTests(bits) {
      if (bits <= 100)
        return 27;
      if (bits <= 150)
        return 18;
      if (bits <= 200)
        return 15;
      if (bits <= 250)
        return 12;
      if (bits <= 300)
        return 9;
      if (bits <= 350)
        return 8;
      if (bits <= 400)
        return 7;
      if (bits <= 500)
        return 6;
      if (bits <= 600)
        return 5;
      if (bits <= 800)
        return 4;
      if (bits <= 1250)
        return 3;
      return 2;
    }
    function _detectNodeCrypto(fn2) {
      return forge$k.util.isNodejs && typeof _crypto[fn2] === "function";
    }
    function _detectSubtleCrypto(fn2) {
      return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.crypto === "object" && typeof util2.globalScope.crypto.subtle === "object" && typeof util2.globalScope.crypto.subtle[fn2] === "function";
    }
    function _detectSubtleMsCrypto(fn2) {
      return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.msCrypto === "object" && typeof util2.globalScope.msCrypto.subtle === "object" && typeof util2.globalScope.msCrypto.subtle[fn2] === "function";
    }
    function _intToUint8Array(x2) {
      var bytes2 = forge$k.util.hexToBytes(x2.toString(16));
      var buffer = new Uint8Array(bytes2.length);
      for (var i3 = 0; i3 < bytes2.length; ++i3) {
        buffer[i3] = bytes2.charCodeAt(i3);
      }
      return buffer;
    }
    var forge$j = forge$F;
    var asn1$6 = forge$j.asn1;
    var pki$3 = forge$j.pki = forge$j.pki || {};
    pki$3.pbe = forge$j.pbe = forge$j.pbe || {};
    var oids$1 = pki$3.oids;
    var encryptedPrivateKeyValidator = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
        tagClass: asn1$6.Class.UNIVERSAL,
        type: asn1$6.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1$6.Class.UNIVERSAL,
          type: asn1$6.Type.OID,
          constructed: false,
          capture: "encryptionOid"
        }, {
          name: "AlgorithmIdentifier.parameters",
          tagClass: asn1$6.Class.UNIVERSAL,
          type: asn1$6.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "encryptionParams"
        }]
      }, {
        name: "EncryptedPrivateKeyInfo.encryptedData",
        tagClass: asn1$6.Class.UNIVERSAL,
        type: asn1$6.Type.OCTETSTRING,
        constructed: false,
        capture: "encryptedData"
      }]
    };
    var PBES2AlgorithmsValidator = {
      name: "PBES2Algorithms",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc",
        tagClass: asn1$6.Class.UNIVERSAL,
        type: asn1$6.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc.oid",
          tagClass: asn1$6.Class.UNIVERSAL,
          type: asn1$6.Type.OID,
          constructed: false,
          capture: "kdfOid"
        }, {
          name: "PBES2Algorithms.params",
          tagClass: asn1$6.Class.UNIVERSAL,
          type: asn1$6.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.params.salt",
            tagClass: asn1$6.Class.UNIVERSAL,
            type: asn1$6.Type.OCTETSTRING,
            constructed: false,
            capture: "kdfSalt"
          }, {
            name: "PBES2Algorithms.params.iterationCount",
            tagClass: asn1$6.Class.UNIVERSAL,
            type: asn1$6.Type.INTEGER,
            constructed: false,
            capture: "kdfIterationCount"
          }, {
            name: "PBES2Algorithms.params.keyLength",
            tagClass: asn1$6.Class.UNIVERSAL,
            type: asn1$6.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "keyLength"
          }, {
            name: "PBES2Algorithms.params.prf",
            tagClass: asn1$6.Class.UNIVERSAL,
            type: asn1$6.Type.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "PBES2Algorithms.params.prf.algorithm",
              tagClass: asn1$6.Class.UNIVERSAL,
              type: asn1$6.Type.OID,
              constructed: false,
              capture: "prfOid"
            }]
          }]
        }]
      }, {
        name: "PBES2Algorithms.encryptionScheme",
        tagClass: asn1$6.Class.UNIVERSAL,
        type: asn1$6.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.encryptionScheme.oid",
          tagClass: asn1$6.Class.UNIVERSAL,
          type: asn1$6.Type.OID,
          constructed: false,
          capture: "encOid"
        }, {
          name: "PBES2Algorithms.encryptionScheme.iv",
          tagClass: asn1$6.Class.UNIVERSAL,
          type: asn1$6.Type.OCTETSTRING,
          constructed: false,
          capture: "encIv"
        }]
      }]
    };
    var pkcs12PbeParamsValidator = {
      name: "pkcs-12PbeParams",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "pkcs-12PbeParams.salt",
        tagClass: asn1$6.Class.UNIVERSAL,
        type: asn1$6.Type.OCTETSTRING,
        constructed: false,
        capture: "salt"
      }, {
        name: "pkcs-12PbeParams.iterations",
        tagClass: asn1$6.Class.UNIVERSAL,
        type: asn1$6.Type.INTEGER,
        constructed: false,
        capture: "iterations"
      }]
    };
    pki$3.encryptPrivateKeyInfo = function(obj, password, options2) {
      options2 = options2 || {};
      options2.saltSize = options2.saltSize || 8;
      options2.count = options2.count || 2048;
      options2.algorithm = options2.algorithm || "aes128";
      options2.prfAlgorithm = options2.prfAlgorithm || "sha1";
      var salt = forge$j.random.getBytesSync(options2.saltSize);
      var count = options2.count;
      var countBytes = asn1$6.integerToDer(count);
      var dkLen;
      var encryptionAlgorithm;
      var encryptedData;
      if (options2.algorithm.indexOf("aes") === 0 || options2.algorithm === "des") {
        var ivLen, encOid, cipherFn;
        switch (options2.algorithm) {
          case "aes128":
            dkLen = 16;
            ivLen = 16;
            encOid = oids$1["aes128-CBC"];
            cipherFn = forge$j.aes.createEncryptionCipher;
            break;
          case "aes192":
            dkLen = 24;
            ivLen = 16;
            encOid = oids$1["aes192-CBC"];
            cipherFn = forge$j.aes.createEncryptionCipher;
            break;
          case "aes256":
            dkLen = 32;
            ivLen = 16;
            encOid = oids$1["aes256-CBC"];
            cipherFn = forge$j.aes.createEncryptionCipher;
            break;
          case "des":
            dkLen = 8;
            ivLen = 8;
            encOid = oids$1["desCBC"];
            cipherFn = forge$j.des.createEncryptionCipher;
            break;
          default:
            var error2 = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error2.algorithm = options2.algorithm;
            throw error2;
        }
        var prfAlgorithm = "hmacWith" + options2.prfAlgorithm.toUpperCase();
        var md = prfAlgorithmToMessageDigest(prfAlgorithm);
        var dk = forge$j.pkcs5.pbkdf2(password, salt, count, dkLen, md);
        var iv = forge$j.random.getBytesSync(ivLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1$6.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
        encryptionAlgorithm = asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
          asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.OID, false, asn1$6.oidToDer(oids$1["pkcs5PBES2"]).getBytes()),
          asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
            asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
              asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.OID, false, asn1$6.oidToDer(oids$1["pkcs5PBKDF2"]).getBytes()),
              params
            ]),
            asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
              asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.OID, false, asn1$6.oidToDer(encOid).getBytes()),
              asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.OCTETSTRING, false, iv)
            ])
          ])
        ]);
      } else if (options2.algorithm === "3des") {
        dkLen = 24;
        var saltBytes = new forge$j.util.ByteBuffer(salt);
        var dk = pki$3.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
        var iv = pki$3.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
        var cipher = forge$j.des.createEncryptionCipher(dk);
        cipher.start(iv);
        cipher.update(asn1$6.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
          asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.OID, false, asn1$6.oidToDer(oids$1["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()),
          asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
            asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.OCTETSTRING, false, salt),
            asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.INTEGER, false, countBytes.getBytes())
          ])
        ]);
      } else {
        var error2 = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error2.algorithm = options2.algorithm;
        throw error2;
      }
      var rval = asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
        encryptionAlgorithm,
        asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.OCTETSTRING, false, encryptedData)
      ]);
      return rval;
    };
    pki$3.decryptPrivateKeyInfo = function(obj, password) {
      var rval = null;
      var capture = {};
      var errors = [];
      if (!asn1$6.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
        var error2 = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error2.errors = errors;
        throw error2;
      }
      var oid = asn1$6.derToOid(capture.encryptionOid);
      var cipher = pki$3.pbe.getCipher(oid, capture.encryptionParams, password);
      var encrypted = forge$j.util.createBuffer(capture.encryptedData);
      cipher.update(encrypted);
      if (cipher.finish()) {
        rval = asn1$6.fromDer(cipher.output);
      }
      return rval;
    };
    pki$3.encryptedPrivateKeyToPem = function(epki, maxline) {
      var msg = {
        type: "ENCRYPTED PRIVATE KEY",
        body: asn1$6.toDer(epki).getBytes()
      };
      return forge$j.pem.encode(msg, { maxline });
    };
    pki$3.encryptedPrivateKeyFromPem = function(pem2) {
      var msg = forge$j.pem.decode(pem2)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY") {
        var error2 = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
        error2.headerType = msg.type;
        throw error2;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
      }
      return asn1$6.fromDer(msg.body);
    };
    pki$3.encryptRsaPrivateKey = function(rsaKey, password, options2) {
      options2 = options2 || {};
      if (!options2.legacy) {
        var rval = pki$3.wrapRsaPrivateKey(pki$3.privateKeyToAsn1(rsaKey));
        rval = pki$3.encryptPrivateKeyInfo(rval, password, options2);
        return pki$3.encryptedPrivateKeyToPem(rval);
      }
      var algorithm;
      var iv;
      var dkLen;
      var cipherFn;
      switch (options2.algorithm) {
        case "aes128":
          algorithm = "AES-128-CBC";
          dkLen = 16;
          iv = forge$j.random.getBytesSync(16);
          cipherFn = forge$j.aes.createEncryptionCipher;
          break;
        case "aes192":
          algorithm = "AES-192-CBC";
          dkLen = 24;
          iv = forge$j.random.getBytesSync(16);
          cipherFn = forge$j.aes.createEncryptionCipher;
          break;
        case "aes256":
          algorithm = "AES-256-CBC";
          dkLen = 32;
          iv = forge$j.random.getBytesSync(16);
          cipherFn = forge$j.aes.createEncryptionCipher;
          break;
        case "3des":
          algorithm = "DES-EDE3-CBC";
          dkLen = 24;
          iv = forge$j.random.getBytesSync(8);
          cipherFn = forge$j.des.createEncryptionCipher;
          break;
        case "des":
          algorithm = "DES-CBC";
          dkLen = 8;
          iv = forge$j.random.getBytesSync(8);
          cipherFn = forge$j.des.createEncryptionCipher;
          break;
        default:
          var error2 = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options2.algorithm + '".');
          error2.algorithm = options2.algorithm;
          throw error2;
      }
      var dk = forge$j.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1$6.toDer(pki$3.privateKeyToAsn1(rsaKey)));
      cipher.finish();
      var msg = {
        type: "RSA PRIVATE KEY",
        procType: {
          version: "4",
          type: "ENCRYPTED"
        },
        dekInfo: {
          algorithm,
          parameters: forge$j.util.bytesToHex(iv).toUpperCase()
        },
        body: cipher.output.getBytes()
      };
      return forge$j.pem.encode(msg);
    };
    pki$3.decryptRsaPrivateKey = function(pem2, password) {
      var rval = null;
      var msg = forge$j.pem.decode(pem2)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error2 = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        error2.headerType = error2;
        throw error2;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        var dkLen;
        var cipherFn;
        switch (msg.dekInfo.algorithm) {
          case "DES-CBC":
            dkLen = 8;
            cipherFn = forge$j.des.createDecryptionCipher;
            break;
          case "DES-EDE3-CBC":
            dkLen = 24;
            cipherFn = forge$j.des.createDecryptionCipher;
            break;
          case "AES-128-CBC":
            dkLen = 16;
            cipherFn = forge$j.aes.createDecryptionCipher;
            break;
          case "AES-192-CBC":
            dkLen = 24;
            cipherFn = forge$j.aes.createDecryptionCipher;
            break;
          case "AES-256-CBC":
            dkLen = 32;
            cipherFn = forge$j.aes.createDecryptionCipher;
            break;
          case "RC2-40-CBC":
            dkLen = 5;
            cipherFn = function(key2) {
              return forge$j.rc2.createDecryptionCipher(key2, 40);
            };
            break;
          case "RC2-64-CBC":
            dkLen = 8;
            cipherFn = function(key2) {
              return forge$j.rc2.createDecryptionCipher(key2, 64);
            };
            break;
          case "RC2-128-CBC":
            dkLen = 16;
            cipherFn = function(key2) {
              return forge$j.rc2.createDecryptionCipher(key2, 128);
            };
            break;
          default:
            var error2 = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
            error2.algorithm = msg.dekInfo.algorithm;
            throw error2;
        }
        var iv = forge$j.util.hexToBytes(msg.dekInfo.parameters);
        var dk = forge$j.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(forge$j.util.createBuffer(msg.body));
        if (cipher.finish()) {
          rval = cipher.output.getBytes();
        } else {
          return rval;
        }
      } else {
        rval = msg.body;
      }
      if (msg.type === "ENCRYPTED PRIVATE KEY") {
        rval = pki$3.decryptPrivateKeyInfo(asn1$6.fromDer(rval), password);
      } else {
        rval = asn1$6.fromDer(rval);
      }
      if (rval !== null) {
        rval = pki$3.privateKeyFromAsn1(rval);
      }
      return rval;
    };
    pki$3.pbe.generatePkcs12Key = function(password, salt, id, iter, n3, md) {
      var j2, l2;
      if (typeof md === "undefined" || md === null) {
        if (!("sha1" in forge$j.md)) {
          throw new Error('"sha1" hash algorithm unavailable.');
        }
        md = forge$j.md.sha1.create();
      }
      var u2 = md.digestLength;
      var v2 = md.blockLength;
      var result2 = new forge$j.util.ByteBuffer();
      var passBuf = new forge$j.util.ByteBuffer();
      if (password !== null && password !== void 0) {
        for (l2 = 0; l2 < password.length; l2++) {
          passBuf.putInt16(password.charCodeAt(l2));
        }
        passBuf.putInt16(0);
      }
      var p2 = passBuf.length();
      var s3 = salt.length();
      var D3 = new forge$j.util.ByteBuffer();
      D3.fillWithByte(id, v2);
      var Slen = v2 * Math.ceil(s3 / v2);
      var S3 = new forge$j.util.ByteBuffer();
      for (l2 = 0; l2 < Slen; l2++) {
        S3.putByte(salt.at(l2 % s3));
      }
      var Plen = v2 * Math.ceil(p2 / v2);
      var P2 = new forge$j.util.ByteBuffer();
      for (l2 = 0; l2 < Plen; l2++) {
        P2.putByte(passBuf.at(l2 % p2));
      }
      var I3 = S3;
      I3.putBuffer(P2);
      var c2 = Math.ceil(n3 / u2);
      for (var i3 = 1; i3 <= c2; i3++) {
        var buf = new forge$j.util.ByteBuffer();
        buf.putBytes(D3.bytes());
        buf.putBytes(I3.bytes());
        for (var round = 0; round < iter; round++) {
          md.start();
          md.update(buf.getBytes());
          buf = md.digest();
        }
        var B3 = new forge$j.util.ByteBuffer();
        for (l2 = 0; l2 < v2; l2++) {
          B3.putByte(buf.at(l2 % u2));
        }
        var k2 = Math.ceil(s3 / v2) + Math.ceil(p2 / v2);
        var Inew = new forge$j.util.ByteBuffer();
        for (j2 = 0; j2 < k2; j2++) {
          var chunk = new forge$j.util.ByteBuffer(I3.getBytes(v2));
          var x2 = 511;
          for (l2 = B3.length() - 1; l2 >= 0; l2--) {
            x2 = x2 >> 8;
            x2 += B3.at(l2) + chunk.at(l2);
            chunk.setAt(l2, x2 & 255);
          }
          Inew.putBuffer(chunk);
        }
        I3 = Inew;
        result2.putBuffer(buf);
      }
      result2.truncate(result2.length() - n3);
      return result2;
    };
    pki$3.pbe.getCipher = function(oid, params, password) {
      switch (oid) {
        case pki$3.oids["pkcs5PBES2"]:
          return pki$3.pbe.getCipherForPBES2(oid, params, password);
        case pki$3.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        case pki$3.oids["pbewithSHAAnd40BitRC2-CBC"]:
          return pki$3.pbe.getCipherForPKCS12PBE(oid, params, password);
        default:
          var error2 = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
          error2.oid = oid;
          error2.supportedOids = [
            "pkcs5PBES2",
            "pbeWithSHAAnd3-KeyTripleDES-CBC",
            "pbewithSHAAnd40BitRC2-CBC"
          ];
          throw error2;
      }
    };
    pki$3.pbe.getCipherForPBES2 = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1$6.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
        var error2 = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error2.errors = errors;
        throw error2;
      }
      oid = asn1$6.derToOid(capture.kdfOid);
      if (oid !== pki$3.oids["pkcs5PBKDF2"]) {
        var error2 = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
        error2.oid = oid;
        error2.supportedOids = ["pkcs5PBKDF2"];
        throw error2;
      }
      oid = asn1$6.derToOid(capture.encOid);
      if (oid !== pki$3.oids["aes128-CBC"] && oid !== pki$3.oids["aes192-CBC"] && oid !== pki$3.oids["aes256-CBC"] && oid !== pki$3.oids["des-EDE3-CBC"] && oid !== pki$3.oids["desCBC"]) {
        var error2 = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
        error2.oid = oid;
        error2.supportedOids = [
          "aes128-CBC",
          "aes192-CBC",
          "aes256-CBC",
          "des-EDE3-CBC",
          "desCBC"
        ];
        throw error2;
      }
      var salt = capture.kdfSalt;
      var count = forge$j.util.createBuffer(capture.kdfIterationCount);
      count = count.getInt(count.length() << 3);
      var dkLen;
      var cipherFn;
      switch (pki$3.oids[oid]) {
        case "aes128-CBC":
          dkLen = 16;
          cipherFn = forge$j.aes.createDecryptionCipher;
          break;
        case "aes192-CBC":
          dkLen = 24;
          cipherFn = forge$j.aes.createDecryptionCipher;
          break;
        case "aes256-CBC":
          dkLen = 32;
          cipherFn = forge$j.aes.createDecryptionCipher;
          break;
        case "des-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge$j.des.createDecryptionCipher;
          break;
        case "desCBC":
          dkLen = 8;
          cipherFn = forge$j.des.createDecryptionCipher;
          break;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var dk = forge$j.pkcs5.pbkdf2(password, salt, count, dkLen, md);
      var iv = capture.encIv;
      var cipher = cipherFn(dk);
      cipher.start(iv);
      return cipher;
    };
    pki$3.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1$6.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
        var error2 = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error2.errors = errors;
        throw error2;
      }
      var salt = forge$j.util.createBuffer(capture.salt);
      var count = forge$j.util.createBuffer(capture.iterations);
      count = count.getInt(count.length() << 3);
      var dkLen, dIvLen, cipherFn;
      switch (oid) {
        case pki$3.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          dkLen = 24;
          dIvLen = 8;
          cipherFn = forge$j.des.startDecrypting;
          break;
        case pki$3.oids["pbewithSHAAnd40BitRC2-CBC"]:
          dkLen = 5;
          dIvLen = 8;
          cipherFn = function(key3, iv2) {
            var cipher = forge$j.rc2.createDecryptionCipher(key3, 40);
            cipher.start(iv2, null);
            return cipher;
          };
          break;
        default:
          var error2 = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
          error2.oid = oid;
          throw error2;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var key2 = pki$3.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
      md.start();
      var iv = pki$3.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
      return cipherFn(key2, iv);
    };
    pki$3.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
      if (typeof md === "undefined" || md === null) {
        if (!("md5" in forge$j.md)) {
          throw new Error('"md5" hash algorithm unavailable.');
        }
        md = forge$j.md.md5.create();
      }
      if (salt === null) {
        salt = "";
      }
      var digests = [hash(md, password + salt)];
      for (var length = 16, i3 = 1; length < dkLen; ++i3, length += 16) {
        digests.push(hash(md, digests[i3 - 1] + password + salt));
      }
      return digests.join("").substr(0, dkLen);
    };
    function hash(md, bytes2) {
      return md.start().update(bytes2).digest().getBytes();
    }
    function prfOidToMessageDigest(prfOid) {
      var prfAlgorithm;
      if (!prfOid) {
        prfAlgorithm = "hmacWithSHA1";
      } else {
        prfAlgorithm = pki$3.oids[asn1$6.derToOid(prfOid)];
        if (!prfAlgorithm) {
          var error2 = new Error("Unsupported PRF OID.");
          error2.oid = prfOid;
          error2.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error2;
        }
      }
      return prfAlgorithmToMessageDigest(prfAlgorithm);
    }
    function prfAlgorithmToMessageDigest(prfAlgorithm) {
      var factory2 = forge$j.md;
      switch (prfAlgorithm) {
        case "hmacWithSHA224":
          factory2 = forge$j.md.sha512;
        case "hmacWithSHA1":
        case "hmacWithSHA256":
        case "hmacWithSHA384":
        case "hmacWithSHA512":
          prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
          break;
        default:
          var error2 = new Error("Unsupported PRF algorithm.");
          error2.algorithm = prfAlgorithm;
          error2.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error2;
      }
      if (!factory2 || !(prfAlgorithm in factory2)) {
        throw new Error("Unknown hash algorithm: " + prfAlgorithm);
      }
      return factory2[prfAlgorithm].create();
    }
    function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
      var params = asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
        asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.OCTETSTRING, false, salt),
        asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.INTEGER, false, countBytes.getBytes())
      ]);
      if (prfAlgorithm !== "hmacWithSHA1") {
        params.value.push(asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.INTEGER, false, forge$j.util.hexToBytes(dkLen.toString(16))), asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
          asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.OID, false, asn1$6.oidToDer(pki$3.oids[prfAlgorithm]).getBytes()),
          asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.NULL, false, "")
        ]));
      }
      return params;
    }
    var forge$i = forge$F;
    var asn1$5 = forge$i.asn1;
    var p7v = forge$i.pkcs7asn1 = forge$i.pkcs7asn1 || {};
    forge$i.pkcs7 = forge$i.pkcs7 || {};
    forge$i.pkcs7.asn1 = p7v;
    var contentInfoValidator$1 = {
      name: "ContentInfo",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "ContentInfo.ContentType",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        captureAsn1: "content"
      }]
    };
    p7v.contentInfoValidator = contentInfoValidator$1;
    var encryptedContentInfoValidator = {
      name: "EncryptedContentInfo",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedContentInfo.contentType",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
          tagClass: asn1$5.Class.UNIVERSAL,
          type: asn1$5.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
          tagClass: asn1$5.Class.UNIVERSAL,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "EncryptedContentInfo.encryptedContent",
        tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
        type: 0,
        capture: "encryptedContent",
        captureAsn1: "encryptedContentAsn1"
      }]
    };
    p7v.envelopedDataValidator = {
      name: "EnvelopedData",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EnvelopedData.Version",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "EnvelopedData.RecipientInfos",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.SET,
        constructed: true,
        captureAsn1: "recipientInfos"
      }].concat(encryptedContentInfoValidator)
    };
    p7v.encryptedDataValidator = {
      name: "EncryptedData",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedData.Version",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.INTEGER,
        constructed: false,
        capture: "version"
      }].concat(encryptedContentInfoValidator)
    };
    var signerValidator = {
      name: "SignerInfo",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.version",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.INTEGER,
        constructed: false
      }, {
        name: "SignerInfo.issuerAndSerialNumber",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.issuerAndSerialNumber.issuer",
          tagClass: asn1$5.Class.UNIVERSAL,
          type: asn1$5.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "SignerInfo.issuerAndSerialNumber.serialNumber",
          tagClass: asn1$5.Class.UNIVERSAL,
          type: asn1$5.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "SignerInfo.digestAlgorithm",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.digestAlgorithm.algorithm",
          tagClass: asn1$5.Class.UNIVERSAL,
          type: asn1$5.Type.OID,
          constructed: false,
          capture: "digestAlgorithm"
        }, {
          name: "SignerInfo.digestAlgorithm.parameter",
          tagClass: asn1$5.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "digestParameter",
          optional: true
        }]
      }, {
        name: "SignerInfo.authenticatedAttributes",
        tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: "authenticatedAttributes"
      }, {
        name: "SignerInfo.digestEncryptionAlgorithm",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.SEQUENCE,
        constructed: true,
        capture: "signatureAlgorithm"
      }, {
        name: "SignerInfo.encryptedDigest",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.OCTETSTRING,
        constructed: false,
        capture: "signature"
      }, {
        name: "SignerInfo.unauthenticatedAttributes",
        tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        capture: "unauthenticatedAttributes"
      }]
    };
    p7v.signedDataValidator = {
      name: "SignedData",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "SignedData.Version",
          tagClass: asn1$5.Class.UNIVERSAL,
          type: asn1$5.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        {
          name: "SignedData.DigestAlgorithms",
          tagClass: asn1$5.Class.UNIVERSAL,
          type: asn1$5.Type.SET,
          constructed: true,
          captureAsn1: "digestAlgorithms"
        },
        contentInfoValidator$1,
        {
          name: "SignedData.Certificates",
          tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
          type: 0,
          optional: true,
          captureAsn1: "certificates"
        },
        {
          name: "SignedData.CertificateRevocationLists",
          tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
          type: 1,
          optional: true,
          captureAsn1: "crls"
        },
        {
          name: "SignedData.SignerInfos",
          tagClass: asn1$5.Class.UNIVERSAL,
          type: asn1$5.Type.SET,
          capture: "signerInfos",
          optional: true,
          value: [signerValidator]
        }
      ]
    };
    p7v.recipientInfoValidator = {
      name: "RecipientInfo",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.version",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "RecipientInfo.issuerAndSerial",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.issuerAndSerial.issuer",
          tagClass: asn1$5.Class.UNIVERSAL,
          type: asn1$5.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "RecipientInfo.issuerAndSerial.serialNumber",
          tagClass: asn1$5.Class.UNIVERSAL,
          type: asn1$5.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
          tagClass: asn1$5.Class.UNIVERSAL,
          type: asn1$5.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
          tagClass: asn1$5.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "RecipientInfo.encryptedKey",
        tagClass: asn1$5.Class.UNIVERSAL,
        type: asn1$5.Type.OCTETSTRING,
        constructed: false,
        capture: "encKey"
      }]
    };
    var forge$h = forge$F;
    forge$h.mgf = forge$h.mgf || {};
    var mgf1 = forge$h.mgf.mgf1 = forge$h.mgf1 = forge$h.mgf1 || {};
    mgf1.create = function(md) {
      var mgf = {
        generate: function(seed, maskLen) {
          var t = new forge$h.util.ByteBuffer();
          var len = Math.ceil(maskLen / md.digestLength);
          for (var i3 = 0; i3 < len; i3++) {
            var c2 = new forge$h.util.ByteBuffer();
            c2.putInt32(i3);
            md.start();
            md.update(seed + c2.getBytes());
            t.putBuffer(md.digest());
          }
          t.truncate(t.length() - maskLen);
          return t.getBytes();
        }
      };
      return mgf;
    };
    var forge$g = forge$F;
    forge$g.mgf = forge$g.mgf || {};
    forge$g.mgf.mgf1 = forge$g.mgf1;
    var forge$f = forge$F;
    var pss = forge$f.pss = forge$f.pss || {};
    pss.create = function(options2) {
      if (arguments.length === 3) {
        options2 = {
          md: arguments[0],
          mgf: arguments[1],
          saltLength: arguments[2]
        };
      }
      var hash2 = options2.md;
      var mgf = options2.mgf;
      var hLen = hash2.digestLength;
      var salt_ = options2.salt || null;
      if (typeof salt_ === "string") {
        salt_ = forge$f.util.createBuffer(salt_);
      }
      var sLen;
      if ("saltLength" in options2) {
        sLen = options2.saltLength;
      } else if (salt_ !== null) {
        sLen = salt_.length();
      } else {
        throw new Error("Salt length not specified or specific salt not given.");
      }
      if (salt_ !== null && salt_.length() !== sLen) {
        throw new Error("Given salt length does not match length of given salt.");
      }
      var prng2 = options2.prng || forge$f.random;
      var pssobj = {};
      pssobj.encode = function(md, modBits) {
        var i3;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        var mHash = md.digest().getBytes();
        if (emLen < hLen + sLen + 2) {
          throw new Error("Message is too long to encrypt.");
        }
        var salt;
        if (salt_ === null) {
          salt = prng2.getBytesSync(sLen);
        } else {
          salt = salt_.bytes();
        }
        var m_ = new forge$f.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash2.start();
        hash2.update(m_.getBytes());
        var h3 = hash2.digest().getBytes();
        var ps2 = new forge$f.util.ByteBuffer();
        ps2.fillWithByte(0, emLen - sLen - hLen - 2);
        ps2.putByte(1);
        ps2.putBytes(salt);
        var db2 = ps2.getBytes();
        var maskLen = emLen - hLen - 1;
        var dbMask = mgf.generate(h3, maskLen);
        var maskedDB = "";
        for (i3 = 0; i3 < maskLen; i3++) {
          maskedDB += String.fromCharCode(db2.charCodeAt(i3) ^ dbMask.charCodeAt(i3));
        }
        var mask2 = 65280 >> 8 * emLen - emBits & 255;
        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask2) + maskedDB.substr(1);
        return maskedDB + h3 + String.fromCharCode(188);
      };
      pssobj.verify = function(mHash, em, modBits) {
        var i3;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        em = em.substr(-emLen);
        if (emLen < hLen + sLen + 2) {
          throw new Error("Inconsistent parameters to PSS signature verification.");
        }
        if (em.charCodeAt(emLen - 1) !== 188) {
          throw new Error("Encoded message does not end in 0xBC.");
        }
        var maskLen = emLen - hLen - 1;
        var maskedDB = em.substr(0, maskLen);
        var h3 = em.substr(maskLen, hLen);
        var mask2 = 65280 >> 8 * emLen - emBits & 255;
        if ((maskedDB.charCodeAt(0) & mask2) !== 0) {
          throw new Error("Bits beyond keysize not zero as expected.");
        }
        var dbMask = mgf.generate(h3, maskLen);
        var db2 = "";
        for (i3 = 0; i3 < maskLen; i3++) {
          db2 += String.fromCharCode(maskedDB.charCodeAt(i3) ^ dbMask.charCodeAt(i3));
        }
        db2 = String.fromCharCode(db2.charCodeAt(0) & ~mask2) + db2.substr(1);
        var checkLen = emLen - hLen - sLen - 2;
        for (i3 = 0; i3 < checkLen; i3++) {
          if (db2.charCodeAt(i3) !== 0) {
            throw new Error("Leftmost octets not zero as expected");
          }
        }
        if (db2.charCodeAt(checkLen) !== 1) {
          throw new Error("Inconsistent PSS signature, 0x01 marker not found");
        }
        var salt = db2.substr(-sLen);
        var m_ = new forge$f.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash2.start();
        hash2.update(m_.getBytes());
        var h_ = hash2.digest().getBytes();
        return h3 === h_;
      };
      return pssobj;
    };
    var forge$e = forge$F;
    var asn1$4 = forge$e.asn1;
    var pki$2 = forge$e.pki = forge$e.pki || {};
    var oids = pki$2.oids;
    var _shortNames = {};
    _shortNames["CN"] = oids["commonName"];
    _shortNames["commonName"] = "CN";
    _shortNames["C"] = oids["countryName"];
    _shortNames["countryName"] = "C";
    _shortNames["L"] = oids["localityName"];
    _shortNames["localityName"] = "L";
    _shortNames["ST"] = oids["stateOrProvinceName"];
    _shortNames["stateOrProvinceName"] = "ST";
    _shortNames["O"] = oids["organizationName"];
    _shortNames["organizationName"] = "O";
    _shortNames["OU"] = oids["organizationalUnitName"];
    _shortNames["organizationalUnitName"] = "OU";
    _shortNames["E"] = oids["emailAddress"];
    _shortNames["emailAddress"] = "E";
    var publicKeyValidator$1 = forge$e.pki.rsa.publicKeyValidator;
    var x509CertificateValidator = {
      name: "Certificate",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Certificate.TBSCertificate",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "tbsCertificate",
        value: [
          {
            name: "Certificate.TBSCertificate.version",
            tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.version.integer",
              tagClass: asn1$4.Class.UNIVERSAL,
              type: asn1$4.Type.INTEGER,
              constructed: false,
              capture: "certVersion"
            }]
          },
          {
            name: "Certificate.TBSCertificate.serialNumber",
            tagClass: asn1$4.Class.UNIVERSAL,
            type: asn1$4.Type.INTEGER,
            constructed: false,
            capture: "certSerialNumber"
          },
          {
            name: "Certificate.TBSCertificate.signature",
            tagClass: asn1$4.Class.UNIVERSAL,
            type: asn1$4.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.signature.algorithm",
              tagClass: asn1$4.Class.UNIVERSAL,
              type: asn1$4.Type.OID,
              constructed: false,
              capture: "certinfoSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: asn1$4.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certinfoSignatureParams"
            }]
          },
          {
            name: "Certificate.TBSCertificate.issuer",
            tagClass: asn1$4.Class.UNIVERSAL,
            type: asn1$4.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certIssuer"
          },
          {
            name: "Certificate.TBSCertificate.validity",
            tagClass: asn1$4.Class.UNIVERSAL,
            type: asn1$4.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.validity.notBefore (utc)",
              tagClass: asn1$4.Class.UNIVERSAL,
              type: asn1$4.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity1UTCTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
              tagClass: asn1$4.Class.UNIVERSAL,
              type: asn1$4.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity2GeneralizedTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notAfter (utc)",
              tagClass: asn1$4.Class.UNIVERSAL,
              type: asn1$4.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity3UTCTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
              tagClass: asn1$4.Class.UNIVERSAL,
              type: asn1$4.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity4GeneralizedTime"
            }]
          },
          {
            name: "Certificate.TBSCertificate.subject",
            tagClass: asn1$4.Class.UNIVERSAL,
            type: asn1$4.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certSubject"
          },
          publicKeyValidator$1,
          {
            name: "Certificate.TBSCertificate.issuerUniqueID",
            tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.issuerUniqueID.id",
              tagClass: asn1$4.Class.UNIVERSAL,
              type: asn1$4.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "certIssuerUniqueId"
            }]
          },
          {
            name: "Certificate.TBSCertificate.subjectUniqueID",
            tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
            type: 2,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.subjectUniqueID.id",
              tagClass: asn1$4.Class.UNIVERSAL,
              type: asn1$4.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "certSubjectUniqueId"
            }]
          },
          {
            name: "Certificate.TBSCertificate.extensions",
            tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
            type: 3,
            constructed: true,
            captureAsn1: "certExtensions",
            optional: true
          }
        ]
      }, {
        name: "Certificate.signatureAlgorithm",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "Certificate.signatureAlgorithm.algorithm",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.OID,
          constructed: false,
          capture: "certSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1$4.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "certSignatureParams"
        }]
      }, {
        name: "Certificate.signatureValue",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.BITSTRING,
        constructed: false,
        captureBitStringValue: "certSignature"
      }]
    };
    var rsassaPssParameterValidator = {
      name: "rsapss",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "rsapss.hashAlgorithm",
        tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1$4.Class.UNIVERSAL,
            type: asn1$4.Type.OID,
            constructed: false,
            capture: "hashOid"
          }]
        }]
      }, {
        name: "rsapss.maskGenAlgorithm",
        tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1$4.Class.UNIVERSAL,
            type: asn1$4.Type.OID,
            constructed: false,
            capture: "maskGenOid"
          }, {
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
            tagClass: asn1$4.Class.UNIVERSAL,
            type: asn1$4.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
              tagClass: asn1$4.Class.UNIVERSAL,
              type: asn1$4.Type.OID,
              constructed: false,
              capture: "maskGenHashOid"
            }]
          }]
        }]
      }, {
        name: "rsapss.saltLength",
        tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: true,
        value: [{
          name: "rsapss.saltLength.saltLength",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Class.INTEGER,
          constructed: false,
          capture: "saltLength"
        }]
      }, {
        name: "rsapss.trailerField",
        tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: true,
        value: [{
          name: "rsapss.trailer.trailer",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Class.INTEGER,
          constructed: false,
          capture: "trailer"
        }]
      }]
    };
    var certificationRequestInfoValidator = {
      name: "CertificationRequestInfo",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfo",
      value: [
        {
          name: "CertificationRequestInfo.integer",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.INTEGER,
          constructed: false,
          capture: "certificationRequestInfoVersion"
        },
        {
          name: "CertificationRequestInfo.subject",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfoSubject"
        },
        publicKeyValidator$1,
        {
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          capture: "certificationRequestInfoAttributes",
          value: [{
            name: "CertificationRequestInfo.attributes",
            tagClass: asn1$4.Class.UNIVERSAL,
            type: asn1$4.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "CertificationRequestInfo.attributes.type",
              tagClass: asn1$4.Class.UNIVERSAL,
              type: asn1$4.Type.OID,
              constructed: false
            }, {
              name: "CertificationRequestInfo.attributes.value",
              tagClass: asn1$4.Class.UNIVERSAL,
              type: asn1$4.Type.SET,
              constructed: true
            }]
          }]
        }
      ]
    };
    var certificationRequestValidator = {
      name: "CertificationRequest",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "csr",
      value: [
        certificationRequestInfoValidator,
        {
          name: "CertificationRequest.signatureAlgorithm",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "CertificationRequest.signatureAlgorithm.algorithm",
            tagClass: asn1$4.Class.UNIVERSAL,
            type: asn1$4.Type.OID,
            constructed: false,
            capture: "csrSignatureOid"
          }, {
            name: "CertificationRequest.signatureAlgorithm.parameters",
            tagClass: asn1$4.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "csrSignatureParams"
          }]
        },
        {
          name: "CertificationRequest.signature",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "csrSignature"
        }
      ]
    };
    pki$2.RDNAttributesAsArray = function(rdn, md) {
      var rval = [];
      var set2, attr, obj;
      for (var si2 = 0; si2 < rdn.value.length; ++si2) {
        set2 = rdn.value[si2];
        for (var i3 = 0; i3 < set2.value.length; ++i3) {
          obj = {};
          attr = set2.value[i3];
          obj.type = asn1$4.derToOid(attr.value[0].value);
          obj.value = attr.value[1].value;
          obj.valueTagClass = attr.value[1].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (md) {
            md.update(obj.type);
            md.update(obj.value);
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    pki$2.CRIAttributesAsArray = function(attributes) {
      var rval = [];
      for (var si2 = 0; si2 < attributes.length; ++si2) {
        var seq2 = attributes[si2];
        var type = asn1$4.derToOid(seq2.value[0].value);
        var values = seq2.value[1].value;
        for (var vi2 = 0; vi2 < values.length; ++vi2) {
          var obj = {};
          obj.type = type;
          obj.value = values[vi2].value;
          obj.valueTagClass = values[vi2].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (obj.type === oids.extensionRequest) {
            obj.extensions = [];
            for (var ei2 = 0; ei2 < obj.value.length; ++ei2) {
              obj.extensions.push(pki$2.certificateExtensionFromAsn1(obj.value[ei2]));
            }
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    function _getAttribute(obj, options2) {
      if (typeof options2 === "string") {
        options2 = { shortName: options2 };
      }
      var rval = null;
      var attr;
      for (var i3 = 0; rval === null && i3 < obj.attributes.length; ++i3) {
        attr = obj.attributes[i3];
        if (options2.type && options2.type === attr.type) {
          rval = attr;
        } else if (options2.name && options2.name === attr.name) {
          rval = attr;
        } else if (options2.shortName && options2.shortName === attr.shortName) {
          rval = attr;
        }
      }
      return rval;
    }
    var _readSignatureParameters = function(oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids["RSASSA-PSS"]) {
        return params;
      }
      if (fillDefaults) {
        params = {
          hash: {
            algorithmOid: oids["sha1"]
          },
          mgf: {
            algorithmOid: oids["mgf1"],
            hash: {
              algorithmOid: oids["sha1"]
            }
          },
          saltLength: 20
        };
      }
      var capture = {};
      var errors = [];
      if (!asn1$4.validate(obj, rsassaPssParameterValidator, capture, errors)) {
        var error2 = new Error("Cannot read RSASSA-PSS parameter block.");
        error2.errors = errors;
        throw error2;
      }
      if (capture.hashOid !== void 0) {
        params.hash = params.hash || {};
        params.hash.algorithmOid = asn1$4.derToOid(capture.hashOid);
      }
      if (capture.maskGenOid !== void 0) {
        params.mgf = params.mgf || {};
        params.mgf.algorithmOid = asn1$4.derToOid(capture.maskGenOid);
        params.mgf.hash = params.mgf.hash || {};
        params.mgf.hash.algorithmOid = asn1$4.derToOid(capture.maskGenHashOid);
      }
      if (capture.saltLength !== void 0) {
        params.saltLength = capture.saltLength.charCodeAt(0);
      }
      return params;
    };
    pki$2.certificateFromPem = function(pem2, computeHash, strict) {
      var msg = forge$e.pem.decode(pem2)[0];
      if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
        var error2 = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
        error2.headerType = msg.type;
        throw error2;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
      }
      var obj = asn1$4.fromDer(msg.body, strict);
      return pki$2.certificateFromAsn1(obj, computeHash);
    };
    pki$2.certificateToPem = function(cert, maxline) {
      var msg = {
        type: "CERTIFICATE",
        body: asn1$4.toDer(pki$2.certificateToAsn1(cert)).getBytes()
      };
      return forge$e.pem.encode(msg, { maxline });
    };
    pki$2.publicKeyFromPem = function(pem2) {
      var msg = forge$e.pem.decode(pem2)[0];
      if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
        var error2 = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
        error2.headerType = msg.type;
        throw error2;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert public key from PEM; PEM is encrypted.");
      }
      var obj = asn1$4.fromDer(msg.body);
      return pki$2.publicKeyFromAsn1(obj);
    };
    pki$2.publicKeyToPem = function(key2, maxline) {
      var msg = {
        type: "PUBLIC KEY",
        body: asn1$4.toDer(pki$2.publicKeyToAsn1(key2)).getBytes()
      };
      return forge$e.pem.encode(msg, { maxline });
    };
    pki$2.publicKeyToRSAPublicKeyPem = function(key2, maxline) {
      var msg = {
        type: "RSA PUBLIC KEY",
        body: asn1$4.toDer(pki$2.publicKeyToRSAPublicKey(key2)).getBytes()
      };
      return forge$e.pem.encode(msg, { maxline });
    };
    pki$2.getPublicKeyFingerprint = function(key2, options2) {
      options2 = options2 || {};
      var md = options2.md || forge$e.md.sha1.create();
      var type = options2.type || "RSAPublicKey";
      var bytes2;
      switch (type) {
        case "RSAPublicKey":
          bytes2 = asn1$4.toDer(pki$2.publicKeyToRSAPublicKey(key2)).getBytes();
          break;
        case "SubjectPublicKeyInfo":
          bytes2 = asn1$4.toDer(pki$2.publicKeyToAsn1(key2)).getBytes();
          break;
        default:
          throw new Error('Unknown fingerprint type "' + options2.type + '".');
      }
      md.start();
      md.update(bytes2);
      var digest = md.digest();
      if (options2.encoding === "hex") {
        var hex = digest.toHex();
        if (options2.delimiter) {
          return hex.match(/.{2}/g).join(options2.delimiter);
        }
        return hex;
      } else if (options2.encoding === "binary") {
        return digest.getBytes();
      } else if (options2.encoding) {
        throw new Error('Unknown encoding "' + options2.encoding + '".');
      }
      return digest;
    };
    pki$2.certificationRequestFromPem = function(pem2, computeHash, strict) {
      var msg = forge$e.pem.decode(pem2)[0];
      if (msg.type !== "CERTIFICATE REQUEST") {
        var error2 = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
        error2.headerType = msg.type;
        throw error2;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
      }
      var obj = asn1$4.fromDer(msg.body, strict);
      return pki$2.certificationRequestFromAsn1(obj, computeHash);
    };
    pki$2.certificationRequestToPem = function(csr, maxline) {
      var msg = {
        type: "CERTIFICATE REQUEST",
        body: asn1$4.toDer(pki$2.certificationRequestToAsn1(csr)).getBytes()
      };
      return forge$e.pem.encode(msg, { maxline });
    };
    pki$2.createCertificate = function() {
      var cert = {};
      cert.version = 2;
      cert.serialNumber = "00";
      cert.signatureOid = null;
      cert.signature = null;
      cert.siginfo = {};
      cert.siginfo.algorithmOid = null;
      cert.validity = {};
      cert.validity.notBefore = new Date();
      cert.validity.notAfter = new Date();
      cert.issuer = {};
      cert.issuer.getField = function(sn2) {
        return _getAttribute(cert.issuer, sn2);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = [];
      cert.issuer.hash = null;
      cert.subject = {};
      cert.subject.getField = function(sn2) {
        return _getAttribute(cert.subject, sn2);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = [];
      cert.subject.hash = null;
      cert.extensions = [];
      cert.publicKey = null;
      cert.md = null;
      cert.setSubject = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.subject.attributes = attrs;
        delete cert.subject.uniqueId;
        if (uniqueId) {
          cert.subject.uniqueId = uniqueId;
        }
        cert.subject.hash = null;
      };
      cert.setIssuer = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.issuer.attributes = attrs;
        delete cert.issuer.uniqueId;
        if (uniqueId) {
          cert.issuer.uniqueId = uniqueId;
        }
        cert.issuer.hash = null;
      };
      cert.setExtensions = function(exts) {
        for (var i3 = 0; i3 < exts.length; ++i3) {
          _fillMissingExtensionFields(exts[i3], { cert });
        }
        cert.extensions = exts;
      };
      cert.getExtension = function(options2) {
        if (typeof options2 === "string") {
          options2 = { name: options2 };
        }
        var rval = null;
        var ext2;
        for (var i3 = 0; rval === null && i3 < cert.extensions.length; ++i3) {
          ext2 = cert.extensions[i3];
          if (options2.id && ext2.id === options2.id) {
            rval = ext2;
          } else if (options2.name && ext2.name === options2.name) {
            rval = ext2;
          }
        }
        return rval;
      };
      cert.sign = function(key2, md) {
        cert.md = md || forge$e.md.sha1.create();
        var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error2 = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
          error2.algorithm = cert.md.algorithm;
          throw error2;
        }
        cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
        cert.tbsCertificate = pki$2.getTBSCertificate(cert);
        var bytes2 = asn1$4.toDer(cert.tbsCertificate);
        cert.md.update(bytes2.getBytes());
        cert.signature = key2.sign(cert.md);
      };
      cert.verify = function(child) {
        var rval = false;
        if (!cert.issued(child)) {
          var issuer = child.issuer;
          var subject = cert.subject;
          var error2 = new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");
          error2.expectedIssuer = issuer.attributes;
          error2.actualIssuer = subject.attributes;
          throw error2;
        }
        var md = child.md;
        if (md === null) {
          if (child.signatureOid in oids) {
            var oid = oids[child.signatureOid];
            switch (oid) {
              case "sha1WithRSAEncryption":
                md = forge$e.md.sha1.create();
                break;
              case "md5WithRSAEncryption":
                md = forge$e.md.md5.create();
                break;
              case "sha256WithRSAEncryption":
                md = forge$e.md.sha256.create();
                break;
              case "sha384WithRSAEncryption":
                md = forge$e.md.sha384.create();
                break;
              case "sha512WithRSAEncryption":
                md = forge$e.md.sha512.create();
                break;
              case "RSASSA-PSS":
                md = forge$e.md.sha256.create();
                break;
            }
          }
          if (md === null) {
            var error2 = new Error("Could not compute certificate digest. Unknown signature OID.");
            error2.signatureOid = child.signatureOid;
            throw error2;
          }
          var tbsCertificate = child.tbsCertificate || pki$2.getTBSCertificate(child);
          var bytes2 = asn1$4.toDer(tbsCertificate);
          md.update(bytes2.getBytes());
        }
        if (md !== null) {
          var scheme;
          switch (child.signatureOid) {
            case oids.sha1WithRSAEncryption:
              scheme = void 0;
              break;
            case oids["RSASSA-PSS"]:
              var hash2, mgf;
              hash2 = oids[child.signatureParameters.mgf.hash.algorithmOid];
              if (hash2 === void 0 || forge$e.md[hash2] === void 0) {
                var error2 = new Error("Unsupported MGF hash function.");
                error2.oid = child.signatureParameters.mgf.hash.algorithmOid;
                error2.name = hash2;
                throw error2;
              }
              mgf = oids[child.signatureParameters.mgf.algorithmOid];
              if (mgf === void 0 || forge$e.mgf[mgf] === void 0) {
                var error2 = new Error("Unsupported MGF function.");
                error2.oid = child.signatureParameters.mgf.algorithmOid;
                error2.name = mgf;
                throw error2;
              }
              mgf = forge$e.mgf[mgf].create(forge$e.md[hash2].create());
              hash2 = oids[child.signatureParameters.hash.algorithmOid];
              if (hash2 === void 0 || forge$e.md[hash2] === void 0) {
                throw {
                  message: "Unsupported RSASSA-PSS hash function.",
                  oid: child.signatureParameters.hash.algorithmOid,
                  name: hash2
                };
              }
              scheme = forge$e.pss.create(forge$e.md[hash2].create(), mgf, child.signatureParameters.saltLength);
              break;
          }
          rval = cert.publicKey.verify(md.digest().getBytes(), child.signature, scheme);
        }
        return rval;
      };
      cert.isIssuer = function(parent) {
        var rval = false;
        var i3 = cert.issuer;
        var s3 = parent.subject;
        if (i3.hash && s3.hash) {
          rval = i3.hash === s3.hash;
        } else if (i3.attributes.length === s3.attributes.length) {
          rval = true;
          var iattr, sattr;
          for (var n3 = 0; rval && n3 < i3.attributes.length; ++n3) {
            iattr = i3.attributes[n3];
            sattr = s3.attributes[n3];
            if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
              rval = false;
            }
          }
        }
        return rval;
      };
      cert.issued = function(child) {
        return child.isIssuer(cert);
      };
      cert.generateSubjectKeyIdentifier = function() {
        return pki$2.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
      };
      cert.verifySubjectKeyIdentifier = function() {
        var oid = oids["subjectKeyIdentifier"];
        for (var i3 = 0; i3 < cert.extensions.length; ++i3) {
          var ext2 = cert.extensions[i3];
          if (ext2.id === oid) {
            var ski = cert.generateSubjectKeyIdentifier().getBytes();
            return forge$e.util.hexToBytes(ext2.subjectKeyIdentifier) === ski;
          }
        }
        return false;
      };
      return cert;
    };
    pki$2.certificateFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1$4.validate(obj, x509CertificateValidator, capture, errors)) {
        var error2 = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
        error2.errors = errors;
        throw error2;
      }
      var oid = asn1$4.derToOid(capture.publicKeyOid);
      if (oid !== pki$2.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var cert = pki$2.createCertificate();
      cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
      var serial = forge$e.util.createBuffer(capture.certSerialNumber);
      cert.serialNumber = serial.toHex();
      cert.signatureOid = forge$e.asn1.derToOid(capture.certSignatureOid);
      cert.signatureParameters = _readSignatureParameters(cert.signatureOid, capture.certSignatureParams, true);
      cert.siginfo.algorithmOid = forge$e.asn1.derToOid(capture.certinfoSignatureOid);
      cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid, capture.certinfoSignatureParams, false);
      cert.signature = capture.certSignature;
      var validity = [];
      if (capture.certValidity1UTCTime !== void 0) {
        validity.push(asn1$4.utcTimeToDate(capture.certValidity1UTCTime));
      }
      if (capture.certValidity2GeneralizedTime !== void 0) {
        validity.push(asn1$4.generalizedTimeToDate(capture.certValidity2GeneralizedTime));
      }
      if (capture.certValidity3UTCTime !== void 0) {
        validity.push(asn1$4.utcTimeToDate(capture.certValidity3UTCTime));
      }
      if (capture.certValidity4GeneralizedTime !== void 0) {
        validity.push(asn1$4.generalizedTimeToDate(capture.certValidity4GeneralizedTime));
      }
      if (validity.length > 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
      }
      if (validity.length < 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
      }
      cert.validity.notBefore = validity[0];
      cert.validity.notAfter = validity[1];
      cert.tbsCertificate = capture.tbsCertificate;
      if (computeHash) {
        cert.md = null;
        if (cert.signatureOid in oids) {
          var oid = oids[cert.signatureOid];
          switch (oid) {
            case "sha1WithRSAEncryption":
              cert.md = forge$e.md.sha1.create();
              break;
            case "md5WithRSAEncryption":
              cert.md = forge$e.md.md5.create();
              break;
            case "sha256WithRSAEncryption":
              cert.md = forge$e.md.sha256.create();
              break;
            case "sha384WithRSAEncryption":
              cert.md = forge$e.md.sha384.create();
              break;
            case "sha512WithRSAEncryption":
              cert.md = forge$e.md.sha512.create();
              break;
            case "RSASSA-PSS":
              cert.md = forge$e.md.sha256.create();
              break;
          }
        }
        if (cert.md === null) {
          var error2 = new Error("Could not compute certificate digest. Unknown signature OID.");
          error2.signatureOid = cert.signatureOid;
          throw error2;
        }
        var bytes2 = asn1$4.toDer(cert.tbsCertificate);
        cert.md.update(bytes2.getBytes());
      }
      var imd = forge$e.md.sha1.create();
      cert.issuer.getField = function(sn2) {
        return _getAttribute(cert.issuer, sn2);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = pki$2.RDNAttributesAsArray(capture.certIssuer, imd);
      if (capture.certIssuerUniqueId) {
        cert.issuer.uniqueId = capture.certIssuerUniqueId;
      }
      cert.issuer.hash = imd.digest().toHex();
      var smd = forge$e.md.sha1.create();
      cert.subject.getField = function(sn2) {
        return _getAttribute(cert.subject, sn2);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = pki$2.RDNAttributesAsArray(capture.certSubject, smd);
      if (capture.certSubjectUniqueId) {
        cert.subject.uniqueId = capture.certSubjectUniqueId;
      }
      cert.subject.hash = smd.digest().toHex();
      if (capture.certExtensions) {
        cert.extensions = pki$2.certificateExtensionsFromAsn1(capture.certExtensions);
      } else {
        cert.extensions = [];
      }
      cert.publicKey = pki$2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      return cert;
    };
    pki$2.certificateExtensionsFromAsn1 = function(exts) {
      var rval = [];
      for (var i3 = 0; i3 < exts.value.length; ++i3) {
        var extseq = exts.value[i3];
        for (var ei2 = 0; ei2 < extseq.value.length; ++ei2) {
          rval.push(pki$2.certificateExtensionFromAsn1(extseq.value[ei2]));
        }
      }
      return rval;
    };
    pki$2.certificateExtensionFromAsn1 = function(ext2) {
      var e2 = {};
      e2.id = asn1$4.derToOid(ext2.value[0].value);
      e2.critical = false;
      if (ext2.value[1].type === asn1$4.Type.BOOLEAN) {
        e2.critical = ext2.value[1].value.charCodeAt(0) !== 0;
        e2.value = ext2.value[2].value;
      } else {
        e2.value = ext2.value[1].value;
      }
      if (e2.id in oids) {
        e2.name = oids[e2.id];
        if (e2.name === "keyUsage") {
          var ev = asn1$4.fromDer(e2.value);
          var b2 = 0;
          var b3 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
            b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
          }
          e2.digitalSignature = (b2 & 128) === 128;
          e2.nonRepudiation = (b2 & 64) === 64;
          e2.keyEncipherment = (b2 & 32) === 32;
          e2.dataEncipherment = (b2 & 16) === 16;
          e2.keyAgreement = (b2 & 8) === 8;
          e2.keyCertSign = (b2 & 4) === 4;
          e2.cRLSign = (b2 & 2) === 2;
          e2.encipherOnly = (b2 & 1) === 1;
          e2.decipherOnly = (b3 & 128) === 128;
        } else if (e2.name === "basicConstraints") {
          var ev = asn1$4.fromDer(e2.value);
          if (ev.value.length > 0 && ev.value[0].type === asn1$4.Type.BOOLEAN) {
            e2.cA = ev.value[0].value.charCodeAt(0) !== 0;
          } else {
            e2.cA = false;
          }
          var value = null;
          if (ev.value.length > 0 && ev.value[0].type === asn1$4.Type.INTEGER) {
            value = ev.value[0].value;
          } else if (ev.value.length > 1) {
            value = ev.value[1].value;
          }
          if (value !== null) {
            e2.pathLenConstraint = asn1$4.derToInteger(value);
          }
        } else if (e2.name === "extKeyUsage") {
          var ev = asn1$4.fromDer(e2.value);
          for (var vi2 = 0; vi2 < ev.value.length; ++vi2) {
            var oid = asn1$4.derToOid(ev.value[vi2].value);
            if (oid in oids) {
              e2[oids[oid]] = true;
            } else {
              e2[oid] = true;
            }
          }
        } else if (e2.name === "nsCertType") {
          var ev = asn1$4.fromDer(e2.value);
          var b2 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
          }
          e2.client = (b2 & 128) === 128;
          e2.server = (b2 & 64) === 64;
          e2.email = (b2 & 32) === 32;
          e2.objsign = (b2 & 16) === 16;
          e2.reserved = (b2 & 8) === 8;
          e2.sslCA = (b2 & 4) === 4;
          e2.emailCA = (b2 & 2) === 2;
          e2.objCA = (b2 & 1) === 1;
        } else if (e2.name === "subjectAltName" || e2.name === "issuerAltName") {
          e2.altNames = [];
          var gn2;
          var ev = asn1$4.fromDer(e2.value);
          for (var n3 = 0; n3 < ev.value.length; ++n3) {
            gn2 = ev.value[n3];
            var altName = {
              type: gn2.type,
              value: gn2.value
            };
            e2.altNames.push(altName);
            switch (gn2.type) {
              case 1:
              case 2:
              case 6:
                break;
              case 7:
                altName.ip = forge$e.util.bytesToIP(gn2.value);
                break;
              case 8:
                altName.oid = asn1$4.derToOid(gn2.value);
                break;
            }
          }
        } else if (e2.name === "subjectKeyIdentifier") {
          var ev = asn1$4.fromDer(e2.value);
          e2.subjectKeyIdentifier = forge$e.util.bytesToHex(ev.value);
        }
      }
      return e2;
    };
    pki$2.certificationRequestFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1$4.validate(obj, certificationRequestValidator, capture, errors)) {
        var error2 = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
        error2.errors = errors;
        throw error2;
      }
      var oid = asn1$4.derToOid(capture.publicKeyOid);
      if (oid !== pki$2.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var csr = pki$2.createCertificationRequest();
      csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
      csr.signatureOid = forge$e.asn1.derToOid(capture.csrSignatureOid);
      csr.signatureParameters = _readSignatureParameters(csr.signatureOid, capture.csrSignatureParams, true);
      csr.siginfo.algorithmOid = forge$e.asn1.derToOid(capture.csrSignatureOid);
      csr.siginfo.parameters = _readSignatureParameters(csr.siginfo.algorithmOid, capture.csrSignatureParams, false);
      csr.signature = capture.csrSignature;
      csr.certificationRequestInfo = capture.certificationRequestInfo;
      if (computeHash) {
        csr.md = null;
        if (csr.signatureOid in oids) {
          var oid = oids[csr.signatureOid];
          switch (oid) {
            case "sha1WithRSAEncryption":
              csr.md = forge$e.md.sha1.create();
              break;
            case "md5WithRSAEncryption":
              csr.md = forge$e.md.md5.create();
              break;
            case "sha256WithRSAEncryption":
              csr.md = forge$e.md.sha256.create();
              break;
            case "sha384WithRSAEncryption":
              csr.md = forge$e.md.sha384.create();
              break;
            case "sha512WithRSAEncryption":
              csr.md = forge$e.md.sha512.create();
              break;
            case "RSASSA-PSS":
              csr.md = forge$e.md.sha256.create();
              break;
          }
        }
        if (csr.md === null) {
          var error2 = new Error("Could not compute certification request digest. Unknown signature OID.");
          error2.signatureOid = csr.signatureOid;
          throw error2;
        }
        var bytes2 = asn1$4.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes2.getBytes());
      }
      var smd = forge$e.md.sha1.create();
      csr.subject.getField = function(sn2) {
        return _getAttribute(csr.subject, sn2);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = pki$2.RDNAttributesAsArray(capture.certificationRequestInfoSubject, smd);
      csr.subject.hash = smd.digest().toHex();
      csr.publicKey = pki$2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      csr.getAttribute = function(sn2) {
        return _getAttribute(csr, sn2);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.attributes = pki$2.CRIAttributesAsArray(capture.certificationRequestInfoAttributes || []);
      return csr;
    };
    pki$2.createCertificationRequest = function() {
      var csr = {};
      csr.version = 0;
      csr.signatureOid = null;
      csr.signature = null;
      csr.siginfo = {};
      csr.siginfo.algorithmOid = null;
      csr.subject = {};
      csr.subject.getField = function(sn2) {
        return _getAttribute(csr.subject, sn2);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = [];
      csr.subject.hash = null;
      csr.publicKey = null;
      csr.attributes = [];
      csr.getAttribute = function(sn2) {
        return _getAttribute(csr, sn2);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.md = null;
      csr.setSubject = function(attrs) {
        _fillMissingFields(attrs);
        csr.subject.attributes = attrs;
        csr.subject.hash = null;
      };
      csr.setAttributes = function(attrs) {
        _fillMissingFields(attrs);
        csr.attributes = attrs;
      };
      csr.sign = function(key2, md) {
        csr.md = md || forge$e.md.sha1.create();
        var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error2 = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
          error2.algorithm = csr.md.algorithm;
          throw error2;
        }
        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
        csr.certificationRequestInfo = pki$2.getCertificationRequestInfo(csr);
        var bytes2 = asn1$4.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes2.getBytes());
        csr.signature = key2.sign(csr.md);
      };
      csr.verify = function() {
        var rval = false;
        var md = csr.md;
        if (md === null) {
          if (csr.signatureOid in oids) {
            var oid = oids[csr.signatureOid];
            switch (oid) {
              case "sha1WithRSAEncryption":
                md = forge$e.md.sha1.create();
                break;
              case "md5WithRSAEncryption":
                md = forge$e.md.md5.create();
                break;
              case "sha256WithRSAEncryption":
                md = forge$e.md.sha256.create();
                break;
              case "sha384WithRSAEncryption":
                md = forge$e.md.sha384.create();
                break;
              case "sha512WithRSAEncryption":
                md = forge$e.md.sha512.create();
                break;
              case "RSASSA-PSS":
                md = forge$e.md.sha256.create();
                break;
            }
          }
          if (md === null) {
            var error2 = new Error("Could not compute certification request digest. Unknown signature OID.");
            error2.signatureOid = csr.signatureOid;
            throw error2;
          }
          var cri = csr.certificationRequestInfo || pki$2.getCertificationRequestInfo(csr);
          var bytes2 = asn1$4.toDer(cri);
          md.update(bytes2.getBytes());
        }
        if (md !== null) {
          var scheme;
          switch (csr.signatureOid) {
            case oids.sha1WithRSAEncryption:
              break;
            case oids["RSASSA-PSS"]:
              var hash2, mgf;
              hash2 = oids[csr.signatureParameters.mgf.hash.algorithmOid];
              if (hash2 === void 0 || forge$e.md[hash2] === void 0) {
                var error2 = new Error("Unsupported MGF hash function.");
                error2.oid = csr.signatureParameters.mgf.hash.algorithmOid;
                error2.name = hash2;
                throw error2;
              }
              mgf = oids[csr.signatureParameters.mgf.algorithmOid];
              if (mgf === void 0 || forge$e.mgf[mgf] === void 0) {
                var error2 = new Error("Unsupported MGF function.");
                error2.oid = csr.signatureParameters.mgf.algorithmOid;
                error2.name = mgf;
                throw error2;
              }
              mgf = forge$e.mgf[mgf].create(forge$e.md[hash2].create());
              hash2 = oids[csr.signatureParameters.hash.algorithmOid];
              if (hash2 === void 0 || forge$e.md[hash2] === void 0) {
                var error2 = new Error("Unsupported RSASSA-PSS hash function.");
                error2.oid = csr.signatureParameters.hash.algorithmOid;
                error2.name = hash2;
                throw error2;
              }
              scheme = forge$e.pss.create(forge$e.md[hash2].create(), mgf, csr.signatureParameters.saltLength);
              break;
          }
          rval = csr.publicKey.verify(md.digest().getBytes(), csr.signature, scheme);
        }
        return rval;
      };
      return csr;
    };
    function _dnToAsn1(obj) {
      var rval = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
      var attr, set2;
      var attrs = obj.attributes;
      for (var i3 = 0; i3 < attrs.length; ++i3) {
        attr = attrs[i3];
        var value = attr.value;
        var valueTagClass = asn1$4.Type.PRINTABLESTRING;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
          if (valueTagClass === asn1$4.Type.UTF8) {
            value = forge$e.util.encodeUtf8(value);
          }
        }
        set2 = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SET, true, [
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
            asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, asn1$4.oidToDer(attr.type).getBytes()),
            asn1$4.create(asn1$4.Class.UNIVERSAL, valueTagClass, false, value)
          ])
        ]);
        rval.value.push(set2);
      }
      return rval;
    }
    function _fillMissingFields(attrs) {
      var attr;
      for (var i3 = 0; i3 < attrs.length; ++i3) {
        attr = attrs[i3];
        if (typeof attr.name === "undefined") {
          if (attr.type && attr.type in pki$2.oids) {
            attr.name = pki$2.oids[attr.type];
          } else if (attr.shortName && attr.shortName in _shortNames) {
            attr.name = pki$2.oids[_shortNames[attr.shortName]];
          }
        }
        if (typeof attr.type === "undefined") {
          if (attr.name && attr.name in pki$2.oids) {
            attr.type = pki$2.oids[attr.name];
          } else {
            var error2 = new Error("Attribute type not specified.");
            error2.attribute = attr;
            throw error2;
          }
        }
        if (typeof attr.shortName === "undefined") {
          if (attr.name && attr.name in _shortNames) {
            attr.shortName = _shortNames[attr.name];
          }
        }
        if (attr.type === oids.extensionRequest) {
          attr.valueConstructed = true;
          attr.valueTagClass = asn1$4.Type.SEQUENCE;
          if (!attr.value && attr.extensions) {
            attr.value = [];
            for (var ei2 = 0; ei2 < attr.extensions.length; ++ei2) {
              attr.value.push(pki$2.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei2])));
            }
          }
        }
        if (typeof attr.value === "undefined") {
          var error2 = new Error("Attribute value not specified.");
          error2.attribute = attr;
          throw error2;
        }
      }
    }
    function _fillMissingExtensionFields(e2, options2) {
      options2 = options2 || {};
      if (typeof e2.name === "undefined") {
        if (e2.id && e2.id in pki$2.oids) {
          e2.name = pki$2.oids[e2.id];
        }
      }
      if (typeof e2.id === "undefined") {
        if (e2.name && e2.name in pki$2.oids) {
          e2.id = pki$2.oids[e2.name];
        } else {
          var error2 = new Error("Extension ID not specified.");
          error2.extension = e2;
          throw error2;
        }
      }
      if (typeof e2.value !== "undefined") {
        return e2;
      }
      if (e2.name === "keyUsage") {
        var unused = 0;
        var b2 = 0;
        var b3 = 0;
        if (e2.digitalSignature) {
          b2 |= 128;
          unused = 7;
        }
        if (e2.nonRepudiation) {
          b2 |= 64;
          unused = 6;
        }
        if (e2.keyEncipherment) {
          b2 |= 32;
          unused = 5;
        }
        if (e2.dataEncipherment) {
          b2 |= 16;
          unused = 4;
        }
        if (e2.keyAgreement) {
          b2 |= 8;
          unused = 3;
        }
        if (e2.keyCertSign) {
          b2 |= 4;
          unused = 2;
        }
        if (e2.cRLSign) {
          b2 |= 2;
          unused = 1;
        }
        if (e2.encipherOnly) {
          b2 |= 1;
          unused = 0;
        }
        if (e2.decipherOnly) {
          b3 |= 128;
          unused = 7;
        }
        var value = String.fromCharCode(unused);
        if (b3 !== 0) {
          value += String.fromCharCode(b2) + String.fromCharCode(b3);
        } else if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e2.value = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.BITSTRING, false, value);
      } else if (e2.name === "basicConstraints") {
        e2.value = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
        if (e2.cA) {
          e2.value.value.push(asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.BOOLEAN, false, String.fromCharCode(255)));
        }
        if ("pathLenConstraint" in e2) {
          e2.value.value.push(asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, asn1$4.integerToDer(e2.pathLenConstraint).getBytes()));
        }
      } else if (e2.name === "extKeyUsage") {
        e2.value = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
        var seq2 = e2.value.value;
        for (var key2 in e2) {
          if (e2[key2] !== true) {
            continue;
          }
          if (key2 in oids) {
            seq2.push(asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, asn1$4.oidToDer(oids[key2]).getBytes()));
          } else if (key2.indexOf(".") !== -1) {
            seq2.push(asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, asn1$4.oidToDer(key2).getBytes()));
          }
        }
      } else if (e2.name === "nsCertType") {
        var unused = 0;
        var b2 = 0;
        if (e2.client) {
          b2 |= 128;
          unused = 7;
        }
        if (e2.server) {
          b2 |= 64;
          unused = 6;
        }
        if (e2.email) {
          b2 |= 32;
          unused = 5;
        }
        if (e2.objsign) {
          b2 |= 16;
          unused = 4;
        }
        if (e2.reserved) {
          b2 |= 8;
          unused = 3;
        }
        if (e2.sslCA) {
          b2 |= 4;
          unused = 2;
        }
        if (e2.emailCA) {
          b2 |= 2;
          unused = 1;
        }
        if (e2.objCA) {
          b2 |= 1;
          unused = 0;
        }
        var value = String.fromCharCode(unused);
        if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e2.value = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.BITSTRING, false, value);
      } else if (e2.name === "subjectAltName" || e2.name === "issuerAltName") {
        e2.value = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
        var altName;
        for (var n3 = 0; n3 < e2.altNames.length; ++n3) {
          altName = e2.altNames[n3];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge$e.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error2 = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
              error2.extension = e2;
              throw error2;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1$4.oidToDer(asn1$4.oidToDer(altName.oid));
            } else {
              value = asn1$4.oidToDer(value);
            }
          }
          e2.value.value.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, altName.type, false, value));
        }
      } else if (e2.name === "nsComment" && options2.cert) {
        if (!/^[\x00-\x7F]*$/.test(e2.comment) || e2.comment.length < 1 || e2.comment.length > 128) {
          throw new Error('Invalid "nsComment" content.');
        }
        e2.value = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.IA5STRING, false, e2.comment);
      } else if (e2.name === "subjectKeyIdentifier" && options2.cert) {
        var ski = options2.cert.generateSubjectKeyIdentifier();
        e2.subjectKeyIdentifier = ski.toHex();
        e2.value = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OCTETSTRING, false, ski.getBytes());
      } else if (e2.name === "authorityKeyIdentifier" && options2.cert) {
        e2.value = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
        var seq2 = e2.value.value;
        if (e2.keyIdentifier) {
          var keyIdentifier = e2.keyIdentifier === true ? options2.cert.generateSubjectKeyIdentifier().getBytes() : e2.keyIdentifier;
          seq2.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));
        }
        if (e2.authorityCertIssuer) {
          var authorityCertIssuer = [
            asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 4, true, [
              _dnToAsn1(e2.authorityCertIssuer === true ? options2.cert.issuer : e2.authorityCertIssuer)
            ])
          ];
          seq2.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));
        }
        if (e2.serialNumber) {
          var serialNumber = forge$e.util.hexToBytes(e2.serialNumber === true ? options2.cert.serialNumber : e2.serialNumber);
          seq2.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));
        }
      } else if (e2.name === "cRLDistributionPoints") {
        e2.value = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
        var seq2 = e2.value.value;
        var subSeq = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
        var fullNameGeneralNames = asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 0, true, []);
        var altName;
        for (var n3 = 0; n3 < e2.altNames.length; ++n3) {
          altName = e2.altNames[n3];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge$e.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error2 = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
              error2.extension = e2;
              throw error2;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1$4.oidToDer(asn1$4.oidToDer(altName.oid));
            } else {
              value = asn1$4.oidToDer(value);
            }
          }
          fullNameGeneralNames.value.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, altName.type, false, value));
        }
        subSeq.value.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames]));
        seq2.push(subSeq);
      }
      if (typeof e2.value === "undefined") {
        var error2 = new Error("Extension value not specified.");
        error2.extension = e2;
        throw error2;
      }
      return e2;
    }
    function _signatureParametersToAsn1(oid, params) {
      switch (oid) {
        case oids["RSASSA-PSS"]:
          var parts = [];
          if (params.hash.algorithmOid !== void 0) {
            parts.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
                asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, asn1$4.oidToDer(params.hash.algorithmOid).getBytes()),
                asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.NULL, false, "")
              ])
            ]));
          }
          if (params.mgf.algorithmOid !== void 0) {
            parts.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 1, true, [
              asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
                asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, asn1$4.oidToDer(params.mgf.algorithmOid).getBytes()),
                asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
                  asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, asn1$4.oidToDer(params.mgf.hash.algorithmOid).getBytes()),
                  asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.NULL, false, "")
                ])
              ])
            ]));
          }
          if (params.saltLength !== void 0) {
            parts.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 2, true, [
              asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, asn1$4.integerToDer(params.saltLength).getBytes())
            ]));
          }
          return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, parts);
        default:
          return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.NULL, false, "");
      }
    }
    function _CRIAttributesToAsn1(csr) {
      var rval = asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 0, true, []);
      if (csr.attributes.length === 0) {
        return rval;
      }
      var attrs = csr.attributes;
      for (var i3 = 0; i3 < attrs.length; ++i3) {
        var attr = attrs[i3];
        var value = attr.value;
        var valueTagClass = asn1$4.Type.UTF8;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
        }
        if (valueTagClass === asn1$4.Type.UTF8) {
          value = forge$e.util.encodeUtf8(value);
        }
        var valueConstructed = false;
        if ("valueConstructed" in attr) {
          valueConstructed = attr.valueConstructed;
        }
        var seq2 = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, asn1$4.oidToDer(attr.type).getBytes()),
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SET, true, [
            asn1$4.create(asn1$4.Class.UNIVERSAL, valueTagClass, valueConstructed, value)
          ])
        ]);
        rval.value.push(seq2);
      }
      return rval;
    }
    var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
    var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
    function _dateToAsn1(date) {
      if (date >= jan_1_1950 && date < jan_1_2050) {
        return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.UTCTIME, false, asn1$4.dateToUtcTime(date));
      } else {
        return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.GENERALIZEDTIME, false, asn1$4.dateToGeneralizedTime(date));
      }
    }
    pki$2.getTBSCertificate = function(cert) {
      var notBefore = _dateToAsn1(cert.validity.notBefore);
      var notAfter = _dateToAsn1(cert.validity.notAfter);
      var tbs = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
        asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, asn1$4.integerToDer(cert.version).getBytes())
        ]),
        asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, forge$e.util.hexToBytes(cert.serialNumber)),
        asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, asn1$4.oidToDer(cert.siginfo.algorithmOid).getBytes()),
          _signatureParametersToAsn1(cert.siginfo.algorithmOid, cert.siginfo.parameters)
        ]),
        _dnToAsn1(cert.issuer),
        asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
          notBefore,
          notAfter
        ]),
        _dnToAsn1(cert.subject),
        pki$2.publicKeyToAsn1(cert.publicKey)
      ]);
      if (cert.issuer.uniqueId) {
        tbs.value.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 1, true, [
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.BITSTRING, false, String.fromCharCode(0) + cert.issuer.uniqueId)
        ]));
      }
      if (cert.subject.uniqueId) {
        tbs.value.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 2, true, [
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.BITSTRING, false, String.fromCharCode(0) + cert.subject.uniqueId)
        ]));
      }
      if (cert.extensions.length > 0) {
        tbs.value.push(pki$2.certificateExtensionsToAsn1(cert.extensions));
      }
      return tbs;
    };
    pki$2.getCertificationRequestInfo = function(csr) {
      var cri = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
        asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.INTEGER, false, asn1$4.integerToDer(csr.version).getBytes()),
        _dnToAsn1(csr.subject),
        pki$2.publicKeyToAsn1(csr.publicKey),
        _CRIAttributesToAsn1(csr)
      ]);
      return cri;
    };
    pki$2.distinguishedNameToAsn1 = function(dn2) {
      return _dnToAsn1(dn2);
    };
    pki$2.certificateToAsn1 = function(cert) {
      var tbsCertificate = cert.tbsCertificate || pki$2.getTBSCertificate(cert);
      return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
        tbsCertificate,
        asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, asn1$4.oidToDer(cert.signatureOid).getBytes()),
          _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
        ]),
        asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.BITSTRING, false, String.fromCharCode(0) + cert.signature)
      ]);
    };
    pki$2.certificateExtensionsToAsn1 = function(exts) {
      var rval = asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 3, true, []);
      var seq2 = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
      rval.value.push(seq2);
      for (var i3 = 0; i3 < exts.length; ++i3) {
        seq2.value.push(pki$2.certificateExtensionToAsn1(exts[i3]));
      }
      return rval;
    };
    pki$2.certificateExtensionToAsn1 = function(ext2) {
      var extseq = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
      extseq.value.push(asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, asn1$4.oidToDer(ext2.id).getBytes()));
      if (ext2.critical) {
        extseq.value.push(asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.BOOLEAN, false, String.fromCharCode(255)));
      }
      var value = ext2.value;
      if (typeof ext2.value !== "string") {
        value = asn1$4.toDer(value).getBytes();
      }
      extseq.value.push(asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OCTETSTRING, false, value));
      return extseq;
    };
    pki$2.certificationRequestToAsn1 = function(csr) {
      var cri = csr.certificationRequestInfo || pki$2.getCertificationRequestInfo(csr);
      return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
        cri,
        asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.OID, false, asn1$4.oidToDer(csr.signatureOid).getBytes()),
          _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
        ]),
        asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.BITSTRING, false, String.fromCharCode(0) + csr.signature)
      ]);
    };
    pki$2.createCaStore = function(certs) {
      var caStore = {
        certs: {}
      };
      caStore.getIssuer = function(cert2) {
        var rval = getBySubject(cert2.issuer);
        return rval;
      };
      caStore.addCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge$e.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          if (cert2.subject.hash in caStore.certs) {
            var tmp = caStore.certs[cert2.subject.hash];
            if (!forge$e.util.isArray(tmp)) {
              tmp = [tmp];
            }
            tmp.push(cert2);
            caStore.certs[cert2.subject.hash] = tmp;
          } else {
            caStore.certs[cert2.subject.hash] = cert2;
          }
        }
      };
      caStore.hasCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge$e.pki.certificateFromPem(cert2);
        }
        var match2 = getBySubject(cert2.subject);
        if (!match2) {
          return false;
        }
        if (!forge$e.util.isArray(match2)) {
          match2 = [match2];
        }
        var der1 = asn1$4.toDer(pki$2.certificateToAsn1(cert2)).getBytes();
        for (var i4 = 0; i4 < match2.length; ++i4) {
          var der2 = asn1$4.toDer(pki$2.certificateToAsn1(match2[i4])).getBytes();
          if (der1 === der2) {
            return true;
          }
        }
        return false;
      };
      caStore.listAllCertificates = function() {
        var certList = [];
        for (var hash2 in caStore.certs) {
          if (caStore.certs.hasOwnProperty(hash2)) {
            var value = caStore.certs[hash2];
            if (!forge$e.util.isArray(value)) {
              certList.push(value);
            } else {
              for (var i4 = 0; i4 < value.length; ++i4) {
                certList.push(value[i4]);
              }
            }
          }
        }
        return certList;
      };
      caStore.removeCertificate = function(cert2) {
        var result2;
        if (typeof cert2 === "string") {
          cert2 = forge$e.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          return null;
        }
        var match2 = getBySubject(cert2.subject);
        if (!forge$e.util.isArray(match2)) {
          result2 = caStore.certs[cert2.subject.hash];
          delete caStore.certs[cert2.subject.hash];
          return result2;
        }
        var der1 = asn1$4.toDer(pki$2.certificateToAsn1(cert2)).getBytes();
        for (var i4 = 0; i4 < match2.length; ++i4) {
          var der2 = asn1$4.toDer(pki$2.certificateToAsn1(match2[i4])).getBytes();
          if (der1 === der2) {
            result2 = match2[i4];
            match2.splice(i4, 1);
          }
        }
        if (match2.length === 0) {
          delete caStore.certs[cert2.subject.hash];
        }
        return result2;
      };
      function getBySubject(subject) {
        ensureSubjectHasHash(subject);
        return caStore.certs[subject.hash] || null;
      }
      function ensureSubjectHasHash(subject) {
        if (!subject.hash) {
          var md = forge$e.md.sha1.create();
          subject.attributes = pki$2.RDNAttributesAsArray(_dnToAsn1(subject), md);
          subject.hash = md.digest().toHex();
        }
      }
      if (certs) {
        for (var i3 = 0; i3 < certs.length; ++i3) {
          var cert = certs[i3];
          caStore.addCertificate(cert);
        }
      }
      return caStore;
    };
    pki$2.certificateError = {
      bad_certificate: "forge.pki.BadCertificate",
      unsupported_certificate: "forge.pki.UnsupportedCertificate",
      certificate_revoked: "forge.pki.CertificateRevoked",
      certificate_expired: "forge.pki.CertificateExpired",
      certificate_unknown: "forge.pki.CertificateUnknown",
      unknown_ca: "forge.pki.UnknownCertificateAuthority"
    };
    pki$2.verifyCertificateChain = function(caStore, chain, options2) {
      if (typeof options2 === "function") {
        options2 = { verify: options2 };
      }
      options2 = options2 || {};
      chain = chain.slice(0);
      var certs = chain.slice(0);
      var validityCheckDate = options2.validityCheckDate;
      if (typeof validityCheckDate === "undefined") {
        validityCheckDate = new Date();
      }
      var first2 = true;
      var error2 = null;
      var depth2 = 0;
      do {
        var cert = chain.shift();
        var parent = null;
        var selfSigned = false;
        if (validityCheckDate) {
          if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
            error2 = {
              message: "Certificate is not valid yet or has expired.",
              error: pki$2.certificateError.certificate_expired,
              notBefore: cert.validity.notBefore,
              notAfter: cert.validity.notAfter,
              now: validityCheckDate
            };
          }
        }
        if (error2 === null) {
          parent = chain[0] || caStore.getIssuer(cert);
          if (parent === null) {
            if (cert.isIssuer(cert)) {
              selfSigned = true;
              parent = cert;
            }
          }
          if (parent) {
            var parents = parent;
            if (!forge$e.util.isArray(parents)) {
              parents = [parents];
            }
            var verified = false;
            while (!verified && parents.length > 0) {
              parent = parents.shift();
              try {
                verified = parent.verify(cert);
              } catch (ex) {
              }
            }
            if (!verified) {
              error2 = {
                message: "Certificate signature is invalid.",
                error: pki$2.certificateError.bad_certificate
              };
            }
          }
          if (error2 === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
            error2 = {
              message: "Certificate is not trusted.",
              error: pki$2.certificateError.unknown_ca
            };
          }
        }
        if (error2 === null && parent && !cert.isIssuer(parent)) {
          error2 = {
            message: "Certificate issuer is invalid.",
            error: pki$2.certificateError.bad_certificate
          };
        }
        if (error2 === null) {
          var se2 = {
            keyUsage: true,
            basicConstraints: true
          };
          for (var i3 = 0; error2 === null && i3 < cert.extensions.length; ++i3) {
            var ext2 = cert.extensions[i3];
            if (ext2.critical && !(ext2.name in se2)) {
              error2 = {
                message: "Certificate has an unsupported critical extension.",
                error: pki$2.certificateError.unsupported_certificate
              };
            }
          }
        }
        if (error2 === null && (!first2 || chain.length === 0 && (!parent || selfSigned))) {
          var bcExt = cert.getExtension("basicConstraints");
          var keyUsageExt = cert.getExtension("keyUsage");
          if (keyUsageExt !== null) {
            if (!keyUsageExt.keyCertSign || bcExt === null) {
              error2 = {
                message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                error: pki$2.certificateError.bad_certificate
              };
            }
          }
          if (error2 === null && bcExt !== null && !bcExt.cA) {
            error2 = {
              message: "Certificate basicConstraints indicates the certificate is not a CA.",
              error: pki$2.certificateError.bad_certificate
            };
          }
          if (error2 === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
            var pathLen = depth2 - 1;
            if (pathLen > bcExt.pathLenConstraint) {
              error2 = {
                message: "Certificate basicConstraints pathLenConstraint violated.",
                error: pki$2.certificateError.bad_certificate
              };
            }
          }
        }
        var vfd = error2 === null ? true : error2.error;
        var ret = options2.verify ? options2.verify(vfd, depth2, certs) : vfd;
        if (ret === true) {
          error2 = null;
        } else {
          if (vfd === true) {
            error2 = {
              message: "The application rejected the certificate.",
              error: pki$2.certificateError.bad_certificate
            };
          }
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge$e.util.isArray(ret)) {
              if (ret.message) {
                error2.message = ret.message;
              }
              if (ret.error) {
                error2.error = ret.error;
              }
            } else if (typeof ret === "string") {
              error2.error = ret;
            }
          }
          throw error2;
        }
        first2 = false;
        ++depth2;
      } while (chain.length > 0);
      return true;
    };
    var forge$d = forge$F;
    var asn1$3 = forge$d.asn1;
    var pki$1 = forge$d.pki;
    var p12 = forge$d.pkcs12 = forge$d.pkcs12 || {};
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "ContentInfo.contentType",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1$3.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: "content"
      }]
    };
    var pfxValidator = {
      name: "PFX",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "PFX.version",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        contentInfoValidator,
        {
          name: "PFX.macData",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "mac",
          value: [{
            name: "PFX.macData.mac",
            tagClass: asn1$3.Class.UNIVERSAL,
            type: asn1$3.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "PFX.macData.mac.digestAlgorithm",
              tagClass: asn1$3.Class.UNIVERSAL,
              type: asn1$3.Type.SEQUENCE,
              constructed: true,
              value: [{
                name: "PFX.macData.mac.digestAlgorithm.algorithm",
                tagClass: asn1$3.Class.UNIVERSAL,
                type: asn1$3.Type.OID,
                constructed: false,
                capture: "macAlgorithm"
              }, {
                name: "PFX.macData.mac.digestAlgorithm.parameters",
                tagClass: asn1$3.Class.UNIVERSAL,
                captureAsn1: "macAlgorithmParameters"
              }]
            }, {
              name: "PFX.macData.mac.digest",
              tagClass: asn1$3.Class.UNIVERSAL,
              type: asn1$3.Type.OCTETSTRING,
              constructed: false,
              capture: "macDigest"
            }]
          }, {
            name: "PFX.macData.macSalt",
            tagClass: asn1$3.Class.UNIVERSAL,
            type: asn1$3.Type.OCTETSTRING,
            constructed: false,
            capture: "macSalt"
          }, {
            name: "PFX.macData.iterations",
            tagClass: asn1$3.Class.UNIVERSAL,
            type: asn1$3.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "macIterations"
          }]
        }
      ]
    };
    var safeBagValidator = {
      name: "SafeBag",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SafeBag.bagId",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.OID,
        constructed: false,
        capture: "bagId"
      }, {
        name: "SafeBag.bagValue",
        tagClass: asn1$3.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: "bagValue"
      }, {
        name: "SafeBag.bagAttributes",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.SET,
        constructed: true,
        optional: true,
        capture: "bagAttributes"
      }]
    };
    var attributeValidator = {
      name: "Attribute",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Attribute.attrId",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.OID,
        constructed: false,
        capture: "oid"
      }, {
        name: "Attribute.attrValues",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.SET,
        constructed: true,
        capture: "values"
      }]
    };
    var certBagValidator = {
      name: "CertBag",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "CertBag.certId",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.OID,
        constructed: false,
        capture: "certId"
      }, {
        name: "CertBag.certValue",
        tagClass: asn1$3.Class.CONTEXT_SPECIFIC,
        constructed: true,
        value: [{
          name: "CertBag.certValue[0]",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Class.OCTETSTRING,
          constructed: false,
          capture: "cert"
        }]
      }]
    };
    function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
      var result2 = [];
      for (var i3 = 0; i3 < safeContents.length; i3++) {
        for (var j2 = 0; j2 < safeContents[i3].safeBags.length; j2++) {
          var bag = safeContents[i3].safeBags[j2];
          if (bagType !== void 0 && bag.type !== bagType) {
            continue;
          }
          if (attrName === null) {
            result2.push(bag);
            continue;
          }
          if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) {
            result2.push(bag);
          }
        }
      }
      return result2;
    }
    p12.pkcs12FromAsn1 = function(obj, strict, password) {
      if (typeof strict === "string") {
        password = strict;
        strict = true;
      } else if (strict === void 0) {
        strict = true;
      }
      var capture = {};
      var errors = [];
      if (!asn1$3.validate(obj, pfxValidator, capture, errors)) {
        var error2 = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
        error2.errors = error2;
        throw error2;
      }
      var pfx = {
        version: capture.version.charCodeAt(0),
        safeContents: [],
        getBags: function(filter2) {
          var rval = {};
          var localKeyId;
          if ("localKeyId" in filter2) {
            localKeyId = filter2.localKeyId;
          } else if ("localKeyIdHex" in filter2) {
            localKeyId = forge$d.util.hexToBytes(filter2.localKeyIdHex);
          }
          if (localKeyId === void 0 && !("friendlyName" in filter2) && "bagType" in filter2) {
            rval[filter2.bagType] = _getBagsByAttribute(pfx.safeContents, null, null, filter2.bagType);
          }
          if (localKeyId !== void 0) {
            rval.localKeyId = _getBagsByAttribute(pfx.safeContents, "localKeyId", localKeyId, filter2.bagType);
          }
          if ("friendlyName" in filter2) {
            rval.friendlyName = _getBagsByAttribute(pfx.safeContents, "friendlyName", filter2.friendlyName, filter2.bagType);
          }
          return rval;
        },
        getBagsByFriendlyName: function(friendlyName, bagType) {
          return _getBagsByAttribute(pfx.safeContents, "friendlyName", friendlyName, bagType);
        },
        getBagsByLocalKeyId: function(localKeyId, bagType) {
          return _getBagsByAttribute(pfx.safeContents, "localKeyId", localKeyId, bagType);
        }
      };
      if (capture.version.charCodeAt(0) !== 3) {
        var error2 = new Error("PKCS#12 PFX of version other than 3 not supported.");
        error2.version = capture.version.charCodeAt(0);
        throw error2;
      }
      if (asn1$3.derToOid(capture.contentType) !== pki$1.oids.data) {
        var error2 = new Error("Only PKCS#12 PFX in password integrity mode supported.");
        error2.oid = asn1$3.derToOid(capture.contentType);
        throw error2;
      }
      var data2 = capture.content.value[0];
      if (data2.tagClass !== asn1$3.Class.UNIVERSAL || data2.type !== asn1$3.Type.OCTETSTRING) {
        throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
      }
      data2 = _decodePkcs7Data(data2);
      if (capture.mac) {
        var md = null;
        var macKeyBytes = 0;
        var macAlgorithm = asn1$3.derToOid(capture.macAlgorithm);
        switch (macAlgorithm) {
          case pki$1.oids.sha1:
            md = forge$d.md.sha1.create();
            macKeyBytes = 20;
            break;
          case pki$1.oids.sha256:
            md = forge$d.md.sha256.create();
            macKeyBytes = 32;
            break;
          case pki$1.oids.sha384:
            md = forge$d.md.sha384.create();
            macKeyBytes = 48;
            break;
          case pki$1.oids.sha512:
            md = forge$d.md.sha512.create();
            macKeyBytes = 64;
            break;
          case pki$1.oids.md5:
            md = forge$d.md.md5.create();
            macKeyBytes = 16;
            break;
        }
        if (md === null) {
          throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
        }
        var macSalt = new forge$d.util.ByteBuffer(capture.macSalt);
        var macIterations = "macIterations" in capture ? parseInt(forge$d.util.bytesToHex(capture.macIterations), 16) : 1;
        var macKey = p12.generateKey(password, macSalt, 3, macIterations, macKeyBytes, md);
        var mac = forge$d.hmac.create();
        mac.start(md, macKey);
        mac.update(data2.value);
        var macValue = mac.getMac();
        if (macValue.getBytes() !== capture.macDigest) {
          throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
        }
      }
      _decodeAuthenticatedSafe(pfx, data2.value, strict, password);
      return pfx;
    };
    function _decodePkcs7Data(data2) {
      if (data2.composed || data2.constructed) {
        var value = forge$d.util.createBuffer();
        for (var i3 = 0; i3 < data2.value.length; ++i3) {
          value.putBytes(data2.value[i3].value);
        }
        data2.composed = data2.constructed = false;
        data2.value = value.getBytes();
      }
      return data2;
    }
    function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
      authSafe = asn1$3.fromDer(authSafe, strict);
      if (authSafe.tagClass !== asn1$3.Class.UNIVERSAL || authSafe.type !== asn1$3.Type.SEQUENCE || authSafe.constructed !== true) {
        throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
      }
      for (var i3 = 0; i3 < authSafe.value.length; i3++) {
        var contentInfo = authSafe.value[i3];
        var capture = {};
        var errors = [];
        if (!asn1$3.validate(contentInfo, contentInfoValidator, capture, errors)) {
          var error2 = new Error("Cannot read ContentInfo.");
          error2.errors = errors;
          throw error2;
        }
        var obj = {
          encrypted: false
        };
        var safeContents = null;
        var data2 = capture.content.value[0];
        switch (asn1$3.derToOid(capture.contentType)) {
          case pki$1.oids.data:
            if (data2.tagClass !== asn1$3.Class.UNIVERSAL || data2.type !== asn1$3.Type.OCTETSTRING) {
              throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
            }
            safeContents = _decodePkcs7Data(data2).value;
            break;
          case pki$1.oids.encryptedData:
            safeContents = _decryptSafeContents(data2, password);
            obj.encrypted = true;
            break;
          default:
            var error2 = new Error("Unsupported PKCS#12 contentType.");
            error2.contentType = asn1$3.derToOid(capture.contentType);
            throw error2;
        }
        obj.safeBags = _decodeSafeContents(safeContents, strict, password);
        pfx.safeContents.push(obj);
      }
    }
    function _decryptSafeContents(data2, password) {
      var capture = {};
      var errors = [];
      if (!asn1$3.validate(data2, forge$d.pkcs7.asn1.encryptedDataValidator, capture, errors)) {
        var error2 = new Error("Cannot read EncryptedContentInfo.");
        error2.errors = errors;
        throw error2;
      }
      var oid = asn1$3.derToOid(capture.contentType);
      if (oid !== pki$1.oids.data) {
        var error2 = new Error("PKCS#12 EncryptedContentInfo ContentType is not Data.");
        error2.oid = oid;
        throw error2;
      }
      oid = asn1$3.derToOid(capture.encAlgorithm);
      var cipher = pki$1.pbe.getCipher(oid, capture.encParameter, password);
      var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
      var encrypted = forge$d.util.createBuffer(encryptedContentAsn1.value);
      cipher.update(encrypted);
      if (!cipher.finish()) {
        throw new Error("Failed to decrypt PKCS#12 SafeContents.");
      }
      return cipher.output.getBytes();
    }
    function _decodeSafeContents(safeContents, strict, password) {
      if (!strict && safeContents.length === 0) {
        return [];
      }
      safeContents = asn1$3.fromDer(safeContents, strict);
      if (safeContents.tagClass !== asn1$3.Class.UNIVERSAL || safeContents.type !== asn1$3.Type.SEQUENCE || safeContents.constructed !== true) {
        throw new Error("PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.");
      }
      var res = [];
      for (var i3 = 0; i3 < safeContents.value.length; i3++) {
        var safeBag = safeContents.value[i3];
        var capture = {};
        var errors = [];
        if (!asn1$3.validate(safeBag, safeBagValidator, capture, errors)) {
          var error2 = new Error("Cannot read SafeBag.");
          error2.errors = errors;
          throw error2;
        }
        var bag = {
          type: asn1$3.derToOid(capture.bagId),
          attributes: _decodeBagAttributes(capture.bagAttributes)
        };
        res.push(bag);
        var validator, decoder;
        var bagAsn1 = capture.bagValue.value[0];
        switch (bag.type) {
          case pki$1.oids.pkcs8ShroudedKeyBag:
            bagAsn1 = pki$1.decryptPrivateKeyInfo(bagAsn1, password);
            if (bagAsn1 === null) {
              throw new Error("Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?");
            }
          case pki$1.oids.keyBag:
            try {
              bag.key = pki$1.privateKeyFromAsn1(bagAsn1);
            } catch (e2) {
              bag.key = null;
              bag.asn1 = bagAsn1;
            }
            continue;
          case pki$1.oids.certBag:
            validator = certBagValidator;
            decoder = function() {
              if (asn1$3.derToOid(capture.certId) !== pki$1.oids.x509Certificate) {
                var error3 = new Error("Unsupported certificate type, only X.509 supported.");
                error3.oid = asn1$3.derToOid(capture.certId);
                throw error3;
              }
              var certAsn1 = asn1$3.fromDer(capture.cert, strict);
              try {
                bag.cert = pki$1.certificateFromAsn1(certAsn1, true);
              } catch (e2) {
                bag.cert = null;
                bag.asn1 = certAsn1;
              }
            };
            break;
          default:
            var error2 = new Error("Unsupported PKCS#12 SafeBag type.");
            error2.oid = bag.type;
            throw error2;
        }
        if (validator !== void 0 && !asn1$3.validate(bagAsn1, validator, capture, errors)) {
          var error2 = new Error("Cannot read PKCS#12 " + validator.name);
          error2.errors = errors;
          throw error2;
        }
        decoder();
      }
      return res;
    }
    function _decodeBagAttributes(attributes) {
      var decodedAttrs = {};
      if (attributes !== void 0) {
        for (var i3 = 0; i3 < attributes.length; ++i3) {
          var capture = {};
          var errors = [];
          if (!asn1$3.validate(attributes[i3], attributeValidator, capture, errors)) {
            var error2 = new Error("Cannot read PKCS#12 BagAttribute.");
            error2.errors = errors;
            throw error2;
          }
          var oid = asn1$3.derToOid(capture.oid);
          if (pki$1.oids[oid] === void 0) {
            continue;
          }
          decodedAttrs[pki$1.oids[oid]] = [];
          for (var j2 = 0; j2 < capture.values.length; ++j2) {
            decodedAttrs[pki$1.oids[oid]].push(capture.values[j2].value);
          }
        }
      }
      return decodedAttrs;
    }
    p12.toPkcs12Asn1 = function(key2, cert, password, options2) {
      options2 = options2 || {};
      options2.saltSize = options2.saltSize || 8;
      options2.count = options2.count || 2048;
      options2.algorithm = options2.algorithm || options2.encAlgorithm || "aes128";
      if (!("useMac" in options2)) {
        options2.useMac = true;
      }
      if (!("localKeyId" in options2)) {
        options2.localKeyId = null;
      }
      if (!("generateLocalKeyId" in options2)) {
        options2.generateLocalKeyId = true;
      }
      var localKeyId = options2.localKeyId;
      var bagAttrs;
      if (localKeyId !== null) {
        localKeyId = forge$d.util.hexToBytes(localKeyId);
      } else if (options2.generateLocalKeyId) {
        if (cert) {
          var pairedCert = forge$d.util.isArray(cert) ? cert[0] : cert;
          if (typeof pairedCert === "string") {
            pairedCert = pki$1.certificateFromPem(pairedCert);
          }
          var sha12 = forge$d.md.sha1.create();
          sha12.update(asn1$3.toDer(pki$1.certificateToAsn1(pairedCert)).getBytes());
          localKeyId = sha12.digest().getBytes();
        } else {
          localKeyId = forge$d.random.getBytes(20);
        }
      }
      var attrs = [];
      if (localKeyId !== null) {
        attrs.push(asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
          asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.OID, false, asn1$3.oidToDer(pki$1.oids.localKeyId).getBytes()),
          asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SET, true, [
            asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.OCTETSTRING, false, localKeyId)
          ])
        ]));
      }
      if ("friendlyName" in options2) {
        attrs.push(asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
          asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.OID, false, asn1$3.oidToDer(pki$1.oids.friendlyName).getBytes()),
          asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SET, true, [
            asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.BMPSTRING, false, options2.friendlyName)
          ])
        ]));
      }
      if (attrs.length > 0) {
        bagAttrs = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SET, true, attrs);
      }
      var contents = [];
      var chain = [];
      if (cert !== null) {
        if (forge$d.util.isArray(cert)) {
          chain = cert;
        } else {
          chain = [cert];
        }
      }
      var certSafeBags = [];
      for (var i3 = 0; i3 < chain.length; ++i3) {
        cert = chain[i3];
        if (typeof cert === "string") {
          cert = pki$1.certificateFromPem(cert);
        }
        var certBagAttrs = i3 === 0 ? bagAttrs : void 0;
        var certAsn1 = pki$1.certificateToAsn1(cert);
        var certSafeBag = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
          asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.OID, false, asn1$3.oidToDer(pki$1.oids.certBag).getBytes()),
          asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
              asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.OID, false, asn1$3.oidToDer(pki$1.oids.x509Certificate).getBytes()),
              asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.OCTETSTRING, false, asn1$3.toDer(certAsn1).getBytes())
              ])
            ])
          ]),
          certBagAttrs
        ]);
        certSafeBags.push(certSafeBag);
      }
      if (certSafeBags.length > 0) {
        var certSafeContents = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, certSafeBags);
        var certCI = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
          asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.OID, false, asn1$3.oidToDer(pki$1.oids.data).getBytes()),
          asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.OCTETSTRING, false, asn1$3.toDer(certSafeContents).getBytes())
          ])
        ]);
        contents.push(certCI);
      }
      var keyBag = null;
      if (key2 !== null) {
        var pkAsn1 = pki$1.wrapRsaPrivateKey(pki$1.privateKeyToAsn1(key2));
        if (password === null) {
          keyBag = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
            asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.OID, false, asn1$3.oidToDer(pki$1.oids.keyBag).getBytes()),
            asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
              pkAsn1
            ]),
            bagAttrs
          ]);
        } else {
          keyBag = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
            asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.OID, false, asn1$3.oidToDer(pki$1.oids.pkcs8ShroudedKeyBag).getBytes()),
            asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
              pki$1.encryptPrivateKeyInfo(pkAsn1, password, options2)
            ]),
            bagAttrs
          ]);
        }
        var keySafeContents = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [keyBag]);
        var keyCI = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
          asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.OID, false, asn1$3.oidToDer(pki$1.oids.data).getBytes()),
          asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.OCTETSTRING, false, asn1$3.toDer(keySafeContents).getBytes())
          ])
        ]);
        contents.push(keyCI);
      }
      var safe = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, contents);
      var macData;
      if (options2.useMac) {
        var sha12 = forge$d.md.sha1.create();
        var macSalt = new forge$d.util.ByteBuffer(forge$d.random.getBytes(options2.saltSize));
        var count = options2.count;
        var key2 = p12.generateKey(password, macSalt, 3, count, 20);
        var mac = forge$d.hmac.create();
        mac.start(sha12, key2);
        mac.update(asn1$3.toDer(safe).getBytes());
        var macValue = mac.getMac();
        macData = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
          asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
            asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
              asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.OID, false, asn1$3.oidToDer(pki$1.oids.sha1).getBytes()),
              asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.NULL, false, "")
            ]),
            asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.OCTETSTRING, false, macValue.getBytes())
          ]),
          asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.OCTETSTRING, false, macSalt.getBytes()),
          asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.INTEGER, false, asn1$3.integerToDer(count).getBytes())
        ]);
      }
      return asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
        asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.INTEGER, false, asn1$3.integerToDer(3).getBytes()),
        asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
          asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.OID, false, asn1$3.oidToDer(pki$1.oids.data).getBytes()),
          asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.OCTETSTRING, false, asn1$3.toDer(safe).getBytes())
          ])
        ]),
        macData
      ]);
    };
    p12.generateKey = forge$d.pbe.generatePkcs12Key;
    var forge$c = forge$F;
    var asn1$2 = forge$c.asn1;
    var pki = forge$c.pki = forge$c.pki || {};
    pki.pemToDer = function(pem2) {
      var msg = forge$c.pem.decode(pem2)[0];
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PEM to DER; PEM is encrypted.");
      }
      return forge$c.util.createBuffer(msg.body);
    };
    pki.privateKeyFromPem = function(pem2) {
      var msg = forge$c.pem.decode(pem2)[0];
      if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error2 = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
        error2.headerType = msg.type;
        throw error2;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert private key from PEM; PEM is encrypted.");
      }
      var obj = asn1$2.fromDer(msg.body);
      return pki.privateKeyFromAsn1(obj);
    };
    pki.privateKeyToPem = function(key2, maxline) {
      var msg = {
        type: "RSA PRIVATE KEY",
        body: asn1$2.toDer(pki.privateKeyToAsn1(key2)).getBytes()
      };
      return forge$c.pem.encode(msg, { maxline });
    };
    pki.privateKeyInfoToPem = function(pki2, maxline) {
      var msg = {
        type: "PRIVATE KEY",
        body: asn1$2.toDer(pki2).getBytes()
      };
      return forge$c.pem.encode(msg, { maxline });
    };
    var forge$b = forge$F;
    var prf_TLS1 = function(secret, label, seed, length) {
      var rval = forge$b.util.createBuffer();
      var idx = secret.length >> 1;
      var slen = idx + (secret.length & 1);
      var s1 = secret.substr(0, slen);
      var s22 = secret.substr(idx, slen);
      var ai2 = forge$b.util.createBuffer();
      var hmac2 = forge$b.hmac.create();
      seed = label + seed;
      var md5itr = Math.ceil(length / 16);
      var sha1itr = Math.ceil(length / 20);
      hmac2.start("MD5", s1);
      var md5bytes = forge$b.util.createBuffer();
      ai2.putBytes(seed);
      for (var i3 = 0; i3 < md5itr; ++i3) {
        hmac2.start(null, null);
        hmac2.update(ai2.getBytes());
        ai2.putBuffer(hmac2.digest());
        hmac2.start(null, null);
        hmac2.update(ai2.bytes() + seed);
        md5bytes.putBuffer(hmac2.digest());
      }
      hmac2.start("SHA1", s22);
      var sha1bytes = forge$b.util.createBuffer();
      ai2.clear();
      ai2.putBytes(seed);
      for (var i3 = 0; i3 < sha1itr; ++i3) {
        hmac2.start(null, null);
        hmac2.update(ai2.getBytes());
        ai2.putBuffer(hmac2.digest());
        hmac2.start(null, null);
        hmac2.update(ai2.bytes() + seed);
        sha1bytes.putBuffer(hmac2.digest());
      }
      rval.putBytes(forge$b.util.xorBytes(md5bytes.getBytes(), sha1bytes.getBytes(), length));
      return rval;
    };
    var hmac_sha1 = function(key2, seqNum, record) {
      var hmac2 = forge$b.hmac.create();
      hmac2.start("SHA1", key2);
      var b2 = forge$b.util.createBuffer();
      b2.putInt32(seqNum[0]);
      b2.putInt32(seqNum[1]);
      b2.putByte(record.type);
      b2.putByte(record.version.major);
      b2.putByte(record.version.minor);
      b2.putInt16(record.length);
      b2.putBytes(record.fragment.bytes());
      hmac2.update(b2.getBytes());
      return hmac2.digest().getBytes();
    };
    var deflate = function(c2, record, s3) {
      var rval = false;
      try {
        var bytes2 = c2.deflate(record.fragment.getBytes());
        record.fragment = forge$b.util.createBuffer(bytes2);
        record.length = bytes2.length;
        rval = true;
      } catch (ex) {
      }
      return rval;
    };
    var inflate = function(c2, record, s3) {
      var rval = false;
      try {
        var bytes2 = c2.inflate(record.fragment.getBytes());
        record.fragment = forge$b.util.createBuffer(bytes2);
        record.length = bytes2.length;
        rval = true;
      } catch (ex) {
      }
      return rval;
    };
    var readVector = function(b2, lenBytes) {
      var len = 0;
      switch (lenBytes) {
        case 1:
          len = b2.getByte();
          break;
        case 2:
          len = b2.getInt16();
          break;
        case 3:
          len = b2.getInt24();
          break;
        case 4:
          len = b2.getInt32();
          break;
      }
      return forge$b.util.createBuffer(b2.getBytes(len));
    };
    var writeVector = function(b2, lenBytes, v2) {
      b2.putInt(v2.length(), lenBytes << 3);
      b2.putBuffer(v2);
    };
    var tls$1 = {};
    tls$1.Versions = {
      TLS_1_0: { major: 3, minor: 1 },
      TLS_1_1: { major: 3, minor: 2 },
      TLS_1_2: { major: 3, minor: 3 }
    };
    tls$1.SupportedVersions = [
      tls$1.Versions.TLS_1_1,
      tls$1.Versions.TLS_1_0
    ];
    tls$1.Version = tls$1.SupportedVersions[0];
    tls$1.MaxFragment = 16384 - 1024;
    tls$1.ConnectionEnd = {
      server: 0,
      client: 1
    };
    tls$1.PRFAlgorithm = {
      tls_prf_sha256: 0
    };
    tls$1.BulkCipherAlgorithm = {
      none: null,
      rc4: 0,
      des3: 1,
      aes: 2
    };
    tls$1.CipherType = {
      stream: 0,
      block: 1,
      aead: 2
    };
    tls$1.MACAlgorithm = {
      none: null,
      hmac_md5: 0,
      hmac_sha1: 1,
      hmac_sha256: 2,
      hmac_sha384: 3,
      hmac_sha512: 4
    };
    tls$1.CompressionMethod = {
      none: 0,
      deflate: 1
    };
    tls$1.ContentType = {
      change_cipher_spec: 20,
      alert: 21,
      handshake: 22,
      application_data: 23,
      heartbeat: 24
    };
    tls$1.HandshakeType = {
      hello_request: 0,
      client_hello: 1,
      server_hello: 2,
      certificate: 11,
      server_key_exchange: 12,
      certificate_request: 13,
      server_hello_done: 14,
      certificate_verify: 15,
      client_key_exchange: 16,
      finished: 20
    };
    tls$1.Alert = {};
    tls$1.Alert.Level = {
      warning: 1,
      fatal: 2
    };
    tls$1.Alert.Description = {
      close_notify: 0,
      unexpected_message: 10,
      bad_record_mac: 20,
      decryption_failed: 21,
      record_overflow: 22,
      decompression_failure: 30,
      handshake_failure: 40,
      bad_certificate: 42,
      unsupported_certificate: 43,
      certificate_revoked: 44,
      certificate_expired: 45,
      certificate_unknown: 46,
      illegal_parameter: 47,
      unknown_ca: 48,
      access_denied: 49,
      decode_error: 50,
      decrypt_error: 51,
      export_restriction: 60,
      protocol_version: 70,
      insufficient_security: 71,
      internal_error: 80,
      user_canceled: 90,
      no_renegotiation: 100
    };
    tls$1.HeartbeatMessageType = {
      heartbeat_request: 1,
      heartbeat_response: 2
    };
    tls$1.CipherSuites = {};
    tls$1.getCipherSuite = function(twoBytes) {
      var rval = null;
      for (var key2 in tls$1.CipherSuites) {
        var cs2 = tls$1.CipherSuites[key2];
        if (cs2.id[0] === twoBytes.charCodeAt(0) && cs2.id[1] === twoBytes.charCodeAt(1)) {
          rval = cs2;
          break;
        }
      }
      return rval;
    };
    tls$1.handleUnexpected = function(c2, record) {
      var ignore2 = !c2.open && c2.entity === tls$1.ConnectionEnd.client;
      if (!ignore2) {
        c2.error(c2, {
          message: "Unexpected message. Received TLS record out of order.",
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.unexpected_message
          }
        });
      }
    };
    tls$1.handleHelloRequest = function(c2, record, length) {
      if (!c2.handshaking && c2.handshakes > 0) {
        tls$1.queue(c2, tls$1.createAlert(c2, {
          level: tls$1.Alert.Level.warning,
          description: tls$1.Alert.Description.no_renegotiation
        }));
        tls$1.flush(c2);
      }
      c2.process();
    };
    tls$1.parseHelloMessage = function(c2, record, length) {
      var msg = null;
      var client = c2.entity === tls$1.ConnectionEnd.client;
      if (length < 38) {
        c2.error(c2, {
          message: client ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.illegal_parameter
          }
        });
      } else {
        var b2 = record.fragment;
        var remaining = b2.length();
        msg = {
          version: {
            major: b2.getByte(),
            minor: b2.getByte()
          },
          random: forge$b.util.createBuffer(b2.getBytes(32)),
          session_id: readVector(b2, 1),
          extensions: []
        };
        if (client) {
          msg.cipher_suite = b2.getBytes(2);
          msg.compression_method = b2.getByte();
        } else {
          msg.cipher_suites = readVector(b2, 2);
          msg.compression_methods = readVector(b2, 1);
        }
        remaining = length - (remaining - b2.length());
        if (remaining > 0) {
          var exts = readVector(b2, 2);
          while (exts.length() > 0) {
            msg.extensions.push({
              type: [exts.getByte(), exts.getByte()],
              data: readVector(exts, 2)
            });
          }
          if (!client) {
            for (var i3 = 0; i3 < msg.extensions.length; ++i3) {
              var ext2 = msg.extensions[i3];
              if (ext2.type[0] === 0 && ext2.type[1] === 0) {
                var snl = readVector(ext2.data, 2);
                while (snl.length() > 0) {
                  var snType = snl.getByte();
                  if (snType !== 0) {
                    break;
                  }
                  c2.session.extensions.server_name.serverNameList.push(readVector(snl, 2).getBytes());
                }
              }
            }
          }
        }
        if (c2.session.version) {
          if (msg.version.major !== c2.session.version.major || msg.version.minor !== c2.session.version.minor) {
            return c2.error(c2, {
              message: "TLS version change is disallowed during renegotiation.",
              send: true,
              alert: {
                level: tls$1.Alert.Level.fatal,
                description: tls$1.Alert.Description.protocol_version
              }
            });
          }
        }
        if (client) {
          c2.session.cipherSuite = tls$1.getCipherSuite(msg.cipher_suite);
        } else {
          var tmp = forge$b.util.createBuffer(msg.cipher_suites.bytes());
          while (tmp.length() > 0) {
            c2.session.cipherSuite = tls$1.getCipherSuite(tmp.getBytes(2));
            if (c2.session.cipherSuite !== null) {
              break;
            }
          }
        }
        if (c2.session.cipherSuite === null) {
          return c2.error(c2, {
            message: "No cipher suites in common.",
            send: true,
            alert: {
              level: tls$1.Alert.Level.fatal,
              description: tls$1.Alert.Description.handshake_failure
            },
            cipherSuite: forge$b.util.bytesToHex(msg.cipher_suite)
          });
        }
        if (client) {
          c2.session.compressionMethod = msg.compression_method;
        } else {
          c2.session.compressionMethod = tls$1.CompressionMethod.none;
        }
      }
      return msg;
    };
    tls$1.createSecurityParameters = function(c2, msg) {
      var client = c2.entity === tls$1.ConnectionEnd.client;
      var msgRandom = msg.random.bytes();
      var cRandom = client ? c2.session.sp.client_random : msgRandom;
      var sRandom = client ? msgRandom : tls$1.createRandom().getBytes();
      c2.session.sp = {
        entity: c2.entity,
        prf_algorithm: tls$1.PRFAlgorithm.tls_prf_sha256,
        bulk_cipher_algorithm: null,
        cipher_type: null,
        enc_key_length: null,
        block_length: null,
        fixed_iv_length: null,
        record_iv_length: null,
        mac_algorithm: null,
        mac_length: null,
        mac_key_length: null,
        compression_algorithm: c2.session.compressionMethod,
        pre_master_secret: null,
        master_secret: null,
        client_random: cRandom,
        server_random: sRandom
      };
    };
    tls$1.handleServerHello = function(c2, record, length) {
      var msg = tls$1.parseHelloMessage(c2, record, length);
      if (c2.fail) {
        return;
      }
      if (msg.version.minor <= c2.version.minor) {
        c2.version.minor = msg.version.minor;
      } else {
        return c2.error(c2, {
          message: "Incompatible TLS version.",
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.protocol_version
          }
        });
      }
      c2.session.version = c2.version;
      var sessionId = msg.session_id.bytes();
      if (sessionId.length > 0 && sessionId === c2.session.id) {
        c2.expect = SCC;
        c2.session.resuming = true;
        c2.session.sp.server_random = msg.random.bytes();
      } else {
        c2.expect = SCE;
        c2.session.resuming = false;
        tls$1.createSecurityParameters(c2, msg);
      }
      c2.session.id = sessionId;
      c2.process();
    };
    tls$1.handleClientHello = function(c2, record, length) {
      var msg = tls$1.parseHelloMessage(c2, record, length);
      if (c2.fail) {
        return;
      }
      var sessionId = msg.session_id.bytes();
      var session = null;
      if (c2.sessionCache) {
        session = c2.sessionCache.getSession(sessionId);
        if (session === null) {
          sessionId = "";
        } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
          session = null;
          sessionId = "";
        }
      }
      if (sessionId.length === 0) {
        sessionId = forge$b.random.getBytes(32);
      }
      c2.session.id = sessionId;
      c2.session.clientHelloVersion = msg.version;
      c2.session.sp = {};
      if (session) {
        c2.version = c2.session.version = session.version;
        c2.session.sp = session.sp;
      } else {
        var version2;
        for (var i3 = 1; i3 < tls$1.SupportedVersions.length; ++i3) {
          version2 = tls$1.SupportedVersions[i3];
          if (version2.minor <= msg.version.minor) {
            break;
          }
        }
        c2.version = { major: version2.major, minor: version2.minor };
        c2.session.version = c2.version;
      }
      if (session !== null) {
        c2.expect = CCC;
        c2.session.resuming = true;
        c2.session.sp.client_random = msg.random.bytes();
      } else {
        c2.expect = c2.verifyClient !== false ? CCE : CKE;
        c2.session.resuming = false;
        tls$1.createSecurityParameters(c2, msg);
      }
      c2.open = true;
      tls$1.queue(c2, tls$1.createRecord(c2, {
        type: tls$1.ContentType.handshake,
        data: tls$1.createServerHello(c2)
      }));
      if (c2.session.resuming) {
        tls$1.queue(c2, tls$1.createRecord(c2, {
          type: tls$1.ContentType.change_cipher_spec,
          data: tls$1.createChangeCipherSpec()
        }));
        c2.state.pending = tls$1.createConnectionState(c2);
        c2.state.current.write = c2.state.pending.write;
        tls$1.queue(c2, tls$1.createRecord(c2, {
          type: tls$1.ContentType.handshake,
          data: tls$1.createFinished(c2)
        }));
      } else {
        tls$1.queue(c2, tls$1.createRecord(c2, {
          type: tls$1.ContentType.handshake,
          data: tls$1.createCertificate(c2)
        }));
        if (!c2.fail) {
          tls$1.queue(c2, tls$1.createRecord(c2, {
            type: tls$1.ContentType.handshake,
            data: tls$1.createServerKeyExchange(c2)
          }));
          if (c2.verifyClient !== false) {
            tls$1.queue(c2, tls$1.createRecord(c2, {
              type: tls$1.ContentType.handshake,
              data: tls$1.createCertificateRequest(c2)
            }));
          }
          tls$1.queue(c2, tls$1.createRecord(c2, {
            type: tls$1.ContentType.handshake,
            data: tls$1.createServerHelloDone(c2)
          }));
        }
      }
      tls$1.flush(c2);
      c2.process();
    };
    tls$1.handleCertificate = function(c2, record, length) {
      if (length < 3) {
        return c2.error(c2, {
          message: "Invalid Certificate message. Message too short.",
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.illegal_parameter
          }
        });
      }
      var b2 = record.fragment;
      var msg = {
        certificate_list: readVector(b2, 3)
      };
      var cert, asn12;
      var certs = [];
      try {
        while (msg.certificate_list.length() > 0) {
          cert = readVector(msg.certificate_list, 3);
          asn12 = forge$b.asn1.fromDer(cert);
          cert = forge$b.pki.certificateFromAsn1(asn12, true);
          certs.push(cert);
        }
      } catch (ex) {
        return c2.error(c2, {
          message: "Could not parse certificate list.",
          cause: ex,
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.bad_certificate
          }
        });
      }
      var client = c2.entity === tls$1.ConnectionEnd.client;
      if ((client || c2.verifyClient === true) && certs.length === 0) {
        c2.error(c2, {
          message: client ? "No server certificate provided." : "No client certificate provided.",
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.illegal_parameter
          }
        });
      } else if (certs.length === 0) {
        c2.expect = client ? SKE : CKE;
      } else {
        if (client) {
          c2.session.serverCertificate = certs[0];
        } else {
          c2.session.clientCertificate = certs[0];
        }
        if (tls$1.verifyCertificateChain(c2, certs)) {
          c2.expect = client ? SKE : CKE;
        }
      }
      c2.process();
    };
    tls$1.handleServerKeyExchange = function(c2, record, length) {
      if (length > 0) {
        return c2.error(c2, {
          message: "Invalid key parameters. Only RSA is supported.",
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.unsupported_certificate
          }
        });
      }
      c2.expect = SCR;
      c2.process();
    };
    tls$1.handleClientKeyExchange = function(c2, record, length) {
      if (length < 48) {
        return c2.error(c2, {
          message: "Invalid key parameters. Only RSA is supported.",
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.unsupported_certificate
          }
        });
      }
      var b2 = record.fragment;
      var msg = {
        enc_pre_master_secret: readVector(b2, 2).getBytes()
      };
      var privateKey = null;
      if (c2.getPrivateKey) {
        try {
          privateKey = c2.getPrivateKey(c2, c2.session.serverCertificate);
          privateKey = forge$b.pki.privateKeyFromPem(privateKey);
        } catch (ex) {
          c2.error(c2, {
            message: "Could not get private key.",
            cause: ex,
            send: true,
            alert: {
              level: tls$1.Alert.Level.fatal,
              description: tls$1.Alert.Description.internal_error
            }
          });
        }
      }
      if (privateKey === null) {
        return c2.error(c2, {
          message: "No private key set.",
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.internal_error
          }
        });
      }
      try {
        var sp = c2.session.sp;
        sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
        var version2 = c2.session.clientHelloVersion;
        if (version2.major !== sp.pre_master_secret.charCodeAt(0) || version2.minor !== sp.pre_master_secret.charCodeAt(1)) {
          throw new Error("TLS version rollback attack detected.");
        }
      } catch (ex) {
        sp.pre_master_secret = forge$b.random.getBytes(48);
      }
      c2.expect = CCC;
      if (c2.session.clientCertificate !== null) {
        c2.expect = CCV;
      }
      c2.process();
    };
    tls$1.handleCertificateRequest = function(c2, record, length) {
      if (length < 3) {
        return c2.error(c2, {
          message: "Invalid CertificateRequest. Message too short.",
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.illegal_parameter
          }
        });
      }
      var b2 = record.fragment;
      var msg = {
        certificate_types: readVector(b2, 1),
        certificate_authorities: readVector(b2, 2)
      };
      c2.session.certificateRequest = msg;
      c2.expect = SHD;
      c2.process();
    };
    tls$1.handleCertificateVerify = function(c2, record, length) {
      if (length < 2) {
        return c2.error(c2, {
          message: "Invalid CertificateVerify. Message too short.",
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.illegal_parameter
          }
        });
      }
      var b2 = record.fragment;
      b2.read -= 4;
      var msgBytes = b2.bytes();
      b2.read += 4;
      var msg = {
        signature: readVector(b2, 2).getBytes()
      };
      var verify = forge$b.util.createBuffer();
      verify.putBuffer(c2.session.md5.digest());
      verify.putBuffer(c2.session.sha1.digest());
      verify = verify.getBytes();
      try {
        var cert = c2.session.clientCertificate;
        if (!cert.publicKey.verify(verify, msg.signature, "NONE")) {
          throw new Error("CertificateVerify signature does not match.");
        }
        c2.session.md5.update(msgBytes);
        c2.session.sha1.update(msgBytes);
      } catch (ex) {
        return c2.error(c2, {
          message: "Bad signature in CertificateVerify.",
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.handshake_failure
          }
        });
      }
      c2.expect = CCC;
      c2.process();
    };
    tls$1.handleServerHelloDone = function(c2, record, length) {
      if (length > 0) {
        return c2.error(c2, {
          message: "Invalid ServerHelloDone message. Invalid length.",
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.record_overflow
          }
        });
      }
      if (c2.serverCertificate === null) {
        var error2 = {
          message: "No server certificate provided. Not enough security.",
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.insufficient_security
          }
        };
        var depth2 = 0;
        var ret = c2.verify(c2, error2.alert.description, depth2, []);
        if (ret !== true) {
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge$b.util.isArray(ret)) {
              if (ret.message) {
                error2.message = ret.message;
              }
              if (ret.alert) {
                error2.alert.description = ret.alert;
              }
            } else if (typeof ret === "number") {
              error2.alert.description = ret;
            }
          }
          return c2.error(c2, error2);
        }
      }
      if (c2.session.certificateRequest !== null) {
        record = tls$1.createRecord(c2, {
          type: tls$1.ContentType.handshake,
          data: tls$1.createCertificate(c2)
        });
        tls$1.queue(c2, record);
      }
      record = tls$1.createRecord(c2, {
        type: tls$1.ContentType.handshake,
        data: tls$1.createClientKeyExchange(c2)
      });
      tls$1.queue(c2, record);
      c2.expect = SER;
      var callback = function(c3, signature) {
        if (c3.session.certificateRequest !== null && c3.session.clientCertificate !== null) {
          tls$1.queue(c3, tls$1.createRecord(c3, {
            type: tls$1.ContentType.handshake,
            data: tls$1.createCertificateVerify(c3, signature)
          }));
        }
        tls$1.queue(c3, tls$1.createRecord(c3, {
          type: tls$1.ContentType.change_cipher_spec,
          data: tls$1.createChangeCipherSpec()
        }));
        c3.state.pending = tls$1.createConnectionState(c3);
        c3.state.current.write = c3.state.pending.write;
        tls$1.queue(c3, tls$1.createRecord(c3, {
          type: tls$1.ContentType.handshake,
          data: tls$1.createFinished(c3)
        }));
        c3.expect = SCC;
        tls$1.flush(c3);
        c3.process();
      };
      if (c2.session.certificateRequest === null || c2.session.clientCertificate === null) {
        return callback(c2, null);
      }
      tls$1.getClientSignature(c2, callback);
    };
    tls$1.handleChangeCipherSpec = function(c2, record) {
      if (record.fragment.getByte() !== 1) {
        return c2.error(c2, {
          message: "Invalid ChangeCipherSpec message received.",
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.illegal_parameter
          }
        });
      }
      var client = c2.entity === tls$1.ConnectionEnd.client;
      if (c2.session.resuming && client || !c2.session.resuming && !client) {
        c2.state.pending = tls$1.createConnectionState(c2);
      }
      c2.state.current.read = c2.state.pending.read;
      if (!c2.session.resuming && client || c2.session.resuming && !client) {
        c2.state.pending = null;
      }
      c2.expect = client ? SFI : CFI;
      c2.process();
    };
    tls$1.handleFinished = function(c2, record, length) {
      var b2 = record.fragment;
      b2.read -= 4;
      var msgBytes = b2.bytes();
      b2.read += 4;
      var vd = record.fragment.getBytes();
      b2 = forge$b.util.createBuffer();
      b2.putBuffer(c2.session.md5.digest());
      b2.putBuffer(c2.session.sha1.digest());
      var client = c2.entity === tls$1.ConnectionEnd.client;
      var label = client ? "server finished" : "client finished";
      var sp = c2.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      b2 = prf(sp.master_secret, label, b2.getBytes(), vdl);
      if (b2.getBytes() !== vd) {
        return c2.error(c2, {
          message: "Invalid verify_data in Finished message.",
          send: true,
          alert: {
            level: tls$1.Alert.Level.fatal,
            description: tls$1.Alert.Description.decrypt_error
          }
        });
      }
      c2.session.md5.update(msgBytes);
      c2.session.sha1.update(msgBytes);
      if (c2.session.resuming && client || !c2.session.resuming && !client) {
        tls$1.queue(c2, tls$1.createRecord(c2, {
          type: tls$1.ContentType.change_cipher_spec,
          data: tls$1.createChangeCipherSpec()
        }));
        c2.state.current.write = c2.state.pending.write;
        c2.state.pending = null;
        tls$1.queue(c2, tls$1.createRecord(c2, {
          type: tls$1.ContentType.handshake,
          data: tls$1.createFinished(c2)
        }));
      }
      c2.expect = client ? SAD : CAD;
      c2.handshaking = false;
      ++c2.handshakes;
      c2.peerCertificate = client ? c2.session.serverCertificate : c2.session.clientCertificate;
      tls$1.flush(c2);
      c2.isConnected = true;
      c2.connected(c2);
      c2.process();
    };
    tls$1.handleAlert = function(c2, record) {
      var b2 = record.fragment;
      var alert = {
        level: b2.getByte(),
        description: b2.getByte()
      };
      var msg;
      switch (alert.description) {
        case tls$1.Alert.Description.close_notify:
          msg = "Connection closed.";
          break;
        case tls$1.Alert.Description.unexpected_message:
          msg = "Unexpected message.";
          break;
        case tls$1.Alert.Description.bad_record_mac:
          msg = "Bad record MAC.";
          break;
        case tls$1.Alert.Description.decryption_failed:
          msg = "Decryption failed.";
          break;
        case tls$1.Alert.Description.record_overflow:
          msg = "Record overflow.";
          break;
        case tls$1.Alert.Description.decompression_failure:
          msg = "Decompression failed.";
          break;
        case tls$1.Alert.Description.handshake_failure:
          msg = "Handshake failure.";
          break;
        case tls$1.Alert.Description.bad_certificate:
          msg = "Bad certificate.";
          break;
        case tls$1.Alert.Description.unsupported_certificate:
          msg = "Unsupported certificate.";
          break;
        case tls$1.Alert.Description.certificate_revoked:
          msg = "Certificate revoked.";
          break;
        case tls$1.Alert.Description.certificate_expired:
          msg = "Certificate expired.";
          break;
        case tls$1.Alert.Description.certificate_unknown:
          msg = "Certificate unknown.";
          break;
        case tls$1.Alert.Description.illegal_parameter:
          msg = "Illegal parameter.";
          break;
        case tls$1.Alert.Description.unknown_ca:
          msg = "Unknown certificate authority.";
          break;
        case tls$1.Alert.Description.access_denied:
          msg = "Access denied.";
          break;
        case tls$1.Alert.Description.decode_error:
          msg = "Decode error.";
          break;
        case tls$1.Alert.Description.decrypt_error:
          msg = "Decrypt error.";
          break;
        case tls$1.Alert.Description.export_restriction:
          msg = "Export restriction.";
          break;
        case tls$1.Alert.Description.protocol_version:
          msg = "Unsupported protocol version.";
          break;
        case tls$1.Alert.Description.insufficient_security:
          msg = "Insufficient security.";
          break;
        case tls$1.Alert.Description.internal_error:
          msg = "Internal error.";
          break;
        case tls$1.Alert.Description.user_canceled:
          msg = "User canceled.";
          break;
        case tls$1.Alert.Description.no_renegotiation:
          msg = "Renegotiation not supported.";
          break;
        default:
          msg = "Unknown error.";
          break;
      }
      if (alert.description === tls$1.Alert.Description.close_notify) {
        return c2.close();
      }
      c2.error(c2, {
        message: msg,
        send: false,
        origin: c2.entity === tls$1.ConnectionEnd.client ? "server" : "client",
        alert
      });
      c2.process();
    };
    tls$1.handleHandshake = function(c2, record) {
      var b2 = record.fragment;
      var type = b2.getByte();
      var length = b2.getInt24();
      if (length > b2.length()) {
        c2.fragmented = record;
        record.fragment = forge$b.util.createBuffer();
        b2.read -= 4;
        return c2.process();
      }
      c2.fragmented = null;
      b2.read -= 4;
      var bytes2 = b2.bytes(length + 4);
      b2.read += 4;
      if (type in hsTable[c2.entity][c2.expect]) {
        if (c2.entity === tls$1.ConnectionEnd.server && !c2.open && !c2.fail) {
          c2.handshaking = true;
          c2.session = {
            version: null,
            extensions: {
              server_name: {
                serverNameList: []
              }
            },
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            clientCertificate: null,
            md5: forge$b.md.md5.create(),
            sha1: forge$b.md.sha1.create()
          };
        }
        if (type !== tls$1.HandshakeType.hello_request && type !== tls$1.HandshakeType.certificate_verify && type !== tls$1.HandshakeType.finished) {
          c2.session.md5.update(bytes2);
          c2.session.sha1.update(bytes2);
        }
        hsTable[c2.entity][c2.expect][type](c2, record, length);
      } else {
        tls$1.handleUnexpected(c2, record);
      }
    };
    tls$1.handleApplicationData = function(c2, record) {
      c2.data.putBuffer(record.fragment);
      c2.dataReady(c2);
      c2.process();
    };
    tls$1.handleHeartbeat = function(c2, record) {
      var b2 = record.fragment;
      var type = b2.getByte();
      var length = b2.getInt16();
      var payload = b2.getBytes(length);
      if (type === tls$1.HeartbeatMessageType.heartbeat_request) {
        if (c2.handshaking || length > payload.length) {
          return c2.process();
        }
        tls$1.queue(c2, tls$1.createRecord(c2, {
          type: tls$1.ContentType.heartbeat,
          data: tls$1.createHeartbeat(tls$1.HeartbeatMessageType.heartbeat_response, payload)
        }));
        tls$1.flush(c2);
      } else if (type === tls$1.HeartbeatMessageType.heartbeat_response) {
        if (payload !== c2.expectedHeartbeatPayload) {
          return c2.process();
        }
        if (c2.heartbeatReceived) {
          c2.heartbeatReceived(c2, forge$b.util.createBuffer(payload));
        }
      }
      c2.process();
    };
    var SHE = 0;
    var SCE = 1;
    var SKE = 2;
    var SCR = 3;
    var SHD = 4;
    var SCC = 5;
    var SFI = 6;
    var SAD = 7;
    var SER = 8;
    var CHE = 0;
    var CCE = 1;
    var CKE = 2;
    var CCV = 3;
    var CCC = 4;
    var CFI = 5;
    var CAD = 6;
    var __ = tls$1.handleUnexpected;
    var R0 = tls$1.handleChangeCipherSpec;
    var R1 = tls$1.handleAlert;
    var R2 = tls$1.handleHandshake;
    var R3 = tls$1.handleApplicationData;
    var R4 = tls$1.handleHeartbeat;
    var ctTable = [];
    ctTable[tls$1.ConnectionEnd.client] = [
      [__, R1, R2, __, R4],
      [__, R1, R2, __, R4],
      [__, R1, R2, __, R4],
      [__, R1, R2, __, R4],
      [__, R1, R2, __, R4],
      [R0, R1, __, __, R4],
      [__, R1, R2, __, R4],
      [__, R1, R2, R3, R4],
      [__, R1, R2, __, R4]
    ];
    ctTable[tls$1.ConnectionEnd.server] = [
      [__, R1, R2, __, R4],
      [__, R1, R2, __, R4],
      [__, R1, R2, __, R4],
      [__, R1, R2, __, R4],
      [R0, R1, __, __, R4],
      [__, R1, R2, __, R4],
      [__, R1, R2, R3, R4],
      [__, R1, R2, __, R4]
    ];
    var H0 = tls$1.handleHelloRequest;
    var H1 = tls$1.handleServerHello;
    var H2 = tls$1.handleCertificate;
    var H3 = tls$1.handleServerKeyExchange;
    var H4 = tls$1.handleCertificateRequest;
    var H5 = tls$1.handleServerHelloDone;
    var H6 = tls$1.handleFinished;
    var hsTable = [];
    hsTable[tls$1.ConnectionEnd.client] = [
      [__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __],
      [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __],
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __],
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __],
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
    ];
    var H7 = tls$1.handleClientHello;
    var H8 = tls$1.handleClientKeyExchange;
    var H9 = tls$1.handleCertificateVerify;
    hsTable[tls$1.ConnectionEnd.server] = [
      [__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __],
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __],
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __],
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
    ];
    tls$1.generateKeys = function(c2, sp) {
      var prf = prf_TLS1;
      var random = sp.client_random + sp.server_random;
      if (!c2.session.resuming) {
        sp.master_secret = prf(sp.pre_master_secret, "master secret", random, 48).bytes();
        sp.pre_master_secret = null;
      }
      random = sp.server_random + sp.client_random;
      var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
      var tls10 = c2.version.major === tls$1.Versions.TLS_1_0.major && c2.version.minor === tls$1.Versions.TLS_1_0.minor;
      if (tls10) {
        length += 2 * sp.fixed_iv_length;
      }
      var km = prf(sp.master_secret, "key expansion", random, length);
      var rval = {
        client_write_MAC_key: km.getBytes(sp.mac_key_length),
        server_write_MAC_key: km.getBytes(sp.mac_key_length),
        client_write_key: km.getBytes(sp.enc_key_length),
        server_write_key: km.getBytes(sp.enc_key_length)
      };
      if (tls10) {
        rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
        rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
      }
      return rval;
    };
    tls$1.createConnectionState = function(c2) {
      var client = c2.entity === tls$1.ConnectionEnd.client;
      var createMode = function() {
        var mode2 = {
          sequenceNumber: [0, 0],
          macKey: null,
          macLength: 0,
          macFunction: null,
          cipherState: null,
          cipherFunction: function(record) {
            return true;
          },
          compressionState: null,
          compressFunction: function(record) {
            return true;
          },
          updateSequenceNumber: function() {
            if (mode2.sequenceNumber[1] === 4294967295) {
              mode2.sequenceNumber[1] = 0;
              ++mode2.sequenceNumber[0];
            } else {
              ++mode2.sequenceNumber[1];
            }
          }
        };
        return mode2;
      };
      var state = {
        read: createMode(),
        write: createMode()
      };
      state.read.update = function(c3, record) {
        if (!state.read.cipherFunction(record, state.read)) {
          c3.error(c3, {
            message: "Could not decrypt record or bad MAC.",
            send: true,
            alert: {
              level: tls$1.Alert.Level.fatal,
              description: tls$1.Alert.Description.bad_record_mac
            }
          });
        } else if (!state.read.compressFunction(c3, record, state.read)) {
          c3.error(c3, {
            message: "Could not decompress record.",
            send: true,
            alert: {
              level: tls$1.Alert.Level.fatal,
              description: tls$1.Alert.Description.decompression_failure
            }
          });
        }
        return !c3.fail;
      };
      state.write.update = function(c3, record) {
        if (!state.write.compressFunction(c3, record, state.write)) {
          c3.error(c3, {
            message: "Could not compress record.",
            send: false,
            alert: {
              level: tls$1.Alert.Level.fatal,
              description: tls$1.Alert.Description.internal_error
            }
          });
        } else if (!state.write.cipherFunction(record, state.write)) {
          c3.error(c3, {
            message: "Could not encrypt record.",
            send: false,
            alert: {
              level: tls$1.Alert.Level.fatal,
              description: tls$1.Alert.Description.internal_error
            }
          });
        }
        return !c3.fail;
      };
      if (c2.session) {
        var sp = c2.session.sp;
        c2.session.cipherSuite.initSecurityParameters(sp);
        sp.keys = tls$1.generateKeys(c2, sp);
        state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
        state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
        c2.session.cipherSuite.initConnectionState(state, c2, sp);
        switch (sp.compression_algorithm) {
          case tls$1.CompressionMethod.none:
            break;
          case tls$1.CompressionMethod.deflate:
            state.read.compressFunction = inflate;
            state.write.compressFunction = deflate;
            break;
          default:
            throw new Error("Unsupported compression algorithm.");
        }
      }
      return state;
    };
    tls$1.createRandom = function() {
      var d3 = new Date();
      var utc = +d3 + d3.getTimezoneOffset() * 6e4;
      var rval = forge$b.util.createBuffer();
      rval.putInt32(utc);
      rval.putBytes(forge$b.random.getBytes(28));
      return rval;
    };
    tls$1.createRecord = function(c2, options2) {
      if (!options2.data) {
        return null;
      }
      var record = {
        type: options2.type,
        version: {
          major: c2.version.major,
          minor: c2.version.minor
        },
        length: options2.data.length(),
        fragment: options2.data
      };
      return record;
    };
    tls$1.createAlert = function(c2, alert) {
      var b2 = forge$b.util.createBuffer();
      b2.putByte(alert.level);
      b2.putByte(alert.description);
      return tls$1.createRecord(c2, {
        type: tls$1.ContentType.alert,
        data: b2
      });
    };
    tls$1.createClientHello = function(c2) {
      c2.session.clientHelloVersion = {
        major: c2.version.major,
        minor: c2.version.minor
      };
      var cipherSuites = forge$b.util.createBuffer();
      for (var i3 = 0; i3 < c2.cipherSuites.length; ++i3) {
        var cs2 = c2.cipherSuites[i3];
        cipherSuites.putByte(cs2.id[0]);
        cipherSuites.putByte(cs2.id[1]);
      }
      var cSuites = cipherSuites.length();
      var compressionMethods = forge$b.util.createBuffer();
      compressionMethods.putByte(tls$1.CompressionMethod.none);
      var cMethods = compressionMethods.length();
      var extensions2 = forge$b.util.createBuffer();
      if (c2.virtualHost) {
        var ext2 = forge$b.util.createBuffer();
        ext2.putByte(0);
        ext2.putByte(0);
        var serverName = forge$b.util.createBuffer();
        serverName.putByte(0);
        writeVector(serverName, 2, forge$b.util.createBuffer(c2.virtualHost));
        var snList = forge$b.util.createBuffer();
        writeVector(snList, 2, serverName);
        writeVector(ext2, 2, snList);
        extensions2.putBuffer(ext2);
      }
      var extLength = extensions2.length();
      if (extLength > 0) {
        extLength += 2;
      }
      var sessionId = c2.session.id;
      var length = sessionId.length + 1 + 2 + 4 + 28 + 2 + cSuites + 1 + cMethods + extLength;
      var rval = forge$b.util.createBuffer();
      rval.putByte(tls$1.HandshakeType.client_hello);
      rval.putInt24(length);
      rval.putByte(c2.version.major);
      rval.putByte(c2.version.minor);
      rval.putBytes(c2.session.sp.client_random);
      writeVector(rval, 1, forge$b.util.createBuffer(sessionId));
      writeVector(rval, 2, cipherSuites);
      writeVector(rval, 1, compressionMethods);
      if (extLength > 0) {
        writeVector(rval, 2, extensions2);
      }
      return rval;
    };
    tls$1.createServerHello = function(c2) {
      var sessionId = c2.session.id;
      var length = sessionId.length + 1 + 2 + 4 + 28 + 2 + 1;
      var rval = forge$b.util.createBuffer();
      rval.putByte(tls$1.HandshakeType.server_hello);
      rval.putInt24(length);
      rval.putByte(c2.version.major);
      rval.putByte(c2.version.minor);
      rval.putBytes(c2.session.sp.server_random);
      writeVector(rval, 1, forge$b.util.createBuffer(sessionId));
      rval.putByte(c2.session.cipherSuite.id[0]);
      rval.putByte(c2.session.cipherSuite.id[1]);
      rval.putByte(c2.session.compressionMethod);
      return rval;
    };
    tls$1.createCertificate = function(c2) {
      var client = c2.entity === tls$1.ConnectionEnd.client;
      var cert = null;
      if (c2.getCertificate) {
        var hint;
        if (client) {
          hint = c2.session.certificateRequest;
        } else {
          hint = c2.session.extensions.server_name.serverNameList;
        }
        cert = c2.getCertificate(c2, hint);
      }
      var certList = forge$b.util.createBuffer();
      if (cert !== null) {
        try {
          if (!forge$b.util.isArray(cert)) {
            cert = [cert];
          }
          var asn12 = null;
          for (var i3 = 0; i3 < cert.length; ++i3) {
            var msg = forge$b.pem.decode(cert[i3])[0];
            if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
              var error2 = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
              error2.headerType = msg.type;
              throw error2;
            }
            if (msg.procType && msg.procType.type === "ENCRYPTED") {
              throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
            }
            var der = forge$b.util.createBuffer(msg.body);
            if (asn12 === null) {
              asn12 = forge$b.asn1.fromDer(der.bytes(), false);
            }
            var certBuffer = forge$b.util.createBuffer();
            writeVector(certBuffer, 3, der);
            certList.putBuffer(certBuffer);
          }
          cert = forge$b.pki.certificateFromAsn1(asn12);
          if (client) {
            c2.session.clientCertificate = cert;
          } else {
            c2.session.serverCertificate = cert;
          }
        } catch (ex) {
          return c2.error(c2, {
            message: "Could not send certificate list.",
            cause: ex,
            send: true,
            alert: {
              level: tls$1.Alert.Level.fatal,
              description: tls$1.Alert.Description.bad_certificate
            }
          });
        }
      }
      var length = 3 + certList.length();
      var rval = forge$b.util.createBuffer();
      rval.putByte(tls$1.HandshakeType.certificate);
      rval.putInt24(length);
      writeVector(rval, 3, certList);
      return rval;
    };
    tls$1.createClientKeyExchange = function(c2) {
      var b2 = forge$b.util.createBuffer();
      b2.putByte(c2.session.clientHelloVersion.major);
      b2.putByte(c2.session.clientHelloVersion.minor);
      b2.putBytes(forge$b.random.getBytes(46));
      var sp = c2.session.sp;
      sp.pre_master_secret = b2.getBytes();
      var key2 = c2.session.serverCertificate.publicKey;
      b2 = key2.encrypt(sp.pre_master_secret);
      var length = b2.length + 2;
      var rval = forge$b.util.createBuffer();
      rval.putByte(tls$1.HandshakeType.client_key_exchange);
      rval.putInt24(length);
      rval.putInt16(b2.length);
      rval.putBytes(b2);
      return rval;
    };
    tls$1.createServerKeyExchange = function(c2) {
      var rval = forge$b.util.createBuffer();
      return rval;
    };
    tls$1.getClientSignature = function(c2, callback) {
      var b2 = forge$b.util.createBuffer();
      b2.putBuffer(c2.session.md5.digest());
      b2.putBuffer(c2.session.sha1.digest());
      b2 = b2.getBytes();
      c2.getSignature = c2.getSignature || function(c3, b3, callback2) {
        var privateKey = null;
        if (c3.getPrivateKey) {
          try {
            privateKey = c3.getPrivateKey(c3, c3.session.clientCertificate);
            privateKey = forge$b.pki.privateKeyFromPem(privateKey);
          } catch (ex) {
            c3.error(c3, {
              message: "Could not get private key.",
              cause: ex,
              send: true,
              alert: {
                level: tls$1.Alert.Level.fatal,
                description: tls$1.Alert.Description.internal_error
              }
            });
          }
        }
        if (privateKey === null) {
          c3.error(c3, {
            message: "No private key set.",
            send: true,
            alert: {
              level: tls$1.Alert.Level.fatal,
              description: tls$1.Alert.Description.internal_error
            }
          });
        } else {
          b3 = privateKey.sign(b3, null);
        }
        callback2(c3, b3);
      };
      c2.getSignature(c2, b2, callback);
    };
    tls$1.createCertificateVerify = function(c2, signature) {
      var length = signature.length + 2;
      var rval = forge$b.util.createBuffer();
      rval.putByte(tls$1.HandshakeType.certificate_verify);
      rval.putInt24(length);
      rval.putInt16(signature.length);
      rval.putBytes(signature);
      return rval;
    };
    tls$1.createCertificateRequest = function(c2) {
      var certTypes = forge$b.util.createBuffer();
      certTypes.putByte(1);
      var cAs = forge$b.util.createBuffer();
      for (var key2 in c2.caStore.certs) {
        var cert = c2.caStore.certs[key2];
        var dn2 = forge$b.pki.distinguishedNameToAsn1(cert.subject);
        var byteBuffer = forge$b.asn1.toDer(dn2);
        cAs.putInt16(byteBuffer.length());
        cAs.putBuffer(byteBuffer);
      }
      var length = 1 + certTypes.length() + 2 + cAs.length();
      var rval = forge$b.util.createBuffer();
      rval.putByte(tls$1.HandshakeType.certificate_request);
      rval.putInt24(length);
      writeVector(rval, 1, certTypes);
      writeVector(rval, 2, cAs);
      return rval;
    };
    tls$1.createServerHelloDone = function(c2) {
      var rval = forge$b.util.createBuffer();
      rval.putByte(tls$1.HandshakeType.server_hello_done);
      rval.putInt24(0);
      return rval;
    };
    tls$1.createChangeCipherSpec = function() {
      var rval = forge$b.util.createBuffer();
      rval.putByte(1);
      return rval;
    };
    tls$1.createFinished = function(c2) {
      var b2 = forge$b.util.createBuffer();
      b2.putBuffer(c2.session.md5.digest());
      b2.putBuffer(c2.session.sha1.digest());
      var client = c2.entity === tls$1.ConnectionEnd.client;
      var sp = c2.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      var label = client ? "client finished" : "server finished";
      b2 = prf(sp.master_secret, label, b2.getBytes(), vdl);
      var rval = forge$b.util.createBuffer();
      rval.putByte(tls$1.HandshakeType.finished);
      rval.putInt24(b2.length());
      rval.putBuffer(b2);
      return rval;
    };
    tls$1.createHeartbeat = function(type, payload, payloadLength) {
      if (typeof payloadLength === "undefined") {
        payloadLength = payload.length;
      }
      var rval = forge$b.util.createBuffer();
      rval.putByte(type);
      rval.putInt16(payloadLength);
      rval.putBytes(payload);
      var plaintextLength = rval.length();
      var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
      rval.putBytes(forge$b.random.getBytes(paddingLength));
      return rval;
    };
    tls$1.queue = function(c2, record) {
      if (!record) {
        return;
      }
      if (record.fragment.length() === 0) {
        if (record.type === tls$1.ContentType.handshake || record.type === tls$1.ContentType.alert || record.type === tls$1.ContentType.change_cipher_spec) {
          return;
        }
      }
      if (record.type === tls$1.ContentType.handshake) {
        var bytes2 = record.fragment.bytes();
        c2.session.md5.update(bytes2);
        c2.session.sha1.update(bytes2);
        bytes2 = null;
      }
      var records;
      if (record.fragment.length() <= tls$1.MaxFragment) {
        records = [record];
      } else {
        records = [];
        var data2 = record.fragment.bytes();
        while (data2.length > tls$1.MaxFragment) {
          records.push(tls$1.createRecord(c2, {
            type: record.type,
            data: forge$b.util.createBuffer(data2.slice(0, tls$1.MaxFragment))
          }));
          data2 = data2.slice(tls$1.MaxFragment);
        }
        if (data2.length > 0) {
          records.push(tls$1.createRecord(c2, {
            type: record.type,
            data: forge$b.util.createBuffer(data2)
          }));
        }
      }
      for (var i3 = 0; i3 < records.length && !c2.fail; ++i3) {
        var rec = records[i3];
        var s3 = c2.state.current.write;
        if (s3.update(c2, rec)) {
          c2.records.push(rec);
        }
      }
    };
    tls$1.flush = function(c2) {
      for (var i3 = 0; i3 < c2.records.length; ++i3) {
        var record = c2.records[i3];
        c2.tlsData.putByte(record.type);
        c2.tlsData.putByte(record.version.major);
        c2.tlsData.putByte(record.version.minor);
        c2.tlsData.putInt16(record.fragment.length());
        c2.tlsData.putBuffer(c2.records[i3].fragment);
      }
      c2.records = [];
      return c2.tlsDataReady(c2);
    };
    var _certErrorToAlertDesc = function(error2) {
      switch (error2) {
        case true:
          return true;
        case forge$b.pki.certificateError.bad_certificate:
          return tls$1.Alert.Description.bad_certificate;
        case forge$b.pki.certificateError.unsupported_certificate:
          return tls$1.Alert.Description.unsupported_certificate;
        case forge$b.pki.certificateError.certificate_revoked:
          return tls$1.Alert.Description.certificate_revoked;
        case forge$b.pki.certificateError.certificate_expired:
          return tls$1.Alert.Description.certificate_expired;
        case forge$b.pki.certificateError.certificate_unknown:
          return tls$1.Alert.Description.certificate_unknown;
        case forge$b.pki.certificateError.unknown_ca:
          return tls$1.Alert.Description.unknown_ca;
        default:
          return tls$1.Alert.Description.bad_certificate;
      }
    };
    var _alertDescToCertError = function(desc) {
      switch (desc) {
        case true:
          return true;
        case tls$1.Alert.Description.bad_certificate:
          return forge$b.pki.certificateError.bad_certificate;
        case tls$1.Alert.Description.unsupported_certificate:
          return forge$b.pki.certificateError.unsupported_certificate;
        case tls$1.Alert.Description.certificate_revoked:
          return forge$b.pki.certificateError.certificate_revoked;
        case tls$1.Alert.Description.certificate_expired:
          return forge$b.pki.certificateError.certificate_expired;
        case tls$1.Alert.Description.certificate_unknown:
          return forge$b.pki.certificateError.certificate_unknown;
        case tls$1.Alert.Description.unknown_ca:
          return forge$b.pki.certificateError.unknown_ca;
        default:
          return forge$b.pki.certificateError.bad_certificate;
      }
    };
    tls$1.verifyCertificateChain = function(c2, chain) {
      try {
        var options2 = {};
        for (var key2 in c2.verifyOptions) {
          options2[key2] = c2.verifyOptions[key2];
        }
        options2.verify = function(vfd, depth2, chain2) {
          var ret = c2.verify(c2, vfd, depth2, chain2);
          if (ret !== true) {
            if (typeof ret === "object" && !forge$b.util.isArray(ret)) {
              var error2 = new Error("The application rejected the certificate.");
              error2.send = true;
              error2.alert = {
                level: tls$1.Alert.Level.fatal,
                description: tls$1.Alert.Description.bad_certificate
              };
              if (ret.message) {
                error2.message = ret.message;
              }
              if (ret.alert) {
                error2.alert.description = ret.alert;
              }
              throw error2;
            }
            if (ret !== vfd) {
              ret = _alertDescToCertError(ret);
            }
          }
          return ret;
        };
        forge$b.pki.verifyCertificateChain(c2.caStore, chain, options2);
      } catch (ex) {
        var err = ex;
        if (typeof err !== "object" || forge$b.util.isArray(err)) {
          err = {
            send: true,
            alert: {
              level: tls$1.Alert.Level.fatal,
              description: _certErrorToAlertDesc(ex)
            }
          };
        }
        if (!("send" in err)) {
          err.send = true;
        }
        if (!("alert" in err)) {
          err.alert = {
            level: tls$1.Alert.Level.fatal,
            description: _certErrorToAlertDesc(err.error)
          };
        }
        c2.error(c2, err);
      }
      return !c2.fail;
    };
    tls$1.createSessionCache = function(cache2, capacity) {
      var rval = null;
      if (cache2 && cache2.getSession && cache2.setSession && cache2.order) {
        rval = cache2;
      } else {
        rval = {};
        rval.cache = cache2 || {};
        rval.capacity = Math.max(capacity || 100, 1);
        rval.order = [];
        for (var key2 in cache2) {
          if (rval.order.length <= capacity) {
            rval.order.push(key2);
          } else {
            delete cache2[key2];
          }
        }
        rval.getSession = function(sessionId) {
          var session = null;
          var key3 = null;
          if (sessionId) {
            key3 = forge$b.util.bytesToHex(sessionId);
          } else if (rval.order.length > 0) {
            key3 = rval.order[0];
          }
          if (key3 !== null && key3 in rval.cache) {
            session = rval.cache[key3];
            delete rval.cache[key3];
            for (var i3 in rval.order) {
              if (rval.order[i3] === key3) {
                rval.order.splice(i3, 1);
                break;
              }
            }
          }
          return session;
        };
        rval.setSession = function(sessionId, session) {
          if (rval.order.length === rval.capacity) {
            var key3 = rval.order.shift();
            delete rval.cache[key3];
          }
          var key3 = forge$b.util.bytesToHex(sessionId);
          rval.order.push(key3);
          rval.cache[key3] = session;
        };
      }
      return rval;
    };
    tls$1.createConnection = function(options2) {
      var caStore = null;
      if (options2.caStore) {
        if (forge$b.util.isArray(options2.caStore)) {
          caStore = forge$b.pki.createCaStore(options2.caStore);
        } else {
          caStore = options2.caStore;
        }
      } else {
        caStore = forge$b.pki.createCaStore();
      }
      var cipherSuites = options2.cipherSuites || null;
      if (cipherSuites === null) {
        cipherSuites = [];
        for (var key2 in tls$1.CipherSuites) {
          cipherSuites.push(tls$1.CipherSuites[key2]);
        }
      }
      var entity = options2.server || false ? tls$1.ConnectionEnd.server : tls$1.ConnectionEnd.client;
      var sessionCache = options2.sessionCache ? tls$1.createSessionCache(options2.sessionCache) : null;
      var c2 = {
        version: { major: tls$1.Version.major, minor: tls$1.Version.minor },
        entity,
        sessionId: options2.sessionId,
        caStore,
        sessionCache,
        cipherSuites,
        connected: options2.connected,
        virtualHost: options2.virtualHost || null,
        verifyClient: options2.verifyClient || false,
        verify: options2.verify || function(cn2, vfd, dpth, cts) {
          return vfd;
        },
        verifyOptions: options2.verifyOptions || {},
        getCertificate: options2.getCertificate || null,
        getPrivateKey: options2.getPrivateKey || null,
        getSignature: options2.getSignature || null,
        input: forge$b.util.createBuffer(),
        tlsData: forge$b.util.createBuffer(),
        data: forge$b.util.createBuffer(),
        tlsDataReady: options2.tlsDataReady,
        dataReady: options2.dataReady,
        heartbeatReceived: options2.heartbeatReceived,
        closed: options2.closed,
        error: function(c3, ex) {
          ex.origin = ex.origin || (c3.entity === tls$1.ConnectionEnd.client ? "client" : "server");
          if (ex.send) {
            tls$1.queue(c3, tls$1.createAlert(c3, ex.alert));
            tls$1.flush(c3);
          }
          var fatal = ex.fatal !== false;
          if (fatal) {
            c3.fail = true;
          }
          options2.error(c3, ex);
          if (fatal) {
            c3.close(false);
          }
        },
        deflate: options2.deflate || null,
        inflate: options2.inflate || null
      };
      c2.reset = function(clearFail) {
        c2.version = { major: tls$1.Version.major, minor: tls$1.Version.minor };
        c2.record = null;
        c2.session = null;
        c2.peerCertificate = null;
        c2.state = {
          pending: null,
          current: null
        };
        c2.expect = c2.entity === tls$1.ConnectionEnd.client ? SHE : CHE;
        c2.fragmented = null;
        c2.records = [];
        c2.open = false;
        c2.handshakes = 0;
        c2.handshaking = false;
        c2.isConnected = false;
        c2.fail = !(clearFail || typeof clearFail === "undefined");
        c2.input.clear();
        c2.tlsData.clear();
        c2.data.clear();
        c2.state.current = tls$1.createConnectionState(c2);
      };
      c2.reset();
      var _update2 = function(c3, record) {
        var aligned = record.type - tls$1.ContentType.change_cipher_spec;
        var handlers = ctTable[c3.entity][c3.expect];
        if (aligned in handlers) {
          handlers[aligned](c3, record);
        } else {
          tls$1.handleUnexpected(c3, record);
        }
      };
      var _readRecordHeader = function(c3) {
        var rval = 0;
        var b2 = c3.input;
        var len = b2.length();
        if (len < 5) {
          rval = 5 - len;
        } else {
          c3.record = {
            type: b2.getByte(),
            version: {
              major: b2.getByte(),
              minor: b2.getByte()
            },
            length: b2.getInt16(),
            fragment: forge$b.util.createBuffer(),
            ready: false
          };
          var compatibleVersion = c3.record.version.major === c3.version.major;
          if (compatibleVersion && c3.session && c3.session.version) {
            compatibleVersion = c3.record.version.minor === c3.version.minor;
          }
          if (!compatibleVersion) {
            c3.error(c3, {
              message: "Incompatible TLS version.",
              send: true,
              alert: {
                level: tls$1.Alert.Level.fatal,
                description: tls$1.Alert.Description.protocol_version
              }
            });
          }
        }
        return rval;
      };
      var _readRecord = function(c3) {
        var rval = 0;
        var b2 = c3.input;
        var len = b2.length();
        if (len < c3.record.length) {
          rval = c3.record.length - len;
        } else {
          c3.record.fragment.putBytes(b2.getBytes(c3.record.length));
          b2.compact();
          var s3 = c3.state.current.read;
          if (s3.update(c3, c3.record)) {
            if (c3.fragmented !== null) {
              if (c3.fragmented.type === c3.record.type) {
                c3.fragmented.fragment.putBuffer(c3.record.fragment);
                c3.record = c3.fragmented;
              } else {
                c3.error(c3, {
                  message: "Invalid fragmented record.",
                  send: true,
                  alert: {
                    level: tls$1.Alert.Level.fatal,
                    description: tls$1.Alert.Description.unexpected_message
                  }
                });
              }
            }
            c3.record.ready = true;
          }
        }
        return rval;
      };
      c2.handshake = function(sessionId) {
        if (c2.entity !== tls$1.ConnectionEnd.client) {
          c2.error(c2, {
            message: "Cannot initiate handshake as a server.",
            fatal: false
          });
        } else if (c2.handshaking) {
          c2.error(c2, {
            message: "Handshake already in progress.",
            fatal: false
          });
        } else {
          if (c2.fail && !c2.open && c2.handshakes === 0) {
            c2.fail = false;
          }
          c2.handshaking = true;
          sessionId = sessionId || "";
          var session = null;
          if (sessionId.length > 0) {
            if (c2.sessionCache) {
              session = c2.sessionCache.getSession(sessionId);
            }
            if (session === null) {
              sessionId = "";
            }
          }
          if (sessionId.length === 0 && c2.sessionCache) {
            session = c2.sessionCache.getSession();
            if (session !== null) {
              sessionId = session.id;
            }
          }
          c2.session = {
            id: sessionId,
            version: null,
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            certificateRequest: null,
            clientCertificate: null,
            sp: {},
            md5: forge$b.md.md5.create(),
            sha1: forge$b.md.sha1.create()
          };
          if (session) {
            c2.version = session.version;
            c2.session.sp = session.sp;
          }
          c2.session.sp.client_random = tls$1.createRandom().getBytes();
          c2.open = true;
          tls$1.queue(c2, tls$1.createRecord(c2, {
            type: tls$1.ContentType.handshake,
            data: tls$1.createClientHello(c2)
          }));
          tls$1.flush(c2);
        }
      };
      c2.process = function(data2) {
        var rval = 0;
        if (data2) {
          c2.input.putBytes(data2);
        }
        if (!c2.fail) {
          if (c2.record !== null && c2.record.ready && c2.record.fragment.isEmpty()) {
            c2.record = null;
          }
          if (c2.record === null) {
            rval = _readRecordHeader(c2);
          }
          if (!c2.fail && c2.record !== null && !c2.record.ready) {
            rval = _readRecord(c2);
          }
          if (!c2.fail && c2.record !== null && c2.record.ready) {
            _update2(c2, c2.record);
          }
        }
        return rval;
      };
      c2.prepare = function(data2) {
        tls$1.queue(c2, tls$1.createRecord(c2, {
          type: tls$1.ContentType.application_data,
          data: forge$b.util.createBuffer(data2)
        }));
        return tls$1.flush(c2);
      };
      c2.prepareHeartbeatRequest = function(payload, payloadLength) {
        if (payload instanceof forge$b.util.ByteBuffer) {
          payload = payload.bytes();
        }
        if (typeof payloadLength === "undefined") {
          payloadLength = payload.length;
        }
        c2.expectedHeartbeatPayload = payload;
        tls$1.queue(c2, tls$1.createRecord(c2, {
          type: tls$1.ContentType.heartbeat,
          data: tls$1.createHeartbeat(tls$1.HeartbeatMessageType.heartbeat_request, payload, payloadLength)
        }));
        return tls$1.flush(c2);
      };
      c2.close = function(clearFail) {
        if (!c2.fail && c2.sessionCache && c2.session) {
          var session = {
            id: c2.session.id,
            version: c2.session.version,
            sp: c2.session.sp
          };
          session.sp.keys = null;
          c2.sessionCache.setSession(session.id, session);
        }
        if (c2.open) {
          c2.open = false;
          c2.input.clear();
          if (c2.isConnected || c2.handshaking) {
            c2.isConnected = c2.handshaking = false;
            tls$1.queue(c2, tls$1.createAlert(c2, {
              level: tls$1.Alert.Level.warning,
              description: tls$1.Alert.Description.close_notify
            }));
            tls$1.flush(c2);
          }
          c2.closed(c2);
        }
        c2.reset(clearFail);
      };
      return c2;
    };
    forge$b.tls = forge$b.tls || {};
    for (key in tls$1) {
      if (typeof tls$1[key] !== "function") {
        forge$b.tls[key] = tls$1[key];
      }
    }
    var key;
    forge$b.tls.prf_tls1 = prf_TLS1;
    forge$b.tls.hmac_sha1 = hmac_sha1;
    forge$b.tls.createSessionCache = tls$1.createSessionCache;
    forge$b.tls.createConnection = tls$1.createConnection;
    var forge$a = forge$F;
    var tls2 = forge$a.tls;
    tls2.CipherSuites["TLS_RSA_WITH_AES_128_CBC_SHA"] = {
      id: [0, 47],
      name: "TLS_RSA_WITH_AES_128_CBC_SHA",
      initSecurityParameters: function(sp) {
        sp.bulk_cipher_algorithm = tls2.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls2.CipherType.block;
        sp.enc_key_length = 16;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls2.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      },
      initConnectionState
    };
    tls2.CipherSuites["TLS_RSA_WITH_AES_256_CBC_SHA"] = {
      id: [0, 53],
      name: "TLS_RSA_WITH_AES_256_CBC_SHA",
      initSecurityParameters: function(sp) {
        sp.bulk_cipher_algorithm = tls2.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls2.CipherType.block;
        sp.enc_key_length = 32;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls2.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      },
      initConnectionState
    };
    function initConnectionState(state, c2, sp) {
      var client = c2.entity === forge$a.tls.ConnectionEnd.client;
      state.read.cipherState = {
        init: false,
        cipher: forge$a.cipher.createDecipher("AES-CBC", client ? sp.keys.server_write_key : sp.keys.client_write_key),
        iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV
      };
      state.write.cipherState = {
        init: false,
        cipher: forge$a.cipher.createCipher("AES-CBC", client ? sp.keys.client_write_key : sp.keys.server_write_key),
        iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV
      };
      state.read.cipherFunction = decrypt_aes_cbc_sha1;
      state.write.cipherFunction = encrypt_aes_cbc_sha1;
      state.read.macLength = state.write.macLength = sp.mac_length;
      state.read.macFunction = state.write.macFunction = tls2.hmac_sha1;
    }
    function encrypt_aes_cbc_sha1(record, s3) {
      var rval = false;
      var mac = s3.macFunction(s3.macKey, s3.sequenceNumber, record);
      record.fragment.putBytes(mac);
      s3.updateSequenceNumber();
      var iv;
      if (record.version.minor === tls2.Versions.TLS_1_0.minor) {
        iv = s3.cipherState.init ? null : s3.cipherState.iv;
      } else {
        iv = forge$a.random.getBytesSync(16);
      }
      s3.cipherState.init = true;
      var cipher = s3.cipherState.cipher;
      cipher.start({ iv });
      if (record.version.minor >= tls2.Versions.TLS_1_1.minor) {
        cipher.output.putBytes(iv);
      }
      cipher.update(record.fragment);
      if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {
        record.fragment = cipher.output;
        record.length = record.fragment.length();
        rval = true;
      }
      return rval;
    }
    function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {
      if (!decrypt) {
        var padding = blockSize - input.length() % blockSize;
        input.fillWithByte(padding - 1, padding);
      }
      return true;
    }
    function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {
      var rval = true;
      if (decrypt) {
        var len = output.length();
        var paddingLength = output.last();
        for (var i3 = len - 1 - paddingLength; i3 < len - 1; ++i3) {
          rval = rval && output.at(i3) == paddingLength;
        }
        if (rval) {
          output.truncate(paddingLength + 1);
        }
      }
      return rval;
    }
    function decrypt_aes_cbc_sha1(record, s3) {
      var rval = false;
      var iv;
      if (record.version.minor === tls2.Versions.TLS_1_0.minor) {
        iv = s3.cipherState.init ? null : s3.cipherState.iv;
      } else {
        iv = record.fragment.getBytes(16);
      }
      s3.cipherState.init = true;
      var cipher = s3.cipherState.cipher;
      cipher.start({ iv });
      cipher.update(record.fragment);
      rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
      var macLen = s3.macLength;
      var mac = forge$a.random.getBytesSync(macLen);
      var len = cipher.output.length();
      if (len >= macLen) {
        record.fragment = cipher.output.getBytes(len - macLen);
        mac = cipher.output.getBytes(macLen);
      } else {
        record.fragment = cipher.output.getBytes();
      }
      record.fragment = forge$a.util.createBuffer(record.fragment);
      record.length = record.fragment.length();
      var mac2 = s3.macFunction(s3.macKey, s3.sequenceNumber, record);
      s3.updateSequenceNumber();
      rval = compareMacs(s3.macKey, mac, mac2) && rval;
      return rval;
    }
    function compareMacs(key2, mac1, mac2) {
      var hmac2 = forge$a.hmac.create();
      hmac2.start("SHA1", key2);
      hmac2.update(mac1);
      mac1 = hmac2.digest().getBytes();
      hmac2.start(null, null);
      hmac2.update(mac2);
      mac2 = hmac2.digest().getBytes();
      return mac1 === mac2;
    }
    var forge$9 = forge$F;
    forge$9.debug = forge$9.debug || {};
    forge$9.debug.storage = {};
    forge$9.debug.get = function(cat2, name) {
      var rval;
      if (typeof cat2 === "undefined") {
        rval = forge$9.debug.storage;
      } else if (cat2 in forge$9.debug.storage) {
        if (typeof name === "undefined") {
          rval = forge$9.debug.storage[cat2];
        } else {
          rval = forge$9.debug.storage[cat2][name];
        }
      }
      return rval;
    };
    forge$9.debug.set = function(cat2, name, data2) {
      if (!(cat2 in forge$9.debug.storage)) {
        forge$9.debug.storage[cat2] = {};
      }
      forge$9.debug.storage[cat2][name] = data2;
    };
    forge$9.debug.clear = function(cat2, name) {
      if (typeof cat2 === "undefined") {
        forge$9.debug.storage = {};
      } else if (cat2 in forge$9.debug.storage) {
        if (typeof name === "undefined") {
          delete forge$9.debug.storage[cat2];
        } else {
          delete forge$9.debug.storage[cat2][name];
        }
      }
    };
    var forge$8 = forge$F;
    var sha512$1 = forge$8.sha512 = forge$8.sha512 || {};
    forge$8.md.sha512 = forge$8.md.algorithms.sha512 = sha512$1;
    var sha384 = forge$8.sha384 = forge$8.sha512.sha384 = forge$8.sha512.sha384 || {};
    sha384.create = function() {
      return sha512$1.create("SHA-384");
    };
    forge$8.md.sha384 = forge$8.md.algorithms.sha384 = sha384;
    forge$8.sha512.sha256 = forge$8.sha512.sha256 || {
      create: function() {
        return sha512$1.create("SHA-512/256");
      }
    };
    forge$8.md["sha512/256"] = forge$8.md.algorithms["sha512/256"] = forge$8.sha512.sha256;
    forge$8.sha512.sha224 = forge$8.sha512.sha224 || {
      create: function() {
        return sha512$1.create("SHA-512/224");
      }
    };
    forge$8.md["sha512/224"] = forge$8.md.algorithms["sha512/224"] = forge$8.sha512.sha224;
    sha512$1.create = function(algorithm) {
      if (!_initialized) {
        _init();
      }
      if (typeof algorithm === "undefined") {
        algorithm = "SHA-512";
      }
      if (!(algorithm in _states)) {
        throw new Error("Invalid SHA-512 algorithm: " + algorithm);
      }
      var _state = _states[algorithm];
      var _h2 = null;
      var _input = forge$8.util.createBuffer();
      var _w = new Array(80);
      for (var wi2 = 0; wi2 < 80; ++wi2) {
        _w[wi2] = new Array(2);
      }
      var digestLength = 64;
      switch (algorithm) {
        case "SHA-384":
          digestLength = 48;
          break;
        case "SHA-512/256":
          digestLength = 32;
          break;
        case "SHA-512/224":
          digestLength = 28;
          break;
      }
      var md = {
        algorithm: algorithm.replace("-", "").toLowerCase(),
        blockLength: 128,
        digestLength,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 16
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength128 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i3 = 0; i3 < int32s; ++i3) {
          md.fullMessageLength.push(0);
        }
        _input = forge$8.util.createBuffer();
        _h2 = new Array(_state.length);
        for (var i3 = 0; i3 < _state.length; ++i3) {
          _h2[i3] = _state[i3].slice(0);
        }
        return md;
      };
      md.start();
      md.update = function(msg, encoding2) {
        if (encoding2 === "utf8") {
          msg = forge$8.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i3 = md.fullMessageLength.length - 1; i3 >= 0; --i3) {
          md.fullMessageLength[i3] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i3] / 4294967296 >>> 0);
          md.fullMessageLength[i3] = md.fullMessageLength[i3] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_h2, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge$8.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i3 = 0; i3 < md.fullMessageLength.length - 1; ++i3) {
          next = md.fullMessageLength[i3 + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var h3 = new Array(_h2.length);
        for (var i3 = 0; i3 < _h2.length; ++i3) {
          h3[i3] = _h2[i3].slice(0);
        }
        _update(h3, _w, finalBlock);
        var rval = forge$8.util.createBuffer();
        var hlen;
        if (algorithm === "SHA-512") {
          hlen = h3.length;
        } else if (algorithm === "SHA-384") {
          hlen = h3.length - 2;
        } else {
          hlen = h3.length - 4;
        }
        for (var i3 = 0; i3 < hlen; ++i3) {
          rval.putInt32(h3[i3][0]);
          if (i3 !== hlen - 1 || algorithm !== "SHA-512/224") {
            rval.putInt32(h3[i3][1]);
          }
        }
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    var _states = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge$8.util.fillString(String.fromCharCode(0), 128);
      _k = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591]
      ];
      _states = {};
      _states["SHA-512"] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209]
      ];
      _states["SHA-384"] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428]
      ];
      _states["SHA-512/256"] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882]
      ];
      _states["SHA-512/224"] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561]
      ];
      _initialized = true;
    }
    function _update(s3, w3, bytes2) {
      var t1_hi, t1_lo;
      var t2_hi, t2_lo;
      var s0_hi, s0_lo;
      var s1_hi, s1_lo;
      var ch_hi, ch_lo;
      var maj_hi, maj_lo;
      var a_hi, a_lo;
      var b_hi, b_lo;
      var c_hi, c_lo;
      var d_hi, d_lo;
      var e_hi, e_lo;
      var f_hi, f_lo;
      var g_hi, g_lo;
      var h_hi, h_lo;
      var i3, hi2, lo2, w22, w7, w15, w16;
      var len = bytes2.length();
      while (len >= 128) {
        for (i3 = 0; i3 < 16; ++i3) {
          w3[i3][0] = bytes2.getInt32() >>> 0;
          w3[i3][1] = bytes2.getInt32() >>> 0;
        }
        for (; i3 < 80; ++i3) {
          w22 = w3[i3 - 2];
          hi2 = w22[0];
          lo2 = w22[1];
          t1_hi = ((hi2 >>> 19 | lo2 << 13) ^ (lo2 >>> 29 | hi2 << 3) ^ hi2 >>> 6) >>> 0;
          t1_lo = ((hi2 << 13 | lo2 >>> 19) ^ (lo2 << 3 | hi2 >>> 29) ^ (hi2 << 26 | lo2 >>> 6)) >>> 0;
          w15 = w3[i3 - 15];
          hi2 = w15[0];
          lo2 = w15[1];
          t2_hi = ((hi2 >>> 1 | lo2 << 31) ^ (hi2 >>> 8 | lo2 << 24) ^ hi2 >>> 7) >>> 0;
          t2_lo = ((hi2 << 31 | lo2 >>> 1) ^ (hi2 << 24 | lo2 >>> 8) ^ (hi2 << 25 | lo2 >>> 7)) >>> 0;
          w7 = w3[i3 - 7];
          w16 = w3[i3 - 16];
          lo2 = t1_lo + w7[1] + t2_lo + w16[1];
          w3[i3][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo2 / 4294967296 >>> 0) >>> 0;
          w3[i3][1] = lo2 >>> 0;
        }
        a_hi = s3[0][0];
        a_lo = s3[0][1];
        b_hi = s3[1][0];
        b_lo = s3[1][1];
        c_hi = s3[2][0];
        c_lo = s3[2][1];
        d_hi = s3[3][0];
        d_lo = s3[3][1];
        e_hi = s3[4][0];
        e_lo = s3[4][1];
        f_hi = s3[5][0];
        f_lo = s3[5][1];
        g_hi = s3[6][0];
        g_lo = s3[6][1];
        h_hi = s3[7][0];
        h_lo = s3[7][1];
        for (i3 = 0; i3 < 80; ++i3) {
          s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ (e_hi >>> 18 | e_lo << 14) ^ (e_lo >>> 9 | e_hi << 23)) >>> 0;
          s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ (e_hi << 14 | e_lo >>> 18) ^ (e_lo << 23 | e_hi >>> 9)) >>> 0;
          ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
          ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
          s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ (a_lo >>> 2 | a_hi << 30) ^ (a_lo >>> 7 | a_hi << 25)) >>> 0;
          s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ (a_lo << 30 | a_hi >>> 2) ^ (a_lo << 25 | a_hi >>> 7)) >>> 0;
          maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
          maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
          lo2 = h_lo + s1_lo + ch_lo + _k[i3][1] + w3[i3][1];
          t1_hi = h_hi + s1_hi + ch_hi + _k[i3][0] + w3[i3][0] + (lo2 / 4294967296 >>> 0) >>> 0;
          t1_lo = lo2 >>> 0;
          lo2 = s0_lo + maj_lo;
          t2_hi = s0_hi + maj_hi + (lo2 / 4294967296 >>> 0) >>> 0;
          t2_lo = lo2 >>> 0;
          h_hi = g_hi;
          h_lo = g_lo;
          g_hi = f_hi;
          g_lo = f_lo;
          f_hi = e_hi;
          f_lo = e_lo;
          lo2 = d_lo + t1_lo;
          e_hi = d_hi + t1_hi + (lo2 / 4294967296 >>> 0) >>> 0;
          e_lo = lo2 >>> 0;
          d_hi = c_hi;
          d_lo = c_lo;
          c_hi = b_hi;
          c_lo = b_lo;
          b_hi = a_hi;
          b_lo = a_lo;
          lo2 = t1_lo + t2_lo;
          a_hi = t1_hi + t2_hi + (lo2 / 4294967296 >>> 0) >>> 0;
          a_lo = lo2 >>> 0;
        }
        lo2 = s3[0][1] + a_lo;
        s3[0][0] = s3[0][0] + a_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s3[0][1] = lo2 >>> 0;
        lo2 = s3[1][1] + b_lo;
        s3[1][0] = s3[1][0] + b_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s3[1][1] = lo2 >>> 0;
        lo2 = s3[2][1] + c_lo;
        s3[2][0] = s3[2][0] + c_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s3[2][1] = lo2 >>> 0;
        lo2 = s3[3][1] + d_lo;
        s3[3][0] = s3[3][0] + d_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s3[3][1] = lo2 >>> 0;
        lo2 = s3[4][1] + e_lo;
        s3[4][0] = s3[4][0] + e_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s3[4][1] = lo2 >>> 0;
        lo2 = s3[5][1] + f_lo;
        s3[5][0] = s3[5][0] + f_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s3[5][1] = lo2 >>> 0;
        lo2 = s3[6][1] + g_lo;
        s3[6][0] = s3[6][0] + g_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s3[6][1] = lo2 >>> 0;
        lo2 = s3[7][1] + h_lo;
        s3[7][0] = s3[7][0] + h_hi + (lo2 / 4294967296 >>> 0) >>> 0;
        s3[7][1] = lo2 >>> 0;
        len -= 128;
      }
    }
    var asn1Validator$1 = {};
    var forge$7 = forge$F;
    var asn1$1 = forge$7.asn1;
    asn1Validator$1.privateKeyValidator = {
      name: "PrivateKeyInfo",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PrivateKeyInfo.version",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1$1.Class.UNIVERSAL,
          type: asn1$1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        name: "PrivateKeyInfo",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    asn1Validator$1.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [
        {
          name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
          tagClass: asn1$1.Class.UNIVERSAL,
          type: asn1$1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: asn1$1.Class.UNIVERSAL,
            type: asn1$1.Type.OID,
            constructed: false,
            capture: "publicKeyOid"
          }]
        },
        {
          tagClass: asn1$1.Class.UNIVERSAL,
          type: asn1$1.Type.BITSTRING,
          constructed: false,
          composed: true,
          captureBitStringValue: "ed25519PublicKey"
        }
      ]
    };
    var forge$6 = forge$F;
    var asn1Validator = asn1Validator$1;
    var publicKeyValidator = asn1Validator.publicKeyValidator;
    var privateKeyValidator = asn1Validator.privateKeyValidator;
    var ByteBuffer = forge$6.util.ByteBuffer;
    var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
    forge$6.pki = forge$6.pki || {};
    forge$6.pki.ed25519 = forge$6.ed25519 = forge$6.ed25519 || {};
    var ed25519 = forge$6.ed25519;
    ed25519.constants = {};
    ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
    ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
    ed25519.constants.SEED_BYTE_LENGTH = 32;
    ed25519.constants.SIGN_BYTE_LENGTH = 64;
    ed25519.constants.HASH_BYTE_LENGTH = 64;
    ed25519.generateKeyPair = function(options2) {
      options2 = options2 || {};
      var seed = options2.seed;
      if (seed === void 0) {
        seed = forge$6.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
      } else if (typeof seed === "string") {
        if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {
          throw new TypeError('"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length.");
        }
      } else if (!(seed instanceof Uint8Array)) {
        throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.');
      }
      seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
      var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
      var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
      for (var i3 = 0; i3 < 32; ++i3) {
        sk[i3] = seed[i3];
      }
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, privateKey: sk };
    };
    ed25519.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      var valid = forge$6.asn1.validate(obj, privateKeyValidator, capture, errors);
      if (!valid) {
        var error2 = new Error("Invalid Key.");
        error2.errors = errors;
        throw error2;
      }
      var oid = forge$6.asn1.derToOid(capture.privateKeyOid);
      var ed25519Oid = forge$6.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var privateKey = capture.privateKey;
      var privateKeyBytes = messageToNativeBuffer({
        message: forge$6.asn1.fromDer(privateKey).value,
        encoding: "binary"
      });
      return { privateKeyBytes };
    };
    ed25519.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      var valid = forge$6.asn1.validate(obj, publicKeyValidator, capture, errors);
      if (!valid) {
        var error2 = new Error("Invalid Key.");
        error2.errors = errors;
        throw error2;
      }
      var oid = forge$6.asn1.derToOid(capture.publicKeyOid);
      var ed25519Oid = forge$6.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var publicKeyBytes = capture.ed25519PublicKey;
      if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new Error("Key length is invalid.");
      }
      return messageToNativeBuffer({
        message: publicKeyBytes,
        encoding: "binary"
      });
    };
    ed25519.publicKeyFromPrivateKey = function(options2) {
      options2 = options2 || {};
      var privateKey = messageToNativeBuffer({
        message: options2.privateKey,
        encoding: "binary"
      });
      if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
      }
      var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
      for (var i3 = 0; i3 < pk.length; ++i3) {
        pk[i3] = privateKey[32 + i3];
      }
      return pk;
    };
    ed25519.sign = function(options2) {
      options2 = options2 || {};
      var msg = messageToNativeBuffer(options2);
      var privateKey = messageToNativeBuffer({
        message: options2.privateKey,
        encoding: "binary"
      });
      if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
        var keyPair = ed25519.generateKeyPair({ seed: privateKey });
        privateKey = keyPair.privateKey;
      } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
      }
      var signedMsg = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
      crypto_sign(signedMsg, msg, msg.length, privateKey);
      var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
      for (var i3 = 0; i3 < sig.length; ++i3) {
        sig[i3] = signedMsg[i3];
      }
      return sig;
    };
    ed25519.verify = function(options2) {
      options2 = options2 || {};
      var msg = messageToNativeBuffer(options2);
      if (options2.signature === void 0) {
        throw new TypeError('"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.');
      }
      var sig = messageToNativeBuffer({
        message: options2.signature,
        encoding: "binary"
      });
      if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {
        throw new TypeError('"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH);
      }
      var publicKey = messageToNativeBuffer({
        message: options2.publicKey,
        encoding: "binary"
      });
      if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new TypeError('"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
      }
      var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
      var m3 = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
      var i3;
      for (i3 = 0; i3 < ed25519.constants.SIGN_BYTE_LENGTH; ++i3) {
        sm[i3] = sig[i3];
      }
      for (i3 = 0; i3 < msg.length; ++i3) {
        sm[i3 + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i3];
      }
      return crypto_sign_open(m3, sm, sm.length, publicKey) >= 0;
    };
    function messageToNativeBuffer(options2) {
      var message = options2.message;
      if (message instanceof Uint8Array || message instanceof NativeBuffer) {
        return message;
      }
      var encoding2 = options2.encoding;
      if (message === void 0) {
        if (options2.md) {
          message = options2.md.digest().getBytes();
          encoding2 = "binary";
        } else {
          throw new TypeError('"options.message" or "options.md" not specified.');
        }
      }
      if (typeof message === "string" && !encoding2) {
        throw new TypeError('"options.encoding" must be "binary" or "utf8".');
      }
      if (typeof message === "string") {
        if (typeof Buffer !== "undefined") {
          return Buffer.from(message, encoding2);
        }
        message = new ByteBuffer(message, encoding2);
      } else if (!(message instanceof ByteBuffer)) {
        throw new TypeError('"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.');
      }
      var buffer = new NativeBuffer(message.length());
      for (var i3 = 0; i3 < buffer.length; ++i3) {
        buffer[i3] = message.at(i3);
      }
      return buffer;
    }
    var gf0 = gf();
    var gf1 = gf([1]);
    var D2 = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D22 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X2 = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y2 = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var L2 = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    var I2 = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function sha512(msg, msgLen) {
      var md = forge$6.md.sha512.create();
      var buffer = new ByteBuffer(msg);
      md.update(buffer.getBytes(msgLen), "binary");
      var hash2 = md.digest().getBytes();
      if (typeof Buffer !== "undefined") {
        return Buffer.from(hash2, "binary");
      }
      var out2 = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
      for (var i3 = 0; i3 < 64; ++i3) {
        out2[i3] = hash2.charCodeAt(i3);
      }
      return out2;
    }
    function crypto_sign_keypair(pk, sk) {
      var p2 = [gf(), gf(), gf(), gf()];
      var i3;
      var d3 = sha512(sk, 32);
      d3[0] &= 248;
      d3[31] &= 127;
      d3[31] |= 64;
      scalarbase(p2, d3);
      pack(pk, p2);
      for (i3 = 0; i3 < 32; ++i3) {
        sk[i3 + 32] = pk[i3];
      }
      return 0;
    }
    function crypto_sign(sm, m3, n3, sk) {
      var i3, j2, x2 = new Float64Array(64);
      var p2 = [gf(), gf(), gf(), gf()];
      var d3 = sha512(sk, 32);
      d3[0] &= 248;
      d3[31] &= 127;
      d3[31] |= 64;
      var smlen = n3 + 64;
      for (i3 = 0; i3 < n3; ++i3) {
        sm[64 + i3] = m3[i3];
      }
      for (i3 = 0; i3 < 32; ++i3) {
        sm[32 + i3] = d3[32 + i3];
      }
      var r2 = sha512(sm.subarray(32), n3 + 32);
      reduce(r2);
      scalarbase(p2, r2);
      pack(sm, p2);
      for (i3 = 32; i3 < 64; ++i3) {
        sm[i3] = sk[i3];
      }
      var h3 = sha512(sm, n3 + 64);
      reduce(h3);
      for (i3 = 32; i3 < 64; ++i3) {
        x2[i3] = 0;
      }
      for (i3 = 0; i3 < 32; ++i3) {
        x2[i3] = r2[i3];
      }
      for (i3 = 0; i3 < 32; ++i3) {
        for (j2 = 0; j2 < 32; j2++) {
          x2[i3 + j2] += h3[i3] * d3[j2];
        }
      }
      modL(sm.subarray(32), x2);
      return smlen;
    }
    function crypto_sign_open(m3, sm, n3, pk) {
      var i3, mlen;
      var t = new NativeBuffer(32);
      var p2 = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
      mlen = -1;
      if (n3 < 64) {
        return -1;
      }
      if (unpackneg(q2, pk)) {
        return -1;
      }
      for (i3 = 0; i3 < n3; ++i3) {
        m3[i3] = sm[i3];
      }
      for (i3 = 0; i3 < 32; ++i3) {
        m3[i3 + 32] = pk[i3];
      }
      var h3 = sha512(m3, n3);
      reduce(h3);
      scalarmult(p2, q2, h3);
      scalarbase(q2, sm.subarray(32));
      add(p2, q2);
      pack(t, p2);
      n3 -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i3 = 0; i3 < n3; ++i3) {
          m3[i3] = 0;
        }
        return -1;
      }
      for (i3 = 0; i3 < n3; ++i3) {
        m3[i3] = sm[i3 + 64];
      }
      mlen = n3;
      return mlen;
    }
    function modL(r2, x2) {
      var carry, i3, j2, k2;
      for (i3 = 63; i3 >= 32; --i3) {
        carry = 0;
        for (j2 = i3 - 32, k2 = i3 - 12; j2 < k2; ++j2) {
          x2[j2] += carry - 16 * x2[i3] * L2[j2 - (i3 - 32)];
          carry = x2[j2] + 128 >> 8;
          x2[j2] -= carry * 256;
        }
        x2[j2] += carry;
        x2[i3] = 0;
      }
      carry = 0;
      for (j2 = 0; j2 < 32; ++j2) {
        x2[j2] += carry - (x2[31] >> 4) * L2[j2];
        carry = x2[j2] >> 8;
        x2[j2] &= 255;
      }
      for (j2 = 0; j2 < 32; ++j2) {
        x2[j2] -= carry * L2[j2];
      }
      for (i3 = 0; i3 < 32; ++i3) {
        x2[i3 + 1] += x2[i3] >> 8;
        r2[i3] = x2[i3] & 255;
      }
    }
    function reduce(r2) {
      var x2 = new Float64Array(64);
      for (var i3 = 0; i3 < 64; ++i3) {
        x2[i3] = r2[i3];
        r2[i3] = 0;
      }
      modL(r2, x2);
    }
    function add(p2, q2) {
      var a2 = gf(), b2 = gf(), c2 = gf(), d3 = gf(), e2 = gf(), f3 = gf(), g2 = gf(), h3 = gf(), t = gf();
      Z2(a2, p2[1], p2[0]);
      Z2(t, q2[1], q2[0]);
      M2(a2, a2, t);
      A3(b2, p2[0], p2[1]);
      A3(t, q2[0], q2[1]);
      M2(b2, b2, t);
      M2(c2, p2[3], q2[3]);
      M2(c2, c2, D22);
      M2(d3, p2[2], q2[2]);
      A3(d3, d3, d3);
      Z2(e2, b2, a2);
      Z2(f3, d3, c2);
      A3(g2, d3, c2);
      A3(h3, b2, a2);
      M2(p2[0], e2, f3);
      M2(p2[1], h3, g2);
      M2(p2[2], g2, f3);
      M2(p2[3], e2, h3);
    }
    function cswap(p2, q2, b2) {
      for (var i3 = 0; i3 < 4; ++i3) {
        sel25519(p2[i3], q2[i3], b2);
      }
    }
    function pack(r2, p2) {
      var tx = gf(), ty = gf(), zi2 = gf();
      inv25519(zi2, p2[2]);
      M2(tx, p2[0], zi2);
      M2(ty, p2[1], zi2);
      pack25519(r2, ty);
      r2[31] ^= par25519(tx) << 7;
    }
    function pack25519(o2, n3) {
      var i3, j2, b2;
      var m3 = gf(), t = gf();
      for (i3 = 0; i3 < 16; ++i3) {
        t[i3] = n3[i3];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (j2 = 0; j2 < 2; ++j2) {
        m3[0] = t[0] - 65517;
        for (i3 = 1; i3 < 15; ++i3) {
          m3[i3] = t[i3] - 65535 - (m3[i3 - 1] >> 16 & 1);
          m3[i3 - 1] &= 65535;
        }
        m3[15] = t[15] - 32767 - (m3[14] >> 16 & 1);
        b2 = m3[15] >> 16 & 1;
        m3[14] &= 65535;
        sel25519(t, m3, 1 - b2);
      }
      for (i3 = 0; i3 < 16; i3++) {
        o2[2 * i3] = t[i3] & 255;
        o2[2 * i3 + 1] = t[i3] >> 8;
      }
    }
    function unpackneg(r2, p2) {
      var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r2[2], gf1);
      unpack25519(r2[1], p2);
      S2(num, r2[1]);
      M2(den, num, D2);
      Z2(num, num, r2[2]);
      A3(den, r2[2], den);
      S2(den2, den);
      S2(den4, den2);
      M2(den6, den4, den2);
      M2(t, den6, num);
      M2(t, t, den);
      pow2523(t, t);
      M2(t, t, num);
      M2(t, t, den);
      M2(t, t, den);
      M2(r2[0], t, den);
      S2(chk, r2[0]);
      M2(chk, chk, den);
      if (neq25519(chk, num)) {
        M2(r2[0], r2[0], I2);
      }
      S2(chk, r2[0]);
      M2(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r2[0]) === p2[31] >> 7) {
        Z2(r2[0], gf0, r2[0]);
      }
      M2(r2[3], r2[0], r2[1]);
      return 0;
    }
    function unpack25519(o2, n3) {
      var i3;
      for (i3 = 0; i3 < 16; ++i3) {
        o2[i3] = n3[2 * i3] + (n3[2 * i3 + 1] << 8);
      }
      o2[15] &= 32767;
    }
    function pow2523(o2, i3) {
      var c2 = gf();
      var a2;
      for (a2 = 0; a2 < 16; ++a2) {
        c2[a2] = i3[a2];
      }
      for (a2 = 250; a2 >= 0; --a2) {
        S2(c2, c2);
        if (a2 !== 1) {
          M2(c2, c2, i3);
        }
      }
      for (a2 = 0; a2 < 16; ++a2) {
        o2[a2] = c2[a2];
      }
    }
    function neq25519(a2, b2) {
      var c2 = new NativeBuffer(32);
      var d3 = new NativeBuffer(32);
      pack25519(c2, a2);
      pack25519(d3, b2);
      return crypto_verify_32(c2, 0, d3, 0);
    }
    function crypto_verify_32(x2, xi2, y3, yi2) {
      return vn2(x2, xi2, y3, yi2, 32);
    }
    function vn2(x2, xi2, y3, yi2, n3) {
      var i3, d3 = 0;
      for (i3 = 0; i3 < n3; ++i3) {
        d3 |= x2[xi2 + i3] ^ y3[yi2 + i3];
      }
      return (1 & d3 - 1 >>> 8) - 1;
    }
    function par25519(a2) {
      var d3 = new NativeBuffer(32);
      pack25519(d3, a2);
      return d3[0] & 1;
    }
    function scalarmult(p2, q2, s3) {
      var b2, i3;
      set25519(p2[0], gf0);
      set25519(p2[1], gf1);
      set25519(p2[2], gf1);
      set25519(p2[3], gf0);
      for (i3 = 255; i3 >= 0; --i3) {
        b2 = s3[i3 / 8 | 0] >> (i3 & 7) & 1;
        cswap(p2, q2, b2);
        add(q2, p2);
        add(p2, p2);
        cswap(p2, q2, b2);
      }
    }
    function scalarbase(p2, s3) {
      var q2 = [gf(), gf(), gf(), gf()];
      set25519(q2[0], X2);
      set25519(q2[1], Y2);
      set25519(q2[2], gf1);
      M2(q2[3], X2, Y2);
      scalarmult(p2, q2, s3);
    }
    function set25519(r2, a2) {
      var i3;
      for (i3 = 0; i3 < 16; i3++) {
        r2[i3] = a2[i3] | 0;
      }
    }
    function inv25519(o2, i3) {
      var c2 = gf();
      var a2;
      for (a2 = 0; a2 < 16; ++a2) {
        c2[a2] = i3[a2];
      }
      for (a2 = 253; a2 >= 0; --a2) {
        S2(c2, c2);
        if (a2 !== 2 && a2 !== 4) {
          M2(c2, c2, i3);
        }
      }
      for (a2 = 0; a2 < 16; ++a2) {
        o2[a2] = c2[a2];
      }
    }
    function car25519(o2) {
      var i3, v2, c2 = 1;
      for (i3 = 0; i3 < 16; ++i3) {
        v2 = o2[i3] + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        o2[i3] = v2 - c2 * 65536;
      }
      o2[0] += c2 - 1 + 37 * (c2 - 1);
    }
    function sel25519(p2, q2, b2) {
      var t, c2 = ~(b2 - 1);
      for (var i3 = 0; i3 < 16; ++i3) {
        t = c2 & (p2[i3] ^ q2[i3]);
        p2[i3] ^= t;
        q2[i3] ^= t;
      }
    }
    function gf(init3) {
      var i3, r2 = new Float64Array(16);
      if (init3) {
        for (i3 = 0; i3 < init3.length; ++i3) {
          r2[i3] = init3[i3];
        }
      }
      return r2;
    }
    function A3(o2, a2, b2) {
      for (var i3 = 0; i3 < 16; ++i3) {
        o2[i3] = a2[i3] + b2[i3];
      }
    }
    function Z2(o2, a2, b2) {
      for (var i3 = 0; i3 < 16; ++i3) {
        o2[i3] = a2[i3] - b2[i3];
      }
    }
    function S2(o2, a2) {
      M2(o2, a2, a2);
    }
    function M2(o2, a2, b2) {
      var v2, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v2 = a2[0];
      t0 += v2 * b0;
      t1 += v2 * b1;
      t2 += v2 * b22;
      t3 += v2 * b3;
      t4 += v2 * b4;
      t5 += v2 * b5;
      t6 += v2 * b6;
      t7 += v2 * b7;
      t8 += v2 * b8;
      t9 += v2 * b9;
      t10 += v2 * b10;
      t11 += v2 * b11;
      t12 += v2 * b12;
      t13 += v2 * b13;
      t14 += v2 * b14;
      t15 += v2 * b15;
      v2 = a2[1];
      t1 += v2 * b0;
      t2 += v2 * b1;
      t3 += v2 * b22;
      t4 += v2 * b3;
      t5 += v2 * b4;
      t6 += v2 * b5;
      t7 += v2 * b6;
      t8 += v2 * b7;
      t9 += v2 * b8;
      t10 += v2 * b9;
      t11 += v2 * b10;
      t12 += v2 * b11;
      t13 += v2 * b12;
      t14 += v2 * b13;
      t15 += v2 * b14;
      t16 += v2 * b15;
      v2 = a2[2];
      t2 += v2 * b0;
      t3 += v2 * b1;
      t4 += v2 * b22;
      t5 += v2 * b3;
      t6 += v2 * b4;
      t7 += v2 * b5;
      t8 += v2 * b6;
      t9 += v2 * b7;
      t10 += v2 * b8;
      t11 += v2 * b9;
      t12 += v2 * b10;
      t13 += v2 * b11;
      t14 += v2 * b12;
      t15 += v2 * b13;
      t16 += v2 * b14;
      t17 += v2 * b15;
      v2 = a2[3];
      t3 += v2 * b0;
      t4 += v2 * b1;
      t5 += v2 * b22;
      t6 += v2 * b3;
      t7 += v2 * b4;
      t8 += v2 * b5;
      t9 += v2 * b6;
      t10 += v2 * b7;
      t11 += v2 * b8;
      t12 += v2 * b9;
      t13 += v2 * b10;
      t14 += v2 * b11;
      t15 += v2 * b12;
      t16 += v2 * b13;
      t17 += v2 * b14;
      t18 += v2 * b15;
      v2 = a2[4];
      t4 += v2 * b0;
      t5 += v2 * b1;
      t6 += v2 * b22;
      t7 += v2 * b3;
      t8 += v2 * b4;
      t9 += v2 * b5;
      t10 += v2 * b6;
      t11 += v2 * b7;
      t12 += v2 * b8;
      t13 += v2 * b9;
      t14 += v2 * b10;
      t15 += v2 * b11;
      t16 += v2 * b12;
      t17 += v2 * b13;
      t18 += v2 * b14;
      t19 += v2 * b15;
      v2 = a2[5];
      t5 += v2 * b0;
      t6 += v2 * b1;
      t7 += v2 * b22;
      t8 += v2 * b3;
      t9 += v2 * b4;
      t10 += v2 * b5;
      t11 += v2 * b6;
      t12 += v2 * b7;
      t13 += v2 * b8;
      t14 += v2 * b9;
      t15 += v2 * b10;
      t16 += v2 * b11;
      t17 += v2 * b12;
      t18 += v2 * b13;
      t19 += v2 * b14;
      t20 += v2 * b15;
      v2 = a2[6];
      t6 += v2 * b0;
      t7 += v2 * b1;
      t8 += v2 * b22;
      t9 += v2 * b3;
      t10 += v2 * b4;
      t11 += v2 * b5;
      t12 += v2 * b6;
      t13 += v2 * b7;
      t14 += v2 * b8;
      t15 += v2 * b9;
      t16 += v2 * b10;
      t17 += v2 * b11;
      t18 += v2 * b12;
      t19 += v2 * b13;
      t20 += v2 * b14;
      t21 += v2 * b15;
      v2 = a2[7];
      t7 += v2 * b0;
      t8 += v2 * b1;
      t9 += v2 * b22;
      t10 += v2 * b3;
      t11 += v2 * b4;
      t12 += v2 * b5;
      t13 += v2 * b6;
      t14 += v2 * b7;
      t15 += v2 * b8;
      t16 += v2 * b9;
      t17 += v2 * b10;
      t18 += v2 * b11;
      t19 += v2 * b12;
      t20 += v2 * b13;
      t21 += v2 * b14;
      t22 += v2 * b15;
      v2 = a2[8];
      t8 += v2 * b0;
      t9 += v2 * b1;
      t10 += v2 * b22;
      t11 += v2 * b3;
      t12 += v2 * b4;
      t13 += v2 * b5;
      t14 += v2 * b6;
      t15 += v2 * b7;
      t16 += v2 * b8;
      t17 += v2 * b9;
      t18 += v2 * b10;
      t19 += v2 * b11;
      t20 += v2 * b12;
      t21 += v2 * b13;
      t22 += v2 * b14;
      t23 += v2 * b15;
      v2 = a2[9];
      t9 += v2 * b0;
      t10 += v2 * b1;
      t11 += v2 * b22;
      t12 += v2 * b3;
      t13 += v2 * b4;
      t14 += v2 * b5;
      t15 += v2 * b6;
      t16 += v2 * b7;
      t17 += v2 * b8;
      t18 += v2 * b9;
      t19 += v2 * b10;
      t20 += v2 * b11;
      t21 += v2 * b12;
      t22 += v2 * b13;
      t23 += v2 * b14;
      t24 += v2 * b15;
      v2 = a2[10];
      t10 += v2 * b0;
      t11 += v2 * b1;
      t12 += v2 * b22;
      t13 += v2 * b3;
      t14 += v2 * b4;
      t15 += v2 * b5;
      t16 += v2 * b6;
      t17 += v2 * b7;
      t18 += v2 * b8;
      t19 += v2 * b9;
      t20 += v2 * b10;
      t21 += v2 * b11;
      t22 += v2 * b12;
      t23 += v2 * b13;
      t24 += v2 * b14;
      t25 += v2 * b15;
      v2 = a2[11];
      t11 += v2 * b0;
      t12 += v2 * b1;
      t13 += v2 * b22;
      t14 += v2 * b3;
      t15 += v2 * b4;
      t16 += v2 * b5;
      t17 += v2 * b6;
      t18 += v2 * b7;
      t19 += v2 * b8;
      t20 += v2 * b9;
      t21 += v2 * b10;
      t22 += v2 * b11;
      t23 += v2 * b12;
      t24 += v2 * b13;
      t25 += v2 * b14;
      t26 += v2 * b15;
      v2 = a2[12];
      t12 += v2 * b0;
      t13 += v2 * b1;
      t14 += v2 * b22;
      t15 += v2 * b3;
      t16 += v2 * b4;
      t17 += v2 * b5;
      t18 += v2 * b6;
      t19 += v2 * b7;
      t20 += v2 * b8;
      t21 += v2 * b9;
      t22 += v2 * b10;
      t23 += v2 * b11;
      t24 += v2 * b12;
      t25 += v2 * b13;
      t26 += v2 * b14;
      t27 += v2 * b15;
      v2 = a2[13];
      t13 += v2 * b0;
      t14 += v2 * b1;
      t15 += v2 * b22;
      t16 += v2 * b3;
      t17 += v2 * b4;
      t18 += v2 * b5;
      t19 += v2 * b6;
      t20 += v2 * b7;
      t21 += v2 * b8;
      t22 += v2 * b9;
      t23 += v2 * b10;
      t24 += v2 * b11;
      t25 += v2 * b12;
      t26 += v2 * b13;
      t27 += v2 * b14;
      t28 += v2 * b15;
      v2 = a2[14];
      t14 += v2 * b0;
      t15 += v2 * b1;
      t16 += v2 * b22;
      t17 += v2 * b3;
      t18 += v2 * b4;
      t19 += v2 * b5;
      t20 += v2 * b6;
      t21 += v2 * b7;
      t22 += v2 * b8;
      t23 += v2 * b9;
      t24 += v2 * b10;
      t25 += v2 * b11;
      t26 += v2 * b12;
      t27 += v2 * b13;
      t28 += v2 * b14;
      t29 += v2 * b15;
      v2 = a2[15];
      t15 += v2 * b0;
      t16 += v2 * b1;
      t17 += v2 * b22;
      t18 += v2 * b3;
      t19 += v2 * b4;
      t20 += v2 * b5;
      t21 += v2 * b6;
      t22 += v2 * b7;
      t23 += v2 * b8;
      t24 += v2 * b9;
      t25 += v2 * b10;
      t26 += v2 * b11;
      t27 += v2 * b12;
      t28 += v2 * b13;
      t29 += v2 * b14;
      t30 += v2 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c2 = 1;
      v2 = t0 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t0 = v2 - c2 * 65536;
      v2 = t1 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t1 = v2 - c2 * 65536;
      v2 = t2 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t2 = v2 - c2 * 65536;
      v2 = t3 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t3 = v2 - c2 * 65536;
      v2 = t4 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t4 = v2 - c2 * 65536;
      v2 = t5 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t5 = v2 - c2 * 65536;
      v2 = t6 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t6 = v2 - c2 * 65536;
      v2 = t7 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t7 = v2 - c2 * 65536;
      v2 = t8 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t8 = v2 - c2 * 65536;
      v2 = t9 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t9 = v2 - c2 * 65536;
      v2 = t10 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t10 = v2 - c2 * 65536;
      v2 = t11 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t11 = v2 - c2 * 65536;
      v2 = t12 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t12 = v2 - c2 * 65536;
      v2 = t13 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t13 = v2 - c2 * 65536;
      v2 = t14 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t14 = v2 - c2 * 65536;
      v2 = t15 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t15 = v2 - c2 * 65536;
      t0 += c2 - 1 + 37 * (c2 - 1);
      c2 = 1;
      v2 = t0 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t0 = v2 - c2 * 65536;
      v2 = t1 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t1 = v2 - c2 * 65536;
      v2 = t2 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t2 = v2 - c2 * 65536;
      v2 = t3 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t3 = v2 - c2 * 65536;
      v2 = t4 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t4 = v2 - c2 * 65536;
      v2 = t5 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t5 = v2 - c2 * 65536;
      v2 = t6 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t6 = v2 - c2 * 65536;
      v2 = t7 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t7 = v2 - c2 * 65536;
      v2 = t8 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t8 = v2 - c2 * 65536;
      v2 = t9 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t9 = v2 - c2 * 65536;
      v2 = t10 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t10 = v2 - c2 * 65536;
      v2 = t11 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t11 = v2 - c2 * 65536;
      v2 = t12 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t12 = v2 - c2 * 65536;
      v2 = t13 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t13 = v2 - c2 * 65536;
      v2 = t14 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t14 = v2 - c2 * 65536;
      v2 = t15 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t15 = v2 - c2 * 65536;
      t0 += c2 - 1 + 37 * (c2 - 1);
      o2[0] = t0;
      o2[1] = t1;
      o2[2] = t2;
      o2[3] = t3;
      o2[4] = t4;
      o2[5] = t5;
      o2[6] = t6;
      o2[7] = t7;
      o2[8] = t8;
      o2[9] = t9;
      o2[10] = t10;
      o2[11] = t11;
      o2[12] = t12;
      o2[13] = t13;
      o2[14] = t14;
      o2[15] = t15;
    }
    var forge$5 = forge$F;
    forge$5.kem = forge$5.kem || {};
    var BigInteger = forge$5.jsbn.BigInteger;
    forge$5.kem.rsa = {};
    forge$5.kem.rsa.create = function(kdf, options2) {
      options2 = options2 || {};
      var prng2 = options2.prng || forge$5.random;
      var kem = {};
      kem.encrypt = function(publicKey, keyLength) {
        var byteLength = Math.ceil(publicKey.n.bitLength() / 8);
        var r2;
        do {
          r2 = new BigInteger(forge$5.util.bytesToHex(prng2.getBytesSync(byteLength)), 16).mod(publicKey.n);
        } while (r2.compareTo(BigInteger.ONE) <= 0);
        r2 = forge$5.util.hexToBytes(r2.toString(16));
        var zeros2 = byteLength - r2.length;
        if (zeros2 > 0) {
          r2 = forge$5.util.fillString(String.fromCharCode(0), zeros2) + r2;
        }
        var encapsulation = publicKey.encrypt(r2, "NONE");
        var key2 = kdf.generate(r2, keyLength);
        return { encapsulation, key: key2 };
      };
      kem.decrypt = function(privateKey, encapsulation, keyLength) {
        var r2 = privateKey.decrypt(encapsulation, "NONE");
        return kdf.generate(r2, keyLength);
      };
      return kem;
    };
    forge$5.kem.kdf1 = function(md, digestLength) {
      _createKDF(this, md, 0, digestLength || md.digestLength);
    };
    forge$5.kem.kdf2 = function(md, digestLength) {
      _createKDF(this, md, 1, digestLength || md.digestLength);
    };
    function _createKDF(kdf, md, counterStart, digestLength) {
      kdf.generate = function(x2, length) {
        var key2 = new forge$5.util.ByteBuffer();
        var k2 = Math.ceil(length / digestLength) + counterStart;
        var c2 = new forge$5.util.ByteBuffer();
        for (var i3 = counterStart; i3 < k2; ++i3) {
          c2.putInt32(i3);
          md.start();
          md.update(x2 + c2.getBytes());
          var hash2 = md.digest();
          key2.putBytes(hash2.getBytes(digestLength));
        }
        key2.truncate(key2.length() - length);
        return key2.getBytes();
      };
    }
    var forge$4 = forge$F;
    forge$4.log = forge$4.log || {};
    forge$4.log.levels = [
      "none",
      "error",
      "warning",
      "info",
      "debug",
      "verbose",
      "max"
    ];
    var sLevelInfo = {};
    var sLoggers = [];
    var sConsoleLogger = null;
    forge$4.log.LEVEL_LOCKED = 1 << 1;
    forge$4.log.NO_LEVEL_CHECK = 1 << 2;
    forge$4.log.INTERPOLATE = 1 << 3;
    for (i2 = 0; i2 < forge$4.log.levels.length; ++i2) {
      level = forge$4.log.levels[i2];
      sLevelInfo[level] = {
        index: i2,
        name: level.toUpperCase()
      };
    }
    var level;
    var i2;
    forge$4.log.logMessage = function(message) {
      var messageLevelIndex = sLevelInfo[message.level].index;
      for (var i3 = 0; i3 < sLoggers.length; ++i3) {
        var logger2 = sLoggers[i3];
        if (logger2.flags & forge$4.log.NO_LEVEL_CHECK) {
          logger2.f(message);
        } else {
          var loggerLevelIndex = sLevelInfo[logger2.level].index;
          if (messageLevelIndex <= loggerLevelIndex) {
            logger2.f(logger2, message);
          }
        }
      }
    };
    forge$4.log.prepareStandard = function(message) {
      if (!("standard" in message)) {
        message.standard = sLevelInfo[message.level].name + " [" + message.category + "] " + message.message;
      }
    };
    forge$4.log.prepareFull = function(message) {
      if (!("full" in message)) {
        var args = [message.message];
        args = args.concat([]);
        message.full = forge$4.util.format.apply(this, args);
      }
    };
    forge$4.log.prepareStandardFull = function(message) {
      if (!("standardFull" in message)) {
        forge$4.log.prepareStandard(message);
        message.standardFull = message.standard;
      }
    };
    {
      levels = ["error", "warning", "info", "debug", "verbose"];
      for (i2 = 0; i2 < levels.length; ++i2) {
        (function(level2) {
          forge$4.log[level2] = function(category, message) {
            var args = Array.prototype.slice.call(arguments).slice(2);
            var msg = {
              timestamp: new Date(),
              level: level2,
              category,
              message,
              "arguments": args
            };
            forge$4.log.logMessage(msg);
          };
        })(levels[i2]);
      }
    }
    var levels;
    var i2;
    forge$4.log.makeLogger = function(logFunction) {
      var logger2 = {
        flags: 0,
        f: logFunction
      };
      forge$4.log.setLevel(logger2, "none");
      return logger2;
    };
    forge$4.log.setLevel = function(logger2, level2) {
      var rval = false;
      if (logger2 && !(logger2.flags & forge$4.log.LEVEL_LOCKED)) {
        for (var i3 = 0; i3 < forge$4.log.levels.length; ++i3) {
          var aValidLevel = forge$4.log.levels[i3];
          if (level2 == aValidLevel) {
            logger2.level = level2;
            rval = true;
            break;
          }
        }
      }
      return rval;
    };
    forge$4.log.lock = function(logger2, lock2) {
      if (typeof lock2 === "undefined" || lock2) {
        logger2.flags |= forge$4.log.LEVEL_LOCKED;
      } else {
        logger2.flags &= ~forge$4.log.LEVEL_LOCKED;
      }
    };
    forge$4.log.addLogger = function(logger2) {
      sLoggers.push(logger2);
    };
    if (typeof console !== "undefined" && "log" in console) {
      if (console.error && console.warn && console.info && console.debug) {
        levelHandlers = {
          error: console.error,
          warning: console.warn,
          info: console.info,
          debug: console.debug,
          verbose: console.debug
        };
        f2 = function(logger2, message) {
          forge$4.log.prepareStandard(message);
          var handler = levelHandlers[message.level];
          var args = [message.standard];
          args = args.concat(message["arguments"].slice());
          handler.apply(console, args);
        };
        logger = forge$4.log.makeLogger(f2);
      } else {
        f2 = function(logger2, message) {
          forge$4.log.prepareStandardFull(message);
          console.log(message.standardFull);
        };
        logger = forge$4.log.makeLogger(f2);
      }
      forge$4.log.setLevel(logger, "debug");
      forge$4.log.addLogger(logger);
      sConsoleLogger = logger;
    } else {
      console = {
        log: function() {
        }
      };
    }
    var logger;
    var levelHandlers;
    var f2;
    if (sConsoleLogger !== null) {
      query = forge$4.util.getQueryVariables();
      if ("console.level" in query) {
        forge$4.log.setLevel(sConsoleLogger, query["console.level"].slice(-1)[0]);
      }
      if ("console.lock" in query) {
        lock = query["console.lock"].slice(-1)[0];
        if (lock == "true") {
          forge$4.log.lock(sConsoleLogger);
        }
      }
    }
    var query;
    var lock;
    forge$4.log.consoleLogger = sConsoleLogger;
    var forge$3 = forge$F;
    var asn1 = forge$3.asn1;
    var p7 = forge$3.pkcs7 = forge$3.pkcs7 || {};
    p7.messageFromPem = function(pem2) {
      var msg = forge$3.pem.decode(pem2)[0];
      if (msg.type !== "PKCS7") {
        var error2 = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
        error2.headerType = msg.type;
        throw error2;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return p7.messageFromAsn1(obj);
    };
    p7.messageToPem = function(msg, maxline) {
      var pemObj = {
        type: "PKCS7",
        body: asn1.toDer(msg.toAsn1()).getBytes()
      };
      return forge$3.pem.encode(pemObj, { maxline });
    };
    p7.messageFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
        var error2 = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
        error2.errors = errors;
        throw error2;
      }
      var contentType = asn1.derToOid(capture.contentType);
      var msg;
      switch (contentType) {
        case forge$3.pki.oids.envelopedData:
          msg = p7.createEnvelopedData();
          break;
        case forge$3.pki.oids.encryptedData:
          msg = p7.createEncryptedData();
          break;
        case forge$3.pki.oids.signedData:
          msg = p7.createSignedData();
          break;
        default:
          throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
      }
      msg.fromAsn1(capture.content.value[0]);
      return msg;
    };
    p7.createSignedData = function() {
      var msg = null;
      msg = {
        type: forge$3.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        signers: [],
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
          msg.certificates = [];
          msg.crls = [];
          msg.digestAlgorithmIdentifiers = [];
          msg.contentInfo = null;
          msg.signerInfos = [];
          if (msg.rawCapture.certificates) {
            var certs = msg.rawCapture.certificates.value;
            for (var i3 = 0; i3 < certs.length; ++i3) {
              msg.certificates.push(forge$3.pki.certificateFromAsn1(certs[i3]));
            }
          }
        },
        toAsn1: function() {
          if (!msg.contentInfo) {
            msg.sign();
          }
          var certs = [];
          for (var i3 = 0; i3 < msg.certificates.length; ++i3) {
            certs.push(forge$3.pki.certificateToAsn1(msg.certificates[i3]));
          }
          var crls = [];
          var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.digestAlgorithmIdentifiers),
              msg.contentInfo
            ])
          ]);
          if (certs.length > 0) {
            signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs));
          }
          if (crls.length > 0) {
            signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls));
          }
          signedData.value[0].value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.signerInfos));
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()),
            signedData
          ]);
        },
        addSigner: function(signer) {
          var issuer = signer.issuer;
          var serialNumber = signer.serialNumber;
          if (signer.certificate) {
            var cert = signer.certificate;
            if (typeof cert === "string") {
              cert = forge$3.pki.certificateFromPem(cert);
            }
            issuer = cert.issuer.attributes;
            serialNumber = cert.serialNumber;
          }
          var key2 = signer.key;
          if (!key2) {
            throw new Error("Could not add PKCS#7 signer; no private key specified.");
          }
          if (typeof key2 === "string") {
            key2 = forge$3.pki.privateKeyFromPem(key2);
          }
          var digestAlgorithm = signer.digestAlgorithm || forge$3.pki.oids.sha1;
          switch (digestAlgorithm) {
            case forge$3.pki.oids.sha1:
            case forge$3.pki.oids.sha256:
            case forge$3.pki.oids.sha384:
            case forge$3.pki.oids.sha512:
            case forge$3.pki.oids.md5:
              break;
            default:
              throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm);
          }
          var authenticatedAttributes = signer.authenticatedAttributes || [];
          if (authenticatedAttributes.length > 0) {
            var contentType = false;
            var messageDigest = false;
            for (var i3 = 0; i3 < authenticatedAttributes.length; ++i3) {
              var attr = authenticatedAttributes[i3];
              if (!contentType && attr.type === forge$3.pki.oids.contentType) {
                contentType = true;
                if (messageDigest) {
                  break;
                }
                continue;
              }
              if (!messageDigest && attr.type === forge$3.pki.oids.messageDigest) {
                messageDigest = true;
                if (contentType) {
                  break;
                }
                continue;
              }
            }
            if (!contentType || !messageDigest) {
              throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
            }
          }
          msg.signers.push({
            key: key2,
            version: 1,
            issuer,
            serialNumber,
            digestAlgorithm,
            signatureAlgorithm: forge$3.pki.oids.rsaEncryption,
            signature: null,
            authenticatedAttributes,
            unauthenticatedAttributes: []
          });
        },
        sign: function(options2) {
          options2 = options2 || {};
          if (typeof msg.content !== "object" || msg.contentInfo === null) {
            msg.contentInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge$3.pki.oids.data).getBytes())
            ]);
            if ("content" in msg) {
              var content2;
              if (msg.content instanceof forge$3.util.ByteBuffer) {
                content2 = msg.content.bytes();
              } else if (typeof msg.content === "string") {
                content2 = forge$3.util.encodeUtf8(msg.content);
              }
              if (options2.detached) {
                msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content2);
              } else {
                msg.contentInfo.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content2)
                ]));
              }
            }
          }
          if (msg.signers.length === 0) {
            return;
          }
          var mds = addDigestAlgorithmIds();
          addSignerInfos(mds);
        },
        verify: function() {
          throw new Error("PKCS#7 signature verification not yet implemented.");
        },
        addCertificate: function(cert) {
          if (typeof cert === "string") {
            cert = forge$3.pki.certificateFromPem(cert);
          }
          msg.certificates.push(cert);
        },
        addCertificateRevokationList: function(crl) {
          throw new Error("PKCS#7 CRL support not yet implemented.");
        }
      };
      return msg;
      function addDigestAlgorithmIds() {
        var mds = {};
        for (var i3 = 0; i3 < msg.signers.length; ++i3) {
          var signer = msg.signers[i3];
          var oid = signer.digestAlgorithm;
          if (!(oid in mds)) {
            mds[oid] = forge$3.md[forge$3.pki.oids[oid]].create();
          }
          if (signer.authenticatedAttributes.length === 0) {
            signer.md = mds[oid];
          } else {
            signer.md = forge$3.md[forge$3.pki.oids[oid]].create();
          }
        }
        msg.digestAlgorithmIdentifiers = [];
        for (var oid in mds) {
          msg.digestAlgorithmIdentifiers.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oid).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ]));
        }
        return mds;
      }
      function addSignerInfos(mds) {
        var content2;
        if (msg.detachedContent) {
          content2 = msg.detachedContent;
        } else {
          content2 = msg.contentInfo.value[1];
          content2 = content2.value[0];
        }
        if (!content2) {
          throw new Error("Could not sign PKCS#7 message; there is no content to sign.");
        }
        var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
        var bytes2 = asn1.toDer(content2);
        bytes2.getByte();
        asn1.getBerValueLength(bytes2);
        bytes2 = bytes2.getBytes();
        for (var oid in mds) {
          mds[oid].start().update(bytes2);
        }
        var signingTime = new Date();
        for (var i3 = 0; i3 < msg.signers.length; ++i3) {
          var signer = msg.signers[i3];
          if (signer.authenticatedAttributes.length === 0) {
            if (contentType !== forge$3.pki.oids.data) {
              throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.");
            }
          } else {
            signer.authenticatedAttributesAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
            var attrsAsn1 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, []);
            for (var ai2 = 0; ai2 < signer.authenticatedAttributes.length; ++ai2) {
              var attr = signer.authenticatedAttributes[ai2];
              if (attr.type === forge$3.pki.oids.messageDigest) {
                attr.value = mds[signer.digestAlgorithm].digest();
              } else if (attr.type === forge$3.pki.oids.signingTime) {
                if (!attr.value) {
                  attr.value = signingTime;
                }
              }
              attrsAsn1.value.push(_attributeToAsn1(attr));
              signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
            }
            bytes2 = asn1.toDer(attrsAsn1).getBytes();
            signer.md.start().update(bytes2);
          }
          signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
        }
        msg.signerInfos = _signersToAsn1(msg.signers);
      }
    };
    p7.createEncryptedData = function() {
      var msg = null;
      msg = {
        type: forge$3.pki.oids.encryptedData,
        version: 0,
        encryptedContent: {
          algorithm: forge$3.pki.oids["aes256-CBC"]
        },
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
        },
        decrypt: function(key2) {
          if (key2 !== void 0) {
            msg.encryptedContent.key = key2;
          }
          _decryptContent(msg);
        }
      };
      return msg;
    };
    p7.createEnvelopedData = function() {
      var msg = null;
      msg = {
        type: forge$3.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: {
          algorithm: forge$3.pki.oids["aes256-CBC"]
        },
        fromAsn1: function(obj) {
          var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
          msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
        },
        toAsn1: function() {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()),
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, _recipientsToAsn1(msg.recipients)),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, _encryptedContentToAsn1(msg.encryptedContent))
              ])
            ])
          ]);
        },
        findRecipient: function(cert) {
          var sAttr = cert.issuer.attributes;
          for (var i3 = 0; i3 < msg.recipients.length; ++i3) {
            var r2 = msg.recipients[i3];
            var rAttr = r2.issuer;
            if (r2.serialNumber !== cert.serialNumber) {
              continue;
            }
            if (rAttr.length !== sAttr.length) {
              continue;
            }
            var match2 = true;
            for (var j2 = 0; j2 < sAttr.length; ++j2) {
              if (rAttr[j2].type !== sAttr[j2].type || rAttr[j2].value !== sAttr[j2].value) {
                match2 = false;
                break;
              }
            }
            if (match2) {
              return r2;
            }
          }
          return null;
        },
        decrypt: function(recipient, privKey) {
          if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
            switch (recipient.encryptedContent.algorithm) {
              case forge$3.pki.oids.rsaEncryption:
              case forge$3.pki.oids.desCBC:
                var key2 = privKey.decrypt(recipient.encryptedContent.content);
                msg.encryptedContent.key = forge$3.util.createBuffer(key2);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
          _decryptContent(msg);
        },
        addRecipient: function(cert) {
          msg.recipients.push({
            version: 0,
            issuer: cert.issuer.attributes,
            serialNumber: cert.serialNumber,
            encryptedContent: {
              algorithm: forge$3.pki.oids.rsaEncryption,
              key: cert.publicKey
            }
          });
        },
        encrypt: function(key2, cipher) {
          if (msg.encryptedContent.content === void 0) {
            cipher = cipher || msg.encryptedContent.algorithm;
            key2 = key2 || msg.encryptedContent.key;
            var keyLen, ivLen, ciphFn;
            switch (cipher) {
              case forge$3.pki.oids["aes128-CBC"]:
                keyLen = 16;
                ivLen = 16;
                ciphFn = forge$3.aes.createEncryptionCipher;
                break;
              case forge$3.pki.oids["aes192-CBC"]:
                keyLen = 24;
                ivLen = 16;
                ciphFn = forge$3.aes.createEncryptionCipher;
                break;
              case forge$3.pki.oids["aes256-CBC"]:
                keyLen = 32;
                ivLen = 16;
                ciphFn = forge$3.aes.createEncryptionCipher;
                break;
              case forge$3.pki.oids["des-EDE3-CBC"]:
                keyLen = 24;
                ivLen = 8;
                ciphFn = forge$3.des.createEncryptionCipher;
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + cipher);
            }
            if (key2 === void 0) {
              key2 = forge$3.util.createBuffer(forge$3.random.getBytes(keyLen));
            } else if (key2.length() != keyLen) {
              throw new Error("Symmetric key has wrong length; got " + key2.length() + " bytes, expected " + keyLen + ".");
            }
            msg.encryptedContent.algorithm = cipher;
            msg.encryptedContent.key = key2;
            msg.encryptedContent.parameter = forge$3.util.createBuffer(forge$3.random.getBytes(ivLen));
            var ciph = ciphFn(key2);
            ciph.start(msg.encryptedContent.parameter.copy());
            ciph.update(msg.content);
            if (!ciph.finish()) {
              throw new Error("Symmetric encryption failed.");
            }
            msg.encryptedContent.content = ciph.output;
          }
          for (var i3 = 0; i3 < msg.recipients.length; ++i3) {
            var recipient = msg.recipients[i3];
            if (recipient.encryptedContent.content !== void 0) {
              continue;
            }
            switch (recipient.encryptedContent.algorithm) {
              case forge$3.pki.oids.rsaEncryption:
                recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(msg.encryptedContent.key.data);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
        }
      };
      return msg;
    };
    function _recipientFromAsn1(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
        var error2 = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
        error2.errors = errors;
        throw error2;
      }
      return {
        version: capture.version.charCodeAt(0),
        issuer: forge$3.pki.RDNAttributesAsArray(capture.issuer),
        serialNumber: forge$3.util.createBuffer(capture.serial).toHex(),
        encryptedContent: {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: capture.encParameter.value,
          content: capture.encKey
        }
      };
    }
    function _recipientToAsn1(obj) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          forge$3.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge$3.util.hexToBytes(obj.serialNumber))
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.encryptedContent.content)
      ]);
    }
    function _recipientsFromAsn1(infos) {
      var ret = [];
      for (var i3 = 0; i3 < infos.length; ++i3) {
        ret.push(_recipientFromAsn1(infos[i3]));
      }
      return ret;
    }
    function _recipientsToAsn1(recipients) {
      var ret = [];
      for (var i3 = 0; i3 < recipients.length; ++i3) {
        ret.push(_recipientToAsn1(recipients[i3]));
      }
      return ret;
    }
    function _signerToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          forge$3.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge$3.util.hexToBytes(obj.serialNumber))
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.digestAlgorithm).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ])
      ]);
      if (obj.authenticatedAttributesAsn1) {
        rval.value.push(obj.authenticatedAttributesAsn1);
      }
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.signatureAlgorithm).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]));
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.signature));
      if (obj.unauthenticatedAttributes.length > 0) {
        var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
        for (var i3 = 0; i3 < obj.unauthenticatedAttributes.length; ++i3) {
          var attr = obj.unauthenticatedAttributes[i3];
          attrsAsn1.values.push(_attributeToAsn1(attr));
        }
        rval.value.push(attrsAsn1);
      }
      return rval;
    }
    function _signersToAsn1(signers) {
      var ret = [];
      for (var i3 = 0; i3 < signers.length; ++i3) {
        ret.push(_signerToAsn1(signers[i3]));
      }
      return ret;
    }
    function _attributeToAsn1(attr) {
      var value;
      if (attr.type === forge$3.pki.oids.contentType) {
        value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.value).getBytes());
      } else if (attr.type === forge$3.pki.oids.messageDigest) {
        value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, attr.value.bytes());
      } else if (attr.type === forge$3.pki.oids.signingTime) {
        var jan_1_19502 = new Date("1950-01-01T00:00:00Z");
        var jan_1_20502 = new Date("2050-01-01T00:00:00Z");
        var date = attr.value;
        if (typeof date === "string") {
          var timestamp2 = Date.parse(date);
          if (!isNaN(timestamp2)) {
            date = new Date(timestamp2);
          } else if (date.length === 13) {
            date = asn1.utcTimeToDate(date);
          } else {
            date = asn1.generalizedTimeToDate(date);
          }
        }
        if (date >= jan_1_19502 && date < jan_1_20502) {
          value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));
        } else {
          value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));
        }
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          value
        ])
      ]);
    }
    function _encryptedContentToAsn1(ec) {
      return [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge$3.pki.oids.data).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ec.algorithm).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.parameter.getBytes())
        ]),
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.content.getBytes())
        ])
      ];
    }
    function _fromAsn1(msg, obj, validator) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, validator, capture, errors)) {
        var error2 = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
        error2.errors = error2;
        throw error2;
      }
      var contentType = asn1.derToOid(capture.contentType);
      if (contentType !== forge$3.pki.oids.data) {
        throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
      }
      if (capture.encryptedContent) {
        var content2 = "";
        if (forge$3.util.isArray(capture.encryptedContent)) {
          for (var i3 = 0; i3 < capture.encryptedContent.length; ++i3) {
            if (capture.encryptedContent[i3].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
            }
            content2 += capture.encryptedContent[i3].value;
          }
        } else {
          content2 = capture.encryptedContent;
        }
        msg.encryptedContent = {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: forge$3.util.createBuffer(capture.encParameter.value),
          content: forge$3.util.createBuffer(content2)
        };
      }
      if (capture.content) {
        var content2 = "";
        if (forge$3.util.isArray(capture.content)) {
          for (var i3 = 0; i3 < capture.content.length; ++i3) {
            if (capture.content[i3].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
            }
            content2 += capture.content[i3].value;
          }
        } else {
          content2 = capture.content;
        }
        msg.content = forge$3.util.createBuffer(content2);
      }
      msg.version = capture.version.charCodeAt(0);
      msg.rawCapture = capture;
      return capture;
    }
    function _decryptContent(msg) {
      if (msg.encryptedContent.key === void 0) {
        throw new Error("Symmetric key not available.");
      }
      if (msg.content === void 0) {
        var ciph;
        switch (msg.encryptedContent.algorithm) {
          case forge$3.pki.oids["aes128-CBC"]:
          case forge$3.pki.oids["aes192-CBC"]:
          case forge$3.pki.oids["aes256-CBC"]:
            ciph = forge$3.aes.createDecryptionCipher(msg.encryptedContent.key);
            break;
          case forge$3.pki.oids["desCBC"]:
          case forge$3.pki.oids["des-EDE3-CBC"]:
            ciph = forge$3.des.createDecryptionCipher(msg.encryptedContent.key);
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
        }
        ciph.start(msg.encryptedContent.parameter);
        ciph.update(msg.encryptedContent.content);
        if (!ciph.finish()) {
          throw new Error("Symmetric decryption failed.");
        }
        msg.content = ciph.output;
      }
    }
    var forge$2 = forge$F;
    var ssh = forge$2.ssh = forge$2.ssh || {};
    ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {
      comment = comment || "";
      passphrase = passphrase || "";
      var algorithm = "ssh-rsa";
      var encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc";
      var ppk = "PuTTY-User-Key-File-2: " + algorithm + "\r\n";
      ppk += "Encryption: " + encryptionAlgorithm + "\r\n";
      ppk += "Comment: " + comment + "\r\n";
      var pubbuffer = forge$2.util.createBuffer();
      _addStringToBuffer(pubbuffer, algorithm);
      _addBigIntegerToBuffer(pubbuffer, privateKey.e);
      _addBigIntegerToBuffer(pubbuffer, privateKey.n);
      var pub = forge$2.util.encode64(pubbuffer.bytes(), 64);
      var length = Math.floor(pub.length / 66) + 1;
      ppk += "Public-Lines: " + length + "\r\n";
      ppk += pub;
      var privbuffer = forge$2.util.createBuffer();
      _addBigIntegerToBuffer(privbuffer, privateKey.d);
      _addBigIntegerToBuffer(privbuffer, privateKey.p);
      _addBigIntegerToBuffer(privbuffer, privateKey.q);
      _addBigIntegerToBuffer(privbuffer, privateKey.qInv);
      var priv;
      if (!passphrase) {
        priv = forge$2.util.encode64(privbuffer.bytes(), 64);
      } else {
        var encLen = privbuffer.length() + 16 - 1;
        encLen -= encLen % 16;
        var padding = _sha1(privbuffer.bytes());
        padding.truncate(padding.length() - encLen + privbuffer.length());
        privbuffer.putBuffer(padding);
        var aeskey = forge$2.util.createBuffer();
        aeskey.putBuffer(_sha1("\0\0\0\0", passphrase));
        aeskey.putBuffer(_sha1("\0\0\0", passphrase));
        var cipher = forge$2.aes.createEncryptionCipher(aeskey.truncate(8), "CBC");
        cipher.start(forge$2.util.createBuffer().fillWithByte(0, 16));
        cipher.update(privbuffer.copy());
        cipher.finish();
        var encrypted = cipher.output;
        encrypted.truncate(16);
        priv = forge$2.util.encode64(encrypted.bytes(), 64);
      }
      length = Math.floor(priv.length / 66) + 1;
      ppk += "\r\nPrivate-Lines: " + length + "\r\n";
      ppk += priv;
      var mackey = _sha1("putty-private-key-file-mac-key", passphrase);
      var macbuffer = forge$2.util.createBuffer();
      _addStringToBuffer(macbuffer, algorithm);
      _addStringToBuffer(macbuffer, encryptionAlgorithm);
      _addStringToBuffer(macbuffer, comment);
      macbuffer.putInt32(pubbuffer.length());
      macbuffer.putBuffer(pubbuffer);
      macbuffer.putInt32(privbuffer.length());
      macbuffer.putBuffer(privbuffer);
      var hmac2 = forge$2.hmac.create();
      hmac2.start("sha1", mackey);
      hmac2.update(macbuffer.bytes());
      ppk += "\r\nPrivate-MAC: " + hmac2.digest().toHex() + "\r\n";
      return ppk;
    };
    ssh.publicKeyToOpenSSH = function(key2, comment) {
      var type = "ssh-rsa";
      comment = comment || "";
      var buffer = forge$2.util.createBuffer();
      _addStringToBuffer(buffer, type);
      _addBigIntegerToBuffer(buffer, key2.e);
      _addBigIntegerToBuffer(buffer, key2.n);
      return type + " " + forge$2.util.encode64(buffer.bytes()) + " " + comment;
    };
    ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {
      if (!passphrase) {
        return forge$2.pki.privateKeyToPem(privateKey);
      }
      return forge$2.pki.encryptRsaPrivateKey(privateKey, passphrase, { legacy: true, algorithm: "aes128" });
    };
    ssh.getPublicKeyFingerprint = function(key2, options2) {
      options2 = options2 || {};
      var md = options2.md || forge$2.md.md5.create();
      var type = "ssh-rsa";
      var buffer = forge$2.util.createBuffer();
      _addStringToBuffer(buffer, type);
      _addBigIntegerToBuffer(buffer, key2.e);
      _addBigIntegerToBuffer(buffer, key2.n);
      md.start();
      md.update(buffer.getBytes());
      var digest = md.digest();
      if (options2.encoding === "hex") {
        var hex = digest.toHex();
        if (options2.delimiter) {
          return hex.match(/.{2}/g).join(options2.delimiter);
        }
        return hex;
      } else if (options2.encoding === "binary") {
        return digest.getBytes();
      } else if (options2.encoding) {
        throw new Error('Unknown encoding "' + options2.encoding + '".');
      }
      return digest;
    };
    function _addBigIntegerToBuffer(buffer, val) {
      var hexVal = val.toString(16);
      if (hexVal[0] >= "8") {
        hexVal = "00" + hexVal;
      }
      var bytes2 = forge$2.util.hexToBytes(hexVal);
      buffer.putInt32(bytes2.length);
      buffer.putBytes(bytes2);
    }
    function _addStringToBuffer(buffer, val) {
      buffer.putInt32(val.length);
      buffer.putString(val);
    }
    function _sha1() {
      var sha = forge$2.md.sha1.create();
      var num = arguments.length;
      for (var i3 = 0; i3 < num; ++i3) {
        sha.update(arguments[i3]);
      }
      return sha.digest();
    }
    var forge$1 = forge$F;
    var cat = "forge.task";
    var sTasks = {};
    var sNextTaskId = 0;
    forge$1.debug.set(cat, "tasks", sTasks);
    var sTaskQueues = {};
    forge$1.debug.set(cat, "queues", sTaskQueues);
    var sNoTaskName = "?";
    var sMaxRecursions = 30;
    var sTimeSlice = 20;
    var READY = "ready";
    var RUNNING2 = "running";
    var BLOCKED = "blocked";
    var SLEEPING = "sleeping";
    var DONE = "done";
    var ERROR = "error";
    var STOP = "stop";
    var START = "start";
    var BLOCK = "block";
    var UNBLOCK = "unblock";
    var SLEEP = "sleep";
    var WAKEUP = "wakeup";
    var CANCEL = "cancel";
    var FAIL = "fail";
    var sStateTable = {};
    sStateTable[READY] = {};
    sStateTable[READY][STOP] = READY;
    sStateTable[READY][START] = RUNNING2;
    sStateTable[READY][CANCEL] = DONE;
    sStateTable[READY][FAIL] = ERROR;
    sStateTable[RUNNING2] = {};
    sStateTable[RUNNING2][STOP] = READY;
    sStateTable[RUNNING2][START] = RUNNING2;
    sStateTable[RUNNING2][BLOCK] = BLOCKED;
    sStateTable[RUNNING2][UNBLOCK] = RUNNING2;
    sStateTable[RUNNING2][SLEEP] = SLEEPING;
    sStateTable[RUNNING2][WAKEUP] = RUNNING2;
    sStateTable[RUNNING2][CANCEL] = DONE;
    sStateTable[RUNNING2][FAIL] = ERROR;
    sStateTable[BLOCKED] = {};
    sStateTable[BLOCKED][STOP] = BLOCKED;
    sStateTable[BLOCKED][START] = BLOCKED;
    sStateTable[BLOCKED][BLOCK] = BLOCKED;
    sStateTable[BLOCKED][UNBLOCK] = BLOCKED;
    sStateTable[BLOCKED][SLEEP] = BLOCKED;
    sStateTable[BLOCKED][WAKEUP] = BLOCKED;
    sStateTable[BLOCKED][CANCEL] = DONE;
    sStateTable[BLOCKED][FAIL] = ERROR;
    sStateTable[SLEEPING] = {};
    sStateTable[SLEEPING][STOP] = SLEEPING;
    sStateTable[SLEEPING][START] = SLEEPING;
    sStateTable[SLEEPING][BLOCK] = SLEEPING;
    sStateTable[SLEEPING][UNBLOCK] = SLEEPING;
    sStateTable[SLEEPING][SLEEP] = SLEEPING;
    sStateTable[SLEEPING][WAKEUP] = SLEEPING;
    sStateTable[SLEEPING][CANCEL] = DONE;
    sStateTable[SLEEPING][FAIL] = ERROR;
    sStateTable[DONE] = {};
    sStateTable[DONE][STOP] = DONE;
    sStateTable[DONE][START] = DONE;
    sStateTable[DONE][BLOCK] = DONE;
    sStateTable[DONE][UNBLOCK] = DONE;
    sStateTable[DONE][SLEEP] = DONE;
    sStateTable[DONE][WAKEUP] = DONE;
    sStateTable[DONE][CANCEL] = DONE;
    sStateTable[DONE][FAIL] = ERROR;
    sStateTable[ERROR] = {};
    sStateTable[ERROR][STOP] = ERROR;
    sStateTable[ERROR][START] = ERROR;
    sStateTable[ERROR][BLOCK] = ERROR;
    sStateTable[ERROR][UNBLOCK] = ERROR;
    sStateTable[ERROR][SLEEP] = ERROR;
    sStateTable[ERROR][WAKEUP] = ERROR;
    sStateTable[ERROR][CANCEL] = ERROR;
    sStateTable[ERROR][FAIL] = ERROR;
    var Task2 = function(options2) {
      this.id = -1;
      this.name = options2.name || sNoTaskName;
      this.parent = options2.parent || null;
      this.run = options2.run;
      this.subtasks = [];
      this.error = false;
      this.state = READY;
      this.blocks = 0;
      this.timeoutId = null;
      this.swapTime = null;
      this.userData = null;
      this.id = sNextTaskId++;
      sTasks[this.id] = this;
    };
    Task2.prototype.debug = function(msg) {
      msg = msg || "";
      forge$1.log.debug(cat, msg, "[%s][%s] task:", this.id, this.name, this, "subtasks:", this.subtasks.length, "queue:", sTaskQueues);
    };
    Task2.prototype.next = function(name, subrun) {
      if (typeof name === "function") {
        subrun = name;
        name = this.name;
      }
      var subtask = new Task2({
        run: subrun,
        name,
        parent: this
      });
      subtask.state = RUNNING2;
      subtask.type = this.type;
      subtask.successCallback = this.successCallback || null;
      subtask.failureCallback = this.failureCallback || null;
      this.subtasks.push(subtask);
      return this;
    };
    Task2.prototype.parallel = function(name, subrun) {
      if (forge$1.util.isArray(name)) {
        subrun = name;
        name = this.name;
      }
      return this.next(name, function(task) {
        var ptask = task;
        ptask.block(subrun.length);
        var startParallelTask = function(pname2, pi3) {
          forge$1.task.start({
            type: pname2,
            run: function(task2) {
              subrun[pi3](task2);
            },
            success: function(task2) {
              ptask.unblock();
            },
            failure: function(task2) {
              ptask.unblock();
            }
          });
        };
        for (var i3 = 0; i3 < subrun.length; i3++) {
          var pname = name + "__parallel-" + task.id + "-" + i3;
          var pi2 = i3;
          startParallelTask(pname, pi2);
        }
      });
    };
    Task2.prototype.stop = function() {
      this.state = sStateTable[this.state][STOP];
    };
    Task2.prototype.start = function() {
      this.error = false;
      this.state = sStateTable[this.state][START];
      if (this.state === RUNNING2) {
        this.start = new Date();
        this.run(this);
        runNext(this, 0);
      }
    };
    Task2.prototype.block = function(n3) {
      n3 = typeof n3 === "undefined" ? 1 : n3;
      this.blocks += n3;
      if (this.blocks > 0) {
        this.state = sStateTable[this.state][BLOCK];
      }
    };
    Task2.prototype.unblock = function(n3) {
      n3 = typeof n3 === "undefined" ? 1 : n3;
      this.blocks -= n3;
      if (this.blocks === 0 && this.state !== DONE) {
        this.state = RUNNING2;
        runNext(this, 0);
      }
      return this.blocks;
    };
    Task2.prototype.sleep = function(n3) {
      n3 = typeof n3 === "undefined" ? 0 : n3;
      this.state = sStateTable[this.state][SLEEP];
      var self2 = this;
      this.timeoutId = setTimeout(function() {
        self2.timeoutId = null;
        self2.state = RUNNING2;
        runNext(self2, 0);
      }, n3);
    };
    Task2.prototype.wait = function(cond) {
      cond.wait(this);
    };
    Task2.prototype.wakeup = function() {
      if (this.state === SLEEPING) {
        cancelTimeout(this.timeoutId);
        this.timeoutId = null;
        this.state = RUNNING2;
        runNext(this, 0);
      }
    };
    Task2.prototype.cancel = function() {
      this.state = sStateTable[this.state][CANCEL];
      this.permitsNeeded = 0;
      if (this.timeoutId !== null) {
        cancelTimeout(this.timeoutId);
        this.timeoutId = null;
      }
      this.subtasks = [];
    };
    Task2.prototype.fail = function(next) {
      this.error = true;
      finish2(this, true);
      if (next) {
        next.error = this.error;
        next.swapTime = this.swapTime;
        next.userData = this.userData;
        runNext(next, 0);
      } else {
        if (this.parent !== null) {
          var parent = this.parent;
          while (parent.parent !== null) {
            parent.error = this.error;
            parent.swapTime = this.swapTime;
            parent.userData = this.userData;
            parent = parent.parent;
          }
          finish2(parent, true);
        }
        if (this.failureCallback) {
          this.failureCallback(this);
        }
      }
    };
    var start = function(task) {
      task.error = false;
      task.state = sStateTable[task.state][START];
      setTimeout(function() {
        if (task.state === RUNNING2) {
          task.swapTime = +new Date();
          task.run(task);
          runNext(task, 0);
        }
      }, 0);
    };
    var runNext = function(task, recurse) {
      var swap2 = recurse > sMaxRecursions || +new Date() - task.swapTime > sTimeSlice;
      var doNext = function(recurse2) {
        recurse2++;
        if (task.state === RUNNING2) {
          if (swap2) {
            task.swapTime = +new Date();
          }
          if (task.subtasks.length > 0) {
            var subtask = task.subtasks.shift();
            subtask.error = task.error;
            subtask.swapTime = task.swapTime;
            subtask.userData = task.userData;
            subtask.run(subtask);
            if (!subtask.error) {
              runNext(subtask, recurse2);
            }
          } else {
            finish2(task);
            if (!task.error) {
              if (task.parent !== null) {
                task.parent.error = task.error;
                task.parent.swapTime = task.swapTime;
                task.parent.userData = task.userData;
                runNext(task.parent, recurse2);
              }
            }
          }
        }
      };
      if (swap2) {
        setTimeout(doNext, 0);
      } else {
        doNext(recurse);
      }
    };
    var finish2 = function(task, suppressCallbacks) {
      task.state = DONE;
      delete sTasks[task.id];
      if (task.parent === null) {
        if (!(task.type in sTaskQueues)) {
          forge$1.log.error(cat, "[%s][%s] task queue missing [%s]", task.id, task.name, task.type);
        } else if (sTaskQueues[task.type].length === 0) {
          forge$1.log.error(cat, "[%s][%s] task queue empty [%s]", task.id, task.name, task.type);
        } else if (sTaskQueues[task.type][0] !== task) {
          forge$1.log.error(cat, "[%s][%s] task not first in queue [%s]", task.id, task.name, task.type);
        } else {
          sTaskQueues[task.type].shift();
          if (sTaskQueues[task.type].length === 0) {
            delete sTaskQueues[task.type];
          } else {
            sTaskQueues[task.type][0].start();
          }
        }
        if (!suppressCallbacks) {
          if (task.error && task.failureCallback) {
            task.failureCallback(task);
          } else if (!task.error && task.successCallback) {
            task.successCallback(task);
          }
        }
      }
    };
    forge$1.task = forge$1.task || {};
    forge$1.task.start = function(options2) {
      var task = new Task2({
        run: options2.run,
        name: options2.name || sNoTaskName
      });
      task.type = options2.type;
      task.successCallback = options2.success || null;
      task.failureCallback = options2.failure || null;
      if (!(task.type in sTaskQueues)) {
        sTaskQueues[task.type] = [task];
        start(task);
      } else {
        sTaskQueues[options2.type].push(task);
      }
    };
    forge$1.task.cancel = function(type) {
      if (type in sTaskQueues) {
        sTaskQueues[type] = [sTaskQueues[type][0]];
      }
    };
    forge$1.task.createCondition = function() {
      var cond = {
        tasks: {}
      };
      cond.wait = function(task) {
        if (!(task.id in cond.tasks)) {
          task.block();
          cond.tasks[task.id] = task;
        }
      };
      cond.notify = function() {
        var tmp = cond.tasks;
        cond.tasks = {};
        for (var id in tmp) {
          tmp[id].unblock();
        }
      };
      return cond;
    };
    var lib2 = forge$F;
    var forge = lib2;
    function toPositiveHex(hexString) {
      var mostSiginficativeHexAsInt = parseInt(hexString[0], 16);
      if (mostSiginficativeHexAsInt < 8) {
        return hexString;
      }
      mostSiginficativeHexAsInt -= 8;
      return mostSiginficativeHexAsInt.toString() + hexString.substring(1);
    }
    function getAlgorithm(key2) {
      switch (key2) {
        case "sha256":
          return forge.md.sha256.create();
        default:
          return forge.md.sha1.create();
      }
    }
    var generate2 = selfsigned.generate = function generate3(attrs, options2, done) {
      if (typeof attrs === "function") {
        done = attrs;
        attrs = void 0;
      } else if (typeof options2 === "function") {
        done = options2;
        options2 = {};
      }
      options2 = options2 || {};
      var generatePem = function(keyPair2) {
        var cert = forge.pki.createCertificate();
        cert.serialNumber = toPositiveHex(forge.util.bytesToHex(forge.random.getBytesSync(9)));
        cert.validity.notBefore = new Date();
        cert.validity.notAfter = new Date();
        cert.validity.notAfter.setDate(cert.validity.notBefore.getDate() + (options2.days || 365));
        attrs = attrs || [{
          name: "commonName",
          value: "example.org"
        }, {
          name: "countryName",
          value: "US"
        }, {
          shortName: "ST",
          value: "Virginia"
        }, {
          name: "localityName",
          value: "Blacksburg"
        }, {
          name: "organizationName",
          value: "Test"
        }, {
          shortName: "OU",
          value: "Test"
        }];
        cert.setSubject(attrs);
        cert.setIssuer(attrs);
        cert.publicKey = keyPair2.publicKey;
        cert.setExtensions(options2.extensions || [{
          name: "basicConstraints",
          cA: true
        }, {
          name: "keyUsage",
          keyCertSign: true,
          digitalSignature: true,
          nonRepudiation: true,
          keyEncipherment: true,
          dataEncipherment: true
        }, {
          name: "subjectAltName",
          altNames: [{
            type: 6,
            value: "http://example.org/webid#me"
          }]
        }]);
        cert.sign(keyPair2.privateKey, getAlgorithm(options2 && options2.algorithm));
        const fingerprint = forge.md.sha1.create().update(forge.asn1.toDer(forge.pki.certificateToAsn1(cert)).getBytes()).digest().toHex().match(/.{2}/g).join(":");
        var pem2 = {
          private: forge.pki.privateKeyToPem(keyPair2.privateKey),
          public: forge.pki.publicKeyToPem(keyPair2.publicKey),
          cert: forge.pki.certificateToPem(cert),
          fingerprint
        };
        if (options2 && options2.pkcs7) {
          var p72 = forge.pkcs7.createSignedData();
          p72.addCertificate(cert);
          pem2.pkcs7 = forge.pkcs7.messageToPem(p72);
        }
        if (options2 && options2.clientCertificate) {
          var clientkeys = forge.pki.rsa.generateKeyPair(1024);
          var clientcert = forge.pki.createCertificate();
          clientcert.serialNumber = toPositiveHex(forge.util.bytesToHex(forge.random.getBytesSync(9)));
          clientcert.validity.notBefore = new Date();
          clientcert.validity.notAfter = new Date();
          clientcert.validity.notAfter.setFullYear(clientcert.validity.notBefore.getFullYear() + 1);
          var clientAttrs = JSON.parse(JSON.stringify(attrs));
          for (var i3 = 0; i3 < clientAttrs.length; i3++) {
            if (clientAttrs[i3].name === "commonName") {
              if (options2.clientCertificateCN)
                clientAttrs[i3] = { name: "commonName", value: options2.clientCertificateCN };
              else
                clientAttrs[i3] = { name: "commonName", value: "John Doe jdoe123" };
            }
          }
          clientcert.setSubject(clientAttrs);
          clientcert.setIssuer(attrs);
          clientcert.publicKey = clientkeys.publicKey;
          clientcert.sign(keyPair2.privateKey);
          pem2.clientprivate = forge.pki.privateKeyToPem(clientkeys.privateKey);
          pem2.clientpublic = forge.pki.publicKeyToPem(clientkeys.publicKey);
          pem2.clientcert = forge.pki.certificateToPem(clientcert);
          if (options2.pkcs7) {
            var clientp7 = forge.pkcs7.createSignedData();
            clientp7.addCertificate(clientcert);
            pem2.clientpkcs7 = forge.pkcs7.messageToPem(clientp7);
          }
        }
        var caStore = forge.pki.createCaStore();
        caStore.addCertificate(cert);
        try {
          forge.pki.verifyCertificateChain(caStore, [cert], function(vfd, depth2, chain) {
            if (vfd !== true) {
              throw new Error("Certificate could not be verified.");
            }
            return true;
          });
        } catch (ex) {
          throw new Error(ex);
        }
        return pem2;
      };
      var keySize = options2.keySize || 1024;
      if (done) {
        return forge.pki.rsa.generateKeyPair({ bits: keySize }, function(err, keyPair2) {
          if (err) {
            return done(err);
          }
          try {
            return done(null, generatePem(keyPair2));
          } catch (ex) {
            return done(ex);
          }
        });
      }
      var keyPair = options2.keyPair ? {
        privateKey: forge.pki.privateKeyFromPem(options2.keyPair.privateKey),
        publicKey: forge.pki.publicKeyFromPem(options2.keyPair.publicKey)
      } : forge.pki.rsa.generateKeyPair(keySize);
      return generatePem(keyPair);
    };
    var index2 = _mergeNamespaces2({
      __proto__: null,
      "default": selfsigned,
      generate: generate2
    }, [selfsigned]);
    exports2.index = index2;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s2 = 1e3;
    var m3 = s2 * 60;
    var h3 = m3 * 60;
    var d3 = h3 * 24;
    var w3 = d3 * 7;
    var y3 = d3 * 365.25;
    module2.exports = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options2.long ? fmtLong2(val) : fmtShort2(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match2) {
        return;
      }
      var n3 = parseFloat(match2[1]);
      var type = (match2[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n3 * y3;
        case "weeks":
        case "week":
        case "w":
          return n3 * w3;
        case "days":
        case "day":
        case "d":
          return n3 * d3;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n3 * h3;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n3 * m3;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n3 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n3;
        default:
          return void 0;
      }
    }
    function fmtShort2(ms3) {
      var msAbs = Math.abs(ms3);
      if (msAbs >= d3) {
        return Math.round(ms3 / d3) + "d";
      }
      if (msAbs >= h3) {
        return Math.round(ms3 / h3) + "h";
      }
      if (msAbs >= m3) {
        return Math.round(ms3 / m3) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms3 / s2) + "s";
      }
      return ms3 + "ms";
    }
    function fmtLong2(ms3) {
      var msAbs = Math.abs(ms3);
      if (msAbs >= d3) {
        return plural2(ms3, msAbs, d3, "day");
      }
      if (msAbs >= h3) {
        return plural2(ms3, msAbs, h3, "hour");
      }
      if (msAbs >= m3) {
        return plural2(ms3, msAbs, m3, "minute");
      }
      if (msAbs >= s2) {
        return plural2(ms3, msAbs, s2, "second");
      }
      return ms3 + " ms";
    }
    function plural2(ms3, msAbs, n3, name) {
      var isPlural = msAbs >= n3 * 1.5;
      return Math.round(ms3 / n3) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup2(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(new Date());
          const ms3 = curr - (prevTime || curr);
          self2.diff = ms3;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format2) => {
            if (match2 === "%%") {
              return "%";
            }
            index2++;
            const formatter2 = createDebug.formatters[format2];
            if (typeof formatter2 === "function") {
              const val = args[index2];
              match2 = formatter2.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match2;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend2;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i2;
        const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split2.length;
        for (i2 = 0; i2 < len; i2++) {
          if (!split2[i2]) {
            continue;
          }
          namespaces = split2[i2].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i2;
        let len;
        for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
          if (createDebug.skips[i2].test(name)) {
            return false;
          }
        }
        for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
          if (createDebug.names[i2].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup2;
  }
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned2 = false;
      return () => {
        if (!warned2) {
          warned2 = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match2) => {
        if (match2 === "%%") {
          return;
        }
        index2++;
        if (match2 === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load2() {
      let r2;
      try {
        r2 = exports2.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  }
});

// node_modules/vite/dist/node/chunks/dep-76613303.js
var require_dep_76613303 = __commonJS({
  "node_modules/vite/dist/node/chunks/dep-76613303.js"(exports, module) {
    "use strict";
    var fs$r = (init_fs(), fs_exports);
    var path$t = (init_path(), path_exports);
    var require$$0$4 = (init_os(), os_exports);
    var require$$0$3 = (init_tty(), tty_exports);
    var require$$0$5 = (init_util(), util_exports);
    var require$$3 = (init_net(), net_exports);
    var require$$0$9 = (init_events(), events_exports);
    var require$$0$6 = (init_url(), url_exports);
    var require$$1$3 = (init_http(), http_exports);
    var require$$0$8 = (init_stream(), stream_exports);
    var resolve$3 = require_resolve();
    var require$$1 = (init_module(), module_exports);
    var perf_hooks = (init_perf_hooks(), perf_hooks_exports);
    var require$$1$4 = (init_https(), https_exports);
    var require$$0$7 = (init_zlib(), zlib_exports);
    var require$$1$1 = (init_crypto(), crypto_exports);
    var require$$4 = (init_tls(), tls_exports);
    var require$$5 = (init_assert(), assert_exports);
    var require$$0$a = (init_buffer(), buffer_exports);
    var qs = (init_querystring(), querystring_exports);
    var esbuild = require_main();
    var require$$1$5 = (init_child_process(), child_process_exports);
    var require$$1$2 = (init_worker_threads(), worker_threads_exports);
    var readline = (init_readline(), readline_exports);
    function _interopDefaultLegacy(e2) {
      return e2 && typeof e2 === "object" && "default" in e2 ? e2["default"] : e2;
    }
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n3 = Object.create(null);
      if (e2) {
        for (var k2 in e2) {
          n3[k2] = e2[k2];
        }
      }
      n3["default"] = e2;
      return n3;
    }
    var fs__default = _interopDefaultLegacy(fs$r);
    var fs__namespace = _interopNamespace(fs$r);
    var path__default = _interopDefaultLegacy(path$t);
    var require$$0__default$1 = _interopDefaultLegacy(require$$0$4);
    var require$$0__default = _interopDefaultLegacy(require$$0$3);
    var require$$0__default$2 = _interopDefaultLegacy(require$$0$5);
    var require$$3__default = _interopDefaultLegacy(require$$3);
    var require$$0__default$4 = _interopDefaultLegacy(require$$0$9);
    var require$$0__default$5 = _interopDefaultLegacy(require$$0$6);
    var require$$1__default$2 = _interopDefaultLegacy(require$$1$3);
    var require$$0__default$3 = _interopDefaultLegacy(require$$0$8);
    var resolve__default = _interopDefaultLegacy(resolve$3);
    var require$$1__default = _interopDefaultLegacy(require$$1);
    var require$$1__default$4 = _interopDefaultLegacy(require$$1$4);
    var require$$0__default$6 = _interopDefaultLegacy(require$$0$7);
    var require$$1__default$3 = _interopDefaultLegacy(require$$1$1);
    var require$$4__default = _interopDefaultLegacy(require$$4);
    var require$$5__default = _interopDefaultLegacy(require$$5);
    var require$$0__default$7 = _interopDefaultLegacy(require$$0$a);
    var qs__namespace = _interopNamespace(qs);
    var require$$1__default$5 = _interopDefaultLegacy(require$$1$5);
    var require$$1__default$1 = _interopDefaultLegacy(require$$1$2);
    var readline__default = _interopDefaultLegacy(readline);
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    function getAugmentedNamespace(n3) {
      if (n3.__esModule)
        return n3;
      var a2 = Object.defineProperty({}, "__esModule", { value: true });
      Object.keys(n3).forEach(function(k2) {
        var d3 = Object.getOwnPropertyDescriptor(n3, k2);
        Object.defineProperty(a2, k2, d3.get ? d3 : {
          enumerable: true,
          get: function() {
            return n3[k2];
          }
        });
      });
      return a2;
    }
    function commonjsRequire(path2) {
      throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
    }
    var ansiStyles$1 = { exports: {} };
    var colorName = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
    var cssKeywords = colorName;
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert$1 = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    var conversions$2 = convert$1;
    for (const model of Object.keys(convert$1)) {
      if (!("channels" in convert$1[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert$1[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert$1[model].labels.length !== convert$1[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert$1[model];
      delete convert$1[model].channels;
      delete convert$1[model].labels;
      Object.defineProperty(convert$1[model], "channels", { value: channels });
      Object.defineProperty(convert$1[model], "labels", { value: labels });
    }
    convert$1.rgb.hsl = function(rgb) {
      const r2 = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b2 = rgb[2] / 255;
      const min2 = Math.min(r2, g2, b2);
      const max = Math.max(r2, g2, b2);
      const delta = max - min2;
      let h3;
      let s2;
      if (max === min2) {
        h3 = 0;
      } else if (r2 === max) {
        h3 = (g2 - b2) / delta;
      } else if (g2 === max) {
        h3 = 2 + (b2 - r2) / delta;
      } else if (b2 === max) {
        h3 = 4 + (r2 - g2) / delta;
      }
      h3 = Math.min(h3 * 60, 360);
      if (h3 < 0) {
        h3 += 360;
      }
      const l2 = (min2 + max) / 2;
      if (max === min2) {
        s2 = 0;
      } else if (l2 <= 0.5) {
        s2 = delta / (max + min2);
      } else {
        s2 = delta / (2 - max - min2);
      }
      return [h3, s2 * 100, l2 * 100];
    };
    convert$1.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h3;
      let s2;
      const r2 = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b2 = rgb[2] / 255;
      const v2 = Math.max(r2, g2, b2);
      const diff = v2 - Math.min(r2, g2, b2);
      const diffc = function(c2) {
        return (v2 - c2) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h3 = 0;
        s2 = 0;
      } else {
        s2 = diff / v2;
        rdif = diffc(r2);
        gdif = diffc(g2);
        bdif = diffc(b2);
        if (r2 === v2) {
          h3 = bdif - gdif;
        } else if (g2 === v2) {
          h3 = 1 / 3 + rdif - bdif;
        } else if (b2 === v2) {
          h3 = 2 / 3 + gdif - rdif;
        }
        if (h3 < 0) {
          h3 += 1;
        } else if (h3 > 1) {
          h3 -= 1;
        }
      }
      return [
        h3 * 360,
        s2 * 100,
        v2 * 100
      ];
    };
    convert$1.rgb.hwb = function(rgb) {
      const r2 = rgb[0];
      const g2 = rgb[1];
      let b2 = rgb[2];
      const h3 = convert$1.rgb.hsl(rgb)[0];
      const w3 = 1 / 255 * Math.min(r2, Math.min(g2, b2));
      b2 = 1 - 1 / 255 * Math.max(r2, Math.max(g2, b2));
      return [h3, w3 * 100, b2 * 100];
    };
    convert$1.rgb.cmyk = function(rgb) {
      const r2 = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b2 = rgb[2] / 255;
      const k2 = Math.min(1 - r2, 1 - g2, 1 - b2);
      const c2 = (1 - r2 - k2) / (1 - k2) || 0;
      const m3 = (1 - g2 - k2) / (1 - k2) || 0;
      const y3 = (1 - b2 - k2) / (1 - k2) || 0;
      return [c2 * 100, m3 * 100, y3 * 100, k2 * 100];
    };
    function comparativeDistance(x2, y3) {
      return (x2[0] - y3[0]) ** 2 + (x2[1] - y3[1]) ** 2 + (x2[2] - y3[2]) ** 2;
    }
    convert$1.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert$1.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert$1.rgb.xyz = function(rgb) {
      let r2 = rgb[0] / 255;
      let g2 = rgb[1] / 255;
      let b2 = rgb[2] / 255;
      r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
      g2 = g2 > 0.04045 ? ((g2 + 0.055) / 1.055) ** 2.4 : g2 / 12.92;
      b2 = b2 > 0.04045 ? ((b2 + 0.055) / 1.055) ** 2.4 : b2 / 12.92;
      const x2 = r2 * 0.4124 + g2 * 0.3576 + b2 * 0.1805;
      const y3 = r2 * 0.2126 + g2 * 0.7152 + b2 * 0.0722;
      const z2 = r2 * 0.0193 + g2 * 0.1192 + b2 * 0.9505;
      return [x2 * 100, y3 * 100, z2 * 100];
    };
    convert$1.rgb.lab = function(rgb) {
      const xyz = convert$1.rgb.xyz(rgb);
      let x2 = xyz[0];
      let y3 = xyz[1];
      let z2 = xyz[2];
      x2 /= 95.047;
      y3 /= 100;
      z2 /= 108.883;
      x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
      y3 = y3 > 8856e-6 ? y3 ** (1 / 3) : 7.787 * y3 + 16 / 116;
      z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
      const l2 = 116 * y3 - 16;
      const a2 = 500 * (x2 - y3);
      const b2 = 200 * (y3 - z2);
      return [l2, a2, b2];
    };
    convert$1.hsl.rgb = function(hsl) {
      const h3 = hsl[0] / 360;
      const s2 = hsl[1] / 100;
      const l2 = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s2 === 0) {
        val = l2 * 255;
        return [val, val, val];
      }
      if (l2 < 0.5) {
        t2 = l2 * (1 + s2);
      } else {
        t2 = l2 + s2 - l2 * s2;
      }
      const t1 = 2 * l2 - t2;
      const rgb = [0, 0, 0];
      for (let i2 = 0; i2 < 3; i2++) {
        t3 = h3 + 1 / 3 * -(i2 - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i2] = val * 255;
      }
      return rgb;
    };
    convert$1.hsl.hsv = function(hsl) {
      const h3 = hsl[0];
      let s2 = hsl[1] / 100;
      let l2 = hsl[2] / 100;
      let smin = s2;
      const lmin = Math.max(l2, 0.01);
      l2 *= 2;
      s2 *= l2 <= 1 ? l2 : 2 - l2;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v2 = (l2 + s2) / 2;
      const sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l2 + s2);
      return [h3, sv * 100, v2 * 100];
    };
    convert$1.hsv.rgb = function(hsv) {
      const h3 = hsv[0] / 60;
      const s2 = hsv[1] / 100;
      let v2 = hsv[2] / 100;
      const hi2 = Math.floor(h3) % 6;
      const f2 = h3 - Math.floor(h3);
      const p2 = 255 * v2 * (1 - s2);
      const q2 = 255 * v2 * (1 - s2 * f2);
      const t = 255 * v2 * (1 - s2 * (1 - f2));
      v2 *= 255;
      switch (hi2) {
        case 0:
          return [v2, t, p2];
        case 1:
          return [q2, v2, p2];
        case 2:
          return [p2, v2, t];
        case 3:
          return [p2, q2, v2];
        case 4:
          return [t, p2, v2];
        case 5:
          return [v2, p2, q2];
      }
    };
    convert$1.hsv.hsl = function(hsv) {
      const h3 = hsv[0];
      const s2 = hsv[1] / 100;
      const v2 = hsv[2] / 100;
      const vmin = Math.max(v2, 0.01);
      let sl;
      let l2;
      l2 = (2 - s2) * v2;
      const lmin = (2 - s2) * vmin;
      sl = s2 * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l2 /= 2;
      return [h3, sl * 100, l2 * 100];
    };
    convert$1.hwb.rgb = function(hwb) {
      const h3 = hwb[0] / 360;
      let wh2 = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh2 + bl;
      let f2;
      if (ratio > 1) {
        wh2 /= ratio;
        bl /= ratio;
      }
      const i2 = Math.floor(6 * h3);
      const v2 = 1 - bl;
      f2 = 6 * h3 - i2;
      if ((i2 & 1) !== 0) {
        f2 = 1 - f2;
      }
      const n3 = wh2 + f2 * (v2 - wh2);
      let r2;
      let g2;
      let b2;
      switch (i2) {
        default:
        case 6:
        case 0:
          r2 = v2;
          g2 = n3;
          b2 = wh2;
          break;
        case 1:
          r2 = n3;
          g2 = v2;
          b2 = wh2;
          break;
        case 2:
          r2 = wh2;
          g2 = v2;
          b2 = n3;
          break;
        case 3:
          r2 = wh2;
          g2 = n3;
          b2 = v2;
          break;
        case 4:
          r2 = n3;
          g2 = wh2;
          b2 = v2;
          break;
        case 5:
          r2 = v2;
          g2 = wh2;
          b2 = n3;
          break;
      }
      return [r2 * 255, g2 * 255, b2 * 255];
    };
    convert$1.cmyk.rgb = function(cmyk) {
      const c2 = cmyk[0] / 100;
      const m3 = cmyk[1] / 100;
      const y3 = cmyk[2] / 100;
      const k2 = cmyk[3] / 100;
      const r2 = 1 - Math.min(1, c2 * (1 - k2) + k2);
      const g2 = 1 - Math.min(1, m3 * (1 - k2) + k2);
      const b2 = 1 - Math.min(1, y3 * (1 - k2) + k2);
      return [r2 * 255, g2 * 255, b2 * 255];
    };
    convert$1.xyz.rgb = function(xyz) {
      const x2 = xyz[0] / 100;
      const y3 = xyz[1] / 100;
      const z2 = xyz[2] / 100;
      let r2;
      let g2;
      let b2;
      r2 = x2 * 3.2406 + y3 * -1.5372 + z2 * -0.4986;
      g2 = x2 * -0.9689 + y3 * 1.8758 + z2 * 0.0415;
      b2 = x2 * 0.0557 + y3 * -0.204 + z2 * 1.057;
      r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : r2 * 12.92;
      g2 = g2 > 31308e-7 ? 1.055 * g2 ** (1 / 2.4) - 0.055 : g2 * 12.92;
      b2 = b2 > 31308e-7 ? 1.055 * b2 ** (1 / 2.4) - 0.055 : b2 * 12.92;
      r2 = Math.min(Math.max(0, r2), 1);
      g2 = Math.min(Math.max(0, g2), 1);
      b2 = Math.min(Math.max(0, b2), 1);
      return [r2 * 255, g2 * 255, b2 * 255];
    };
    convert$1.xyz.lab = function(xyz) {
      let x2 = xyz[0];
      let y3 = xyz[1];
      let z2 = xyz[2];
      x2 /= 95.047;
      y3 /= 100;
      z2 /= 108.883;
      x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
      y3 = y3 > 8856e-6 ? y3 ** (1 / 3) : 7.787 * y3 + 16 / 116;
      z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
      const l2 = 116 * y3 - 16;
      const a2 = 500 * (x2 - y3);
      const b2 = 200 * (y3 - z2);
      return [l2, a2, b2];
    };
    convert$1.lab.xyz = function(lab) {
      const l2 = lab[0];
      const a2 = lab[1];
      const b2 = lab[2];
      let x2;
      let y3;
      let z2;
      y3 = (l2 + 16) / 116;
      x2 = a2 / 500 + y3;
      z2 = y3 - b2 / 200;
      const y22 = y3 ** 3;
      const x22 = x2 ** 3;
      const z22 = z2 ** 3;
      y3 = y22 > 8856e-6 ? y22 : (y3 - 16 / 116) / 7.787;
      x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
      z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
      x2 *= 95.047;
      y3 *= 100;
      z2 *= 108.883;
      return [x2, y3, z2];
    };
    convert$1.lab.lch = function(lab) {
      const l2 = lab[0];
      const a2 = lab[1];
      const b2 = lab[2];
      let h3;
      const hr2 = Math.atan2(b2, a2);
      h3 = hr2 * 360 / 2 / Math.PI;
      if (h3 < 0) {
        h3 += 360;
      }
      const c2 = Math.sqrt(a2 * a2 + b2 * b2);
      return [l2, c2, h3];
    };
    convert$1.lch.lab = function(lch) {
      const l2 = lch[0];
      const c2 = lch[1];
      const h3 = lch[2];
      const hr2 = h3 / 360 * 2 * Math.PI;
      const a2 = c2 * Math.cos(hr2);
      const b2 = c2 * Math.sin(hr2);
      return [l2, a2, b2];
    };
    convert$1.rgb.ansi16 = function(args, saturation = null) {
      const [r2, g2, b2] = args;
      let value = saturation === null ? convert$1.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b2 / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r2 / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert$1.hsv.ansi16 = function(args) {
      return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
    };
    convert$1.rgb.ansi256 = function(args) {
      const r2 = args[0];
      const g2 = args[1];
      const b2 = args[2];
      if (r2 === g2 && g2 === b2) {
        if (r2 < 8) {
          return 16;
        }
        if (r2 > 248) {
          return 231;
        }
        return Math.round((r2 - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b2 / 255 * 5);
      return ansi;
    };
    convert$1.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r2 = (color & 1) * mult * 255;
      const g2 = (color >> 1 & 1) * mult * 255;
      const b2 = (color >> 2 & 1) * mult * 255;
      return [r2, g2, b2];
    };
    convert$1.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c2 = (args - 232) * 10 + 8;
        return [c2, c2, c2];
      }
      args -= 16;
      let rem;
      const r2 = Math.floor(args / 36) / 5 * 255;
      const g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b2 = rem % 6 / 5 * 255;
      return [r2, g2, b2];
    };
    convert$1.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string2 = integer.toString(16).toUpperCase();
      return "000000".substring(string2.length) + string2;
    };
    convert$1.hex.rgb = function(args) {
      const match2 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match2) {
        return [0, 0, 0];
      }
      let colorString = match2[0];
      if (match2[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r2 = integer >> 16 & 255;
      const g2 = integer >> 8 & 255;
      const b2 = integer & 255;
      return [r2, g2, b2];
    };
    convert$1.rgb.hcg = function(rgb) {
      const r2 = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b2 = rgb[2] / 255;
      const max = Math.max(Math.max(r2, g2), b2);
      const min2 = Math.min(Math.min(r2, g2), b2);
      const chroma = max - min2;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min2 / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r2) {
        hue = (g2 - b2) / chroma % 6;
      } else if (max === g2) {
        hue = 2 + (b2 - r2) / chroma;
      } else {
        hue = 4 + (r2 - g2) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert$1.hsl.hcg = function(hsl) {
      const s2 = hsl[1] / 100;
      const l2 = hsl[2] / 100;
      const c2 = l2 < 0.5 ? 2 * s2 * l2 : 2 * s2 * (1 - l2);
      let f2 = 0;
      if (c2 < 1) {
        f2 = (l2 - 0.5 * c2) / (1 - c2);
      }
      return [hsl[0], c2 * 100, f2 * 100];
    };
    convert$1.hsv.hcg = function(hsv) {
      const s2 = hsv[1] / 100;
      const v2 = hsv[2] / 100;
      const c2 = s2 * v2;
      let f2 = 0;
      if (c2 < 1) {
        f2 = (v2 - c2) / (1 - c2);
      }
      return [hsv[0], c2 * 100, f2 * 100];
    };
    convert$1.hcg.rgb = function(hcg) {
      const h3 = hcg[0] / 360;
      const c2 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      if (c2 === 0) {
        return [g2 * 255, g2 * 255, g2 * 255];
      }
      const pure = [0, 0, 0];
      const hi2 = h3 % 1 * 6;
      const v2 = hi2 % 1;
      const w3 = 1 - v2;
      let mg = 0;
      switch (Math.floor(hi2)) {
        case 0:
          pure[0] = 1;
          pure[1] = v2;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w3;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v2;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w3;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v2;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w3;
      }
      mg = (1 - c2) * g2;
      return [
        (c2 * pure[0] + mg) * 255,
        (c2 * pure[1] + mg) * 255,
        (c2 * pure[2] + mg) * 255
      ];
    };
    convert$1.hcg.hsv = function(hcg) {
      const c2 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const v2 = c2 + g2 * (1 - c2);
      let f2 = 0;
      if (v2 > 0) {
        f2 = c2 / v2;
      }
      return [hcg[0], f2 * 100, v2 * 100];
    };
    convert$1.hcg.hsl = function(hcg) {
      const c2 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const l2 = g2 * (1 - c2) + 0.5 * c2;
      let s2 = 0;
      if (l2 > 0 && l2 < 0.5) {
        s2 = c2 / (2 * l2);
      } else if (l2 >= 0.5 && l2 < 1) {
        s2 = c2 / (2 * (1 - l2));
      }
      return [hcg[0], s2 * 100, l2 * 100];
    };
    convert$1.hcg.hwb = function(hcg) {
      const c2 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const v2 = c2 + g2 * (1 - c2);
      return [hcg[0], (v2 - c2) * 100, (1 - v2) * 100];
    };
    convert$1.hwb.hcg = function(hwb) {
      const w3 = hwb[1] / 100;
      const b2 = hwb[2] / 100;
      const v2 = 1 - b2;
      const c2 = v2 - w3;
      let g2 = 0;
      if (c2 < 1) {
        g2 = (v2 - c2) / (1 - c2);
      }
      return [hwb[0], c2 * 100, g2 * 100];
    };
    convert$1.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert$1.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert$1.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert$1.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert$1.gray.hsv = convert$1.gray.hsl;
    convert$1.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert$1.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert$1.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert$1.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string2 = integer.toString(16).toUpperCase();
      return "000000".substring(string2.length) + string2;
    };
    convert$1.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
    var conversions$1 = conversions$2;
    function buildGraph() {
      const graph = {};
      const models2 = Object.keys(conversions$1);
      for (let len = models2.length, i2 = 0; i2 < len; i2++) {
        graph[models2[i2]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue2 = [fromModel];
      graph[fromModel].distance = 0;
      while (queue2.length) {
        const current = queue2.pop();
        const adjacents = Object.keys(conversions$1[current]);
        for (let len = adjacents.length, i2 = 0; i2 < len; i2++) {
          const adjacent = adjacents[i2];
          const node2 = graph[adjacent];
          if (node2.distance === -1) {
            node2.distance = graph[current].distance + 1;
            node2.parent = current;
            queue2.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to2) {
      return function(args) {
        return to2(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path2 = [graph[toModel].parent, toModel];
      let fn2 = conversions$1[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path2.unshift(graph[cur].parent);
        fn2 = link(conversions$1[graph[cur].parent][cur], fn2);
        cur = graph[cur].parent;
      }
      fn2.conversion = path2;
      return fn2;
    }
    var route$1 = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models2 = Object.keys(graph);
      for (let len = models2.length, i2 = 0; i2 < len; i2++) {
        const toModel = models2[i2];
        const node2 = graph[toModel];
        if (node2.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
    var conversions = conversions$2;
    var route = route$1;
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn2) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn2(args);
      };
      if ("conversion" in fn2) {
        wrappedFn.conversion = fn2.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn2) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result2 = fn2(args);
        if (typeof result2 === "object") {
          for (let len = result2.length, i2 = 0; i2 < len; i2++) {
            result2[i2] = Math.round(result2[i2]);
          }
        }
        return result2;
      };
      if ("conversion" in fn2) {
        wrappedFn.conversion = fn2.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn2 = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn2);
        convert[fromModel][toModel].raw = wrapRaw(fn2);
      });
    });
    var colorConvert = convert;
    (function(module2) {
      const wrapAnsi16 = (fn2, offset2) => (...args) => {
        const code = fn2(...args);
        return `[${code + offset2}m`;
      };
      const wrapAnsi256 = (fn2, offset2) => (...args) => {
        const code = fn2(...args);
        return `[${38 + offset2};5;${code}m`;
      };
      const wrapAnsi16m = (fn2, offset2) => (...args) => {
        const rgb = fn2(...args);
        return `[${38 + offset2};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
      };
      const ansi2ansi = (n3) => n3;
      const rgb2rgb = (r2, g2, b2) => [r2, g2, b2];
      const setLazyProperty = (object, property, get) => {
        Object.defineProperty(object, property, {
          get: () => {
            const value = get();
            Object.defineProperty(object, property, {
              value,
              enumerable: true,
              configurable: true
            });
            return value;
          },
          enumerable: true,
          configurable: true
        });
      };
      let colorConvert$1;
      const makeDynamicStyles = (wrap2, targetSpace, identity, isBackground) => {
        if (colorConvert$1 === void 0) {
          colorConvert$1 = colorConvert;
        }
        const offset2 = isBackground ? 10 : 0;
        const styles2 = {};
        for (const [sourceSpace, suite] of Object.entries(colorConvert$1)) {
          const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
          if (sourceSpace === targetSpace) {
            styles2[name] = wrap2(identity, offset2);
          } else if (typeof suite === "object") {
            styles2[name] = wrap2(suite[targetSpace], offset2);
          }
        }
        return styles2;
      };
      function assembleStyles() {
        const codes2 = new Map();
        const styles2 = {
          modifier: {
            reset: [0, 0],
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29]
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            blackBright: [90, 39],
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39]
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49]
          }
        };
        styles2.color.gray = styles2.color.blackBright;
        styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;
        styles2.color.grey = styles2.color.blackBright;
        styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;
        for (const [groupName, group] of Object.entries(styles2)) {
          for (const [styleName, style] of Object.entries(group)) {
            styles2[styleName] = {
              open: `[${style[0]}m`,
              close: `[${style[1]}m`
            };
            group[styleName] = styles2[styleName];
            codes2.set(style[0], style[1]);
          }
          Object.defineProperty(styles2, groupName, {
            value: group,
            enumerable: false
          });
        }
        Object.defineProperty(styles2, "codes", {
          value: codes2,
          enumerable: false
        });
        styles2.color.close = "[39m";
        styles2.bgColor.close = "[49m";
        setLazyProperty(styles2.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
        setLazyProperty(styles2.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
        setLazyProperty(styles2.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
        setLazyProperty(styles2.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
        setLazyProperty(styles2.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
        setLazyProperty(styles2.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
        return styles2;
      }
      Object.defineProperty(module2, "exports", {
        enumerable: true,
        get: assembleStyles
      });
    })(ansiStyles$1);
    var hasFlag$1 = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
    var os$4 = require$$0__default$1;
    var tty$1 = require$$0__default;
    var hasFlag = hasFlag$1;
    var { env: env$1 } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env$1) {
      if (env$1.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env$1.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env$1.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env$1.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min2 = forceColor || 0;
      if (env$1.TERM === "dumb") {
        return min2;
      }
      if (process.platform === "win32") {
        const osRelease = os$4.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env$1) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env$1) || env$1.CI_NAME === "codeship") {
          return 1;
        }
        return min2;
      }
      if ("TEAMCITY_VERSION" in env$1) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env$1.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env$1.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env$1) {
        const version2 = parseInt((env$1.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env$1.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env$1.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env$1.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env$1) {
        return 1;
      }
      return min2;
    }
    function getSupportLevel(stream2) {
      const level = supportsColor(stream2, stream2 && stream2.isTTY);
      return translateLevel(level);
    }
    var supportsColor_1 = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty$1.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty$1.isatty(2)))
    };
    var stringReplaceAll$1 = (string2, substring, replacer) => {
      let index2 = string2.indexOf(substring);
      if (index2 === -1) {
        return string2;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string2.substr(endIndex, index2 - endIndex) + substring + replacer;
        endIndex = index2 + substringLength;
        index2 = string2.indexOf(substring, endIndex);
      } while (index2 !== -1);
      returnValue += string2.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex$1 = (string2, prefix, postfix, index2) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string2[index2 - 1] === "\r";
        returnValue += string2.substr(endIndex, (gotCR ? index2 - 1 : index2) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index2 + 1;
        index2 = string2.indexOf("\n", endIndex);
      } while (index2 !== -1);
      returnValue += string2.substr(endIndex);
      return returnValue;
    };
    var util$9 = {
      stringReplaceAll: stringReplaceAll$1,
      stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex$1
    };
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", ""],
      ["a", "\x07"]
    ]);
    function unescape$1(c2) {
      const u2 = c2[0] === "u";
      const bracket = c2[1] === "{";
      if (u2 && !bracket && c2.length === 5 || c2[0] === "x" && c2.length === 3) {
        return String.fromCharCode(parseInt(c2.slice(1), 16));
      }
      if (u2 && bracket) {
        return String.fromCodePoint(parseInt(c2.slice(2, -1), 16));
      }
      return ESCAPES.get(c2) || c2;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches2;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches2 = chunk.match(STRING_REGEX)) {
          results.push(matches2[2].replace(ESCAPE_REGEX, (m3, escape2, character) => escape2 ? unescape$1(escape2) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches2;
      while ((matches2 = STYLE_REGEX.exec(style)) !== null) {
        const name = matches2[1];
        if (matches2[2]) {
          const args = parseArguments(name, matches2[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk2, styles2) {
      const enabled = {};
      for (const layer of styles2) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk2;
      for (const [styleName, styles3] of Object.entries(enabled)) {
        if (!Array.isArray(styles3)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles3.length > 0 ? current[styleName](...styles3) : current[styleName];
      }
      return current;
    }
    var templates = (chalk2, temporary) => {
      const styles2 = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m3, escapeCharacter, inverse, style, close2, character) => {
        if (escapeCharacter) {
          chunk.push(unescape$1(escapeCharacter));
        } else if (style) {
          const string2 = chunk.join("");
          chunk = [];
          chunks.push(styles2.length === 0 ? string2 : buildStyle(chalk2, styles2)(string2));
          styles2.push({ inverse, styles: parseStyle(style) });
        } else if (close2) {
          if (styles2.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk2, styles2)(chunk.join("")));
          chunk = [];
          styles2.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles2.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles2.length} closing bracket${styles2.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
    var ansiStyles = ansiStyles$1.exports;
    var { stdout: stdoutColor, stderr: stderrColor } = supportsColor_1;
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = util$9;
    var { isArray: isArray$4 } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = Object.create(null);
    var applyOptions = (object, options2 = {}) => {
      if (options2.level && !(Number.isInteger(options2.level) && options2.level >= 0 && options2.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options2.level === void 0 ? colorLevel : options2.level;
    };
    var ChalkClass = class {
      constructor(options2) {
        return chalkFactory(options2);
      }
    };
    var chalkFactory = (options2) => {
      const chalk2 = {};
      applyOptions(chalk2, options2);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options2) {
      return chalkFactory(options2);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto$1 = Object.defineProperties(() => {
    }, __spreadProps2(__spreadValues2({}, styles), {
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    }));
    var createStyler = (open2, close2, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open2;
        closeAll = close2;
      } else {
        openAll = parent.openAll + open2;
        closeAll = close2 + parent.closeAll;
      }
      return {
        open: open2,
        close: close2,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray$4(arguments_[0]) && isArray$4(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto$1);
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self2, string2) => {
      if (self2.level <= 0 || !string2) {
        return self2._isEmpty ? "" : string2;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string2;
      }
      const { openAll, closeAll } = styler;
      if (string2.indexOf("") !== -1) {
        while (styler !== void 0) {
          string2 = stringReplaceAll(string2, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string2.indexOf("\n");
      if (lfIndex !== -1) {
        string2 = stringEncaseCRLFWithFirstIndex(string2, closeAll, openAll, lfIndex);
      }
      return openAll + string2 + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray$4(firstString) || !isArray$4(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i2 = 1; i2 < firstString.length; i2++) {
        parts.push(String(arguments_[i2 - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i2]));
      }
      if (template === void 0) {
        template = templates;
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    var source = chalk;
    var src$2 = { exports: {} };
    var browser$1 = { exports: {} };
    var s$1 = 1e3;
    var m$1 = s$1 * 60;
    var h$1 = m$1 * 60;
    var d$1 = h$1 * 24;
    var w = d$1 * 7;
    var y$1 = d$1 * 365.25;
    var ms$1 = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse$m(val);
      } else if (type === "number" && isFinite(val)) {
        return options2.long ? fmtLong$1(val) : fmtShort$1(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse$m(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match2) {
        return;
      }
      var n3 = parseFloat(match2[1]);
      var type = (match2[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n3 * y$1;
        case "weeks":
        case "week":
        case "w":
          return n3 * w;
        case "days":
        case "day":
        case "d":
          return n3 * d$1;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n3 * h$1;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n3 * m$1;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n3 * s$1;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n3;
        default:
          return void 0;
      }
    }
    function fmtShort$1(ms3) {
      var msAbs = Math.abs(ms3);
      if (msAbs >= d$1) {
        return Math.round(ms3 / d$1) + "d";
      }
      if (msAbs >= h$1) {
        return Math.round(ms3 / h$1) + "h";
      }
      if (msAbs >= m$1) {
        return Math.round(ms3 / m$1) + "m";
      }
      if (msAbs >= s$1) {
        return Math.round(ms3 / s$1) + "s";
      }
      return ms3 + "ms";
    }
    function fmtLong$1(ms3) {
      var msAbs = Math.abs(ms3);
      if (msAbs >= d$1) {
        return plural$1(ms3, msAbs, d$1, "day");
      }
      if (msAbs >= h$1) {
        return plural$1(ms3, msAbs, h$1, "hour");
      }
      if (msAbs >= m$1) {
        return plural$1(ms3, msAbs, m$1, "minute");
      }
      if (msAbs >= s$1) {
        return plural$1(ms3, msAbs, s$1, "second");
      }
      return ms3 + " ms";
    }
    function plural$1(ms3, msAbs, n3, name) {
      var isPlural = msAbs >= n3 * 1.5;
      return Math.round(ms3 / n3) + " " + name + (isPlural ? "s" : "");
    }
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = ms$1;
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(new Date());
          const ms3 = curr - (prevTime || curr);
          self2.diff = ms3;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format2) => {
            if (match2 === "%%") {
              return "%";
            }
            index2++;
            const formatter2 = createDebug.formatters[format2];
            if (typeof formatter2 === "function") {
              const val = args[index2];
              match2 = formatter2.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match2;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend2;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i2;
        const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split2.length;
        for (i2 = 0; i2 < len; i2++) {
          if (!split2[i2]) {
            continue;
          }
          namespaces = split2[i2].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i2;
        let len;
        for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
          if (createDebug.skips[i2].test(name)) {
            return false;
          }
        }
        for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
          if (createDebug.names[i2].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    var common$e = setup;
    (function(module2, exports2) {
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load2;
      exports2.useColors = useColors;
      exports2.storage = localstorage();
      exports2.destroy = (() => {
        let warned2 = false;
        return () => {
          if (!warned2) {
            warned2 = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports2.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c2 = "color: " + this.color;
        args.splice(1, 0, c2, "color: inherit");
        let index2 = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match2) => {
          if (match2 === "%%") {
            return;
          }
          index2++;
          if (match2 === "%c") {
            lastC = index2;
          }
        });
        args.splice(lastC, 0, c2);
      }
      exports2.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports2.storage.setItem("debug", namespaces);
          } else {
            exports2.storage.removeItem("debug");
          }
        } catch (error2) {
        }
      }
      function load2() {
        let r2;
        try {
          r2 = exports2.storage.getItem("debug");
        } catch (error2) {
        }
        if (!r2 && typeof process !== "undefined" && "env" in process) {
          r2 = process.env.DEBUG;
        }
        return r2;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error2) {
        }
      }
      module2.exports = common$e(exports2);
      const { formatters } = module2.exports;
      formatters.j = function(v2) {
        try {
          return JSON.stringify(v2);
        } catch (error2) {
          return "[UnexpectedJSONParseError]: " + error2.message;
        }
      };
    })(browser$1, browser$1.exports);
    var node$1 = { exports: {} };
    (function(module2, exports2) {
      const tty2 = require$$0__default;
      const util2 = require$$0__default$2;
      exports2.init = init2;
      exports2.log = log2;
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load2;
      exports2.useColors = useColors;
      exports2.destroy = util2.deprecate(() => {
      }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      exports2.colors = [6, 2, 3, 4, 5, 1];
      try {
        const supportsColor2 = require_browser();
        if (supportsColor2 && (supportsColor2.stderr || supportsColor2).level >= 2) {
          exports2.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
          ];
        }
      } catch (error2) {
      }
      exports2.inspectOpts = Object.keys(process.env).filter((key) => {
        return /^debug_/i.test(key);
      }).reduce((obj, key) => {
        const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k2) => {
          return k2.toUpperCase();
        });
        let val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val)) {
          val = true;
        } else if (/^(no|off|false|disabled)$/i.test(val)) {
          val = false;
        } else if (val === "null") {
          val = null;
        } else {
          val = Number(val);
        }
        obj[prop] = val;
        return obj;
      }, {});
      function useColors() {
        return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty2.isatty(process.stderr.fd);
      }
      function formatArgs(args) {
        const { namespace: name, useColors: useColors2 } = this;
        if (useColors2) {
          const c2 = this.color;
          const colorCode = "[3" + (c2 < 8 ? c2 : "8;5;" + c2);
          const prefix = `  ${colorCode};1m${name} [0m`;
          args[0] = prefix + args[0].split("\n").join("\n" + prefix);
          args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
        } else {
          args[0] = getDate() + name + " " + args[0];
        }
      }
      function getDate() {
        if (exports2.inspectOpts.hideDate) {
          return "";
        }
        return new Date().toISOString() + " ";
      }
      function log2(...args) {
        return process.stderr.write(util2.format(...args) + "\n");
      }
      function save(namespaces) {
        if (namespaces) {
          process.env.DEBUG = namespaces;
        } else {
          delete process.env.DEBUG;
        }
      }
      function load2() {
        return process.env.DEBUG;
      }
      function init2(debug2) {
        debug2.inspectOpts = {};
        const keys = Object.keys(exports2.inspectOpts);
        for (let i2 = 0; i2 < keys.length; i2++) {
          debug2.inspectOpts[keys[i2]] = exports2.inspectOpts[keys[i2]];
        }
      }
      module2.exports = common$e(exports2);
      const { formatters } = module2.exports;
      formatters.o = function(v2) {
        this.inspectOpts.colors = this.useColors;
        return util2.inspect(v2, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
      };
      formatters.O = function(v2) {
        this.inspectOpts.colors = this.useColors;
        return util2.inspect(v2, this.inspectOpts);
      };
    })(node$1, node$1.exports);
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      src$2.exports = browser$1.exports;
    } else {
      src$2.exports = node$1.exports;
    }
    var debug$g = src$2.exports;
    var DEFAULT_MAIN_FIELDS = [
      "module",
      "jsnext:main",
      "jsnext"
    ];
    var DEFAULT_EXTENSIONS$1 = [
      ".mjs",
      ".js",
      ".ts",
      ".jsx",
      ".tsx",
      ".json"
    ];
    var JS_TYPES_RE = /\.(?:j|t)sx?$|\.mjs$/;
    var OPTIMIZABLE_ENTRY_RE = /\.(?:m?js|ts)$/;
    var SPECIAL_QUERY_RE = /[\?&](?:worker|sharedworker|raw|url)\b/;
    var FS_PREFIX = `/@fs/`;
    var VALID_ID_PREFIX = `/@id/`;
    var NULL_BYTE_PLACEHOLDER = `__x00__`;
    var CLIENT_PUBLIC_PATH = `/@vite/client`;
    var ENV_PUBLIC_PATH = `/@vite/env`;
    var CLIENT_ENTRY = __require.resolve("vite/dist/client/client.mjs");
    var ENV_ENTRY = __require.resolve("vite/dist/client/env.mjs");
    var CLIENT_DIR = path__default.dirname(CLIENT_ENTRY);
    var KNOWN_ASSET_TYPES = [
      "png",
      "jpe?g",
      "gif",
      "svg",
      "ico",
      "webp",
      "avif",
      "mp4",
      "webm",
      "ogg",
      "mp3",
      "wav",
      "flac",
      "aac",
      "woff2?",
      "eot",
      "ttf",
      "otf",
      "wasm",
      "webmanifest",
      "pdf"
    ];
    var DEFAULT_ASSETS_RE = new RegExp(`\\.(` + KNOWN_ASSET_TYPES.join("|") + `)(\\?.*)?$`);
    var DEP_VERSION_RE = /[\?&](v=[\w\.-]+)\b/;
    var charToInteger$1 = {};
    var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    for (i$3 = 0; i$3 < chars$2.length; i$3++) {
      charToInteger$1[chars$2.charCodeAt(i$3)] = i$3;
    }
    var i$3;
    function decode(mappings) {
      var decoded = [];
      var line = [];
      var segment = [
        0,
        0,
        0,
        0,
        0
      ];
      var j2 = 0;
      for (var i2 = 0, shift = 0, value = 0; i2 < mappings.length; i2++) {
        var c2 = mappings.charCodeAt(i2);
        if (c2 === 44) {
          segmentify(line, segment, j2);
          j2 = 0;
        } else if (c2 === 59) {
          segmentify(line, segment, j2);
          j2 = 0;
          decoded.push(line);
          line = [];
          segment[0] = 0;
        } else {
          var integer = charToInteger$1[c2];
          if (integer === void 0) {
            throw new Error("Invalid character (" + String.fromCharCode(c2) + ")");
          }
          var hasContinuationBit = integer & 32;
          integer &= 31;
          value += integer << shift;
          if (hasContinuationBit) {
            shift += 5;
          } else {
            var shouldNegate = value & 1;
            value >>>= 1;
            if (shouldNegate) {
              value = value === 0 ? -2147483648 : -value;
            }
            segment[j2] += value;
            j2++;
            value = shift = 0;
          }
        }
      }
      segmentify(line, segment, j2);
      decoded.push(line);
      return decoded;
    }
    function segmentify(line, segment, j2) {
      if (j2 === 4)
        line.push([segment[0], segment[1], segment[2], segment[3]]);
      else if (j2 === 5)
        line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);
      else if (j2 === 1)
        line.push([segment[0]]);
    }
    function encode$1(decoded) {
      var sourceFileIndex = 0;
      var sourceCodeLine = 0;
      var sourceCodeColumn = 0;
      var nameIndex = 0;
      var mappings = "";
      for (var i2 = 0; i2 < decoded.length; i2++) {
        var line = decoded[i2];
        if (i2 > 0)
          mappings += ";";
        if (line.length === 0)
          continue;
        var generatedCodeColumn = 0;
        var lineMappings = [];
        for (var _i2 = 0, line_1 = line; _i2 < line_1.length; _i2++) {
          var segment = line_1[_i2];
          var segmentMappings = encodeInteger$1(segment[0] - generatedCodeColumn);
          generatedCodeColumn = segment[0];
          if (segment.length > 1) {
            segmentMappings += encodeInteger$1(segment[1] - sourceFileIndex) + encodeInteger$1(segment[2] - sourceCodeLine) + encodeInteger$1(segment[3] - sourceCodeColumn);
            sourceFileIndex = segment[1];
            sourceCodeLine = segment[2];
            sourceCodeColumn = segment[3];
          }
          if (segment.length === 5) {
            segmentMappings += encodeInteger$1(segment[4] - nameIndex);
            nameIndex = segment[4];
          }
          lineMappings.push(segmentMappings);
        }
        mappings += lineMappings.join(",");
      }
      return mappings;
    }
    function encodeInteger$1(num) {
      var result2 = "";
      num = num < 0 ? -num << 1 | 1 : num << 1;
      do {
        var clamped = num & 31;
        num >>>= 5;
        if (num > 0) {
          clamped |= 32;
        }
        result2 += chars$2[clamped];
      } while (num > 0);
      return result2;
    }
    function defaults(target, source2) {
      return Object.assign(Object.create(null), source2, target);
    }
    function decodeSourceMap(map2) {
      if (typeof map2 === "string") {
        map2 = JSON.parse(map2);
      }
      let { mappings } = map2;
      if (typeof mappings === "string") {
        mappings = sortMappings(decode(mappings), true);
      } else {
        mappings = sortMappings(mappings, false);
      }
      return defaults({ mappings }, map2);
    }
    function firstUnsortedSegmentLine(mappings) {
      for (let i2 = 0; i2 < mappings.length; i2++) {
        const segments = mappings[i2];
        for (let j2 = 1; j2 < segments.length; j2++) {
          if (segments[j2][0] < segments[j2 - 1][0]) {
            return i2;
          }
        }
      }
      return mappings.length;
    }
    function sortMappings(mappings, owned) {
      const unosrtedIndex = firstUnsortedSegmentLine(mappings);
      if (unosrtedIndex === mappings.length)
        return mappings;
      if (!owned)
        mappings = mappings.slice();
      for (let i2 = unosrtedIndex; i2 < mappings.length; i2++) {
        mappings[i2] = sortSegments(mappings[i2], owned);
      }
      return mappings;
    }
    function sortSegments(segments, owned) {
      if (!owned)
        segments = segments.slice();
      return segments.sort(segmentComparator);
    }
    function segmentComparator(a2, b2) {
      return a2[0] - b2[0];
    }
    var OriginalSource = class {
      constructor(filename2, content2) {
        this.filename = filename2;
        this.content = content2;
      }
      traceSegment(line, column, name) {
        return { column, line, name, source: this };
      }
    };
    var Url$1 = typeof URL !== "undefined" ? URL : (init_url(), url_exports).URL;
    var parentRegex = /(^|\/)\.\.(?=\/|$)/g;
    function isAbsoluteUrl(url2) {
      try {
        return !!new Url$1(url2);
      } catch (e2) {
        return false;
      }
    }
    function uniqInStr(str) {
      let uniq = String(Math.random()).slice(2);
      while (str.indexOf(uniq) > -1) {
        uniq += uniq;
      }
      return uniq;
    }
    function stripPathFilename(path2) {
      path2 = normalizePath$5(path2);
      const index2 = path2.lastIndexOf("/");
      return path2.slice(0, index2 + 1);
    }
    function normalizeProtocolRelative(input, absoluteBase) {
      const { href, protocol } = new Url$1(input, absoluteBase);
      return href.slice(protocol.length);
    }
    function normalizeSimplePath(input) {
      const { href } = new Url$1(input, "https://foo.com/");
      return href.slice("https://foo.com/".length);
    }
    function normalizePath$5(input) {
      if (!parentRegex.test(input))
        return normalizeSimplePath(input);
      let total = 1;
      while (parentRegex.test(input))
        total++;
      const uniqDirectory = `z${uniqInStr(input)}/`;
      const search = new RegExp(`^(?:${uniqDirectory})*`);
      const relative = normalizeSimplePath(uniqDirectory.repeat(total) + input);
      return relative.replace(search, (all) => {
        const leftover = all.length / uniqDirectory.length;
        return "../".repeat(total - leftover);
      });
    }
    function resolve$2(input, base2) {
      if (!base2)
        base2 = "";
      if (isAbsoluteUrl(input))
        return new Url$1(input).href;
      if (base2) {
        if (isAbsoluteUrl(base2))
          return new Url$1(input, base2).href;
        if (base2.startsWith("//"))
          return normalizeProtocolRelative(input, `https:${base2}`);
      }
      if (input.startsWith("//"))
        return normalizeProtocolRelative(input, "https://foo.com/");
      if (input.startsWith("/"))
        return "/" + normalizeSimplePath(input);
      const joined = stripPathFilename(base2) + input;
      if (base2.startsWith("/"))
        return "/" + normalizeSimplePath(joined);
      const relative = normalizePath$5(joined);
      if ((base2 || input).startsWith(".") && !relative.startsWith(".")) {
        return "./" + relative;
      }
      return relative;
    }
    function resolve$1$1(input, base2) {
      if (base2 && !base2.endsWith("/"))
        base2 += "/";
      return resolve$2(input, base2);
    }
    function binarySearch$2(haystack, needle, comparator, low, high) {
      low = Math.max(low, 0);
      while (low <= high) {
        const mid = low + (high - low >> 1);
        const cmp = comparator(haystack[mid], needle);
        if (cmp === 0) {
          return mid;
        }
        if (cmp < 0) {
          low = mid + 1;
        } else {
          high = mid - 1;
        }
      }
      return ~low;
    }
    var FastStringArray = class {
      constructor() {
        this.indexes = Object.create(null);
        this.array = [];
      }
      put(key) {
        const { array: array2, indexes } = this;
        let index2 = indexes[key];
        if (index2 === void 0) {
          index2 = indexes[key] = array2.length;
          array2.push(key);
        }
        return index2;
      }
    };
    var SourceMapTree = class {
      constructor(map2, sources) {
        this.map = map2;
        this.sources = sources;
        this.lastLine = 0;
        this.lastColumn = 0;
        this.lastIndex = 0;
      }
      traceMappings() {
        const mappings = [];
        const names = new FastStringArray();
        const sources = new FastStringArray();
        const sourcesContent = [];
        const { mappings: rootMappings, names: rootNames } = this.map;
        for (let i2 = 0; i2 < rootMappings.length; i2++) {
          const segments = rootMappings[i2];
          const tracedSegments = [];
          let lastTraced = void 0;
          for (let j2 = 0; j2 < segments.length; j2++) {
            const segment = segments[j2];
            if (segment.length === 1)
              continue;
            const source2 = this.sources[segment[1]];
            const traced = source2.traceSegment(segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
            if (!traced)
              continue;
            const { column, line, name } = traced;
            const { content: content2, filename: filename2 } = traced.source;
            const sourceIndex = sources.put(filename2);
            sourcesContent[sourceIndex] = content2;
            if (lastTraced && lastTraced[1] === sourceIndex && lastTraced[2] === line && lastTraced[3] === column) {
              continue;
            }
            if (name) {
              lastTraced = [segment[0], sourceIndex, line, column, names.put(name)];
            } else {
              lastTraced = [segment[0], sourceIndex, line, column];
            }
            tracedSegments.push(lastTraced);
          }
          mappings.push(tracedSegments);
        }
        return defaults({
          mappings,
          names: names.array,
          sources: sources.array,
          sourcesContent
        }, this.map);
      }
      traceSegment(line, column, name) {
        const { mappings, names } = this.map;
        if (line >= mappings.length)
          return null;
        const segments = mappings[line];
        if (segments.length === 0)
          return null;
        let low = 0;
        let high = segments.length - 1;
        if (line === this.lastLine) {
          if (column >= this.lastColumn) {
            low = this.lastIndex;
          } else {
            high = this.lastIndex;
          }
        }
        let index2 = binarySearch$2(segments, column, segmentComparator$1, low, high);
        this.lastLine = line;
        this.lastColumn = column;
        if (index2 === -1) {
          this.lastIndex = index2;
          return null;
        }
        if (index2 < 0) {
          index2 = ~index2 - 1;
        }
        this.lastIndex = index2;
        const segment = segments[index2];
        if (segment.length === 1)
          return null;
        const source2 = this.sources[segment[1]];
        return source2.traceSegment(segment[2], segment[3], segment.length === 5 ? names[segment[4]] : name);
      }
    };
    function segmentComparator$1(segment, column) {
      return segment[0] - column;
    }
    function stripFilename(path2) {
      if (!path2)
        return "";
      const index2 = path2.lastIndexOf("/");
      return path2.slice(0, index2 + 1);
    }
    function asArray(value) {
      if (Array.isArray(value))
        return value;
      return [value];
    }
    function buildSourceMapTree(input, loader, relativeRoot) {
      const maps = asArray(input).map(decodeSourceMap);
      const map2 = maps.pop();
      for (let i2 = 0; i2 < maps.length; i2++) {
        if (maps[i2].sources.length > 1) {
          throw new Error(`Transformation map ${i2} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
        }
      }
      const { sourceRoot, sources, sourcesContent } = map2;
      const children = sources.map((sourceFile, i2) => {
        const uri = resolve$1$1(sourceFile || "", resolve$1$1(sourceRoot || "", stripFilename(relativeRoot)));
        const sourceMap = loader(uri);
        if (!sourceMap) {
          const sourceContent = sourcesContent ? sourcesContent[i2] : null;
          return new OriginalSource(uri, sourceContent);
        }
        return buildSourceMapTree(decodeSourceMap(sourceMap), loader, uri);
      });
      let tree = new SourceMapTree(map2, children);
      for (let i2 = maps.length - 1; i2 >= 0; i2--) {
        tree = new SourceMapTree(maps[i2], [tree]);
      }
      return tree;
    }
    var SourceMap$1 = class {
      constructor(map2, options2) {
        this.version = 3;
        if ("file" in map2)
          this.file = map2.file;
        this.mappings = options2.decodedMappings ? map2.mappings : encode$1(map2.mappings);
        this.names = map2.names;
        this.sources = map2.sources;
        if (!options2.excludeContent && "sourcesContent" in map2) {
          this.sourcesContent = map2.sourcesContent;
        }
      }
      toString() {
        return JSON.stringify(this);
      }
    };
    function remapping(input, loader, options2) {
      const opts = typeof options2 === "object" ? options2 : { excludeContent: !!options2, decodedMappings: false };
      const graph = buildSourceMapTree(input, loader);
      return new SourceMap$1(graph.traceMappings(), opts);
    }
    function slash$3(p2) {
      return p2.replace(/\\/g, "/");
    }
    function unwrapId$1(id) {
      return id.startsWith(VALID_ID_PREFIX) ? id.slice(VALID_ID_PREFIX.length) : id;
    }
    var flattenId = (id) => id.replace(/(\s*>\s*)/g, "__").replace(/[\/\.]/g, "_");
    var normalizeId$1 = (id) => id.replace(/(\s*>\s*)/g, " > ");
    var builtins$2 = new Set([
      ...require$$1.builtinModules,
      "assert/strict",
      "diagnostics_channel",
      "dns/promises",
      "fs/promises",
      "path/posix",
      "path/win32",
      "readline/promises",
      "stream/consumers",
      "stream/promises",
      "stream/web",
      "timers/promises",
      "util/types",
      "wasi"
    ]);
    function isBuiltin(id) {
      return builtins$2.has(id.replace(/^node:/, ""));
    }
    function moduleListContains(moduleList, id) {
      return moduleList === null || moduleList === void 0 ? void 0 : moduleList.some((m3) => m3 === id || id.startsWith(m3 + "/"));
    }
    var bareImportRE = /^[\w@](?!.*:\/\/)/;
    var isRunningWithYarnPnp;
    try {
      isRunningWithYarnPnp = Boolean(__require("pnpapi"));
    } catch {
    }
    var ssrExtensions = [".js", ".cjs", ".json", ".node"];
    function resolveFrom$3(id, basedir, preserveSymlinks = false, ssr = false) {
      return resolve__default.sync(id, {
        basedir,
        extensions: ssr ? ssrExtensions : DEFAULT_EXTENSIONS$1,
        preserveSymlinks: preserveSymlinks || isRunningWithYarnPnp || false
      });
    }
    function nestedResolveFrom(id, basedir, preserveSymlinks = false) {
      const pkgs = id.split(">").map((pkg) => pkg.trim());
      try {
        for (const pkg of pkgs) {
          basedir = resolveFrom$3(pkg, basedir, preserveSymlinks);
        }
      } catch {
      }
      return basedir;
    }
    var filter$1 = process.env.VITE_DEBUG_FILTER;
    var DEBUG$1 = process.env.DEBUG;
    function createDebugger(namespace, options2 = {}) {
      const log2 = debug$g(namespace);
      const { onlyWhenFocused } = options2;
      const focus = typeof onlyWhenFocused === "string" ? onlyWhenFocused : namespace;
      return (msg, ...args) => {
        if (filter$1 && !msg.includes(filter$1)) {
          return;
        }
        if (onlyWhenFocused && !(DEBUG$1 === null || DEBUG$1 === void 0 ? void 0 : DEBUG$1.includes(focus))) {
          return;
        }
        log2(msg, ...args);
      };
    }
    var isWindows$4 = require$$0__default$1.platform() === "win32";
    var VOLUME_RE = /^[A-Z]:/i;
    function normalizePath$4(id) {
      return path__default.posix.normalize(isWindows$4 ? slash$3(id) : id);
    }
    function fsPathFromId(id) {
      const fsPath = normalizePath$4(id.slice(FS_PREFIX.length));
      return fsPath.startsWith("/") || fsPath.match(VOLUME_RE) ? fsPath : `/${fsPath}`;
    }
    function ensureVolumeInPath(file) {
      return isWindows$4 ? path__default.resolve(file) : file;
    }
    var queryRE = /\?.*$/s;
    var hashRE = /#.*$/s;
    var cleanUrl = (url2) => url2.replace(hashRE, "").replace(queryRE, "");
    var externalRE = /^(https?:)?\/\//;
    var isExternalUrl = (url2) => externalRE.test(url2);
    var dataUrlRE = /^\s*data:/i;
    var isDataUrl = (url2) => dataUrlRE.test(url2);
    var virtualModuleRE = /^virtual-module:.*/;
    var virtualModulePrefix = "virtual-module:";
    var knownJsSrcRE = /\.((j|t)sx?|mjs|vue|marko|svelte|astro)($|\?)/;
    var isJSRequest = (url2) => {
      url2 = cleanUrl(url2);
      if (knownJsSrcRE.test(url2)) {
        return true;
      }
      if (!path__default.extname(url2) && !url2.endsWith("/")) {
        return true;
      }
      return false;
    };
    var knownTsRE = /\.(ts|mts|cts|tsx)$/;
    var knownTsOutputRE = /\.(js|mjs|cjs|jsx)$/;
    var isTsRequest = (url2) => knownTsRE.test(cleanUrl(url2));
    var isPossibleTsOutput = (url2) => knownTsOutputRE.test(cleanUrl(url2));
    var getTsSrcPath = (filename2) => filename2.replace(/\.([cm])?(js)(x?)(\?|$)/, ".$1ts$3");
    var importQueryRE = /(\?|&)import=?(?:&|$)/;
    var internalPrefixes = [
      FS_PREFIX,
      VALID_ID_PREFIX,
      CLIENT_PUBLIC_PATH,
      ENV_PUBLIC_PATH
    ];
    var InternalPrefixRE = new RegExp(`^(?:${internalPrefixes.join("|")})`);
    var trailingSeparatorRE = /[\?&]$/;
    var isImportRequest = (url2) => importQueryRE.test(url2);
    var isInternalRequest = (url2) => InternalPrefixRE.test(url2);
    function removeImportQuery(url2) {
      return url2.replace(importQueryRE, "$1").replace(trailingSeparatorRE, "");
    }
    function injectQuery(url2, queryToInject) {
      let resolvedUrl = new require$$0$6.URL(url2.replace(/%/g, "%25"), "relative:///");
      if (resolvedUrl.protocol !== "relative:") {
        resolvedUrl = require$$0$6.pathToFileURL(url2);
      }
      let { protocol, pathname, search, hash } = resolvedUrl;
      if (protocol === "file:") {
        pathname = pathname.slice(1);
      }
      pathname = decodeURIComponent(pathname);
      return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ""}${hash || ""}`;
    }
    var timestampRE = /\bt=\d{13}&?\b/;
    function removeTimestampQuery(url2) {
      return url2.replace(timestampRE, "").replace(trailingSeparatorRE, "");
    }
    async function asyncReplace(input, re2, replacer) {
      let match2;
      let remaining = input;
      let rewritten = "";
      while (match2 = re2.exec(remaining)) {
        rewritten += remaining.slice(0, match2.index);
        rewritten += await replacer(match2);
        remaining = remaining.slice(match2.index + match2[0].length);
      }
      rewritten += remaining;
      return rewritten;
    }
    function timeFrom(start, subtract = 0) {
      const time = perf_hooks.performance.now() - start - subtract;
      const timeString = (time.toFixed(2) + `ms`).padEnd(5, " ");
      if (time < 10) {
        return source.green(timeString);
      } else if (time < 50) {
        return source.yellow(timeString);
      } else {
        return source.red(timeString);
      }
    }
    function prettifyUrl(url2, root) {
      url2 = removeTimestampQuery(url2);
      const isAbsoluteFile = url2.startsWith(root);
      if (isAbsoluteFile || url2.startsWith(FS_PREFIX)) {
        let file = path__default.relative(root, isAbsoluteFile ? url2 : fsPathFromId(url2));
        const seg = file.split("/");
        const npmIndex = seg.indexOf(`node_modules`);
        const isSourceMap = file.endsWith(".map");
        if (npmIndex > 0) {
          file = seg[npmIndex + 1];
          if (file.startsWith("@")) {
            file = `${file}/${seg[npmIndex + 2]}`;
          }
          file = `npm: ${source.dim(file)}${isSourceMap ? ` (source map)` : ``}`;
        }
        return source.dim(file);
      } else {
        return source.dim(url2);
      }
    }
    function isObject$3(value) {
      return Object.prototype.toString.call(value) === "[object Object]";
    }
    function isDefined(value) {
      return value != null;
    }
    function lookupFile(dir, formats, pathOnly = false) {
      for (const format2 of formats) {
        const fullPath = path__default.join(dir, format2);
        if (fs__default.existsSync(fullPath) && fs__default.statSync(fullPath).isFile()) {
          return pathOnly ? fullPath : fs__default.readFileSync(fullPath, "utf-8");
        }
      }
      const parentDir = path__default.dirname(dir);
      if (parentDir !== dir) {
        return lookupFile(parentDir, formats, pathOnly);
      }
    }
    var splitRE = /\r?\n/;
    var range$1 = 2;
    function pad$1(source2, n3 = 2) {
      const lines = source2.split(splitRE);
      return lines.map((l2) => ` `.repeat(n3) + l2).join(`
`);
    }
    function posToNumber(source2, pos) {
      if (typeof pos === "number")
        return pos;
      const lines = source2.split(splitRE);
      const { line, column } = pos;
      let start = 0;
      for (let i2 = 0; i2 < line - 1; i2++) {
        start += lines[i2].length + 1;
      }
      return start + column;
    }
    function numberToPos(source2, offset2) {
      if (typeof offset2 !== "number")
        return offset2;
      if (offset2 > source2.length) {
        throw new Error(`offset is longer than source length! offset ${offset2} > length ${source2.length}`);
      }
      const lines = source2.split(splitRE);
      let counted = 0;
      let line = 0;
      let column = 0;
      for (; line < lines.length; line++) {
        const lineLength = lines[line].length + 1;
        if (counted + lineLength >= offset2) {
          column = offset2 - counted + 1;
          break;
        }
        counted += lineLength;
      }
      return { line: line + 1, column };
    }
    function generateCodeFrame(source2, start = 0, end) {
      start = posToNumber(source2, start);
      end = end || start;
      const lines = source2.split(splitRE);
      let count = 0;
      const res = [];
      for (let i2 = 0; i2 < lines.length; i2++) {
        count += lines[i2].length + 1;
        if (count >= start) {
          for (let j2 = i2 - range$1; j2 <= i2 + range$1 || end > count; j2++) {
            if (j2 < 0 || j2 >= lines.length)
              continue;
            const line = j2 + 1;
            res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j2]}`);
            const lineLength = lines[j2].length;
            if (j2 === i2) {
              const pad2 = start - (count - lineLength) + 1;
              const length = Math.max(1, end > count ? lineLength - pad2 : end - start);
              res.push(`   |  ` + " ".repeat(pad2) + "^".repeat(length));
            } else if (j2 > i2) {
              if (end > count) {
                const length = Math.max(Math.min(end - count, lineLength), 1);
                res.push(`   |  ` + "^".repeat(length));
              }
              count += lineLength + 1;
            }
          }
          break;
        }
      }
      return res.join("\n");
    }
    function writeFile(filename2, content2) {
      const dir = path__default.dirname(filename2);
      if (!fs__default.existsSync(dir)) {
        fs__default.mkdirSync(dir, { recursive: true });
      }
      fs__default.writeFileSync(filename2, content2);
    }
    function isFileReadable(filename2) {
      try {
        fs__default.accessSync(filename2, fs__default.constants.R_OK);
        return true;
      } catch {
        return false;
      }
    }
    function emptyDir(dir, skip) {
      for (const file of fs__default.readdirSync(dir)) {
        if (skip === null || skip === void 0 ? void 0 : skip.includes(file)) {
          continue;
        }
        const abs = path__default.resolve(dir, file);
        if (fs__default.lstatSync(abs).isDirectory()) {
          emptyDir(abs);
          fs__default.rmdirSync(abs);
        } else {
          fs__default.unlinkSync(abs);
        }
      }
    }
    function copyDir(srcDir, destDir) {
      fs__default.mkdirSync(destDir, { recursive: true });
      for (const file of fs__default.readdirSync(srcDir)) {
        const srcFile = path__default.resolve(srcDir, file);
        if (srcFile === destDir) {
          continue;
        }
        const destFile = path__default.resolve(destDir, file);
        const stat2 = fs__default.statSync(srcFile);
        if (stat2.isDirectory()) {
          copyDir(srcFile, destFile);
        } else {
          fs__default.copyFileSync(srcFile, destFile);
        }
      }
    }
    function ensureLeadingSlash(path2) {
      return !path2.startsWith("/") ? "/" + path2 : path2;
    }
    function ensureWatchedFile(watcher, file, root) {
      if (file && !file.startsWith(root + "/") && !file.includes("\0") && fs__default.existsSync(file)) {
        watcher.add(path__default.resolve(file));
      }
    }
    var escapedSpaceCharacters = /( |\\t|\\n|\\f|\\r)+/g;
    async function processSrcSet(srcs, replacer) {
      const imageCandidates = srcs.split(",").map((s2) => {
        const [url2, descriptor] = s2.replace(escapedSpaceCharacters, " ").trim().split(" ", 2);
        return { url: url2, descriptor };
      }).filter(({ url: url2 }) => !!url2);
      const ret = await Promise.all(imageCandidates.map(async ({ url: url2, descriptor }) => {
        return {
          url: await replacer({ url: url2, descriptor }),
          descriptor
        };
      }));
      return ret.reduce((prev, { url: url2, descriptor }, index2) => {
        descriptor = descriptor || "";
        return prev += url2 + ` ${descriptor}${index2 === ret.length - 1 ? "" : ", "}`;
      }, "");
    }
    var nullSourceMap = {
      names: [],
      sources: [],
      mappings: "",
      version: 3
    };
    function combineSourcemaps(filename2, sourcemapList) {
      if (sourcemapList.length === 0 || sourcemapList.every((m3) => m3.sources.length === 0)) {
        return __spreadValues2({}, nullSourceMap);
      }
      let map2;
      let mapIndex = 1;
      const useArrayInterface = sourcemapList.slice(0, -1).find((m3) => m3.sources.length !== 1) === void 0;
      if (useArrayInterface) {
        map2 = remapping(sourcemapList, () => null, true);
      } else {
        map2 = remapping(sourcemapList[0], function loader(sourcefile) {
          if (sourcefile === filename2 && sourcemapList[mapIndex]) {
            return sourcemapList[mapIndex++];
          } else {
            return __spreadValues2({}, nullSourceMap);
          }
        }, true);
      }
      if (!map2.file) {
        delete map2.file;
      }
      return map2;
    }
    function resolveHostname(optionsHost) {
      let host;
      if (optionsHost === void 0 || optionsHost === false || optionsHost === "localhost") {
        host = "127.0.0.1";
      } else if (optionsHost === true) {
        host = void 0;
      } else {
        host = optionsHost;
      }
      const name = optionsHost !== "127.0.0.1" && host === "127.0.0.1" || host === "0.0.0.0" || host === "::" || host === void 0 ? "localhost" : host;
      return { host, name };
    }
    function arraify(target) {
      return Array.isArray(target) ? target : [target];
    }
    function toUpperCaseDriveLetter(pathName) {
      return pathName.replace(/^\w:/, (letter) => letter.toUpperCase());
    }
    var multilineCommentsRE$1 = /\/\*(.|[\r\n])*?\*\//gm;
    var singlelineCommentsRE$1 = /\/\/.*/g;
    var usingDynamicImport = typeof jest === "undefined";
    var dynamicImport = usingDynamicImport ? new Function("file", "return import(file)") : __require;
    var LogLevels = {
      silent: 0,
      error: 1,
      warn: 2,
      info: 3
    };
    var lastType;
    var lastMsg;
    var sameCount = 0;
    function clearScreen() {
      const repeatCount = process.stdout.rows - 2;
      const blank = repeatCount > 0 ? "\n".repeat(repeatCount) : "";
      console.log(blank);
      readline__default.cursorTo(process.stdout, 0, 0);
      readline__default.clearScreenDown(process.stdout);
    }
    function createLogger(level = "info", options2 = {}) {
      if (options2.customLogger) {
        return options2.customLogger;
      }
      const loggedErrors = new WeakSet();
      const { prefix = "[vite]", allowClearScreen = true } = options2;
      const thresh = LogLevels[level];
      const canClearScreen = allowClearScreen && process.stdout.isTTY && !process.env.CI;
      const clear = canClearScreen ? clearScreen : () => {
      };
      function output(type, msg, options3 = {}) {
        if (thresh >= LogLevels[type]) {
          const method = type === "info" ? "log" : type;
          const format2 = () => {
            if (options3.timestamp) {
              const tag = type === "info" ? source.cyan.bold(prefix) : type === "warn" ? source.yellow.bold(prefix) : source.red.bold(prefix);
              return `${source.dim(new Date().toLocaleTimeString())} ${tag} ${msg}`;
            } else {
              return msg;
            }
          };
          if (options3.error) {
            loggedErrors.add(options3.error);
          }
          if (canClearScreen) {
            if (type === lastType && msg === lastMsg) {
              sameCount++;
              clear();
              console[method](format2(), source.yellow(`(x${sameCount + 1})`));
            } else {
              sameCount = 0;
              lastMsg = msg;
              lastType = type;
              if (options3.clear) {
                clear();
              }
              console[method](format2());
            }
          } else {
            console[method](format2());
          }
        }
      }
      const warnedMessages = new Set();
      const logger = {
        hasWarned: false,
        info(msg, opts) {
          output("info", msg, opts);
        },
        warn(msg, opts) {
          logger.hasWarned = true;
          output("warn", msg, opts);
        },
        warnOnce(msg, opts) {
          if (warnedMessages.has(msg))
            return;
          logger.hasWarned = true;
          output("warn", msg, opts);
          warnedMessages.add(msg);
        },
        error(msg, opts) {
          logger.hasWarned = true;
          output("error", msg, opts);
        },
        clearScreen(type) {
          if (thresh >= LogLevels[type]) {
            clear();
          }
        },
        hasErrorLogged(error2) {
          return loggedErrors.has(error2);
        }
      };
      return logger;
    }
    function printHttpServerUrls(server2, config2) {
      printCommonServerUrls(server2, config2.server, config2);
    }
    function printCommonServerUrls(server2, options2, config2) {
      const address = server2.address();
      const isAddressInfo = (x2) => x2 === null || x2 === void 0 ? void 0 : x2.address;
      if (isAddressInfo(address)) {
        const hostname = resolveHostname(options2.host);
        const protocol = options2.https ? "https" : "http";
        printServerUrls(hostname, protocol, address.port, config2.base, config2.logger.info);
      }
    }
    function printServerUrls(hostname, protocol, port, base2, info) {
      if (hostname.host === "127.0.0.1") {
        const url2 = `${protocol}://${hostname.name}:${source.bold(port)}${base2}`;
        info(`  > Local: ${source.cyan(url2)}`);
        if (hostname.name !== "127.0.0.1") {
          info(`  > Network: ${source.dim("use `--host` to expose")}`);
        }
      } else {
        Object.values(require$$0__default$1.networkInterfaces()).flatMap((nInterface) => nInterface !== null && nInterface !== void 0 ? nInterface : []).filter((detail) => detail && detail.address && detail.family === "IPv4").map((detail) => {
          const type = detail.address.includes("127.0.0.1") ? "Local:   " : "Network: ";
          const host = detail.address.replace("127.0.0.1", hostname.name);
          const url2 = `${protocol}://${host}:${source.bold(port)}${base2}`;
          return `  > ${type} ${source.cyan(url2)}`;
        }).forEach((msg) => info(msg));
      }
    }
    var writeColors = {
      [0]: source.cyan,
      [1]: source.magenta,
      [2]: source.green,
      [3]: source.blue,
      [4]: source.gray
    };
    function buildReporterPlugin(config2) {
      const compress = require$$0$5.promisify(require$$0$7.gzip);
      const chunkLimit = config2.build.chunkSizeWarningLimit;
      function isLarge(code) {
        return code.length / 1024 > chunkLimit;
      }
      async function getCompressedSize(code) {
        if (config2.build.ssr || !config2.build.reportCompressedSize || config2.build.brotliSize === false) {
          return "";
        }
        return ` / gzip: ${((await compress(typeof code === "string" ? code : Buffer.from(code))).length / 1024).toFixed(2)} KiB`;
      }
      function printFileInfo(filePath, content2, type, maxLength, compressedSize = "") {
        const outDir = normalizePath$4(path__default.relative(config2.root, path__default.resolve(config2.root, config2.build.outDir))) + "/";
        const kibs = content2.length / 1024;
        const sizeColor = kibs > chunkLimit ? source.yellow : source.dim;
        config2.logger.info(`${source.gray(source.white.dim(outDir))}${writeColors[type](filePath.padEnd(maxLength + 2))} ${sizeColor(`${kibs.toFixed(2)} KiB${compressedSize}`)}`);
      }
      const tty2 = process.stdout.isTTY && !process.env.CI;
      const shouldLogInfo = LogLevels[config2.logLevel || "info"] >= LogLevels.info;
      let hasTransformed = false;
      let hasRenderedChunk = false;
      let transformedCount = 0;
      let chunkCount = 0;
      const logTransform = throttle((id) => {
        writeLine(`transforming (${transformedCount}) ${source.dim(path__default.relative(config2.root, id))}`);
      });
      return {
        name: "vite:reporter",
        transform(_2, id) {
          transformedCount++;
          if (shouldLogInfo) {
            if (!tty2) {
              if (!hasTransformed) {
                config2.logger.info(`transforming...`);
              }
            } else {
              if (id.includes(`?`))
                return;
              logTransform(id);
            }
            hasTransformed = true;
          }
          return null;
        },
        buildEnd() {
          if (shouldLogInfo) {
            if (tty2) {
              process.stdout.clearLine(0);
              process.stdout.cursorTo(0);
            }
            config2.logger.info(`${source.green(`\u2713`)} ${transformedCount} modules transformed.`);
          }
        },
        renderStart() {
          chunkCount = 0;
        },
        renderChunk() {
          chunkCount++;
          if (shouldLogInfo) {
            if (!tty2) {
              if (!hasRenderedChunk) {
                config2.logger.info("rendering chunks...");
              }
            } else {
              writeLine(`rendering chunks (${chunkCount})...`);
            }
            hasRenderedChunk = true;
          }
          return null;
        },
        generateBundle() {
          if (shouldLogInfo && tty2) {
            process.stdout.clearLine(0);
            process.stdout.cursorTo(0);
          }
        },
        async writeBundle(_2, output) {
          let hasLargeChunks = false;
          if (shouldLogInfo) {
            let longest = 0;
            for (const file in output) {
              const l2 = output[file].fileName.length;
              if (l2 > longest)
                longest = l2;
            }
            const deferredLogs = [];
            await Promise.all(Object.keys(output).map(async (file) => {
              const chunk = output[file];
              if (chunk.type === "chunk") {
                const log2 = async () => {
                  printFileInfo(chunk.fileName, chunk.code, 0, longest, await getCompressedSize(chunk.code));
                  if (chunk.map) {
                    printFileInfo(chunk.fileName + ".map", chunk.map.toString(), 4, longest);
                  }
                };
                if (isLarge(chunk.code)) {
                  hasLargeChunks = true;
                  deferredLogs.push(log2);
                } else {
                  await log2();
                }
              } else if (chunk.source) {
                const isCSS = chunk.fileName.endsWith(".css");
                printFileInfo(chunk.fileName, chunk.source, isCSS ? 1 : 2, longest, isCSS ? await getCompressedSize(chunk.source) : void 0);
              }
            }));
            await Promise.all(deferredLogs.map((l2) => l2()));
          } else {
            hasLargeChunks = Object.keys(output).some((file) => {
              const chunk = output[file];
              return chunk.type === "chunk" && chunk.code.length / 1024 > chunkLimit;
            });
          }
          if (hasLargeChunks && config2.build.minify && !config2.build.lib && !config2.build.ssr) {
            config2.logger.warn(source.yellow(`
(!) Some chunks are larger than ${chunkLimit} KiB after minification. Consider:
- Using dynamic import() to code-split the application
- Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/guide/en/#outputmanualchunks
- Adjust chunk size limit for this warning via build.chunkSizeWarningLimit.`));
          }
        }
      };
    }
    function writeLine(output) {
      process.stdout.clearLine(0);
      process.stdout.cursorTo(0);
      if (output.length < process.stdout.columns) {
        process.stdout.write(output);
      } else {
        process.stdout.write(output.substring(0, process.stdout.columns - 1));
      }
    }
    function throttle(fn2) {
      let timerHandle = null;
      return (...args) => {
        if (timerHandle)
          return;
        fn2(...args);
        timerHandle = setTimeout(() => {
          timerHandle = null;
        }, 100);
      };
    }
    var charToInteger = {};
    var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    for (i$2 = 0; i$2 < chars$1.length; i$2++) {
      charToInteger[chars$1.charCodeAt(i$2)] = i$2;
    }
    var i$2;
    function encode(decoded) {
      var sourceFileIndex = 0;
      var sourceCodeLine = 0;
      var sourceCodeColumn = 0;
      var nameIndex = 0;
      var mappings = "";
      for (var i2 = 0; i2 < decoded.length; i2++) {
        var line = decoded[i2];
        if (i2 > 0)
          mappings += ";";
        if (line.length === 0)
          continue;
        var generatedCodeColumn = 0;
        var lineMappings = [];
        for (var _i2 = 0, line_1 = line; _i2 < line_1.length; _i2++) {
          var segment = line_1[_i2];
          var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
          generatedCodeColumn = segment[0];
          if (segment.length > 1) {
            segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);
            sourceFileIndex = segment[1];
            sourceCodeLine = segment[2];
            sourceCodeColumn = segment[3];
          }
          if (segment.length === 5) {
            segmentMappings += encodeInteger(segment[4] - nameIndex);
            nameIndex = segment[4];
          }
          lineMappings.push(segmentMappings);
        }
        mappings += lineMappings.join(",");
      }
      return mappings;
    }
    function encodeInteger(num) {
      var result2 = "";
      num = num < 0 ? -num << 1 | 1 : num << 1;
      do {
        var clamped = num & 31;
        num >>>= 5;
        if (num > 0) {
          clamped |= 32;
        }
        result2 += chars$1[clamped];
      } while (num > 0);
      return result2;
    }
    var BitSet = function BitSet2(arg) {
      this.bits = arg instanceof BitSet2 ? arg.bits.slice() : [];
    };
    BitSet.prototype.add = function add(n3) {
      this.bits[n3 >> 5] |= 1 << (n3 & 31);
    };
    BitSet.prototype.has = function has2(n3) {
      return !!(this.bits[n3 >> 5] & 1 << (n3 & 31));
    };
    var Chunk = function Chunk2(start, end, content2) {
      this.start = start;
      this.end = end;
      this.original = content2;
      this.intro = "";
      this.outro = "";
      this.content = content2;
      this.storeName = false;
      this.edited = false;
      Object.defineProperties(this, {
        previous: { writable: true, value: null },
        next: { writable: true, value: null }
      });
    };
    Chunk.prototype.appendLeft = function appendLeft(content2) {
      this.outro += content2;
    };
    Chunk.prototype.appendRight = function appendRight(content2) {
      this.intro = this.intro + content2;
    };
    Chunk.prototype.clone = function clone() {
      var chunk = new Chunk(this.start, this.end, this.original);
      chunk.intro = this.intro;
      chunk.outro = this.outro;
      chunk.content = this.content;
      chunk.storeName = this.storeName;
      chunk.edited = this.edited;
      return chunk;
    };
    Chunk.prototype.contains = function contains2(index2) {
      return this.start < index2 && index2 < this.end;
    };
    Chunk.prototype.eachNext = function eachNext(fn2) {
      var chunk = this;
      while (chunk) {
        fn2(chunk);
        chunk = chunk.next;
      }
    };
    Chunk.prototype.eachPrevious = function eachPrevious(fn2) {
      var chunk = this;
      while (chunk) {
        fn2(chunk);
        chunk = chunk.previous;
      }
    };
    Chunk.prototype.edit = function edit(content2, storeName, contentOnly) {
      this.content = content2;
      if (!contentOnly) {
        this.intro = "";
        this.outro = "";
      }
      this.storeName = storeName;
      this.edited = true;
      return this;
    };
    Chunk.prototype.prependLeft = function prependLeft(content2) {
      this.outro = content2 + this.outro;
    };
    Chunk.prototype.prependRight = function prependRight(content2) {
      this.intro = content2 + this.intro;
    };
    Chunk.prototype.split = function split2(index2) {
      var sliceIndex = index2 - this.start;
      var originalBefore = this.original.slice(0, sliceIndex);
      var originalAfter = this.original.slice(sliceIndex);
      this.original = originalBefore;
      var newChunk = new Chunk(index2, this.end, originalAfter);
      newChunk.outro = this.outro;
      this.outro = "";
      this.end = index2;
      if (this.edited) {
        newChunk.edit("", false);
        this.content = "";
      } else {
        this.content = originalBefore;
      }
      newChunk.next = this.next;
      if (newChunk.next) {
        newChunk.next.previous = newChunk;
      }
      newChunk.previous = this;
      this.next = newChunk;
      return newChunk;
    };
    Chunk.prototype.toString = function toString2() {
      return this.intro + this.content + this.outro;
    };
    Chunk.prototype.trimEnd = function trimEnd(rx) {
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length) {
        return true;
      }
      var trimmed = this.content.replace(rx, "");
      if (trimmed.length) {
        if (trimmed !== this.content) {
          this.split(this.start + trimmed.length).edit("", void 0, true);
        }
        return true;
      } else {
        this.edit("", void 0, true);
        this.intro = this.intro.replace(rx, "");
        if (this.intro.length) {
          return true;
        }
      }
    };
    Chunk.prototype.trimStart = function trimStart(rx) {
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length) {
        return true;
      }
      var trimmed = this.content.replace(rx, "");
      if (trimmed.length) {
        if (trimmed !== this.content) {
          this.split(this.end - trimmed.length);
          this.edit("", void 0, true);
        }
        return true;
      } else {
        this.edit("", void 0, true);
        this.outro = this.outro.replace(rx, "");
        if (this.outro.length) {
          return true;
        }
      }
    };
    var btoa$1 = function() {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
    if (typeof window !== "undefined" && typeof window.btoa === "function") {
      btoa$1 = function(str) {
        return window.btoa(unescape(encodeURIComponent(str)));
      };
    } else if (typeof Buffer === "function") {
      btoa$1 = function(str) {
        return Buffer.from(str, "utf-8").toString("base64");
      };
    }
    var SourceMap = function SourceMap2(properties) {
      this.version = 3;
      this.file = properties.file;
      this.sources = properties.sources;
      this.sourcesContent = properties.sourcesContent;
      this.names = properties.names;
      this.mappings = encode(properties.mappings);
    };
    SourceMap.prototype.toString = function toString2() {
      return JSON.stringify(this);
    };
    SourceMap.prototype.toUrl = function toUrl() {
      return "data:application/json;charset=utf-8;base64," + btoa$1(this.toString());
    };
    function guessIndent(code) {
      var lines = code.split("\n");
      var tabbed = lines.filter(function(line) {
        return /^\t+/.test(line);
      });
      var spaced = lines.filter(function(line) {
        return /^ {2,}/.test(line);
      });
      if (tabbed.length === 0 && spaced.length === 0) {
        return null;
      }
      if (tabbed.length >= spaced.length) {
        return "	";
      }
      var min2 = spaced.reduce(function(previous, current) {
        var numSpaces = /^ +/.exec(current)[0].length;
        return Math.min(numSpaces, previous);
      }, Infinity);
      return new Array(min2 + 1).join(" ");
    }
    function getRelativePath(from, to2) {
      var fromParts = from.split(/[/\\]/);
      var toParts = to2.split(/[/\\]/);
      fromParts.pop();
      while (fromParts[0] === toParts[0]) {
        fromParts.shift();
        toParts.shift();
      }
      if (fromParts.length) {
        var i2 = fromParts.length;
        while (i2--) {
          fromParts[i2] = "..";
        }
      }
      return fromParts.concat(toParts).join("/");
    }
    var toString$2 = Object.prototype.toString;
    function isObject$2(thing) {
      return toString$2.call(thing) === "[object Object]";
    }
    function getLocator(source2) {
      var originalLines = source2.split("\n");
      var lineOffsets = [];
      for (var i2 = 0, pos = 0; i2 < originalLines.length; i2++) {
        lineOffsets.push(pos);
        pos += originalLines[i2].length + 1;
      }
      return function locate(index2) {
        var i3 = 0;
        var j2 = lineOffsets.length;
        while (i3 < j2) {
          var m3 = i3 + j2 >> 1;
          if (index2 < lineOffsets[m3]) {
            j2 = m3;
          } else {
            i3 = m3 + 1;
          }
        }
        var line = i3 - 1;
        var column = index2 - lineOffsets[line];
        return { line, column };
      };
    }
    var Mappings = function Mappings2(hires) {
      this.hires = hires;
      this.generatedCodeLine = 0;
      this.generatedCodeColumn = 0;
      this.raw = [];
      this.rawSegments = this.raw[this.generatedCodeLine] = [];
      this.pending = null;
    };
    Mappings.prototype.addEdit = function addEdit(sourceIndex, content2, loc, nameIndex) {
      if (content2.length) {
        var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (nameIndex >= 0) {
          segment.push(nameIndex);
        }
        this.rawSegments.push(segment);
      } else if (this.pending) {
        this.rawSegments.push(this.pending);
      }
      this.advance(content2);
      this.pending = null;
    };
    Mappings.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
      var originalCharIndex = chunk.start;
      var first2 = true;
      while (originalCharIndex < chunk.end) {
        if (this.hires || first2 || sourcemapLocations.has(originalCharIndex)) {
          this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
        }
        if (original[originalCharIndex] === "\n") {
          loc.line += 1;
          loc.column = 0;
          this.generatedCodeLine += 1;
          this.raw[this.generatedCodeLine] = this.rawSegments = [];
          this.generatedCodeColumn = 0;
          first2 = true;
        } else {
          loc.column += 1;
          this.generatedCodeColumn += 1;
          first2 = false;
        }
        originalCharIndex += 1;
      }
      this.pending = null;
    };
    Mappings.prototype.advance = function advance(str) {
      if (!str) {
        return;
      }
      var lines = str.split("\n");
      if (lines.length > 1) {
        for (var i2 = 0; i2 < lines.length - 1; i2++) {
          this.generatedCodeLine++;
          this.raw[this.generatedCodeLine] = this.rawSegments = [];
        }
        this.generatedCodeColumn = 0;
      }
      this.generatedCodeColumn += lines[lines.length - 1].length;
    };
    var n = "\n";
    var warned$1 = {
      insertLeft: false,
      insertRight: false,
      storeName: false
    };
    var MagicString = function MagicString2(string2, options2) {
      if (options2 === void 0)
        options2 = {};
      var chunk = new Chunk(0, string2.length, string2);
      Object.defineProperties(this, {
        original: { writable: true, value: string2 },
        outro: { writable: true, value: "" },
        intro: { writable: true, value: "" },
        firstChunk: { writable: true, value: chunk },
        lastChunk: { writable: true, value: chunk },
        lastSearchedChunk: { writable: true, value: chunk },
        byStart: { writable: true, value: {} },
        byEnd: { writable: true, value: {} },
        filename: { writable: true, value: options2.filename },
        indentExclusionRanges: { writable: true, value: options2.indentExclusionRanges },
        sourcemapLocations: { writable: true, value: new BitSet() },
        storedNames: { writable: true, value: {} },
        indentStr: { writable: true, value: guessIndent(string2) }
      });
      this.byStart[0] = chunk;
      this.byEnd[string2.length] = chunk;
    };
    MagicString.prototype.addSourcemapLocation = function addSourcemapLocation(char) {
      this.sourcemapLocations.add(char);
    };
    MagicString.prototype.append = function append2(content2) {
      if (typeof content2 !== "string") {
        throw new TypeError("outro content must be a string");
      }
      this.outro += content2;
      return this;
    };
    MagicString.prototype.appendLeft = function appendLeft(index2, content2) {
      if (typeof content2 !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index2);
      var chunk = this.byEnd[index2];
      if (chunk) {
        chunk.appendLeft(content2);
      } else {
        this.intro += content2;
      }
      return this;
    };
    MagicString.prototype.appendRight = function appendRight(index2, content2) {
      if (typeof content2 !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index2);
      var chunk = this.byStart[index2];
      if (chunk) {
        chunk.appendRight(content2);
      } else {
        this.outro += content2;
      }
      return this;
    };
    MagicString.prototype.clone = function clone() {
      var cloned = new MagicString(this.original, { filename: this.filename });
      var originalChunk = this.firstChunk;
      var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
      while (originalChunk) {
        cloned.byStart[clonedChunk.start] = clonedChunk;
        cloned.byEnd[clonedChunk.end] = clonedChunk;
        var nextOriginalChunk = originalChunk.next;
        var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
        if (nextClonedChunk) {
          clonedChunk.next = nextClonedChunk;
          nextClonedChunk.previous = clonedChunk;
          clonedChunk = nextClonedChunk;
        }
        originalChunk = nextOriginalChunk;
      }
      cloned.lastChunk = clonedChunk;
      if (this.indentExclusionRanges) {
        cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
      }
      cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
      cloned.intro = this.intro;
      cloned.outro = this.outro;
      return cloned;
    };
    MagicString.prototype.generateDecodedMap = function generateDecodedMap(options2) {
      var this$1$1 = this;
      options2 = options2 || {};
      var sourceIndex = 0;
      var names = Object.keys(this.storedNames);
      var mappings = new Mappings(options2.hires);
      var locate = getLocator(this.original);
      if (this.intro) {
        mappings.advance(this.intro);
      }
      this.firstChunk.eachNext(function(chunk) {
        var loc = locate(chunk.start);
        if (chunk.intro.length) {
          mappings.advance(chunk.intro);
        }
        if (chunk.edited) {
          mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
        } else {
          mappings.addUneditedChunk(sourceIndex, chunk, this$1$1.original, loc, this$1$1.sourcemapLocations);
        }
        if (chunk.outro.length) {
          mappings.advance(chunk.outro);
        }
      });
      return {
        file: options2.file ? options2.file.split(/[/\\]/).pop() : null,
        sources: [options2.source ? getRelativePath(options2.file || "", options2.source) : null],
        sourcesContent: options2.includeContent ? [this.original] : [null],
        names,
        mappings: mappings.raw
      };
    };
    MagicString.prototype.generateMap = function generateMap(options2) {
      return new SourceMap(this.generateDecodedMap(options2));
    };
    MagicString.prototype.getIndentString = function getIndentString() {
      return this.indentStr === null ? "	" : this.indentStr;
    };
    MagicString.prototype.indent = function indent(indentStr, options2) {
      var pattern2 = /^[^\r\n]/gm;
      if (isObject$2(indentStr)) {
        options2 = indentStr;
        indentStr = void 0;
      }
      indentStr = indentStr !== void 0 ? indentStr : this.indentStr || "	";
      if (indentStr === "") {
        return this;
      }
      options2 = options2 || {};
      var isExcluded = {};
      if (options2.exclude) {
        var exclusions = typeof options2.exclude[0] === "number" ? [options2.exclude] : options2.exclude;
        exclusions.forEach(function(exclusion) {
          for (var i2 = exclusion[0]; i2 < exclusion[1]; i2 += 1) {
            isExcluded[i2] = true;
          }
        });
      }
      var shouldIndentNextCharacter = options2.indentStart !== false;
      var replacer = function(match2) {
        if (shouldIndentNextCharacter) {
          return "" + indentStr + match2;
        }
        shouldIndentNextCharacter = true;
        return match2;
      };
      this.intro = this.intro.replace(pattern2, replacer);
      var charIndex = 0;
      var chunk = this.firstChunk;
      while (chunk) {
        var end = chunk.end;
        if (chunk.edited) {
          if (!isExcluded[charIndex]) {
            chunk.content = chunk.content.replace(pattern2, replacer);
            if (chunk.content.length) {
              shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
            }
          }
        } else {
          charIndex = chunk.start;
          while (charIndex < end) {
            if (!isExcluded[charIndex]) {
              var char = this.original[charIndex];
              if (char === "\n") {
                shouldIndentNextCharacter = true;
              } else if (char !== "\r" && shouldIndentNextCharacter) {
                shouldIndentNextCharacter = false;
                if (charIndex === chunk.start) {
                  chunk.prependRight(indentStr);
                } else {
                  this._splitChunk(chunk, charIndex);
                  chunk = chunk.next;
                  chunk.prependRight(indentStr);
                }
              }
            }
            charIndex += 1;
          }
        }
        charIndex = chunk.end;
        chunk = chunk.next;
      }
      this.outro = this.outro.replace(pattern2, replacer);
      return this;
    };
    MagicString.prototype.insert = function insert() {
      throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
    };
    MagicString.prototype.insertLeft = function insertLeft(index2, content2) {
      if (!warned$1.insertLeft) {
        console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead");
        warned$1.insertLeft = true;
      }
      return this.appendLeft(index2, content2);
    };
    MagicString.prototype.insertRight = function insertRight(index2, content2) {
      if (!warned$1.insertRight) {
        console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead");
        warned$1.insertRight = true;
      }
      return this.prependRight(index2, content2);
    };
    MagicString.prototype.move = function move(start, end, index2) {
      if (index2 >= start && index2 <= end) {
        throw new Error("Cannot move a selection inside itself");
      }
      this._split(start);
      this._split(end);
      this._split(index2);
      var first2 = this.byStart[start];
      var last = this.byEnd[end];
      var oldLeft = first2.previous;
      var oldRight = last.next;
      var newRight = this.byStart[index2];
      if (!newRight && last === this.lastChunk) {
        return this;
      }
      var newLeft = newRight ? newRight.previous : this.lastChunk;
      if (oldLeft) {
        oldLeft.next = oldRight;
      }
      if (oldRight) {
        oldRight.previous = oldLeft;
      }
      if (newLeft) {
        newLeft.next = first2;
      }
      if (newRight) {
        newRight.previous = last;
      }
      if (!first2.previous) {
        this.firstChunk = last.next;
      }
      if (!last.next) {
        this.lastChunk = first2.previous;
        this.lastChunk.next = null;
      }
      first2.previous = newLeft;
      last.next = newRight || null;
      if (!newLeft) {
        this.firstChunk = first2;
      }
      if (!newRight) {
        this.lastChunk = last;
      }
      return this;
    };
    MagicString.prototype.overwrite = function overwrite(start, end, content2, options2) {
      if (typeof content2 !== "string") {
        throw new TypeError("replacement content must be a string");
      }
      while (start < 0) {
        start += this.original.length;
      }
      while (end < 0) {
        end += this.original.length;
      }
      if (end > this.original.length) {
        throw new Error("end is out of bounds");
      }
      if (start === end) {
        throw new Error("Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead");
      }
      this._split(start);
      this._split(end);
      if (options2 === true) {
        if (!warned$1.storeName) {
          console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string");
          warned$1.storeName = true;
        }
        options2 = { storeName: true };
      }
      var storeName = options2 !== void 0 ? options2.storeName : false;
      var contentOnly = options2 !== void 0 ? options2.contentOnly : false;
      if (storeName) {
        var original = this.original.slice(start, end);
        this.storedNames[original] = true;
      }
      var first2 = this.byStart[start];
      var last = this.byEnd[end];
      if (first2) {
        if (end > first2.end && first2.next !== this.byStart[first2.end]) {
          throw new Error("Cannot overwrite across a split point");
        }
        first2.edit(content2, storeName, contentOnly);
        if (first2 !== last) {
          var chunk = first2.next;
          while (chunk !== last) {
            chunk.edit("", false);
            chunk = chunk.next;
          }
          chunk.edit("", false);
        }
      } else {
        var newChunk = new Chunk(start, end, "").edit(content2, storeName);
        last.next = newChunk;
        newChunk.previous = last;
      }
      return this;
    };
    MagicString.prototype.prepend = function prepend(content2) {
      if (typeof content2 !== "string") {
        throw new TypeError("outro content must be a string");
      }
      this.intro = content2 + this.intro;
      return this;
    };
    MagicString.prototype.prependLeft = function prependLeft(index2, content2) {
      if (typeof content2 !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index2);
      var chunk = this.byEnd[index2];
      if (chunk) {
        chunk.prependLeft(content2);
      } else {
        this.intro = content2 + this.intro;
      }
      return this;
    };
    MagicString.prototype.prependRight = function prependRight(index2, content2) {
      if (typeof content2 !== "string") {
        throw new TypeError("inserted content must be a string");
      }
      this._split(index2);
      var chunk = this.byStart[index2];
      if (chunk) {
        chunk.prependRight(content2);
      } else {
        this.outro = content2 + this.outro;
      }
      return this;
    };
    MagicString.prototype.remove = function remove2(start, end) {
      while (start < 0) {
        start += this.original.length;
      }
      while (end < 0) {
        end += this.original.length;
      }
      if (start === end) {
        return this;
      }
      if (start < 0 || end > this.original.length) {
        throw new Error("Character is out of bounds");
      }
      if (start > end) {
        throw new Error("end must be greater than start");
      }
      this._split(start);
      this._split(end);
      var chunk = this.byStart[start];
      while (chunk) {
        chunk.intro = "";
        chunk.outro = "";
        chunk.edit("");
        chunk = end > chunk.end ? this.byStart[chunk.end] : null;
      }
      return this;
    };
    MagicString.prototype.lastChar = function lastChar() {
      if (this.outro.length) {
        return this.outro[this.outro.length - 1];
      }
      var chunk = this.lastChunk;
      do {
        if (chunk.outro.length) {
          return chunk.outro[chunk.outro.length - 1];
        }
        if (chunk.content.length) {
          return chunk.content[chunk.content.length - 1];
        }
        if (chunk.intro.length) {
          return chunk.intro[chunk.intro.length - 1];
        }
      } while (chunk = chunk.previous);
      if (this.intro.length) {
        return this.intro[this.intro.length - 1];
      }
      return "";
    };
    MagicString.prototype.lastLine = function lastLine() {
      var lineIndex = this.outro.lastIndexOf(n);
      if (lineIndex !== -1) {
        return this.outro.substr(lineIndex + 1);
      }
      var lineStr = this.outro;
      var chunk = this.lastChunk;
      do {
        if (chunk.outro.length > 0) {
          lineIndex = chunk.outro.lastIndexOf(n);
          if (lineIndex !== -1) {
            return chunk.outro.substr(lineIndex + 1) + lineStr;
          }
          lineStr = chunk.outro + lineStr;
        }
        if (chunk.content.length > 0) {
          lineIndex = chunk.content.lastIndexOf(n);
          if (lineIndex !== -1) {
            return chunk.content.substr(lineIndex + 1) + lineStr;
          }
          lineStr = chunk.content + lineStr;
        }
        if (chunk.intro.length > 0) {
          lineIndex = chunk.intro.lastIndexOf(n);
          if (lineIndex !== -1) {
            return chunk.intro.substr(lineIndex + 1) + lineStr;
          }
          lineStr = chunk.intro + lineStr;
        }
      } while (chunk = chunk.previous);
      lineIndex = this.intro.lastIndexOf(n);
      if (lineIndex !== -1) {
        return this.intro.substr(lineIndex + 1) + lineStr;
      }
      return this.intro + lineStr;
    };
    MagicString.prototype.slice = function slice2(start, end) {
      if (start === void 0)
        start = 0;
      if (end === void 0)
        end = this.original.length;
      while (start < 0) {
        start += this.original.length;
      }
      while (end < 0) {
        end += this.original.length;
      }
      var result2 = "";
      var chunk = this.firstChunk;
      while (chunk && (chunk.start > start || chunk.end <= start)) {
        if (chunk.start < end && chunk.end >= end) {
          return result2;
        }
        chunk = chunk.next;
      }
      if (chunk && chunk.edited && chunk.start !== start) {
        throw new Error("Cannot use replaced character " + start + " as slice start anchor.");
      }
      var startChunk = chunk;
      while (chunk) {
        if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
          result2 += chunk.intro;
        }
        var containsEnd = chunk.start < end && chunk.end >= end;
        if (containsEnd && chunk.edited && chunk.end !== end) {
          throw new Error("Cannot use replaced character " + end + " as slice end anchor.");
        }
        var sliceStart = startChunk === chunk ? start - chunk.start : 0;
        var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
        result2 += chunk.content.slice(sliceStart, sliceEnd);
        if (chunk.outro && (!containsEnd || chunk.end === end)) {
          result2 += chunk.outro;
        }
        if (containsEnd) {
          break;
        }
        chunk = chunk.next;
      }
      return result2;
    };
    MagicString.prototype.snip = function snip(start, end) {
      var clone = this.clone();
      clone.remove(0, start);
      clone.remove(end, clone.original.length);
      return clone;
    };
    MagicString.prototype._split = function _split(index2) {
      if (this.byStart[index2] || this.byEnd[index2]) {
        return;
      }
      var chunk = this.lastSearchedChunk;
      var searchForward = index2 > chunk.end;
      while (chunk) {
        if (chunk.contains(index2)) {
          return this._splitChunk(chunk, index2);
        }
        chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
      }
    };
    MagicString.prototype._splitChunk = function _splitChunk(chunk, index2) {
      if (chunk.edited && chunk.content.length) {
        var loc = getLocator(this.original)(index2);
        throw new Error("Cannot split a chunk that has already been edited (" + loc.line + ":" + loc.column + ' \u2013 "' + chunk.original + '")');
      }
      var newChunk = chunk.split(index2);
      this.byEnd[index2] = chunk;
      this.byStart[index2] = newChunk;
      this.byEnd[newChunk.end] = newChunk;
      if (chunk === this.lastChunk) {
        this.lastChunk = newChunk;
      }
      this.lastSearchedChunk = chunk;
      return true;
    };
    MagicString.prototype.toString = function toString2() {
      var str = this.intro;
      var chunk = this.firstChunk;
      while (chunk) {
        str += chunk.toString();
        chunk = chunk.next;
      }
      return str + this.outro;
    };
    MagicString.prototype.isEmpty = function isEmpty2() {
      var chunk = this.firstChunk;
      do {
        if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) {
          return false;
        }
      } while (chunk = chunk.next);
      return true;
    };
    MagicString.prototype.length = function length() {
      var chunk = this.firstChunk;
      var length2 = 0;
      do {
        length2 += chunk.intro.length + chunk.content.length + chunk.outro.length;
      } while (chunk = chunk.next);
      return length2;
    };
    MagicString.prototype.trimLines = function trimLines() {
      return this.trim("[\\r\\n]");
    };
    MagicString.prototype.trim = function trim(charType) {
      return this.trimStart(charType).trimEnd(charType);
    };
    MagicString.prototype.trimEndAborted = function trimEndAborted(charType) {
      var rx = new RegExp((charType || "\\s") + "+$");
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length) {
        return true;
      }
      var chunk = this.lastChunk;
      do {
        var end = chunk.end;
        var aborted = chunk.trimEnd(rx);
        if (chunk.end !== end) {
          if (this.lastChunk === chunk) {
            this.lastChunk = chunk.next;
          }
          this.byEnd[chunk.end] = chunk;
          this.byStart[chunk.next.start] = chunk.next;
          this.byEnd[chunk.next.end] = chunk.next;
        }
        if (aborted) {
          return true;
        }
        chunk = chunk.previous;
      } while (chunk);
      return false;
    };
    MagicString.prototype.trimEnd = function trimEnd(charType) {
      this.trimEndAborted(charType);
      return this;
    };
    MagicString.prototype.trimStartAborted = function trimStartAborted(charType) {
      var rx = new RegExp("^" + (charType || "\\s") + "+");
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length) {
        return true;
      }
      var chunk = this.firstChunk;
      do {
        var end = chunk.end;
        var aborted = chunk.trimStart(rx);
        if (chunk.end !== end) {
          if (chunk === this.lastChunk) {
            this.lastChunk = chunk.next;
          }
          this.byEnd[chunk.end] = chunk;
          this.byStart[chunk.next.start] = chunk.next;
          this.byEnd[chunk.next.end] = chunk.next;
        }
        if (aborted) {
          return true;
        }
        chunk = chunk.next;
      } while (chunk);
      return false;
    };
    MagicString.prototype.trimStart = function trimStart(charType) {
      this.trimStartAborted(charType);
      return this;
    };
    function Mime$1() {
      this._types = Object.create(null);
      this._extensions = Object.create(null);
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.define(arguments[i2]);
      }
      this.define = this.define.bind(this);
      this.getType = this.getType.bind(this);
      this.getExtension = this.getExtension.bind(this);
    }
    Mime$1.prototype.define = function(typeMap, force) {
      for (let type in typeMap) {
        let extensions2 = typeMap[type].map(function(t) {
          return t.toLowerCase();
        });
        type = type.toLowerCase();
        for (let i2 = 0; i2 < extensions2.length; i2++) {
          const ext2 = extensions2[i2];
          if (ext2[0] === "*") {
            continue;
          }
          if (!force && ext2 in this._types) {
            throw new Error('Attempt to change mapping for "' + ext2 + '" extension from "' + this._types[ext2] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext2 + '" from the list of extensions for "' + type + '".');
          }
          this._types[ext2] = type;
        }
        if (force || !this._extensions[type]) {
          const ext2 = extensions2[0];
          this._extensions[type] = ext2[0] !== "*" ? ext2 : ext2.substr(1);
        }
      }
    };
    Mime$1.prototype.getType = function(path2) {
      path2 = String(path2);
      let last = path2.replace(/^.*[/\\]/, "").toLowerCase();
      let ext2 = last.replace(/^.*\./, "").toLowerCase();
      let hasPath = last.length < path2.length;
      let hasDot = ext2.length < last.length - 1;
      return (hasDot || !hasPath) && this._types[ext2] || null;
    };
    Mime$1.prototype.getExtension = function(type) {
      type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
      return type && this._extensions[type.toLowerCase()] || null;
    };
    var Mime_1 = Mime$1;
    var standard = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
    var Mime = Mime_1;
    var lite = new Mime(standard);
    var assetUrlRE = /__VITE_ASSET__([a-z\d]{8})__(?:\$_(.*?)__)?/g;
    var rawRE = /(\?|&)raw(?:&|$)/;
    var urlRE = /(\?|&)url(?:&|$)/;
    var chunkToEmittedAssetsMap = new WeakMap();
    var assetCache = new WeakMap();
    var assetHashToFilenameMap = new WeakMap();
    var emittedHashMap = new WeakMap();
    function assetPlugin(config2) {
      assetHashToFilenameMap.set(config2, new Map());
      return {
        name: "vite:asset",
        buildStart() {
          assetCache.set(config2, new Map());
          emittedHashMap.set(config2, new Set());
        },
        resolveId(id) {
          if (!config2.assetsInclude(cleanUrl(id))) {
            return;
          }
          const publicFile = checkPublicFile(id, config2);
          if (publicFile) {
            return id;
          }
        },
        async load(id) {
          if (id.startsWith("\0")) {
            return;
          }
          if (rawRE.test(id)) {
            const file = checkPublicFile(id, config2) || cleanUrl(id);
            return `export default ${JSON.stringify(await fs$r.promises.readFile(file, "utf-8"))}`;
          }
          if (!config2.assetsInclude(cleanUrl(id)) && !urlRE.test(id)) {
            return;
          }
          id = id.replace(urlRE, "$1").replace(/[\?&]$/, "");
          const url2 = await fileToUrl(id, config2, this);
          return `export default ${JSON.stringify(url2)}`;
        },
        renderChunk(code, chunk) {
          let match2;
          let s2;
          while (match2 = assetUrlRE.exec(code)) {
            s2 = s2 || (s2 = new MagicString(code));
            const [full, hash, postfix = ""] = match2;
            const file = getAssetFilename(hash, config2) || this.getFileName(hash);
            registerAssetToChunk(chunk, file);
            const outputFilepath = config2.base + file + postfix;
            s2.overwrite(match2.index, match2.index + full.length, outputFilepath);
          }
          if (s2) {
            return {
              code: s2.toString(),
              map: config2.build.sourcemap ? s2.generateMap({ hires: true }) : null
            };
          } else {
            return null;
          }
        },
        generateBundle(_2, bundle) {
          if (config2.command === "build" && config2.build.ssr) {
            for (const file in bundle) {
              if (bundle[file].type === "asset" && !file.includes("ssr-manifest.json")) {
                delete bundle[file];
              }
            }
          }
        }
      };
    }
    function registerAssetToChunk(chunk, file) {
      let emitted = chunkToEmittedAssetsMap.get(chunk);
      if (!emitted) {
        emitted = new Set();
        chunkToEmittedAssetsMap.set(chunk, emitted);
      }
      emitted.add(cleanUrl(file));
    }
    function checkPublicFile(url2, { publicDir }) {
      if (!publicDir || !url2.startsWith("/")) {
        return;
      }
      const publicFile = path__default.join(publicDir, cleanUrl(url2));
      if (fs__default.existsSync(publicFile)) {
        return publicFile;
      } else {
        return;
      }
    }
    function fileToUrl(id, config2, ctx) {
      if (config2.command === "serve") {
        return fileToDevUrl(id, config2);
      } else {
        return fileToBuiltUrl(id, config2, ctx);
      }
    }
    function fileToDevUrl(id, config2) {
      var _a2, _b;
      let rtn;
      if (checkPublicFile(id, config2)) {
        rtn = id;
      } else if (id.startsWith(config2.root)) {
        rtn = "/" + path__default.posix.relative(config2.root, id);
      } else {
        rtn = path__default.posix.join(FS_PREFIX + id);
      }
      const origin = (_b = (_a2 = config2.server) === null || _a2 === void 0 ? void 0 : _a2.origin) !== null && _b !== void 0 ? _b : "";
      return origin + config2.base + rtn.replace(/^\//, "");
    }
    function getAssetFilename(hash, config2) {
      var _a2;
      return (_a2 = assetHashToFilenameMap.get(config2)) === null || _a2 === void 0 ? void 0 : _a2.get(hash);
    }
    function assetFileNamesToFileName(assetFileNames, file, contentHash, content2) {
      const basename = path__default.basename(file);
      const extname = path__default.extname(basename);
      const ext2 = extname.substring(1);
      const name = basename.slice(0, -extname.length);
      const hash = contentHash;
      if (typeof assetFileNames === "function") {
        assetFileNames = assetFileNames({
          name: file,
          source: content2,
          type: "asset"
        });
        if (typeof assetFileNames !== "string") {
          throw new TypeError("assetFileNames must return a string");
        }
      } else if (typeof assetFileNames !== "string") {
        throw new TypeError("assetFileNames must be a string or a function");
      }
      const fileName = assetFileNames.replace(/\[\w+\]/g, (placeholder) => {
        switch (placeholder) {
          case "[ext]":
            return ext2;
          case "[extname]":
            return extname;
          case "[hash]":
            return hash;
          case "[name]":
            return name;
        }
        throw new Error(`invalid placeholder ${placeholder} in assetFileNames "${assetFileNames}"`);
      });
      return fileName;
    }
    async function fileToBuiltUrl(id, config2, pluginContext, skipPublicCheck = false) {
      var _a2, _b, _c;
      if (!skipPublicCheck && checkPublicFile(id, config2)) {
        return config2.base + id.slice(1);
      }
      const cache2 = assetCache.get(config2);
      const cached = cache2.get(id);
      if (cached) {
        return cached;
      }
      const file = cleanUrl(id);
      const content2 = await fs$r.promises.readFile(file);
      let url2;
      if (config2.build.lib || !file.endsWith(".svg") && content2.length < Number(config2.build.assetsInlineLimit)) {
        url2 = `data:${lite.getType(file)};base64,${content2.toString("base64")}`;
      } else {
        const map2 = assetHashToFilenameMap.get(config2);
        const contentHash = getAssetHash(content2);
        const { search, hash } = require$$0$6.parse(id);
        const postfix = (search || "") + (hash || "");
        const output = (_b = (_a2 = config2.build) === null || _a2 === void 0 ? void 0 : _a2.rollupOptions) === null || _b === void 0 ? void 0 : _b.output;
        const assetFileNames = (_c = output && !Array.isArray(output) ? output.assetFileNames : void 0) !== null && _c !== void 0 ? _c : path__default.posix.join(config2.build.assetsDir, "[name].[hash][extname]");
        const fileName = assetFileNamesToFileName(assetFileNames, file, contentHash, content2);
        if (!map2.has(contentHash)) {
          map2.set(contentHash, fileName);
        }
        const emittedSet = emittedHashMap.get(config2);
        if (!emittedSet.has(contentHash)) {
          const name = normalizePath$4(path__default.relative(config2.root, file));
          pluginContext.emitFile({
            name,
            fileName,
            type: "asset",
            source: content2
          });
          emittedSet.add(contentHash);
        }
        url2 = `__VITE_ASSET__${contentHash}__${postfix ? `$_${postfix}__` : ``}`;
      }
      cache2.set(id, url2);
      return url2;
    }
    function getAssetHash(content2) {
      return require$$1$1.createHash("sha256").update(content2).digest("hex").slice(0, 8);
    }
    async function urlToBuiltUrl(url2, importer, config2, pluginContext) {
      if (checkPublicFile(url2, config2)) {
        return config2.base + url2.slice(1);
      }
      const file = url2.startsWith("/") ? path__default.join(config2.root, url2) : path__default.join(path__default.dirname(importer), url2);
      return fileToBuiltUrl(file, config2, pluginContext, true);
    }
    var tasks = {};
    var utils$k = {};
    var array$1 = {};
    Object.defineProperty(array$1, "__esModule", { value: true });
    array$1.splitWhen = array$1.flatten = void 0;
    function flatten$1(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    array$1.flatten = flatten$1;
    function splitWhen(items, predicate) {
      const result2 = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result2[groupIndex] = [];
        } else {
          result2[groupIndex].push(item);
        }
      }
      return result2;
    }
    array$1.splitWhen = splitWhen;
    var errno$1 = {};
    Object.defineProperty(errno$1, "__esModule", { value: true });
    errno$1.isEnoentCodeError = void 0;
    function isEnoentCodeError(error2) {
      return error2.code === "ENOENT";
    }
    errno$1.isEnoentCodeError = isEnoentCodeError;
    var fs$q = {};
    Object.defineProperty(fs$q, "__esModule", { value: true });
    fs$q.createDirentFromStats = void 0;
    var DirentFromStats$1 = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats$1(name, stats) {
      return new DirentFromStats$1(name, stats);
    }
    fs$q.createDirentFromStats = createDirentFromStats$1;
    var path$s = {};
    Object.defineProperty(path$s, "__esModule", { value: true });
    path$s.removeLeadingDotSegment = path$s.escape = path$s.makeAbsolute = path$s.unixify = void 0;
    var path$r = path__default;
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    path$s.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path$r.resolve(cwd, filepath);
    }
    path$s.makeAbsolute = makeAbsolute;
    function escape$1(pattern2) {
      return pattern2.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    path$s.escape = escape$1;
    function removeLeadingDotSegment(entry2) {
      if (entry2.charAt(0) === ".") {
        const secondCharactery = entry2.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry2.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry2;
    }
    path$s.removeLeadingDotSegment = removeLeadingDotSegment;
    var pattern$1 = {};
    var isExtglob$1 = function isExtglob2(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match2;
      while (match2 = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match2[2])
          return true;
        str = str.slice(match2.index + match2[0].length);
      }
      return false;
    };
    var isExtglob = isExtglob$1;
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index2 = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index2 < str.length) {
        if (str[index2] === "*") {
          return true;
        }
        if (str[index2 + 1] === "?" && /[\].+)]/.test(str[index2])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index2] === "[" && str[index2 + 1] !== "]") {
          if (closeSquareIndex < index2) {
            closeSquareIndex = str.indexOf("]", index2);
          }
          if (closeSquareIndex > index2) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index2);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index2] === "{" && str[index2 + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index2);
          if (closeCurlyIndex > index2) {
            backSlashIndex = str.indexOf("\\", index2);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index2] === "(" && str[index2 + 1] === "?" && /[:!=]/.test(str[index2 + 2]) && str[index2 + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index2);
          if (closeParenIndex > index2) {
            backSlashIndex = str.indexOf("\\", index2);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index2] === "(" && str[index2 + 1] !== "|") {
          if (pipeIndex < index2) {
            pipeIndex = str.indexOf("|", index2);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index2] === "\\") {
          var open2 = str[index2 + 1];
          index2 += 2;
          var close2 = chars[open2];
          if (close2) {
            var n3 = str.indexOf(close2, index2);
            if (n3 !== -1) {
              index2 = n3 + 1;
            }
          }
          if (str[index2] === "!") {
            return true;
          }
        } else {
          index2++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index2 = 0;
      while (index2 < str.length) {
        if (/[*?{}()[\]]/.test(str[index2])) {
          return true;
        }
        if (str[index2] === "\\") {
          var open2 = str[index2 + 1];
          index2 += 2;
          var close2 = chars[open2];
          if (close2) {
            var n3 = str.indexOf(close2, index2);
            if (n3 !== -1) {
              index2 = n3 + 1;
            }
          }
          if (str[index2] === "!") {
            return true;
          }
        } else {
          index2++;
        }
      }
      return false;
    };
    var isGlob$2 = function isGlob2(str, options2) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options2 && options2.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
    var isGlob$1 = isGlob$2;
    var pathPosixDirname = path__default.posix.dirname;
    var isWin32 = require$$0__default$1.platform() === "win32";
    var slash$2 = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby$2 = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    var globParent$2 = function globParent2(str, opts) {
      var options2 = Object.assign({ flipBackslashes: true }, opts);
      if (options2.flipBackslashes && isWin32 && str.indexOf(slash$2) < 0) {
        str = str.replace(backslash, slash$2);
      }
      if (enclosure.test(str)) {
        str += slash$2;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob$1(str) || globby$2.test(str));
      return str.replace(escaped, "$1");
    };
    var utils$j = {};
    (function(exports2) {
      exports2.isInteger = (num) => {
        if (typeof num === "number") {
          return Number.isInteger(num);
        }
        if (typeof num === "string" && num.trim() !== "") {
          return Number.isInteger(Number(num));
        }
        return false;
      };
      exports2.find = (node2, type) => node2.nodes.find((node3) => node3.type === type);
      exports2.exceedsLimit = (min2, max, step = 1, limit) => {
        if (limit === false)
          return false;
        if (!exports2.isInteger(min2) || !exports2.isInteger(max))
          return false;
        return (Number(max) - Number(min2)) / Number(step) >= limit;
      };
      exports2.escapeNode = (block, n3 = 0, type) => {
        let node2 = block.nodes[n3];
        if (!node2)
          return;
        if (type && node2.type === type || node2.type === "open" || node2.type === "close") {
          if (node2.escaped !== true) {
            node2.value = "\\" + node2.value;
            node2.escaped = true;
          }
        }
      };
      exports2.encloseBrace = (node2) => {
        if (node2.type !== "brace")
          return false;
        if (node2.commas >> 0 + node2.ranges >> 0 === 0) {
          node2.invalid = true;
          return true;
        }
        return false;
      };
      exports2.isInvalidBrace = (block) => {
        if (block.type !== "brace")
          return false;
        if (block.invalid === true || block.dollar)
          return true;
        if (block.commas >> 0 + block.ranges >> 0 === 0) {
          block.invalid = true;
          return true;
        }
        if (block.open !== true || block.close !== true) {
          block.invalid = true;
          return true;
        }
        return false;
      };
      exports2.isOpenOrClose = (node2) => {
        if (node2.type === "open" || node2.type === "close") {
          return true;
        }
        return node2.open === true || node2.close === true;
      };
      exports2.reduce = (nodes) => nodes.reduce((acc, node2) => {
        if (node2.type === "text")
          acc.push(node2.value);
        if (node2.type === "range")
          node2.type = "text";
        return acc;
      }, []);
      exports2.flatten = (...args) => {
        const result2 = [];
        const flat = (arr) => {
          for (let i2 = 0; i2 < arr.length; i2++) {
            let ele = arr[i2];
            Array.isArray(ele) ? flat(ele) : ele !== void 0 && result2.push(ele);
          }
          return result2;
        };
        flat(args);
        return result2;
      };
    })(utils$j);
    var utils$i = utils$j;
    var stringify$7 = (ast, options2 = {}) => {
      let stringify2 = (node2, parent = {}) => {
        let invalidBlock = options2.escapeInvalid && utils$i.isInvalidBrace(parent);
        let invalidNode = node2.invalid === true && options2.escapeInvalid === true;
        let output = "";
        if (node2.value) {
          if ((invalidBlock || invalidNode) && utils$i.isOpenOrClose(node2)) {
            return "\\" + node2.value;
          }
          return node2.value;
        }
        if (node2.value) {
          return node2.value;
        }
        if (node2.nodes) {
          for (let child of node2.nodes) {
            output += stringify2(child);
          }
        }
        return output;
      };
      return stringify2(ast);
    };
    var isNumber$2 = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
    var isNumber$1 = isNumber$2;
    var toRegexRange$1 = (min2, max, options2) => {
      if (isNumber$1(min2) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min2 === max) {
        return String(min2);
      }
      if (isNumber$1(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = __spreadValues2({ relaxZeros: true }, options2);
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap2 = String(opts.wrap);
      let cacheKey = min2 + ":" + max + "=" + relax + shorthand + capture + wrap2;
      if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange$1.cache[cacheKey].result;
      }
      let a2 = Math.min(min2, max);
      let b2 = Math.max(min2, max);
      if (Math.abs(a2 - b2) === 1) {
        let result2 = min2 + "|" + max;
        if (opts.capture) {
          return `(${result2})`;
        }
        if (opts.wrap === false) {
          return result2;
        }
        return `(?:${result2})`;
      }
      let isPadded2 = hasPadding(min2) || hasPadding(max);
      let state = { min: min2, max, a: a2, b: b2 };
      let positives = [];
      let negatives = [];
      if (isPadded2) {
        state.isPadded = isPadded2;
        state.maxLen = String(state.max).length;
      }
      if (a2 < 0) {
        let newMin = b2 < 0 ? Math.abs(b2) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a2), state, opts);
        a2 = state.a = 0;
      }
      if (b2 >= 0) {
        positives = splitToPatterns(a2, b2, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange$1.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options2) {
      let onlyNegative = filterPatterns(neg, pos, "-", false) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false) || [];
      let intersected = filterPatterns(neg, pos, "-?", true) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min2, max) {
      let nines = 1;
      let zeros2 = 1;
      let stop = countNines(min2, nines);
      let stops = new Set([max]);
      while (min2 <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min2, nines);
      }
      stop = countZeros(max + 1, zeros2) - 1;
      while (min2 < stop && stop <= max) {
        stops.add(stop);
        zeros2 += 1;
        stop = countZeros(max + 1, zeros2) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options2) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern2 = "";
      let count = 0;
      for (let i2 = 0; i2 < digits; i2++) {
        let [startDigit, stopDigit] = zipped[i2];
        if (startDigit === stopDigit) {
          pattern2 += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern2 += toCharacterClass(startDigit, stopDigit);
        } else {
          count++;
        }
      }
      if (count) {
        pattern2 += options2.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern: pattern2, count: [count], digits };
    }
    function splitToPatterns(min2, max, tok, options2) {
      let ranges = splitToRanges(min2, max);
      let tokens = [];
      let start = min2;
      let prev;
      for (let i2 = 0; i2 < ranges.length; i2++) {
        let max2 = ranges[i2];
        let obj = rangeToPattern(String(start), String(max2), options2);
        let zeros2 = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros2 = padZeros(max2, tok, options2);
        }
        obj.string = zeros2 + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options2) {
      let result2 = [];
      for (let ele of arr) {
        let { string: string2 } = ele;
        if (!intersection && !contains(comparison, "string", string2)) {
          result2.push(prefix + string2);
        }
        if (intersection && contains(comparison, "string", string2)) {
          result2.push(prefix + string2);
        }
      }
      return result2;
    }
    function zip(a2, b2) {
      let arr = [];
      for (let i2 = 0; i2 < a2.length; i2++)
        arr.push([a2[i2], b2[i2]]);
      return arr;
    }
    function compare(a2, b2) {
      return a2 > b2 ? 1 : b2 > a2 ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min2, len) {
      return Number(String(min2).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros2) {
      return integer - integer % Math.pow(10, zeros2);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a2, b2, options2) {
      return `[${a2}${b2 - a2 === 1 ? "" : "-"}${b2}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options2) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options2.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange$1.cache = {};
    toRegexRange$1.clearCache = () => toRegexRange$1.cache = {};
    var toRegexRange_1 = toRegexRange$1;
    var util$8 = require$$0__default$2;
    var toRegexRange = toRegexRange_1;
    var isObject$1 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index2 = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index2] === "0")
        ;
      return index2 > 0;
    };
    var stringify$6 = (start, end, options2) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options2.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options2) => {
      parts.negatives.sort((a2, b2) => a2 < b2 ? -1 : a2 > b2 ? 1 : 0);
      parts.positives.sort((a2, b2) => a2 < b2 ? -1 : a2 > b2 ? 1 : 0);
      let prefix = options2.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result2;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result2 = `${positives}|${negatives}`;
      } else {
        result2 = positives || negatives;
      }
      if (options2.wrap) {
        return `(${prefix}${result2})`;
      }
      return result2;
    };
    var toRange = (a2, b2, isNumbers, options2) => {
      if (isNumbers) {
        return toRegexRange(a2, b2, __spreadValues2({ wrap: false }, options2));
      }
      let start = String.fromCharCode(a2);
      if (a2 === b2)
        return start;
      let stop = String.fromCharCode(b2);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options2) => {
      if (Array.isArray(start)) {
        let wrap2 = options2.wrap === true;
        let prefix = options2.capture ? "" : "?:";
        return wrap2 ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options2);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util$8.inspect(...args));
    };
    var invalidRange = (start, end, options2) => {
      if (options2.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options2) => {
      if (options2.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options2 = {}) => {
      let a2 = Number(start);
      let b2 = Number(end);
      if (!Number.isInteger(a2) || !Number.isInteger(b2)) {
        if (options2.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a2 === 0)
        a2 = 0;
      if (b2 === 0)
        b2 = 0;
      let descending = a2 > b2;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify$6(start, end, options2) === false;
      let format2 = options2.transform || transform(toNumber);
      if (options2.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options2);
      }
      let parts = { negatives: [], positives: [] };
      let push2 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range2 = [];
      let index2 = 0;
      while (descending ? a2 >= b2 : a2 <= b2) {
        if (options2.toRegex === true && step > 1) {
          push2(a2);
        } else {
          range2.push(pad(format2(a2, index2), maxLen, toNumber));
        }
        a2 = descending ? a2 - step : a2 + step;
        index2++;
      }
      if (options2.toRegex === true) {
        return step > 1 ? toSequence(parts, options2) : toRegex(range2, null, __spreadValues2({ wrap: false }, options2));
      }
      return range2;
    };
    var fillLetters = (start, end, step = 1, options2 = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options2);
      }
      let format2 = options2.transform || ((val) => String.fromCharCode(val));
      let a2 = `${start}`.charCodeAt(0);
      let b2 = `${end}`.charCodeAt(0);
      let descending = a2 > b2;
      let min2 = Math.min(a2, b2);
      let max = Math.max(a2, b2);
      if (options2.toRegex && step === 1) {
        return toRange(min2, max, false, options2);
      }
      let range2 = [];
      let index2 = 0;
      while (descending ? a2 >= b2 : a2 <= b2) {
        range2.push(format2(a2, index2));
        a2 = descending ? a2 - step : a2 + step;
        index2++;
      }
      if (options2.toRegex === true) {
        return toRegex(range2, null, { wrap: false, options: options2 });
      }
      return range2;
    };
    var fill$2 = (start, end, step, options2 = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options2);
      }
      if (typeof step === "function") {
        return fill$2(start, end, 1, { transform: step });
      }
      if (isObject$1(step)) {
        return fill$2(start, end, 0, step);
      }
      let opts = __spreadValues2({}, options2);
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject$1(step))
          return invalidStep(step, opts);
        return fill$2(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    var fillRange = fill$2;
    var fill$1 = fillRange;
    var utils$h = utils$j;
    var compile$1 = (ast, options2 = {}) => {
      let walk2 = (node2, parent = {}) => {
        let invalidBlock = utils$h.isInvalidBrace(parent);
        let invalidNode = node2.invalid === true && options2.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options2.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node2.isOpen === true) {
          return prefix + node2.value;
        }
        if (node2.isClose === true) {
          return prefix + node2.value;
        }
        if (node2.type === "open") {
          return invalid ? prefix + node2.value : "(";
        }
        if (node2.type === "close") {
          return invalid ? prefix + node2.value : ")";
        }
        if (node2.type === "comma") {
          return node2.prev.type === "comma" ? "" : invalid ? node2.value : "|";
        }
        if (node2.value) {
          return node2.value;
        }
        if (node2.nodes && node2.ranges > 0) {
          let args = utils$h.reduce(node2.nodes);
          let range2 = fill$1(...args, __spreadProps2(__spreadValues2({}, options2), { wrap: false, toRegex: true }));
          if (range2.length !== 0) {
            return args.length > 1 && range2.length > 1 ? `(${range2})` : range2;
          }
        }
        if (node2.nodes) {
          for (let child of node2.nodes) {
            output += walk2(child, node2);
          }
        }
        return output;
      };
      return walk2(ast);
    };
    var compile_1 = compile$1;
    var fill = fillRange;
    var stringify$5 = stringify$7;
    var utils$g = utils$j;
    var append$1 = (queue2 = "", stash = "", enclose = false) => {
      let result2 = [];
      queue2 = [].concat(queue2);
      stash = [].concat(stash);
      if (!stash.length)
        return queue2;
      if (!queue2.length) {
        return enclose ? utils$g.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue2) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result2.push(append$1(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result2.push(Array.isArray(ele) ? append$1(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils$g.flatten(result2);
    };
    var expand$3 = (ast, options2 = {}) => {
      let rangeLimit = options2.rangeLimit === void 0 ? 1e3 : options2.rangeLimit;
      let walk2 = (node2, parent = {}) => {
        node2.queue = [];
        let p2 = parent;
        let q2 = parent.queue;
        while (p2.type !== "brace" && p2.type !== "root" && p2.parent) {
          p2 = p2.parent;
          q2 = p2.queue;
        }
        if (node2.invalid || node2.dollar) {
          q2.push(append$1(q2.pop(), stringify$5(node2, options2)));
          return;
        }
        if (node2.type === "brace" && node2.invalid !== true && node2.nodes.length === 2) {
          q2.push(append$1(q2.pop(), ["{}"]));
          return;
        }
        if (node2.nodes && node2.ranges > 0) {
          let args = utils$g.reduce(node2.nodes);
          if (utils$g.exceedsLimit(...args, options2.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range2 = fill(...args, options2);
          if (range2.length === 0) {
            range2 = stringify$5(node2, options2);
          }
          q2.push(append$1(q2.pop(), range2));
          node2.nodes = [];
          return;
        }
        let enclose = utils$g.encloseBrace(node2);
        let queue2 = node2.queue;
        let block = node2;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue2 = block.queue;
        }
        for (let i2 = 0; i2 < node2.nodes.length; i2++) {
          let child = node2.nodes[i2];
          if (child.type === "comma" && node2.type === "brace") {
            if (i2 === 1)
              queue2.push("");
            queue2.push("");
            continue;
          }
          if (child.type === "close") {
            q2.push(append$1(q2.pop(), queue2, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue2.push(append$1(queue2.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk2(child, node2);
          }
        }
        return queue2;
      };
      return utils$g.flatten(walk2(ast));
    };
    var expand_1 = expand$3;
    var constants$6 = {
      MAX_LENGTH: 1024 * 64,
      CHAR_0: "0",
      CHAR_9: "9",
      CHAR_UPPERCASE_A: "A",
      CHAR_LOWERCASE_A: "a",
      CHAR_UPPERCASE_Z: "Z",
      CHAR_LOWERCASE_Z: "z",
      CHAR_LEFT_PARENTHESES: "(",
      CHAR_RIGHT_PARENTHESES: ")",
      CHAR_ASTERISK: "*",
      CHAR_AMPERSAND: "&",
      CHAR_AT: "@",
      CHAR_BACKSLASH: "\\",
      CHAR_BACKTICK: "`",
      CHAR_CARRIAGE_RETURN: "\r",
      CHAR_CIRCUMFLEX_ACCENT: "^",
      CHAR_COLON: ":",
      CHAR_COMMA: ",",
      CHAR_DOLLAR: "$",
      CHAR_DOT: ".",
      CHAR_DOUBLE_QUOTE: '"',
      CHAR_EQUAL: "=",
      CHAR_EXCLAMATION_MARK: "!",
      CHAR_FORM_FEED: "\f",
      CHAR_FORWARD_SLASH: "/",
      CHAR_HASH: "#",
      CHAR_HYPHEN_MINUS: "-",
      CHAR_LEFT_ANGLE_BRACKET: "<",
      CHAR_LEFT_CURLY_BRACE: "{",
      CHAR_LEFT_SQUARE_BRACKET: "[",
      CHAR_LINE_FEED: "\n",
      CHAR_NO_BREAK_SPACE: "\xA0",
      CHAR_PERCENT: "%",
      CHAR_PLUS: "+",
      CHAR_QUESTION_MARK: "?",
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      CHAR_RIGHT_CURLY_BRACE: "}",
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      CHAR_SEMICOLON: ";",
      CHAR_SINGLE_QUOTE: "'",
      CHAR_SPACE: " ",
      CHAR_TAB: "	",
      CHAR_UNDERSCORE: "_",
      CHAR_VERTICAL_LINE: "|",
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    };
    var stringify$4 = stringify$7;
    var {
      MAX_LENGTH: MAX_LENGTH$1,
      CHAR_BACKSLASH,
      CHAR_BACKTICK,
      CHAR_COMMA: CHAR_COMMA$1,
      CHAR_DOT: CHAR_DOT$1,
      CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1,
      CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1,
      CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1,
      CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1,
      CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1,
      CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1,
      CHAR_DOUBLE_QUOTE,
      CHAR_SINGLE_QUOTE,
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = constants$6;
    var parse$l = (input, options2 = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options2 || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index2 = 0;
      let depth2 = 0;
      let value;
      const advance = () => input[index2++];
      const push2 = (node2) => {
        if (node2.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node2.type === "text") {
          prev.value += node2.value;
          return;
        }
        block.nodes.push(node2);
        node2.parent = block;
        node2.prev = prev;
        prev = node2;
        return node2;
      };
      push2({ type: "bos" });
      while (index2 < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push2({ type: "text", value: (options2.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET$1) {
          push2({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET$1) {
          brackets++;
          let next;
          while (index2 < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET$1) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push2({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES$1) {
          block = push2({ type: "paren", nodes: [] });
          stack.push(block);
          push2({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES$1) {
          if (block.type !== "paren") {
            push2({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push2({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open2 = value;
          let next;
          if (options2.keepQuotes !== true) {
            value = "";
          }
          while (index2 < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open2) {
              if (options2.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push2({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE$1) {
          depth2++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth: depth2,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push2(brace);
          stack.push(block);
          push2({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE$1) {
          if (block.type !== "brace") {
            push2({ type: "text", value });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push2({ type, value });
          depth2--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA$1 && depth2 > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open2 = block.nodes.shift();
            block.nodes = [open2, { type: "text", value: stringify$4(block) }];
          }
          push2({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT$1 && depth2 > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth2 === 0 || siblings.length === 0) {
            push2({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push2({ type: "dot", value });
          continue;
        }
        push2({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node2) => {
            if (!node2.nodes) {
              if (node2.type === "open")
                node2.isOpen = true;
              if (node2.type === "close")
                node2.isClose = true;
              if (!node2.nodes)
                node2.type = "text";
              node2.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index3 = parent.nodes.indexOf(block);
          parent.nodes.splice(index3, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push2({ type: "eos" });
      return ast;
    };
    var parse_1$2 = parse$l;
    var stringify$3 = stringify$7;
    var compile = compile_1;
    var expand$2 = expand_1;
    var parse$k = parse_1$2;
    var braces$2 = (input, options2 = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern2 of input) {
          let result2 = braces$2.create(pattern2, options2);
          if (Array.isArray(result2)) {
            output.push(...result2);
          } else {
            output.push(result2);
          }
        }
      } else {
        output = [].concat(braces$2.create(input, options2));
      }
      if (options2 && options2.expand === true && options2.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces$2.parse = (input, options2 = {}) => parse$k(input, options2);
    braces$2.stringify = (input, options2 = {}) => {
      if (typeof input === "string") {
        return stringify$3(braces$2.parse(input, options2), options2);
      }
      return stringify$3(input, options2);
    };
    braces$2.compile = (input, options2 = {}) => {
      if (typeof input === "string") {
        input = braces$2.parse(input, options2);
      }
      return compile(input, options2);
    };
    braces$2.expand = (input, options2 = {}) => {
      if (typeof input === "string") {
        input = braces$2.parse(input, options2);
      }
      let result2 = expand$2(input, options2);
      if (options2.noempty === true) {
        result2 = result2.filter(Boolean);
      }
      if (options2.nodupes === true) {
        result2 = [...new Set(result2)];
      }
      return result2;
    };
    braces$2.create = (input, options2 = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options2.expand !== true ? braces$2.compile(input, options2) : braces$2.expand(input, options2);
    };
    var braces_1 = braces$2;
    var utils$f = {};
    var path$q = path__default;
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR$1 = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR: STAR$1,
      START_ANCHOR
    };
    var WINDOWS_CHARS = __spreadProps2(__spreadValues2({}, POSIX_CHARS), {
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    });
    var POSIX_REGEX_SOURCE$1 = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    var constants$5 = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      CHAR_0: 48,
      CHAR_9: 57,
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_LEFT_PARENTHESES: 40,
      CHAR_RIGHT_PARENTHESES: 41,
      CHAR_ASTERISK: 42,
      CHAR_AMPERSAND: 38,
      CHAR_AT: 64,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_COLON: 58,
      CHAR_COMMA: 44,
      CHAR_DOT: 46,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_EQUAL: 61,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_FORM_FEED: 12,
      CHAR_FORWARD_SLASH: 47,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_HASH: 35,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_LEFT_CURLY_BRACE: 123,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_LINE_FEED: 10,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_PERCENT: 37,
      CHAR_PLUS: 43,
      CHAR_QUESTION_MARK: 63,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_RIGHT_CURLY_BRACE: 125,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_SEMICOLON: 59,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_SPACE: 32,
      CHAR_TAB: 9,
      CHAR_UNDERSCORE: 95,
      CHAR_VERTICAL_LINE: 124,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      SEP: path$q.sep,
      extglobChars(chars2) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars2.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      globChars(win322) {
        return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
    (function(exports2) {
      const path2 = path__default;
      const win322 = process.platform === "win32";
      const {
        REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL
      } = constants$5;
      exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
      exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
      exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
      exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
      exports2.removeBackslashes = (str) => {
        return str.replace(REGEX_REMOVE_BACKSLASH, (match2) => {
          return match2 === "\\" ? "" : match2;
        });
      };
      exports2.supportsLookbehinds = () => {
        const segs = process.version.slice(1).split(".").map(Number);
        if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
          return true;
        }
        return false;
      };
      exports2.isWindows = (options2) => {
        if (options2 && typeof options2.windows === "boolean") {
          return options2.windows;
        }
        return win322 === true || path2.sep === "\\";
      };
      exports2.escapeLast = (input, char, lastIdx) => {
        const idx = input.lastIndexOf(char, lastIdx);
        if (idx === -1)
          return input;
        if (input[idx - 1] === "\\")
          return exports2.escapeLast(input, char, idx - 1);
        return `${input.slice(0, idx)}\\${input.slice(idx)}`;
      };
      exports2.removePrefix = (input, state = {}) => {
        let output = input;
        if (output.startsWith("./")) {
          output = output.slice(2);
          state.prefix = "./";
        }
        return output;
      };
      exports2.wrapOutput = (input, state = {}, options2 = {}) => {
        const prepend = options2.contains ? "" : "^";
        const append2 = options2.contains ? "" : "$";
        let output = `${prepend}(?:${input})${append2}`;
        if (state.negated === true) {
          output = `(?:^(?!${output}).*$)`;
        }
        return output;
      };
    })(utils$f);
    var utils$e = utils$f;
    var {
      CHAR_ASTERISK,
      CHAR_AT,
      CHAR_BACKWARD_SLASH,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_EXCLAMATION_MARK,
      CHAR_FORWARD_SLASH,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_LEFT_PARENTHESES,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_PLUS,
      CHAR_QUESTION_MARK,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_RIGHT_PARENTHESES,
      CHAR_RIGHT_SQUARE_BRACKET
    } = constants$5;
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan$1 = (input, options2) => {
      const opts = options2 || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index2 = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob2 = false;
      let isExtglob2 = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces2 = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index2 >= length;
      const peek = () => str.charCodeAt(index2 + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index2);
      };
      while (index2 < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces2++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces2++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob2 = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob2 = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces2--;
              if (braces2 === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index2);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index2 === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index2 + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob2 = token.isGlob = true;
            isExtglob2 = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index2 === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob2 = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob2 = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob2 = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob2 = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index2 === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob2 = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob2 === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob2 = false;
        isGlob2 = false;
      }
      let base2 = str;
      let prefix = "";
      let glob2 = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base2 && isGlob2 === true && lastIndex > 0) {
        base2 = str.slice(0, lastIndex);
        glob2 = str.slice(lastIndex);
      } else if (isGlob2 === true) {
        base2 = "";
        glob2 = str;
      } else {
        base2 = str;
      }
      if (base2 && base2 !== "" && base2 !== "/" && base2 !== str) {
        if (isPathSeparator(base2.charCodeAt(base2.length - 1))) {
          base2 = base2.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob2)
          glob2 = utils$e.removeBackslashes(glob2);
        if (base2 && backslashes === true) {
          base2 = utils$e.removeBackslashes(base2);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base: base2,
        glob: glob2,
        isBrace,
        isBracket,
        isGlob: isGlob2,
        isExtglob: isExtglob2,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n3 = prevIndex ? prevIndex + 1 : start;
          const i2 = slashes[idx];
          const value = input.slice(n3, i2);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i2;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    var scan_1 = scan$1;
    var constants$4 = constants$5;
    var utils$d = utils$f;
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants$4;
    var expandRange = (args, options2) => {
      if (typeof options2.expandRange === "function") {
        return options2.expandRange(...args, options2);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse$j = (input, options2) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = __spreadValues2({}, options2);
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win322 = utils$d.isWindows(options2);
      const PLATFORM_CHARS = constants$4.globChars(win322);
      const EXTGLOB_CHARS = constants$4.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL: DOT_LITERAL2,
        PLUS_LITERAL: PLUS_LITERAL2,
        SLASH_LITERAL: SLASH_LITERAL2,
        ONE_CHAR: ONE_CHAR2,
        DOTS_SLASH: DOTS_SLASH2,
        NO_DOT: NO_DOT2,
        NO_DOT_SLASH: NO_DOT_SLASH2,
        NO_DOTS_SLASH: NO_DOTS_SLASH2,
        QMARK: QMARK2,
        QMARK_NO_DOT: QMARK_NO_DOT2,
        STAR: STAR2,
        START_ANCHOR: START_ANCHOR2
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT2;
      const qmarkNoDot = opts.dot ? QMARK2 : QMARK_NO_DOT2;
      let star2 = opts.bash === true ? globstar(opts) : STAR2;
      if (opts.capture) {
        star2 = `(${star2})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils$d.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces2 = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n3 = 1) => input[state.index + n3];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append2 = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push2 = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob2 = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob2) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star2;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append2(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = __spreadProps2(__spreadValues2({}, EXTGLOB_CHARS[value2]), { conditions: 1, inner: "" });
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push2({ type, value: value2, output: state.output ? "" : ONE_CHAR2 });
        push2({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star2;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star2 || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            output = token.close = `)${rest})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push2({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m3, esc, chars2, first2, rest, index2) => {
          if (first2 === "\\") {
            backslashes = true;
            return m3;
          }
          if (first2 === "?") {
            if (esc) {
              return esc + first2 + (rest ? QMARK2.repeat(rest.length) : "");
            }
            if (index2 === 0) {
              return qmarkNoDot + (rest ? QMARK2.repeat(rest.length) : "");
            }
            return QMARK2.repeat(chars2.length);
          }
          if (first2 === ".") {
            return DOT_LITERAL2.repeat(chars2.length);
          }
          if (first2 === "*") {
            if (esc) {
              return esc + first2 + (rest ? star2 : "");
            }
            return star2;
          }
          return esc ? m3 : `\\${m3}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m3) => {
              return m3.length % 2 === 0 ? "\\\\" : m3 ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils$d.wrapOutput(output, state, options2);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push2({ type: "text", value });
            continue;
          }
          const match2 = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match2 && match2[0].length > 2) {
            slashes = match2[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push2({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix2 = POSIX_REGEX_SOURCE[rest2];
                if (posix2) {
                  prev.value = pre + posix2;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR2;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append2({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils$d.escapeRegex(value);
          prev.value += value;
          append2({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push2({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push2({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push2({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push2({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push2({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push2({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append2({ value });
          if (opts.literalBrackets === false || utils$d.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped2 = utils$d.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped2;
            prev.value = escaped2;
            continue;
          }
          prev.value = `(${capture}${escaped2}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open2 = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces2.push(open2);
          push2(open2);
          continue;
        }
        if (value === "}") {
          const brace = braces2[braces2.length - 1];
          if (opts.nobrace === true || !brace) {
            push2({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range2 = [];
            for (let i2 = arr.length - 1; i2 >= 0; i2--) {
              tokens.pop();
              if (arr[i2].type === "brace") {
                break;
              }
              if (arr[i2].type !== "dots") {
                range2.unshift(arr[i2].value);
              }
            }
            output = expandRange(range2, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out2 = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out2;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push2({ type: "brace", value, output });
          decrement("braces");
          braces2.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push2({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces2[braces2.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push2({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push2({ type: "slash", value, output: SLASH_LITERAL2 });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL2;
            const brace = braces2[braces2.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push2({ type: "text", value, output: DOT_LITERAL2 });
            continue;
          }
          push2({ type: "dot", value, output: DOT_LITERAL2 });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils$d.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push2({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push2({ type: "qmark", value, output: QMARK_NO_DOT2 });
            continue;
          }
          push2({ type: "qmark", value, output: QMARK2 });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push2({ type: "plus", value, output: PLUS_LITERAL2 });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push2({ type: "plus", value });
            continue;
          }
          push2({ type: "plus", value: PLUS_LITERAL2 });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push2({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push2({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match2 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match2) {
            value += match2[0];
            state.index += match2[0].length;
          }
          push2({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star2;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push2({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob2 = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob2) {
            push2({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL2}|${SLASH_LITERAL2}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL2}|${globstar(opts)}${SLASH_LITERAL2})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star2 };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push2(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push2(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH2;
            prev.output += NO_DOT_SLASH2;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH2;
            prev.output += NO_DOTS_SLASH2;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR2;
            prev.output += ONE_CHAR2;
          }
        }
        push2(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils$d.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils$d.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils$d.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL2}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse$j.fastpaths = (input, options2) => {
      const opts = __spreadValues2({}, options2);
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win322 = utils$d.isWindows(options2);
      const {
        DOT_LITERAL: DOT_LITERAL2,
        SLASH_LITERAL: SLASH_LITERAL2,
        ONE_CHAR: ONE_CHAR2,
        DOTS_SLASH: DOTS_SLASH2,
        NO_DOT: NO_DOT2,
        NO_DOTS: NO_DOTS2,
        NO_DOTS_SLASH: NO_DOTS_SLASH2,
        STAR: STAR2,
        START_ANCHOR: START_ANCHOR2
      } = constants$4.globChars(win322);
      const nodot = opts.dot ? NO_DOTS2 : NO_DOT2;
      const slashDot = opts.dot ? NO_DOTS_SLASH2 : NO_DOT2;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star2 = opts.bash === true ? ".*?" : STAR2;
      if (opts.capture) {
        star2 = `(${star2})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star2;
        return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR2}${star2}`;
          case ".*":
            return `${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
          case "*.*":
            return `${nodot}${star2}${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
          case "*/*":
            return `${nodot}${star2}${SLASH_LITERAL2}${ONE_CHAR2}${slashDot}${star2}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${ONE_CHAR2}${star2}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${star2}${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
          default: {
            const match2 = /^(.*?)\.(\w+)$/.exec(str);
            if (!match2)
              return;
            const source3 = create(match2[1]);
            if (!source3)
              return;
            return source3 + DOT_LITERAL2 + match2[2];
          }
        }
      };
      const output = utils$d.removePrefix(input, state);
      let source2 = create(output);
      if (source2 && opts.strictSlashes !== true) {
        source2 += `${SLASH_LITERAL2}?`;
      }
      return source2;
    };
    var parse_1$1 = parse$j;
    var path$p = path__default;
    var scan = scan_1;
    var parse$i = parse_1$1;
    var utils$c = utils$f;
    var constants$3 = constants$5;
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch$4 = (glob2, options2, returnState = false) => {
      if (Array.isArray(glob2)) {
        const fns = glob2.map((input) => picomatch$4(input, options2, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch2 of fns) {
            const state2 = isMatch2(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob2) && glob2.tokens && glob2.input;
      if (glob2 === "" || typeof glob2 !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options2 || {};
      const posix2 = utils$c.isWindows(options2);
      const regex = isState ? picomatch$4.compileRe(glob2, options2) : picomatch$4.makeRe(glob2, options2, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored2 = () => false;
      if (opts.ignore) {
        const ignoreOpts = __spreadProps2(__spreadValues2({}, options2), { ignore: null, onMatch: null, onResult: null });
        isIgnored2 = picomatch$4(opts.ignore, ignoreOpts, returnState);
      }
      const matcher2 = (input, returnObject = false) => {
        const { isMatch: isMatch2, match: match2, output } = picomatch$4.test(input, regex, options2, { glob: glob2, posix: posix2 });
        const result2 = { glob: glob2, state, regex, posix: posix2, input, output, match: match2, isMatch: isMatch2 };
        if (typeof opts.onResult === "function") {
          opts.onResult(result2);
        }
        if (isMatch2 === false) {
          result2.isMatch = false;
          return returnObject ? result2 : false;
        }
        if (isIgnored2(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result2);
          }
          result2.isMatch = false;
          return returnObject ? result2 : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result2);
        }
        return returnObject ? result2 : true;
      };
      if (returnState) {
        matcher2.state = state;
      }
      return matcher2;
    };
    picomatch$4.test = (input, regex, options2, { glob: glob2, posix: posix2 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options2 || {};
      const format2 = opts.format || (posix2 ? utils$c.toPosixSlashes : null);
      let match2 = input === glob2;
      let output = match2 && format2 ? format2(input) : input;
      if (match2 === false) {
        output = format2 ? format2(input) : input;
        match2 = output === glob2;
      }
      if (match2 === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match2 = picomatch$4.matchBase(input, regex, options2, posix2);
        } else {
          match2 = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match2), match: match2, output };
    };
    picomatch$4.matchBase = (input, glob2, options2, posix2 = utils$c.isWindows(options2)) => {
      const regex = glob2 instanceof RegExp ? glob2 : picomatch$4.makeRe(glob2, options2);
      return regex.test(path$p.basename(input));
    };
    picomatch$4.isMatch = (str, patterns, options2) => picomatch$4(patterns, options2)(str);
    picomatch$4.parse = (pattern2, options2) => {
      if (Array.isArray(pattern2))
        return pattern2.map((p2) => picomatch$4.parse(p2, options2));
      return parse$i(pattern2, __spreadProps2(__spreadValues2({}, options2), { fastpaths: false }));
    };
    picomatch$4.scan = (input, options2) => scan(input, options2);
    picomatch$4.compileRe = (state, options2, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options2 || {};
      const prepend = opts.contains ? "" : "^";
      const append2 = opts.contains ? "" : "$";
      let source2 = `${prepend}(?:${state.output})${append2}`;
      if (state && state.negated === true) {
        source2 = `^(?!${source2}).*$`;
      }
      const regex = picomatch$4.toRegex(source2, options2);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch$4.makeRe = (input, options2 = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options2.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse$i.fastpaths(input, options2);
      }
      if (!parsed.output) {
        parsed = parse$i(input, options2);
      }
      return picomatch$4.compileRe(parsed, options2, returnOutput, returnState);
    };
    picomatch$4.toRegex = (source2, options2) => {
      try {
        const opts = options2 || {};
        return new RegExp(source2, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options2 && options2.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch$4.constants = constants$3;
    var picomatch_1 = picomatch$4;
    var picomatch$3 = picomatch_1;
    var util$7 = require$$0__default$2;
    var braces$1 = braces_1;
    var picomatch$2 = picomatch$3;
    var utils$b = utils$f;
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch$1 = (list2, patterns, options2) => {
      patterns = [].concat(patterns);
      list2 = [].concat(list2);
      let omit = new Set();
      let keep = new Set();
      let items = new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options2 && options2.onResult) {
          options2.onResult(state);
        }
      };
      for (let i2 = 0; i2 < patterns.length; i2++) {
        let isMatch2 = picomatch$2(String(patterns[i2]), __spreadProps2(__spreadValues2({}, options2), { onResult }), true);
        let negated = isMatch2.state.negated || isMatch2.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list2) {
          let matched = isMatch2(item, true);
          let match2 = negated ? !matched.isMatch : matched.isMatch;
          if (!match2)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result2 = negatives === patterns.length ? [...items] : [...keep];
      let matches2 = result2.filter((item) => !omit.has(item));
      if (options2 && matches2.length === 0) {
        if (options2.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options2.nonull === true || options2.nullglob === true) {
          return options2.unescape ? patterns.map((p2) => p2.replace(/\\/g, "")) : patterns;
        }
      }
      return matches2;
    };
    micromatch$1.match = micromatch$1;
    micromatch$1.matcher = (pattern2, options2) => picomatch$2(pattern2, options2);
    micromatch$1.isMatch = (str, patterns, options2) => picomatch$2(patterns, options2)(str);
    micromatch$1.any = micromatch$1.isMatch;
    micromatch$1.not = (list2, patterns, options2 = {}) => {
      patterns = [].concat(patterns).map(String);
      let result2 = new Set();
      let items = [];
      let onResult = (state) => {
        if (options2.onResult)
          options2.onResult(state);
        items.push(state.output);
      };
      let matches2 = micromatch$1(list2, patterns, __spreadProps2(__spreadValues2({}, options2), { onResult }));
      for (let item of items) {
        if (!matches2.includes(item)) {
          result2.add(item);
        }
      }
      return [...result2];
    };
    micromatch$1.contains = (str, pattern2, options2) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util$7.inspect(str)}"`);
      }
      if (Array.isArray(pattern2)) {
        return pattern2.some((p2) => micromatch$1.contains(str, p2, options2));
      }
      if (typeof pattern2 === "string") {
        if (isEmptyString(str) || isEmptyString(pattern2)) {
          return false;
        }
        if (str.includes(pattern2) || str.startsWith("./") && str.slice(2).includes(pattern2)) {
          return true;
        }
      }
      return micromatch$1.isMatch(str, pattern2, __spreadProps2(__spreadValues2({}, options2), { contains: true }));
    };
    micromatch$1.matchKeys = (obj, patterns, options2) => {
      if (!utils$b.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch$1(Object.keys(obj), patterns, options2);
      let res = {};
      for (let key of keys)
        res[key] = obj[key];
      return res;
    };
    micromatch$1.some = (list2, patterns, options2) => {
      let items = [].concat(list2);
      for (let pattern2 of [].concat(patterns)) {
        let isMatch2 = picomatch$2(String(pattern2), options2);
        if (items.some((item) => isMatch2(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch$1.every = (list2, patterns, options2) => {
      let items = [].concat(list2);
      for (let pattern2 of [].concat(patterns)) {
        let isMatch2 = picomatch$2(String(pattern2), options2);
        if (!items.every((item) => isMatch2(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch$1.all = (str, patterns, options2) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util$7.inspect(str)}"`);
      }
      return [].concat(patterns).every((p2) => picomatch$2(p2, options2)(str));
    };
    micromatch$1.capture = (glob2, input, options2) => {
      let posix2 = utils$b.isWindows(options2);
      let regex = picomatch$2.makeRe(String(glob2), __spreadProps2(__spreadValues2({}, options2), { capture: true }));
      let match2 = regex.exec(posix2 ? utils$b.toPosixSlashes(input) : input);
      if (match2) {
        return match2.slice(1).map((v2) => v2 === void 0 ? "" : v2);
      }
    };
    micromatch$1.makeRe = (...args) => picomatch$2.makeRe(...args);
    micromatch$1.scan = (...args) => picomatch$2.scan(...args);
    micromatch$1.parse = (patterns, options2) => {
      let res = [];
      for (let pattern2 of [].concat(patterns || [])) {
        for (let str of braces$1(String(pattern2), options2)) {
          res.push(picomatch$2.parse(str, options2));
        }
      }
      return res;
    };
    micromatch$1.braces = (pattern2, options2) => {
      if (typeof pattern2 !== "string")
        throw new TypeError("Expected a string");
      if (options2 && options2.nobrace === true || !/\{.*\}/.test(pattern2)) {
        return [pattern2];
      }
      return braces$1(pattern2, options2);
    };
    micromatch$1.braceExpand = (pattern2, options2) => {
      if (typeof pattern2 !== "string")
        throw new TypeError("Expected a string");
      return micromatch$1.braces(pattern2, __spreadProps2(__spreadValues2({}, options2), { expand: true }));
    };
    var micromatch_1 = micromatch$1;
    Object.defineProperty(pattern$1, "__esModule", { value: true });
    pattern$1.matchAny = pattern$1.convertPatternsToRe = pattern$1.makeRe = pattern$1.getPatternParts = pattern$1.expandBraceExpansion = pattern$1.expandPatternsWithBraceExpansion = pattern$1.isAffectDepthOfReadingPattern = pattern$1.endsWithSlashGlobStar = pattern$1.hasGlobStar = pattern$1.getBaseDirectory = pattern$1.isPatternRelatedToParentDirectory = pattern$1.getPatternsOutsideCurrentDirectory = pattern$1.getPatternsInsideCurrentDirectory = pattern$1.getPositivePatterns = pattern$1.getNegativePatterns = pattern$1.isPositivePattern = pattern$1.isNegativePattern = pattern$1.convertToNegativePattern = pattern$1.convertToPositivePattern = pattern$1.isDynamicPattern = pattern$1.isStaticPattern = void 0;
    var path$o = path__default;
    var globParent$1 = globParent$2;
    var micromatch = micromatch_1;
    var GLOBSTAR$2 = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[.*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\(.*\|.*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\(.*\)/;
    var BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\.\.).*}/;
    function isStaticPattern(pattern2, options2 = {}) {
      return !isDynamicPattern(pattern2, options2);
    }
    pattern$1.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern2, options2 = {}) {
      if (pattern2 === "") {
        return false;
      }
      if (options2.caseSensitiveMatch === false || pattern2.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern2) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern2) || REGEX_GROUP_SYMBOLS_RE.test(pattern2)) {
        return true;
      }
      if (options2.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern2)) {
        return true;
      }
      if (options2.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern2)) {
        return true;
      }
      return false;
    }
    pattern$1.isDynamicPattern = isDynamicPattern;
    function convertToPositivePattern(pattern2) {
      return isNegativePattern(pattern2) ? pattern2.slice(1) : pattern2;
    }
    pattern$1.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern2) {
      return "!" + pattern2;
    }
    pattern$1.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern2) {
      return pattern2.startsWith("!") && pattern2[1] !== "(";
    }
    pattern$1.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern2) {
      return !isNegativePattern(pattern2);
    }
    pattern$1.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
    }
    pattern$1.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns$1(patterns) {
      return patterns.filter(isPositivePattern);
    }
    pattern$1.getPositivePatterns = getPositivePatterns$1;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter((pattern2) => !isPatternRelatedToParentDirectory(pattern2));
    }
    pattern$1.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    pattern$1.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern2) {
      return pattern2.startsWith("..") || pattern2.startsWith("./..");
    }
    pattern$1.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern2) {
      return globParent$1(pattern2, { flipBackslashes: false });
    }
    pattern$1.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern2) {
      return pattern2.includes(GLOBSTAR$2);
    }
    pattern$1.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern2) {
      return pattern2.endsWith("/" + GLOBSTAR$2);
    }
    pattern$1.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern2) {
      const basename = path$o.basename(pattern2);
      return endsWithSlashGlobStar(pattern2) || isStaticPattern(basename);
    }
    pattern$1.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern2) => {
        return collection.concat(expandBraceExpansion(pattern2));
      }, []);
    }
    pattern$1.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern2) {
      return micromatch.braces(pattern2, {
        expand: true,
        nodupes: true
      });
    }
    pattern$1.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern2, options2) {
      let { parts } = micromatch.scan(pattern2, Object.assign(Object.assign({}, options2), { parts: true }));
      if (parts.length === 0) {
        parts = [pattern2];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    pattern$1.getPatternParts = getPatternParts;
    function makeRe$1(pattern2, options2) {
      return micromatch.makeRe(pattern2, options2);
    }
    pattern$1.makeRe = makeRe$1;
    function convertPatternsToRe(patterns, options2) {
      return patterns.map((pattern2) => makeRe$1(pattern2, options2));
    }
    pattern$1.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry2, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry2));
    }
    pattern$1.matchAny = matchAny;
    var stream$6 = {};
    var Stream = require$$0__default$3;
    var PassThrough$1 = Stream.PassThrough;
    var slice$1 = Array.prototype.slice;
    var merge2_1 = merge2$2;
    function merge2$2() {
      const streamsQueue = [];
      const args = slice$1.call(arguments);
      let merging = false;
      let options2 = args[args.length - 1];
      if (options2 && !Array.isArray(options2) && options2.pipe == null) {
        args.pop();
      } else {
        options2 = {};
      }
      const doEnd = options2.end !== false;
      const doPipeError = options2.pipeError === true;
      if (options2.objectMode == null) {
        options2.objectMode = true;
      }
      if (options2.highWaterMark == null) {
        options2.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough$1(options2);
      function addStream() {
        for (let i2 = 0, len = arguments.length; i2 < len; i2++) {
          streamsQueue.push(pauseStreams(arguments[i2], options2));
        }
        mergeStream2();
        return this;
      }
      function mergeStream2() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream2();
        }
        function pipe(stream2) {
          function onend() {
            stream2.removeListener("merge2UnpipeEnd", onend);
            stream2.removeListener("end", onend);
            if (doPipeError) {
              stream2.removeListener("error", onerror);
            }
            next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream2._readableState.endEmitted) {
            return next();
          }
          stream2.on("merge2UnpipeEnd", onend);
          stream2.on("end", onend);
          if (doPipeError) {
            stream2.on("error", onerror);
          }
          stream2.pipe(mergedStream, { end: false });
          stream2.resume();
        }
        for (let i2 = 0; i2 < streams.length; i2++) {
          pipe(streams[i2]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream2) {
        stream2.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options2) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough$1(options2));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i2 = 0, len = streams.length; i2 < len; i2++) {
          streams[i2] = pauseStreams(streams[i2], options2);
        }
      }
      return streams;
    }
    Object.defineProperty(stream$6, "__esModule", { value: true });
    stream$6.merge = void 0;
    var merge2$1 = merge2_1;
    function merge$1(streams) {
      const mergedStream = merge2$1(streams);
      streams.forEach((stream2) => {
        stream2.once("error", (error2) => mergedStream.emit("error", error2));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    stream$6.merge = merge$1;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream2) => stream2.emit("close"));
    }
    var string$2 = {};
    Object.defineProperty(string$2, "__esModule", { value: true });
    string$2.isEmpty = string$2.isString = void 0;
    function isString$1(input) {
      return typeof input === "string";
    }
    string$2.isString = isString$1;
    function isEmpty(input) {
      return input === "";
    }
    string$2.isEmpty = isEmpty;
    Object.defineProperty(utils$k, "__esModule", { value: true });
    utils$k.string = utils$k.stream = utils$k.pattern = utils$k.path = utils$k.fs = utils$k.errno = utils$k.array = void 0;
    var array = array$1;
    utils$k.array = array;
    var errno = errno$1;
    utils$k.errno = errno;
    var fs$p = fs$q;
    utils$k.fs = fs$p;
    var path$n = path$s;
    utils$k.path = path$n;
    var pattern = pattern$1;
    utils$k.pattern = pattern;
    var stream$5 = stream$6;
    utils$k.stream = stream$5;
    var string$1 = string$2;
    utils$k.string = string$1;
    Object.defineProperty(tasks, "__esModule", { value: true });
    tasks.convertPatternGroupToTask = tasks.convertPatternGroupsToTasks = tasks.groupPatternsByBaseDirectory = tasks.getNegativePatternsAsPositive = tasks.getPositivePatterns = tasks.convertPatternsToTasks = tasks.generate = void 0;
    var utils$a = utils$k;
    function generate(patterns, settings2) {
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, settings2.ignore);
      const staticPatterns = positivePatterns.filter((pattern2) => utils$a.pattern.isStaticPattern(pattern2, settings2));
      const dynamicPatterns = positivePatterns.filter((pattern2) => utils$a.pattern.isDynamicPattern(pattern2, settings2));
      const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
      const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
      return staticTasks.concat(dynamicTasks);
    }
    tasks.generate = generate;
    function convertPatternsToTasks(positive, negative, dynamic) {
      const tasks2 = [];
      const patternsOutsideCurrentDirectory = utils$a.pattern.getPatternsOutsideCurrentDirectory(positive);
      const patternsInsideCurrentDirectory = utils$a.pattern.getPatternsInsideCurrentDirectory(positive);
      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      tasks2.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
      if ("." in insideCurrentDirectoryGroup) {
        tasks2.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
      } else {
        tasks2.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
      }
      return tasks2;
    }
    tasks.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils$a.pattern.getPositivePatterns(patterns);
    }
    tasks.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore2) {
      const negative = utils$a.pattern.getNegativePatterns(patterns).concat(ignore2);
      const positive = negative.map(utils$a.pattern.convertToPositivePattern);
      return positive;
    }
    tasks.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group = {};
      return patterns.reduce((collection, pattern2) => {
        const base2 = utils$a.pattern.getBaseDirectory(pattern2);
        if (base2 in collection) {
          collection[base2].push(pattern2);
        } else {
          collection[base2] = [pattern2];
        }
        return collection;
      }, group);
    }
    tasks.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base2) => {
        return convertPatternGroupToTask(base2, positive[base2], negative, dynamic);
      });
    }
    tasks.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base2, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base: base2,
        patterns: [].concat(positive, negative.map(utils$a.pattern.convertToNegativePattern))
      };
    }
    tasks.convertPatternGroupToTask = convertPatternGroupToTask;
    var async$6 = {};
    var stream$4 = {};
    var out$3 = {};
    var async$5 = {};
    Object.defineProperty(async$5, "__esModule", { value: true });
    async$5.read = void 0;
    function read$3(path2, settings2, callback) {
      settings2.fs.lstat(path2, (lstatError, lstat2) => {
        if (lstatError !== null) {
          callFailureCallback$2(callback, lstatError);
          return;
        }
        if (!lstat2.isSymbolicLink() || !settings2.followSymbolicLink) {
          callSuccessCallback$2(callback, lstat2);
          return;
        }
        settings2.fs.stat(path2, (statError, stat2) => {
          if (statError !== null) {
            if (settings2.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback$2(callback, statError);
              return;
            }
            callSuccessCallback$2(callback, lstat2);
            return;
          }
          if (settings2.markSymbolicLink) {
            stat2.isSymbolicLink = () => true;
          }
          callSuccessCallback$2(callback, stat2);
        });
      });
    }
    async$5.read = read$3;
    function callFailureCallback$2(callback, error2) {
      callback(error2);
    }
    function callSuccessCallback$2(callback, result2) {
      callback(null, result2);
    }
    var sync$b = {};
    Object.defineProperty(sync$b, "__esModule", { value: true });
    sync$b.read = void 0;
    function read$2(path2, settings2) {
      const lstat2 = settings2.fs.lstatSync(path2);
      if (!lstat2.isSymbolicLink() || !settings2.followSymbolicLink) {
        return lstat2;
      }
      try {
        const stat2 = settings2.fs.statSync(path2);
        if (settings2.markSymbolicLink) {
          stat2.isSymbolicLink = () => true;
        }
        return stat2;
      } catch (error2) {
        if (!settings2.throwErrorOnBrokenSymbolicLink) {
          return lstat2;
        }
        throw error2;
      }
    }
    sync$b.read = read$2;
    var settings$3 = {};
    var fs$o = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
      const fs3 = fs__default;
      exports2.FILE_SYSTEM_ADAPTER = {
        lstat: fs3.lstat,
        stat: fs3.stat,
        lstatSync: fs3.lstatSync,
        statSync: fs3.statSync
      };
      function createFileSystemAdapter(fsMethods) {
        if (fsMethods === void 0) {
          return exports2.FILE_SYSTEM_ADAPTER;
        }
        return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
      }
      exports2.createFileSystemAdapter = createFileSystemAdapter;
    })(fs$o);
    Object.defineProperty(settings$3, "__esModule", { value: true });
    var fs$n = fs$o;
    var Settings$2 = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs$n.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    settings$3.default = Settings$2;
    Object.defineProperty(out$3, "__esModule", { value: true });
    out$3.statSync = out$3.stat = out$3.Settings = void 0;
    var async$4 = async$5;
    var sync$a = sync$b;
    var settings_1$3 = settings$3;
    out$3.Settings = settings_1$3.default;
    function stat$4(path2, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async$4.read(path2, getSettings$2(), optionsOrSettingsOrCallback);
        return;
      }
      async$4.read(path2, getSettings$2(optionsOrSettingsOrCallback), callback);
    }
    out$3.stat = stat$4;
    function statSync(path2, optionsOrSettings) {
      const settings2 = getSettings$2(optionsOrSettings);
      return sync$a.read(path2, settings2);
    }
    out$3.statSync = statSync;
    function getSettings$2(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1$3.default) {
        return settingsOrOptions;
      }
      return new settings_1$3.default(settingsOrOptions);
    }
    var out$2 = {};
    var async$3 = {};
    var async$2 = {};
    var out$1 = {};
    var async$1 = {};
    var promise$1;
    var queueMicrotask_1 = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : commonjsGlobal) : (cb) => (promise$1 || (promise$1 = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
    var runParallel_1 = runParallel;
    var queueMicrotask$1 = queueMicrotask_1;
    function runParallel(tasks2, cb) {
      let results, pending, keys;
      let isSync = true;
      if (Array.isArray(tasks2)) {
        results = [];
        pending = tasks2.length;
      } else {
        keys = Object.keys(tasks2);
        results = {};
        pending = keys.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask$1(end);
        else
          end();
      }
      function each(i2, err, result2) {
        results[i2] = result2;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.forEach(function(key) {
          tasks2[key](function(err, result2) {
            each(key, err, result2);
          });
        });
      } else {
        tasks2.forEach(function(task, i2) {
          task(function(err, result2) {
            each(i2, err, result2);
          });
        });
      }
      isSync = false;
    }
    var constants$2 = {};
    Object.defineProperty(constants$2, "__esModule", { value: true });
    constants$2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    constants$2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
    var utils$9 = {};
    var fs$m = {};
    Object.defineProperty(fs$m, "__esModule", { value: true });
    fs$m.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    fs$m.createDirentFromStats = createDirentFromStats;
    Object.defineProperty(utils$9, "__esModule", { value: true });
    utils$9.fs = void 0;
    var fs$l = fs$m;
    utils$9.fs = fs$l;
    var common$d = {};
    Object.defineProperty(common$d, "__esModule", { value: true });
    common$d.joinPathSegments = void 0;
    function joinPathSegments$1(a2, b2, separator) {
      if (a2.endsWith(separator)) {
        return a2 + b2;
      }
      return a2 + separator + b2;
    }
    common$d.joinPathSegments = joinPathSegments$1;
    Object.defineProperty(async$1, "__esModule", { value: true });
    async$1.readdir = async$1.readdirWithFileTypes = async$1.read = void 0;
    var fsStat$5 = out$3;
    var rpl = runParallel_1;
    var constants_1$1 = constants$2;
    var utils$8 = utils$9;
    var common$c = common$d;
    function read$1(directory, settings2, callback) {
      if (!settings2.stats && constants_1$1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes$1(directory, settings2, callback);
        return;
      }
      readdir$3(directory, settings2, callback);
    }
    async$1.read = read$1;
    function readdirWithFileTypes$1(directory, settings2, callback) {
      settings2.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback$1(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common$c.joinPathSegments(directory, dirent.name, settings2.pathSegmentSeparator)
        }));
        if (!settings2.followSymbolicLinks) {
          callSuccessCallback$1(callback, entries);
          return;
        }
        const tasks2 = entries.map((entry2) => makeRplTaskEntry(entry2, settings2));
        rpl(tasks2, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback$1(callback, rplError);
            return;
          }
          callSuccessCallback$1(callback, rplEntries);
        });
      });
    }
    async$1.readdirWithFileTypes = readdirWithFileTypes$1;
    function makeRplTaskEntry(entry2, settings2) {
      return (done) => {
        if (!entry2.dirent.isSymbolicLink()) {
          done(null, entry2);
          return;
        }
        settings2.fs.stat(entry2.path, (statError, stats) => {
          if (statError !== null) {
            if (settings2.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry2);
            return;
          }
          entry2.dirent = utils$8.fs.createDirentFromStats(entry2.name, stats);
          done(null, entry2);
        });
      };
    }
    function readdir$3(directory, settings2, callback) {
      settings2.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback$1(callback, readdirError);
          return;
        }
        const tasks2 = names.map((name) => {
          const path2 = common$c.joinPathSegments(directory, name, settings2.pathSegmentSeparator);
          return (done) => {
            fsStat$5.stat(path2, settings2.fsStatSettings, (error2, stats) => {
              if (error2 !== null) {
                done(error2);
                return;
              }
              const entry2 = {
                name,
                path: path2,
                dirent: utils$8.fs.createDirentFromStats(name, stats)
              };
              if (settings2.stats) {
                entry2.stats = stats;
              }
              done(null, entry2);
            });
          };
        });
        rpl(tasks2, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback$1(callback, rplError);
            return;
          }
          callSuccessCallback$1(callback, entries);
        });
      });
    }
    async$1.readdir = readdir$3;
    function callFailureCallback$1(callback, error2) {
      callback(error2);
    }
    function callSuccessCallback$1(callback, result2) {
      callback(null, result2);
    }
    var sync$9 = {};
    Object.defineProperty(sync$9, "__esModule", { value: true });
    sync$9.readdir = sync$9.readdirWithFileTypes = sync$9.read = void 0;
    var fsStat$4 = out$3;
    var constants_1 = constants$2;
    var utils$7 = utils$9;
    var common$b = common$d;
    function read(directory, settings2) {
      if (!settings2.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings2);
      }
      return readdir$2(directory, settings2);
    }
    sync$9.read = read;
    function readdirWithFileTypes(directory, settings2) {
      const dirents = settings2.fs.readdirSync(directory, { withFileTypes: true });
      return dirents.map((dirent) => {
        const entry2 = {
          dirent,
          name: dirent.name,
          path: common$b.joinPathSegments(directory, dirent.name, settings2.pathSegmentSeparator)
        };
        if (entry2.dirent.isSymbolicLink() && settings2.followSymbolicLinks) {
          try {
            const stats = settings2.fs.statSync(entry2.path);
            entry2.dirent = utils$7.fs.createDirentFromStats(entry2.name, stats);
          } catch (error2) {
            if (settings2.throwErrorOnBrokenSymbolicLink) {
              throw error2;
            }
          }
        }
        return entry2;
      });
    }
    sync$9.readdirWithFileTypes = readdirWithFileTypes;
    function readdir$2(directory, settings2) {
      const names = settings2.fs.readdirSync(directory);
      return names.map((name) => {
        const entryPath = common$b.joinPathSegments(directory, name, settings2.pathSegmentSeparator);
        const stats = fsStat$4.statSync(entryPath, settings2.fsStatSettings);
        const entry2 = {
          name,
          path: entryPath,
          dirent: utils$7.fs.createDirentFromStats(name, stats)
        };
        if (settings2.stats) {
          entry2.stats = stats;
        }
        return entry2;
      });
    }
    sync$9.readdir = readdir$2;
    var settings$2 = {};
    var fs$k = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
      const fs3 = fs__default;
      exports2.FILE_SYSTEM_ADAPTER = {
        lstat: fs3.lstat,
        stat: fs3.stat,
        lstatSync: fs3.lstatSync,
        statSync: fs3.statSync,
        readdir: fs3.readdir,
        readdirSync: fs3.readdirSync
      };
      function createFileSystemAdapter(fsMethods) {
        if (fsMethods === void 0) {
          return exports2.FILE_SYSTEM_ADAPTER;
        }
        return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
      }
      exports2.createFileSystemAdapter = createFileSystemAdapter;
    })(fs$k);
    Object.defineProperty(settings$2, "__esModule", { value: true });
    var path$m = path__default;
    var fsStat$3 = out$3;
    var fs$j = fs$k;
    var Settings$1 = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs$j.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path$m.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat$3.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    settings$2.default = Settings$1;
    Object.defineProperty(out$1, "__esModule", { value: true });
    out$1.Settings = out$1.scandirSync = out$1.scandir = void 0;
    var async = async$1;
    var sync$8 = sync$9;
    var settings_1$2 = settings$2;
    out$1.Settings = settings_1$2.default;
    function scandir(path2, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path2, getSettings$1(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path2, getSettings$1(optionsOrSettingsOrCallback), callback);
    }
    out$1.scandir = scandir;
    function scandirSync(path2, optionsOrSettings) {
      const settings2 = getSettings$1(optionsOrSettings);
      return sync$8.read(path2, settings2);
    }
    out$1.scandirSync = scandirSync;
    function getSettings$1(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1$2.default) {
        return settingsOrOptions;
      }
      return new settings_1$2.default(settingsOrOptions);
    }
    var queue = { exports: {} };
    function reusify$1(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    var reusify_1 = reusify$1;
    var reusify = reusify_1;
    function fastqueue(context2, worker, concurrency) {
      if (typeof context2 === "function") {
        concurrency = worker;
        worker = context2;
        context2 = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache2 = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push: push2,
        drain: noop$3,
        saturated: noop$3,
        pause,
        paused: false,
        concurrency,
        running,
        resume: resume2,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop$3,
        kill: kill2,
        killAndDrain,
        error: error2
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks2 = [];
        while (current) {
          tasks2.push(current.value);
          current = current.next;
        }
        return tasks2;
      }
      function resume2() {
        if (!self2.paused)
          return;
        self2.paused = false;
        for (var i2 = 0; i2 < self2.concurrency; i2++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push2(value, done) {
        var current = cache2.get();
        current.context = context2;
        current.release = release;
        current.value = value;
        current.callback = done || noop$3;
        current.errorHandler = errorHandler;
        if (_running === self2.concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context2, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache2.get();
        current.context = context2;
        current.release = release;
        current.value = value;
        current.callback = done || noop$3;
        if (_running === self2.concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context2, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache2.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context2, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill2() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop$3;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop$3;
      }
      function error2(handler) {
        errorHandler = handler;
      }
    }
    function noop$3() {
    }
    function Task() {
      this.value = null;
      this.callback = noop$3;
      this.next = null;
      this.release = noop$3;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err, result2) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop$3;
        if (self2.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self2.context, err, result2);
        self2.release(self2);
      };
    }
    function queueAsPromised(context2, worker, concurrency) {
      if (typeof context2 === "function") {
        concurrency = worker;
        worker = context2;
        context2 = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue2 = fastqueue(context2, asyncWrapper, concurrency);
      var pushCb = queue2.push;
      var unshiftCb = queue2.unshift;
      queue2.push = push2;
      queue2.unshift = unshift;
      queue2.drained = drained;
      return queue2;
      function push2(value) {
        var p2 = new Promise(function(resolve2, reject) {
          pushCb(value, function(err, result2) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(result2);
          });
        });
        p2.catch(noop$3);
        return p2;
      }
      function unshift(value) {
        var p2 = new Promise(function(resolve2, reject) {
          unshiftCb(value, function(err, result2) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(result2);
          });
        });
        p2.catch(noop$3);
        return p2;
      }
      function drained() {
        var previousDrain = queue2.drain;
        var p2 = new Promise(function(resolve2) {
          queue2.drain = function() {
            previousDrain();
            resolve2();
          };
        });
        return p2;
      }
    }
    queue.exports = fastqueue;
    queue.exports.promise = queueAsPromised;
    var common$a = {};
    Object.defineProperty(common$a, "__esModule", { value: true });
    common$a.joinPathSegments = common$a.replacePathSegmentSeparator = common$a.isAppliedFilter = common$a.isFatalError = void 0;
    function isFatalError(settings2, error2) {
      if (settings2.errorFilter === null) {
        return true;
      }
      return !settings2.errorFilter(error2);
    }
    common$a.isFatalError = isFatalError;
    function isAppliedFilter(filter2, value) {
      return filter2 === null || filter2(value);
    }
    common$a.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    common$a.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a2, b2, separator) {
      if (a2 === "") {
        return b2;
      }
      if (a2.endsWith(separator)) {
        return a2 + b2;
      }
      return a2 + separator + b2;
    }
    common$a.joinPathSegments = joinPathSegments;
    var reader$1 = {};
    Object.defineProperty(reader$1, "__esModule", { value: true });
    var common$9 = common$a;
    var Reader$1 = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common$9.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    reader$1.default = Reader$1;
    Object.defineProperty(async$2, "__esModule", { value: true });
    var events_1 = require$$0__default$4;
    var fsScandir$2 = out$1;
    var fastq = queue.exports;
    var common$8 = common$a;
    var reader_1$3 = reader$1;
    var AsyncReader = class extends reader_1$3.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir$2.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base2) {
        const queueItem = { directory, base: base2 };
        this._queue.push(queueItem, (error2) => {
          if (error2 !== null) {
            this._handleError(error2);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error2, entries) => {
          if (error2 !== null) {
            done(error2, void 0);
            return;
          }
          for (const entry2 of entries) {
            this._handleEntry(entry2, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error2) {
        if (this._isDestroyed || !common$8.isFatalError(this._settings, error2)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error2);
      }
      _handleEntry(entry2, base2) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry2.path;
        if (base2 !== void 0) {
          entry2.path = common$8.joinPathSegments(base2, entry2.name, this._settings.pathSegmentSeparator);
        }
        if (common$8.isAppliedFilter(this._settings.entryFilter, entry2)) {
          this._emitEntry(entry2);
        }
        if (entry2.dirent.isDirectory() && common$8.isAppliedFilter(this._settings.deepFilter, entry2)) {
          this._pushToQueue(fullpath, base2 === void 0 ? void 0 : entry2.path);
        }
      }
      _emitEntry(entry2) {
        this._emitter.emit("entry", entry2);
      }
    };
    async$2.default = AsyncReader;
    Object.defineProperty(async$3, "__esModule", { value: true });
    var async_1$3 = async$2;
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1$3.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error2) => {
          callFailureCallback(callback, error2);
        });
        this._reader.onEntry((entry2) => {
          this._storage.push(entry2);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    async$3.default = AsyncProvider;
    function callFailureCallback(callback, error2) {
      callback(error2);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
    var stream$3 = {};
    Object.defineProperty(stream$3, "__esModule", { value: true });
    var stream_1$5 = require$$0__default$3;
    var async_1$2 = async$2;
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1$2.default(this._root, this._settings);
        this._stream = new stream_1$5.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error2) => {
          this._stream.emit("error", error2);
        });
        this._reader.onEntry((entry2) => {
          this._stream.push(entry2);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    stream$3.default = StreamProvider;
    var sync$7 = {};
    var sync$6 = {};
    Object.defineProperty(sync$6, "__esModule", { value: true });
    var fsScandir$1 = out$1;
    var common$7 = common$a;
    var reader_1$2 = reader$1;
    var SyncReader = class extends reader_1$2.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir$1.scandirSync;
        this._storage = [];
        this._queue = new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base2) {
        this._queue.add({ directory, base: base2 });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base2) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry2 of entries) {
            this._handleEntry(entry2, base2);
          }
        } catch (error2) {
          this._handleError(error2);
        }
      }
      _handleError(error2) {
        if (!common$7.isFatalError(this._settings, error2)) {
          return;
        }
        throw error2;
      }
      _handleEntry(entry2, base2) {
        const fullpath = entry2.path;
        if (base2 !== void 0) {
          entry2.path = common$7.joinPathSegments(base2, entry2.name, this._settings.pathSegmentSeparator);
        }
        if (common$7.isAppliedFilter(this._settings.entryFilter, entry2)) {
          this._pushToStorage(entry2);
        }
        if (entry2.dirent.isDirectory() && common$7.isAppliedFilter(this._settings.deepFilter, entry2)) {
          this._pushToQueue(fullpath, base2 === void 0 ? void 0 : entry2.path);
        }
      }
      _pushToStorage(entry2) {
        this._storage.push(entry2);
      }
    };
    sync$6.default = SyncReader;
    Object.defineProperty(sync$7, "__esModule", { value: true });
    var sync_1$3 = sync$6;
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1$3.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    sync$7.default = SyncProvider;
    var settings$1 = {};
    Object.defineProperty(settings$1, "__esModule", { value: true });
    var path$l = path__default;
    var fsScandir = out$1;
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path$l.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    settings$1.default = Settings;
    Object.defineProperty(out$2, "__esModule", { value: true });
    out$2.Settings = out$2.walkStream = out$2.walkSync = out$2.walk = void 0;
    var async_1$1 = async$3;
    var stream_1$4 = stream$3;
    var sync_1$2 = sync$7;
    var settings_1$1 = settings$1;
    out$2.Settings = settings_1$1.default;
    function walk$3(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_1$1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1$1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    out$2.walk = walk$3;
    function walkSync(directory, optionsOrSettings) {
      const settings2 = getSettings(optionsOrSettings);
      const provider2 = new sync_1$2.default(directory, settings2);
      return provider2.read();
    }
    out$2.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings2 = getSettings(optionsOrSettings);
      const provider2 = new stream_1$4.default(directory, settings2);
      return provider2.read();
    }
    out$2.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1$1.default) {
        return settingsOrOptions;
      }
      return new settings_1$1.default(settingsOrOptions);
    }
    var reader = {};
    Object.defineProperty(reader, "__esModule", { value: true });
    var path$k = path__default;
    var fsStat$2 = out$3;
    var utils$6 = utils$k;
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat$2.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path$k.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern2) {
        const entry2 = {
          name: pattern2,
          path: pattern2,
          dirent: utils$6.fs.createDirentFromStats(pattern2, stats)
        };
        if (this._settings.stats) {
          entry2.stats = stats;
        }
        return entry2;
      }
      _isFatalError(error2) {
        return !utils$6.errno.isEnoentCodeError(error2) && !this._settings.suppressErrors;
      }
    };
    reader.default = Reader;
    Object.defineProperty(stream$4, "__esModule", { value: true });
    var stream_1$3 = require$$0__default$3;
    var fsStat$1 = out$3;
    var fsWalk$1 = out$2;
    var reader_1$1 = reader;
    var ReaderStream = class extends reader_1$1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk$1.walkStream;
        this._stat = fsStat$1.stat;
      }
      dynamic(root, options2) {
        return this._walkStream(root, options2);
      }
      static(patterns, options2) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream2 = new stream_1$3.PassThrough({ objectMode: true });
        stream2._write = (index2, _enc, done) => {
          return this._getEntry(filepaths[index2], patterns[index2], options2).then((entry2) => {
            if (entry2 !== null && options2.entryFilter(entry2)) {
              stream2.push(entry2);
            }
            if (index2 === filepaths.length - 1) {
              stream2.end();
            }
            done();
          }).catch(done);
        };
        for (let i2 = 0; i2 < filepaths.length; i2++) {
          stream2.write(i2);
        }
        return stream2;
      }
      _getEntry(filepath, pattern2, options2) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern2)).catch((error2) => {
          if (options2.errorFilter(error2)) {
            return null;
          }
          throw error2;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve2, reject) => {
          this._stat(filepath, this._fsStatSettings, (error2, stats) => {
            return error2 === null ? resolve2(stats) : reject(error2);
          });
        });
      }
    };
    stream$4.default = ReaderStream;
    var provider = {};
    var deep = {};
    var partial = {};
    var matcher = {};
    Object.defineProperty(matcher, "__esModule", { value: true });
    var utils$5 = utils$k;
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        const patterns = utils$5.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern2 of patterns) {
          const segments = this._getPatternSegments(pattern2);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern: pattern2,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern2) {
        const parts = utils$5.pattern.getPatternParts(pattern2, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils$5.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils$5.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils$5.array.splitWhen(segments, (segment) => segment.dynamic && utils$5.pattern.hasGlobStar(segment.pattern));
      }
    };
    matcher.default = Matcher;
    Object.defineProperty(partial, "__esModule", { value: true });
    var matcher_1 = matcher;
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern2 of patterns) {
          const section = pattern2.sections[0];
          if (!pattern2.complete && levels > section.length) {
            return true;
          }
          const match2 = parts.every((part, index2) => {
            const segment = pattern2.segments[index2];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match2) {
            return true;
          }
        }
        return false;
      }
    };
    partial.default = PartialMatcher;
    Object.defineProperty(deep, "__esModule", { value: true });
    var utils$4 = utils$k;
    var partial_1 = partial;
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher2 = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry2) => this._filter(basePath, entry2, matcher2, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils$4.pattern.isAffectDepthOfReadingPattern);
        return utils$4.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry2, matcher2, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry2.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry2)) {
          return false;
        }
        const filepath = utils$4.path.removeLeadingDotSegment(entry2.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher2)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry2) {
        return !this._settings.followSymbolicLinks && entry2.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher2) {
        return !this._settings.baseNameMatch && !matcher2.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils$4.pattern.matchAny(entryPath, patternsRe);
      }
    };
    deep.default = DeepFilter;
    var entry$1 = {};
    Object.defineProperty(entry$1, "__esModule", { value: true });
    var utils$3 = utils$k;
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils$3.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils$3.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry2) => this._filter(entry2, positiveRe, negativeRe);
      }
      _filter(entry2, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry2)) {
          return false;
        }
        if (this._onlyFileFilter(entry2) || this._onlyDirectoryFilter(entry2)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry2.path, negativeRe)) {
          return false;
        }
        const filepath = this._settings.baseNameMatch ? entry2.name : entry2.path;
        const isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry2.path, negativeRe);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(entry2);
        }
        return isMatched;
      }
      _isDuplicateEntry(entry2) {
        return this.index.has(entry2.path);
      }
      _createIndexRecord(entry2) {
        this.index.set(entry2.path, void 0);
      }
      _onlyFileFilter(entry2) {
        return this._settings.onlyFiles && !entry2.dirent.isFile();
      }
      _onlyDirectoryFilter(entry2) {
        return this._settings.onlyDirectories && !entry2.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils$3.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils$3.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(entryPath, patternsRe) {
        const filepath = utils$3.path.removeLeadingDotSegment(entryPath);
        return utils$3.pattern.matchAny(filepath, patternsRe);
      }
    };
    entry$1.default = EntryFilter;
    var error$4 = {};
    Object.defineProperty(error$4, "__esModule", { value: true });
    var utils$2 = utils$k;
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error2) => this._isNonFatalError(error2);
      }
      _isNonFatalError(error2) {
        return utils$2.errno.isEnoentCodeError(error2) || this._settings.suppressErrors;
      }
    };
    error$4.default = ErrorFilter;
    var entry = {};
    Object.defineProperty(entry, "__esModule", { value: true });
    var utils$1 = utils$k;
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry2) => this._transform(entry2);
      }
      _transform(entry2) {
        let filepath = entry2.path;
        if (this._settings.absolute) {
          filepath = utils$1.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils$1.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry2.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry2), { path: filepath });
      }
    };
    entry.default = EntryTransformer;
    Object.defineProperty(provider, "__esModule", { value: true });
    var path$j = path__default;
    var deep_1 = deep;
    var entry_1 = entry$1;
    var error_1 = error$4;
    var entry_2 = entry;
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path$j.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    provider.default = Provider;
    Object.defineProperty(async$6, "__esModule", { value: true });
    var stream_1$2 = stream$4;
    var provider_1$2 = provider;
    var ProviderAsync = class extends provider_1$2.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_1$2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options2 = this._getReaderOptions(task);
        const entries = [];
        return new Promise((resolve2, reject) => {
          const stream2 = this.api(root, task, options2);
          stream2.once("error", reject);
          stream2.on("data", (entry2) => entries.push(options2.transform(entry2)));
          stream2.once("end", () => resolve2(entries));
        });
      }
      api(root, task, options2) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options2);
        }
        return this._reader.static(task.patterns, options2);
      }
    };
    async$6.default = ProviderAsync;
    var stream$2 = {};
    Object.defineProperty(stream$2, "__esModule", { value: true });
    var stream_1$1 = require$$0__default$3;
    var stream_2 = stream$4;
    var provider_1$1 = provider;
    var ProviderStream = class extends provider_1$1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options2 = this._getReaderOptions(task);
        const source2 = this.api(root, task, options2);
        const destination = new stream_1$1.Readable({ objectMode: true, read: () => {
        } });
        source2.once("error", (error2) => destination.emit("error", error2)).on("data", (entry2) => destination.emit("data", options2.transform(entry2))).once("end", () => destination.emit("end"));
        destination.once("close", () => source2.destroy());
        return destination;
      }
      api(root, task, options2) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options2);
        }
        return this._reader.static(task.patterns, options2);
      }
    };
    stream$2.default = ProviderStream;
    var sync$5 = {};
    var sync$4 = {};
    Object.defineProperty(sync$4, "__esModule", { value: true });
    var fsStat = out$3;
    var fsWalk = out$2;
    var reader_1 = reader;
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root, options2) {
        return this._walkSync(root, options2);
      }
      static(patterns, options2) {
        const entries = [];
        for (const pattern2 of patterns) {
          const filepath = this._getFullEntryPath(pattern2);
          const entry2 = this._getEntry(filepath, pattern2, options2);
          if (entry2 === null || !options2.entryFilter(entry2)) {
            continue;
          }
          entries.push(entry2);
        }
        return entries;
      }
      _getEntry(filepath, pattern2, options2) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern2);
        } catch (error2) {
          if (options2.errorFilter(error2)) {
            return null;
          }
          throw error2;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    sync$4.default = ReaderSync;
    Object.defineProperty(sync$5, "__esModule", { value: true });
    var sync_1$1 = sync$4;
    var provider_1 = provider;
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1$1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options2 = this._getReaderOptions(task);
        const entries = this.api(root, task, options2);
        return entries.map(options2.transform);
      }
      api(root, task, options2) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options2);
        }
        return this._reader.static(task.patterns, options2);
      }
    };
    sync$5.default = ProviderSync;
    var settings = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
      const fs3 = fs__default;
      const os3 = require$$0__default$1;
      const CPU_COUNT = Math.max(os3.cpus().length, 1);
      exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
        lstat: fs3.lstat,
        lstatSync: fs3.lstatSync,
        stat: fs3.stat,
        statSync: fs3.statSync,
        readdir: fs3.readdir,
        readdirSync: fs3.readdirSync
      };
      class Settings2 {
        constructor(_options = {}) {
          this._options = _options;
          this.absolute = this._getValue(this._options.absolute, false);
          this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
          this.braceExpansion = this._getValue(this._options.braceExpansion, true);
          this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
          this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
          this.cwd = this._getValue(this._options.cwd, process.cwd());
          this.deep = this._getValue(this._options.deep, Infinity);
          this.dot = this._getValue(this._options.dot, false);
          this.extglob = this._getValue(this._options.extglob, true);
          this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
          this.fs = this._getFileSystemMethods(this._options.fs);
          this.globstar = this._getValue(this._options.globstar, true);
          this.ignore = this._getValue(this._options.ignore, []);
          this.markDirectories = this._getValue(this._options.markDirectories, false);
          this.objectMode = this._getValue(this._options.objectMode, false);
          this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
          this.onlyFiles = this._getValue(this._options.onlyFiles, true);
          this.stats = this._getValue(this._options.stats, false);
          this.suppressErrors = this._getValue(this._options.suppressErrors, false);
          this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
          this.unique = this._getValue(this._options.unique, true);
          if (this.onlyDirectories) {
            this.onlyFiles = false;
          }
          if (this.stats) {
            this.objectMode = true;
          }
        }
        _getValue(option, value) {
          return option === void 0 ? value : option;
        }
        _getFileSystemMethods(methods = {}) {
          return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
        }
      }
      exports2.default = Settings2;
    })(settings);
    var taskManager = tasks;
    var async_1 = async$6;
    var stream_1 = stream$2;
    var sync_1 = sync$5;
    var settings_1 = settings;
    var utils = utils$k;
    async function FastGlob(source2, options2) {
      assertPatternsInput$1(source2);
      const works = getWorks(source2, async_1.default, options2);
      const result2 = await Promise.all(works);
      return utils.array.flatten(result2);
    }
    (function(FastGlob2) {
      function sync2(source2, options2) {
        assertPatternsInput$1(source2);
        const works = getWorks(source2, sync_1.default, options2);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync2;
      function stream2(source2, options2) {
        assertPatternsInput$1(source2);
        const works = getWorks(source2, stream_1.default, options2);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream2;
      function generateTasks(source2, options2) {
        assertPatternsInput$1(source2);
        const patterns = [].concat(source2);
        const settings2 = new settings_1.default(options2);
        return taskManager.generate(patterns, settings2);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern2(source2, options2) {
        assertPatternsInput$1(source2);
        const settings2 = new settings_1.default(options2);
        return utils.pattern.isDynamicPattern(source2, settings2);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern2;
      function escapePath(source2) {
        assertPatternsInput$1(source2);
        return utils.path.escape(source2);
      }
      FastGlob2.escapePath = escapePath;
    })(FastGlob || (FastGlob = {}));
    function getWorks(source2, _Provider, options2) {
      const patterns = [].concat(source2);
      const settings2 = new settings_1.default(options2);
      const tasks2 = taskManager.generate(patterns, settings2);
      const provider2 = new _Provider(settings2);
      return tasks2.map(provider2.read, provider2);
    }
    function assertPatternsInput$1(input) {
      const source2 = [].concat(input);
      const isValidSource = source2.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    var out = FastGlob;
    var dist$2 = {};
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.lilconfigSync = exports.lilconfig = exports.defaultLoaders = void 0;
      const path = path__default;
      const fs = fs__default;
      const os = require$$0__default$1;
      const fsReadFileAsync = fs.promises.readFile;
      function getDefaultSearchPlaces(name) {
        return [
          "package.json",
          `.${name}rc.json`,
          `.${name}rc.js`,
          `${name}.config.js`,
          `.${name}rc.cjs`,
          `${name}.config.cjs`
        ];
      }
      function getSearchPaths(startDir, stopDir) {
        return startDir.split(path.sep).reduceRight((acc, _2, ind, arr) => {
          const currentPath = arr.slice(0, ind + 1).join(path.sep);
          if (!acc.passedStopDir)
            acc.searchPlaces.push(currentPath || path.sep);
          if (currentPath === stopDir)
            acc.passedStopDir = true;
          return acc;
        }, { searchPlaces: [], passedStopDir: false }).searchPlaces;
      }
      exports.defaultLoaders = Object.freeze({
        ".js": eval("require"),
        ".json": eval("require"),
        ".cjs": eval("require"),
        noExt(_2, content2) {
          return JSON.parse(content2);
        }
      });
      function getExtDesc(ext2) {
        return ext2 === "noExt" ? "files without extensions" : `extension "${ext2}"`;
      }
      function getOptions(name, options2 = {}) {
        const conf = __spreadProps2(__spreadValues2({
          stopDir: os.homedir(),
          searchPlaces: getDefaultSearchPlaces(name),
          ignoreEmptySearchPlaces: true,
          transform: (x2) => x2,
          packageProp: [name]
        }, options2), {
          loaders: __spreadValues2(__spreadValues2({}, exports.defaultLoaders), options2.loaders)
        });
        conf.searchPlaces.forEach((place) => {
          const key = path.extname(place) || "noExt";
          const loader = conf.loaders[key];
          if (!loader) {
            throw new Error(`No loader specified for ${getExtDesc(key)}, so searchPlaces item "${place}" is invalid`);
          }
          if (typeof loader !== "function") {
            throw new Error(`loader for ${getExtDesc(key)} is not a function (type provided: "${typeof loader}"), so searchPlaces item "${place}" is invalid`);
          }
        });
        return conf;
      }
      function getPackageProp(props, obj) {
        if (typeof props === "string" && props in obj)
          return obj[props];
        return (Array.isArray(props) ? props : props.split(".")).reduce((acc, prop) => acc === void 0 ? acc : acc[prop], obj) || null;
      }
      function getSearchItems(searchPlaces, searchPaths) {
        return searchPaths.reduce((acc, searchPath) => {
          searchPlaces.forEach((fileName) => acc.push({
            fileName,
            filepath: path.join(searchPath, fileName),
            loaderKey: path.extname(fileName) || "noExt"
          }));
          return acc;
        }, []);
      }
      function validateFilePath(filepath) {
        if (!filepath)
          throw new Error("load must pass a non-empty string");
      }
      function validateLoader(loader, ext2) {
        if (!loader)
          throw new Error(`No loader specified for extension "${ext2}"`);
        if (typeof loader !== "function")
          throw new Error("loader is not a function");
      }
      function lilconfig(name, options2) {
        const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform: transform2 } = getOptions(name, options2);
        return {
          async search(searchFrom = process.cwd()) {
            const searchPaths = getSearchPaths(searchFrom, stopDir);
            const result2 = {
              config: null,
              filepath: ""
            };
            const searchItems = getSearchItems(searchPlaces, searchPaths);
            for (const { fileName, filepath, loaderKey } of searchItems) {
              try {
                await fs.promises.access(filepath);
              } catch (_a2) {
                continue;
              }
              const content2 = String(await fsReadFileAsync(filepath));
              const loader = loaders[loaderKey];
              if (fileName === "package.json") {
                const pkg = loader(filepath, content2);
                const maybeConfig = getPackageProp(packageProp, pkg);
                if (maybeConfig != null) {
                  result2.config = maybeConfig;
                  result2.filepath = filepath;
                  break;
                }
                continue;
              }
              const isEmpty2 = content2.trim() === "";
              if (isEmpty2 && ignoreEmptySearchPlaces)
                continue;
              if (isEmpty2) {
                result2.isEmpty = true;
                result2.config = void 0;
              } else {
                validateLoader(loader, loaderKey);
                result2.config = loader(filepath, content2);
              }
              result2.filepath = filepath;
              break;
            }
            if (result2.filepath === "" && result2.config === null)
              return transform2(null);
            return transform2(result2);
          },
          async load(filepath) {
            validateFilePath(filepath);
            const absPath = path.resolve(process.cwd(), filepath);
            const { base: base2, ext: ext2 } = path.parse(absPath);
            const loaderKey = ext2 || "noExt";
            const loader = loaders[loaderKey];
            validateLoader(loader, loaderKey);
            const content2 = String(await fsReadFileAsync(absPath));
            if (base2 === "package.json") {
              const pkg = await loader(absPath, content2);
              return transform2({
                config: getPackageProp(packageProp, pkg),
                filepath: absPath
              });
            }
            const result2 = {
              config: null,
              filepath: absPath
            };
            const isEmpty2 = content2.trim() === "";
            if (isEmpty2 && ignoreEmptySearchPlaces)
              return transform2({
                config: void 0,
                filepath: absPath,
                isEmpty: true
              });
            result2.config = isEmpty2 ? void 0 : await loader(absPath, content2);
            return transform2(isEmpty2 ? __spreadProps2(__spreadValues2({}, result2), { isEmpty: isEmpty2, config: void 0 }) : result2);
          }
        };
      }
      exports.lilconfig = lilconfig;
      function lilconfigSync(name, options2) {
        const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform: transform2 } = getOptions(name, options2);
        return {
          search(searchFrom = process.cwd()) {
            const searchPaths = getSearchPaths(searchFrom, stopDir);
            const result2 = {
              config: null,
              filepath: ""
            };
            const searchItems = getSearchItems(searchPlaces, searchPaths);
            for (const { fileName, filepath, loaderKey } of searchItems) {
              try {
                fs.accessSync(filepath);
              } catch (_a2) {
                continue;
              }
              const loader = loaders[loaderKey];
              const content2 = String(fs.readFileSync(filepath));
              if (fileName === "package.json") {
                const pkg = loader(filepath, content2);
                const maybeConfig = getPackageProp(packageProp, pkg);
                if (maybeConfig != null) {
                  result2.config = maybeConfig;
                  result2.filepath = filepath;
                  break;
                }
                continue;
              }
              const isEmpty2 = content2.trim() === "";
              if (isEmpty2 && ignoreEmptySearchPlaces)
                continue;
              if (isEmpty2) {
                result2.isEmpty = true;
                result2.config = void 0;
              } else {
                validateLoader(loader, loaderKey);
                result2.config = loader(filepath, content2);
              }
              result2.filepath = filepath;
              break;
            }
            if (result2.filepath === "" && result2.config === null)
              return transform2(null);
            return transform2(result2);
          },
          load(filepath) {
            validateFilePath(filepath);
            const absPath = path.resolve(process.cwd(), filepath);
            const { base: base2, ext: ext2 } = path.parse(absPath);
            const loaderKey = ext2 || "noExt";
            const loader = loaders[loaderKey];
            validateLoader(loader, loaderKey);
            const content2 = String(fs.readFileSync(absPath));
            if (base2 === "package.json") {
              const pkg = loader(absPath, content2);
              return transform2({
                config: getPackageProp(packageProp, pkg),
                filepath: absPath
              });
            }
            const result2 = {
              config: null,
              filepath: absPath
            };
            const isEmpty2 = content2.trim() === "";
            if (isEmpty2 && ignoreEmptySearchPlaces)
              return transform2({
                filepath: absPath,
                config: void 0,
                isEmpty: true
              });
            result2.config = isEmpty2 ? void 0 : loader(absPath, content2);
            return transform2(isEmpty2 ? __spreadProps2(__spreadValues2({}, result2), { isEmpty: isEmpty2, config: void 0 }) : result2);
          }
        };
      }
      exports.lilconfigSync = lilconfigSync;
    })(dist$2);
    var dist$1 = {};
    var parseCst$1 = {};
    var PlainValueEc8e588e = {};
    var Char = {
      ANCHOR: "&",
      COMMENT: "#",
      TAG: "!",
      DIRECTIVES_END: "-",
      DOCUMENT_END: "."
    };
    var Type = {
      ALIAS: "ALIAS",
      BLANK_LINE: "BLANK_LINE",
      BLOCK_FOLDED: "BLOCK_FOLDED",
      BLOCK_LITERAL: "BLOCK_LITERAL",
      COMMENT: "COMMENT",
      DIRECTIVE: "DIRECTIVE",
      DOCUMENT: "DOCUMENT",
      FLOW_MAP: "FLOW_MAP",
      FLOW_SEQ: "FLOW_SEQ",
      MAP: "MAP",
      MAP_KEY: "MAP_KEY",
      MAP_VALUE: "MAP_VALUE",
      PLAIN: "PLAIN",
      QUOTE_DOUBLE: "QUOTE_DOUBLE",
      QUOTE_SINGLE: "QUOTE_SINGLE",
      SEQ: "SEQ",
      SEQ_ITEM: "SEQ_ITEM"
    };
    var defaultTagPrefix = "tag:yaml.org,2002:";
    var defaultTags = {
      MAP: "tag:yaml.org,2002:map",
      SEQ: "tag:yaml.org,2002:seq",
      STR: "tag:yaml.org,2002:str"
    };
    function findLineStarts(src2) {
      const ls2 = [0];
      let offset2 = src2.indexOf("\n");
      while (offset2 !== -1) {
        offset2 += 1;
        ls2.push(offset2);
        offset2 = src2.indexOf("\n", offset2);
      }
      return ls2;
    }
    function getSrcInfo(cst) {
      let lineStarts, src2;
      if (typeof cst === "string") {
        lineStarts = findLineStarts(cst);
        src2 = cst;
      } else {
        if (Array.isArray(cst))
          cst = cst[0];
        if (cst && cst.context) {
          if (!cst.lineStarts)
            cst.lineStarts = findLineStarts(cst.context.src);
          lineStarts = cst.lineStarts;
          src2 = cst.context.src;
        }
      }
      return {
        lineStarts,
        src: src2
      };
    }
    function getLinePos(offset2, cst) {
      if (typeof offset2 !== "number" || offset2 < 0)
        return null;
      const {
        lineStarts,
        src: src2
      } = getSrcInfo(cst);
      if (!lineStarts || !src2 || offset2 > src2.length)
        return null;
      for (let i2 = 0; i2 < lineStarts.length; ++i2) {
        const start = lineStarts[i2];
        if (offset2 < start) {
          return {
            line: i2,
            col: offset2 - lineStarts[i2 - 1] + 1
          };
        }
        if (offset2 === start)
          return {
            line: i2 + 1,
            col: 1
          };
      }
      const line = lineStarts.length;
      return {
        line,
        col: offset2 - lineStarts[line - 1] + 1
      };
    }
    function getLine(line, cst) {
      const {
        lineStarts,
        src: src2
      } = getSrcInfo(cst);
      if (!lineStarts || !(line >= 1) || line > lineStarts.length)
        return null;
      const start = lineStarts[line - 1];
      let end = lineStarts[line];
      while (end && end > start && src2[end - 1] === "\n")
        --end;
      return src2.slice(start, end);
    }
    function getPrettyContext({
      start,
      end
    }, cst, maxWidth = 80) {
      let src2 = getLine(start.line, cst);
      if (!src2)
        return null;
      let {
        col
      } = start;
      if (src2.length > maxWidth) {
        if (col <= maxWidth - 10) {
          src2 = src2.substr(0, maxWidth - 1) + "\u2026";
        } else {
          const halfWidth = Math.round(maxWidth / 2);
          if (src2.length > col + halfWidth)
            src2 = src2.substr(0, col + halfWidth - 1) + "\u2026";
          col -= src2.length - maxWidth;
          src2 = "\u2026" + src2.substr(1 - maxWidth);
        }
      }
      let errLen = 1;
      let errEnd = "";
      if (end) {
        if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
          errLen = end.col - start.col;
        } else {
          errLen = Math.min(src2.length + 1, maxWidth) - col;
          errEnd = "\u2026";
        }
      }
      const offset2 = col > 1 ? " ".repeat(col - 1) : "";
      const err = "^".repeat(errLen);
      return `${src2}
${offset2}${err}${errEnd}`;
    }
    var Range = class {
      static copy(orig) {
        return new Range(orig.start, orig.end);
      }
      constructor(start, end) {
        this.start = start;
        this.end = end || start;
      }
      isEmpty() {
        return typeof this.start !== "number" || !this.end || this.end <= this.start;
      }
      setOrigRange(cr2, offset2) {
        const {
          start,
          end
        } = this;
        if (cr2.length === 0 || end <= cr2[0]) {
          this.origStart = start;
          this.origEnd = end;
          return offset2;
        }
        let i2 = offset2;
        while (i2 < cr2.length) {
          if (cr2[i2] > start)
            break;
          else
            ++i2;
        }
        this.origStart = start + i2;
        const nextOffset = i2;
        while (i2 < cr2.length) {
          if (cr2[i2] >= end)
            break;
          else
            ++i2;
        }
        this.origEnd = end + i2;
        return nextOffset;
      }
    };
    var Node$2 = class {
      static addStringTerminator(src2, offset2, str) {
        if (str[str.length - 1] === "\n")
          return str;
        const next = Node$2.endOfWhiteSpace(src2, offset2);
        return next >= src2.length || src2[next] === "\n" ? str + "\n" : str;
      }
      static atDocumentBoundary(src2, offset2, sep) {
        const ch0 = src2[offset2];
        if (!ch0)
          return true;
        const prev = src2[offset2 - 1];
        if (prev && prev !== "\n")
          return false;
        if (sep) {
          if (ch0 !== sep)
            return false;
        } else {
          if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END)
            return false;
        }
        const ch1 = src2[offset2 + 1];
        const ch2 = src2[offset2 + 2];
        if (ch1 !== ch0 || ch2 !== ch0)
          return false;
        const ch3 = src2[offset2 + 3];
        return !ch3 || ch3 === "\n" || ch3 === "	" || ch3 === " ";
      }
      static endOfIdentifier(src2, offset2) {
        let ch2 = src2[offset2];
        const isVerbatim = ch2 === "<";
        const notOk = isVerbatim ? ["\n", "	", " ", ">"] : ["\n", "	", " ", "[", "]", "{", "}", ","];
        while (ch2 && notOk.indexOf(ch2) === -1)
          ch2 = src2[offset2 += 1];
        if (isVerbatim && ch2 === ">")
          offset2 += 1;
        return offset2;
      }
      static endOfIndent(src2, offset2) {
        let ch2 = src2[offset2];
        while (ch2 === " ")
          ch2 = src2[offset2 += 1];
        return offset2;
      }
      static endOfLine(src2, offset2) {
        let ch2 = src2[offset2];
        while (ch2 && ch2 !== "\n")
          ch2 = src2[offset2 += 1];
        return offset2;
      }
      static endOfWhiteSpace(src2, offset2) {
        let ch2 = src2[offset2];
        while (ch2 === "	" || ch2 === " ")
          ch2 = src2[offset2 += 1];
        return offset2;
      }
      static startOfLine(src2, offset2) {
        let ch2 = src2[offset2 - 1];
        if (ch2 === "\n")
          return offset2;
        while (ch2 && ch2 !== "\n")
          ch2 = src2[offset2 -= 1];
        return offset2 + 1;
      }
      static endOfBlockIndent(src2, indent, lineStart) {
        const inEnd = Node$2.endOfIndent(src2, lineStart);
        if (inEnd > lineStart + indent) {
          return inEnd;
        } else {
          const wsEnd = Node$2.endOfWhiteSpace(src2, inEnd);
          const ch2 = src2[wsEnd];
          if (!ch2 || ch2 === "\n")
            return wsEnd;
        }
        return null;
      }
      static atBlank(src2, offset2, endAsBlank) {
        const ch2 = src2[offset2];
        return ch2 === "\n" || ch2 === "	" || ch2 === " " || endAsBlank && !ch2;
      }
      static nextNodeIsIndented(ch2, indentDiff, indicatorAsIndent) {
        if (!ch2 || indentDiff < 0)
          return false;
        if (indentDiff > 0)
          return true;
        return indicatorAsIndent && ch2 === "-";
      }
      static normalizeOffset(src2, offset2) {
        const ch2 = src2[offset2];
        return !ch2 ? offset2 : ch2 !== "\n" && src2[offset2 - 1] === "\n" ? offset2 - 1 : Node$2.endOfWhiteSpace(src2, offset2);
      }
      static foldNewline(src2, offset2, indent) {
        let inCount = 0;
        let error2 = false;
        let fold = "";
        let ch2 = src2[offset2 + 1];
        while (ch2 === " " || ch2 === "	" || ch2 === "\n") {
          switch (ch2) {
            case "\n":
              inCount = 0;
              offset2 += 1;
              fold += "\n";
              break;
            case "	":
              if (inCount <= indent)
                error2 = true;
              offset2 = Node$2.endOfWhiteSpace(src2, offset2 + 2) - 1;
              break;
            case " ":
              inCount += 1;
              offset2 += 1;
              break;
          }
          ch2 = src2[offset2 + 1];
        }
        if (!fold)
          fold = " ";
        if (ch2 && inCount <= indent)
          error2 = true;
        return {
          fold,
          offset: offset2,
          error: error2
        };
      }
      constructor(type, props, context2) {
        Object.defineProperty(this, "context", {
          value: context2 || null,
          writable: true
        });
        this.error = null;
        this.range = null;
        this.valueRange = null;
        this.props = props || [];
        this.type = type;
        this.value = null;
      }
      getPropValue(idx, key, skipKey) {
        if (!this.context)
          return null;
        const {
          src: src2
        } = this.context;
        const prop = this.props[idx];
        return prop && src2[prop.start] === key ? src2.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
      }
      get anchor() {
        for (let i2 = 0; i2 < this.props.length; ++i2) {
          const anchor = this.getPropValue(i2, Char.ANCHOR, true);
          if (anchor != null)
            return anchor;
        }
        return null;
      }
      get comment() {
        const comments = [];
        for (let i2 = 0; i2 < this.props.length; ++i2) {
          const comment = this.getPropValue(i2, Char.COMMENT, true);
          if (comment != null)
            comments.push(comment);
        }
        return comments.length > 0 ? comments.join("\n") : null;
      }
      commentHasRequiredWhitespace(start) {
        const {
          src: src2
        } = this.context;
        if (this.header && start === this.header.end)
          return false;
        if (!this.valueRange)
          return false;
        const {
          end
        } = this.valueRange;
        return start !== end || Node$2.atBlank(src2, end - 1);
      }
      get hasComment() {
        if (this.context) {
          const {
            src: src2
          } = this.context;
          for (let i2 = 0; i2 < this.props.length; ++i2) {
            if (src2[this.props[i2].start] === Char.COMMENT)
              return true;
          }
        }
        return false;
      }
      get hasProps() {
        if (this.context) {
          const {
            src: src2
          } = this.context;
          for (let i2 = 0; i2 < this.props.length; ++i2) {
            if (src2[this.props[i2].start] !== Char.COMMENT)
              return true;
          }
        }
        return false;
      }
      get includesTrailingLines() {
        return false;
      }
      get jsonLike() {
        const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];
        return jsonLikeTypes.indexOf(this.type) !== -1;
      }
      get rangeAsLinePos() {
        if (!this.range || !this.context)
          return void 0;
        const start = getLinePos(this.range.start, this.context.root);
        if (!start)
          return void 0;
        const end = getLinePos(this.range.end, this.context.root);
        return {
          start,
          end
        };
      }
      get rawValue() {
        if (!this.valueRange || !this.context)
          return null;
        const {
          start,
          end
        } = this.valueRange;
        return this.context.src.slice(start, end);
      }
      get tag() {
        for (let i2 = 0; i2 < this.props.length; ++i2) {
          const tag = this.getPropValue(i2, Char.TAG, false);
          if (tag != null) {
            if (tag[1] === "<") {
              return {
                verbatim: tag.slice(2, -1)
              };
            } else {
              const [_2, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);
              return {
                handle,
                suffix
              };
            }
          }
        }
        return null;
      }
      get valueRangeContainsNewline() {
        if (!this.valueRange || !this.context)
          return false;
        const {
          start,
          end
        } = this.valueRange;
        const {
          src: src2
        } = this.context;
        for (let i2 = start; i2 < end; ++i2) {
          if (src2[i2] === "\n")
            return true;
        }
        return false;
      }
      parseComment(start) {
        const {
          src: src2
        } = this.context;
        if (src2[start] === Char.COMMENT) {
          const end = Node$2.endOfLine(src2, start + 1);
          const commentRange = new Range(start, end);
          this.props.push(commentRange);
          return end;
        }
        return start;
      }
      setOrigRanges(cr2, offset2) {
        if (this.range)
          offset2 = this.range.setOrigRange(cr2, offset2);
        if (this.valueRange)
          this.valueRange.setOrigRange(cr2, offset2);
        this.props.forEach((prop) => prop.setOrigRange(cr2, offset2));
        return offset2;
      }
      toString() {
        const {
          context: {
            src: src2
          },
          range: range2,
          value
        } = this;
        if (value != null)
          return value;
        const str = src2.slice(range2.start, range2.end);
        return Node$2.addStringTerminator(src2, range2.end, str);
      }
    };
    var YAMLError = class extends Error {
      constructor(name, source2, message) {
        if (!message || !(source2 instanceof Node$2))
          throw new Error(`Invalid arguments for new ${name}`);
        super();
        this.name = name;
        this.message = message;
        this.source = source2;
      }
      makePretty() {
        if (!this.source)
          return;
        this.nodeType = this.source.type;
        const cst = this.source.context && this.source.context.root;
        if (typeof this.offset === "number") {
          this.range = new Range(this.offset, this.offset + 1);
          const start = cst && getLinePos(this.offset, cst);
          if (start) {
            const end = {
              line: start.line,
              col: start.col + 1
            };
            this.linePos = {
              start,
              end
            };
          }
          delete this.offset;
        } else {
          this.range = this.source.range;
          this.linePos = this.source.rangeAsLinePos;
        }
        if (this.linePos) {
          const {
            line,
            col
          } = this.linePos.start;
          this.message += ` at line ${line}, column ${col}`;
          const ctx = cst && getPrettyContext(this.linePos, cst);
          if (ctx)
            this.message += `:

${ctx}
`;
        }
        delete this.source;
      }
    };
    var YAMLReferenceError = class extends YAMLError {
      constructor(source2, message) {
        super("YAMLReferenceError", source2, message);
      }
    };
    var YAMLSemanticError = class extends YAMLError {
      constructor(source2, message) {
        super("YAMLSemanticError", source2, message);
      }
    };
    var YAMLSyntaxError = class extends YAMLError {
      constructor(source2, message) {
        super("YAMLSyntaxError", source2, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(source2, message) {
        super("YAMLWarning", source2, message);
      }
    };
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var PlainValue$6 = class extends Node$2 {
      static endOfLine(src2, start, inFlow) {
        let ch2 = src2[start];
        let offset2 = start;
        while (ch2 && ch2 !== "\n") {
          if (inFlow && (ch2 === "[" || ch2 === "]" || ch2 === "{" || ch2 === "}" || ch2 === ","))
            break;
          const next = src2[offset2 + 1];
          if (ch2 === ":" && (!next || next === "\n" || next === "	" || next === " " || inFlow && next === ","))
            break;
          if ((ch2 === " " || ch2 === "	") && next === "#")
            break;
          offset2 += 1;
          ch2 = next;
        }
        return offset2;
      }
      get strValue() {
        if (!this.valueRange || !this.context)
          return null;
        let {
          start,
          end
        } = this.valueRange;
        const {
          src: src2
        } = this.context;
        let ch2 = src2[end - 1];
        while (start < end && (ch2 === "\n" || ch2 === "	" || ch2 === " "))
          ch2 = src2[--end - 1];
        let str = "";
        for (let i2 = start; i2 < end; ++i2) {
          const ch3 = src2[i2];
          if (ch3 === "\n") {
            const {
              fold,
              offset: offset2
            } = Node$2.foldNewline(src2, i2, -1);
            str += fold;
            i2 = offset2;
          } else if (ch3 === " " || ch3 === "	") {
            const wsStart = i2;
            let next = src2[i2 + 1];
            while (i2 < end && (next === " " || next === "	")) {
              i2 += 1;
              next = src2[i2 + 1];
            }
            if (next !== "\n")
              str += i2 > wsStart ? src2.slice(wsStart, i2 + 1) : ch3;
          } else {
            str += ch3;
          }
        }
        const ch0 = src2[start];
        switch (ch0) {
          case "	": {
            const msg = "Plain value cannot start with a tab character";
            const errors = [new YAMLSemanticError(this, msg)];
            return {
              errors,
              str
            };
          }
          case "@":
          case "`": {
            const msg = `Plain value cannot start with reserved character ${ch0}`;
            const errors = [new YAMLSemanticError(this, msg)];
            return {
              errors,
              str
            };
          }
          default:
            return str;
        }
      }
      parseBlockValue(start) {
        const {
          indent,
          inFlow,
          src: src2
        } = this.context;
        let offset2 = start;
        let valueEnd = start;
        for (let ch2 = src2[offset2]; ch2 === "\n"; ch2 = src2[offset2]) {
          if (Node$2.atDocumentBoundary(src2, offset2 + 1))
            break;
          const end = Node$2.endOfBlockIndent(src2, indent, offset2 + 1);
          if (end === null || src2[end] === "#")
            break;
          if (src2[end] === "\n") {
            offset2 = end;
          } else {
            valueEnd = PlainValue$6.endOfLine(src2, end, inFlow);
            offset2 = valueEnd;
          }
        }
        if (this.valueRange.isEmpty())
          this.valueRange.start = start;
        this.valueRange.end = valueEnd;
        return valueEnd;
      }
      parse(context2, start) {
        this.context = context2;
        const {
          inFlow,
          src: src2
        } = context2;
        let offset2 = start;
        const ch2 = src2[offset2];
        if (ch2 && ch2 !== "#" && ch2 !== "\n") {
          offset2 = PlainValue$6.endOfLine(src2, start, inFlow);
        }
        this.valueRange = new Range(start, offset2);
        offset2 = Node$2.endOfWhiteSpace(src2, offset2);
        offset2 = this.parseComment(offset2);
        if (!this.hasComment || this.valueRange.isEmpty()) {
          offset2 = this.parseBlockValue(offset2);
        }
        return offset2;
      }
    };
    PlainValueEc8e588e.Char = Char;
    PlainValueEc8e588e.Node = Node$2;
    PlainValueEc8e588e.PlainValue = PlainValue$6;
    PlainValueEc8e588e.Range = Range;
    PlainValueEc8e588e.Type = Type;
    PlainValueEc8e588e.YAMLError = YAMLError;
    PlainValueEc8e588e.YAMLReferenceError = YAMLReferenceError;
    PlainValueEc8e588e.YAMLSemanticError = YAMLSemanticError;
    PlainValueEc8e588e.YAMLSyntaxError = YAMLSyntaxError;
    PlainValueEc8e588e.YAMLWarning = YAMLWarning;
    PlainValueEc8e588e._defineProperty = _defineProperty;
    PlainValueEc8e588e.defaultTagPrefix = defaultTagPrefix;
    PlainValueEc8e588e.defaultTags = defaultTags;
    var PlainValue$5 = PlainValueEc8e588e;
    var BlankLine = class extends PlainValue$5.Node {
      constructor() {
        super(PlainValue$5.Type.BLANK_LINE);
      }
      get includesTrailingLines() {
        return true;
      }
      parse(context2, start) {
        this.context = context2;
        this.range = new PlainValue$5.Range(start, start + 1);
        return start + 1;
      }
    };
    var CollectionItem = class extends PlainValue$5.Node {
      constructor(type, props) {
        super(type, props);
        this.node = null;
      }
      get includesTrailingLines() {
        return !!this.node && this.node.includesTrailingLines;
      }
      parse(context2, start) {
        this.context = context2;
        const {
          parseNode,
          src: src2
        } = context2;
        let {
          atLineStart,
          lineStart
        } = context2;
        if (!atLineStart && this.type === PlainValue$5.Type.SEQ_ITEM)
          this.error = new PlainValue$5.YAMLSemanticError(this, "Sequence items must not have preceding content on the same line");
        const indent = atLineStart ? start - lineStart : context2.indent;
        let offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, start + 1);
        let ch2 = src2[offset2];
        const inlineComment = ch2 === "#";
        const comments = [];
        let blankLine = null;
        while (ch2 === "\n" || ch2 === "#") {
          if (ch2 === "#") {
            const end2 = PlainValue$5.Node.endOfLine(src2, offset2 + 1);
            comments.push(new PlainValue$5.Range(offset2, end2));
            offset2 = end2;
          } else {
            atLineStart = true;
            lineStart = offset2 + 1;
            const wsEnd = PlainValue$5.Node.endOfWhiteSpace(src2, lineStart);
            if (src2[wsEnd] === "\n" && comments.length === 0) {
              blankLine = new BlankLine();
              lineStart = blankLine.parse({
                src: src2
              }, lineStart);
            }
            offset2 = PlainValue$5.Node.endOfIndent(src2, lineStart);
          }
          ch2 = src2[offset2];
        }
        if (PlainValue$5.Node.nextNodeIsIndented(ch2, offset2 - (lineStart + indent), this.type !== PlainValue$5.Type.SEQ_ITEM)) {
          this.node = parseNode({
            atLineStart,
            inCollection: false,
            indent,
            lineStart,
            parent: this
          }, offset2);
        } else if (ch2 && lineStart > start + 1) {
          offset2 = lineStart - 1;
        }
        if (this.node) {
          if (blankLine) {
            const items = context2.parent.items || context2.parent.contents;
            if (items)
              items.push(blankLine);
          }
          if (comments.length)
            Array.prototype.push.apply(this.props, comments);
          offset2 = this.node.range.end;
        } else {
          if (inlineComment) {
            const c2 = comments[0];
            this.props.push(c2);
            offset2 = c2.end;
          } else {
            offset2 = PlainValue$5.Node.endOfLine(src2, start + 1);
          }
        }
        const end = this.node ? this.node.valueRange.end : offset2;
        this.valueRange = new PlainValue$5.Range(start, end);
        return offset2;
      }
      setOrigRanges(cr2, offset2) {
        offset2 = super.setOrigRanges(cr2, offset2);
        return this.node ? this.node.setOrigRanges(cr2, offset2) : offset2;
      }
      toString() {
        const {
          context: {
            src: src2
          },
          node: node2,
          range: range2,
          value
        } = this;
        if (value != null)
          return value;
        const str = node2 ? src2.slice(range2.start, node2.range.start) + String(node2) : src2.slice(range2.start, range2.end);
        return PlainValue$5.Node.addStringTerminator(src2, range2.end, str);
      }
    };
    var Comment = class extends PlainValue$5.Node {
      constructor() {
        super(PlainValue$5.Type.COMMENT);
      }
      parse(context2, start) {
        this.context = context2;
        const offset2 = this.parseComment(start);
        this.range = new PlainValue$5.Range(start, offset2);
        return offset2;
      }
    };
    function grabCollectionEndComments(node2) {
      let cnode = node2;
      while (cnode instanceof CollectionItem)
        cnode = cnode.node;
      if (!(cnode instanceof Collection$1))
        return null;
      const len = cnode.items.length;
      let ci2 = -1;
      for (let i2 = len - 1; i2 >= 0; --i2) {
        const n3 = cnode.items[i2];
        if (n3.type === PlainValue$5.Type.COMMENT) {
          const {
            indent,
            lineStart
          } = n3.context;
          if (indent > 0 && n3.range.start >= lineStart + indent)
            break;
          ci2 = i2;
        } else if (n3.type === PlainValue$5.Type.BLANK_LINE)
          ci2 = i2;
        else
          break;
      }
      if (ci2 === -1)
        return null;
      const ca2 = cnode.items.splice(ci2, len - ci2);
      const prevEnd = ca2[0].range.start;
      while (true) {
        cnode.range.end = prevEnd;
        if (cnode.valueRange && cnode.valueRange.end > prevEnd)
          cnode.valueRange.end = prevEnd;
        if (cnode === node2)
          break;
        cnode = cnode.context.parent;
      }
      return ca2;
    }
    var Collection$1 = class extends PlainValue$5.Node {
      static nextContentHasIndent(src2, offset2, indent) {
        const lineStart = PlainValue$5.Node.endOfLine(src2, offset2) + 1;
        offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, lineStart);
        const ch2 = src2[offset2];
        if (!ch2)
          return false;
        if (offset2 >= lineStart + indent)
          return true;
        if (ch2 !== "#" && ch2 !== "\n")
          return false;
        return Collection$1.nextContentHasIndent(src2, offset2, indent);
      }
      constructor(firstItem) {
        super(firstItem.type === PlainValue$5.Type.SEQ_ITEM ? PlainValue$5.Type.SEQ : PlainValue$5.Type.MAP);
        for (let i2 = firstItem.props.length - 1; i2 >= 0; --i2) {
          if (firstItem.props[i2].start < firstItem.context.lineStart) {
            this.props = firstItem.props.slice(0, i2 + 1);
            firstItem.props = firstItem.props.slice(i2 + 1);
            const itemRange = firstItem.props[0] || firstItem.valueRange;
            firstItem.range.start = itemRange.start;
            break;
          }
        }
        this.items = [firstItem];
        const ec = grabCollectionEndComments(firstItem);
        if (ec)
          Array.prototype.push.apply(this.items, ec);
      }
      get includesTrailingLines() {
        return this.items.length > 0;
      }
      parse(context2, start) {
        this.context = context2;
        const {
          parseNode,
          src: src2
        } = context2;
        let lineStart = PlainValue$5.Node.startOfLine(src2, start);
        const firstItem = this.items[0];
        firstItem.context.parent = this;
        this.valueRange = PlainValue$5.Range.copy(firstItem.valueRange);
        const indent = firstItem.range.start - firstItem.context.lineStart;
        let offset2 = start;
        offset2 = PlainValue$5.Node.normalizeOffset(src2, offset2);
        let ch2 = src2[offset2];
        let atLineStart = PlainValue$5.Node.endOfWhiteSpace(src2, lineStart) === offset2;
        let prevIncludesTrailingLines = false;
        while (ch2) {
          while (ch2 === "\n" || ch2 === "#") {
            if (atLineStart && ch2 === "\n" && !prevIncludesTrailingLines) {
              const blankLine = new BlankLine();
              offset2 = blankLine.parse({
                src: src2
              }, offset2);
              this.valueRange.end = offset2;
              if (offset2 >= src2.length) {
                ch2 = null;
                break;
              }
              this.items.push(blankLine);
              offset2 -= 1;
            } else if (ch2 === "#") {
              if (offset2 < lineStart + indent && !Collection$1.nextContentHasIndent(src2, offset2, indent)) {
                return offset2;
              }
              const comment = new Comment();
              offset2 = comment.parse({
                indent,
                lineStart,
                src: src2
              }, offset2);
              this.items.push(comment);
              this.valueRange.end = offset2;
              if (offset2 >= src2.length) {
                ch2 = null;
                break;
              }
            }
            lineStart = offset2 + 1;
            offset2 = PlainValue$5.Node.endOfIndent(src2, lineStart);
            if (PlainValue$5.Node.atBlank(src2, offset2)) {
              const wsEnd = PlainValue$5.Node.endOfWhiteSpace(src2, offset2);
              const next = src2[wsEnd];
              if (!next || next === "\n" || next === "#") {
                offset2 = wsEnd;
              }
            }
            ch2 = src2[offset2];
            atLineStart = true;
          }
          if (!ch2) {
            break;
          }
          if (offset2 !== lineStart + indent && (atLineStart || ch2 !== ":")) {
            if (offset2 < lineStart + indent) {
              if (lineStart > start)
                offset2 = lineStart;
              break;
            } else if (!this.error) {
              const msg = "All collection items must start at the same column";
              this.error = new PlainValue$5.YAMLSyntaxError(this, msg);
            }
          }
          if (firstItem.type === PlainValue$5.Type.SEQ_ITEM) {
            if (ch2 !== "-") {
              if (lineStart > start)
                offset2 = lineStart;
              break;
            }
          } else if (ch2 === "-" && !this.error) {
            const next = src2[offset2 + 1];
            if (!next || next === "\n" || next === "	" || next === " ") {
              const msg = "A collection cannot be both a mapping and a sequence";
              this.error = new PlainValue$5.YAMLSyntaxError(this, msg);
            }
          }
          const node2 = parseNode({
            atLineStart,
            inCollection: true,
            indent,
            lineStart,
            parent: this
          }, offset2);
          if (!node2)
            return offset2;
          this.items.push(node2);
          this.valueRange.end = node2.valueRange.end;
          offset2 = PlainValue$5.Node.normalizeOffset(src2, node2.range.end);
          ch2 = src2[offset2];
          atLineStart = false;
          prevIncludesTrailingLines = node2.includesTrailingLines;
          if (ch2) {
            let ls2 = offset2 - 1;
            let prev = src2[ls2];
            while (prev === " " || prev === "	")
              prev = src2[--ls2];
            if (prev === "\n") {
              lineStart = ls2 + 1;
              atLineStart = true;
            }
          }
          const ec = grabCollectionEndComments(node2);
          if (ec)
            Array.prototype.push.apply(this.items, ec);
        }
        return offset2;
      }
      setOrigRanges(cr2, offset2) {
        offset2 = super.setOrigRanges(cr2, offset2);
        this.items.forEach((node2) => {
          offset2 = node2.setOrigRanges(cr2, offset2);
        });
        return offset2;
      }
      toString() {
        const {
          context: {
            src: src2
          },
          items,
          range: range2,
          value
        } = this;
        if (value != null)
          return value;
        let str = src2.slice(range2.start, items[0].range.start) + String(items[0]);
        for (let i2 = 1; i2 < items.length; ++i2) {
          const item = items[i2];
          const {
            atLineStart,
            indent
          } = item.context;
          if (atLineStart)
            for (let i3 = 0; i3 < indent; ++i3)
              str += " ";
          str += String(item);
        }
        return PlainValue$5.Node.addStringTerminator(src2, range2.end, str);
      }
    };
    var Directive = class extends PlainValue$5.Node {
      constructor() {
        super(PlainValue$5.Type.DIRECTIVE);
        this.name = null;
      }
      get parameters() {
        const raw = this.rawValue;
        return raw ? raw.trim().split(/[ \t]+/) : [];
      }
      parseName(start) {
        const {
          src: src2
        } = this.context;
        let offset2 = start;
        let ch2 = src2[offset2];
        while (ch2 && ch2 !== "\n" && ch2 !== "	" && ch2 !== " ")
          ch2 = src2[offset2 += 1];
        this.name = src2.slice(start, offset2);
        return offset2;
      }
      parseParameters(start) {
        const {
          src: src2
        } = this.context;
        let offset2 = start;
        let ch2 = src2[offset2];
        while (ch2 && ch2 !== "\n" && ch2 !== "#")
          ch2 = src2[offset2 += 1];
        this.valueRange = new PlainValue$5.Range(start, offset2);
        return offset2;
      }
      parse(context2, start) {
        this.context = context2;
        let offset2 = this.parseName(start + 1);
        offset2 = this.parseParameters(offset2);
        offset2 = this.parseComment(offset2);
        this.range = new PlainValue$5.Range(start, offset2);
        return offset2;
      }
    };
    var Document$3 = class extends PlainValue$5.Node {
      static startCommentOrEndBlankLine(src2, start) {
        const offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, start);
        const ch2 = src2[offset2];
        return ch2 === "#" || ch2 === "\n" ? offset2 : start;
      }
      constructor() {
        super(PlainValue$5.Type.DOCUMENT);
        this.directives = null;
        this.contents = null;
        this.directivesEndMarker = null;
        this.documentEndMarker = null;
      }
      parseDirectives(start) {
        const {
          src: src2
        } = this.context;
        this.directives = [];
        let atLineStart = true;
        let hasDirectives = false;
        let offset2 = start;
        while (!PlainValue$5.Node.atDocumentBoundary(src2, offset2, PlainValue$5.Char.DIRECTIVES_END)) {
          offset2 = Document$3.startCommentOrEndBlankLine(src2, offset2);
          switch (src2[offset2]) {
            case "\n":
              if (atLineStart) {
                const blankLine = new BlankLine();
                offset2 = blankLine.parse({
                  src: src2
                }, offset2);
                if (offset2 < src2.length) {
                  this.directives.push(blankLine);
                }
              } else {
                offset2 += 1;
                atLineStart = true;
              }
              break;
            case "#":
              {
                const comment = new Comment();
                offset2 = comment.parse({
                  src: src2
                }, offset2);
                this.directives.push(comment);
                atLineStart = false;
              }
              break;
            case "%":
              {
                const directive = new Directive();
                offset2 = directive.parse({
                  parent: this,
                  src: src2
                }, offset2);
                this.directives.push(directive);
                hasDirectives = true;
                atLineStart = false;
              }
              break;
            default:
              if (hasDirectives) {
                this.error = new PlainValue$5.YAMLSemanticError(this, "Missing directives-end indicator line");
              } else if (this.directives.length > 0) {
                this.contents = this.directives;
                this.directives = [];
              }
              return offset2;
          }
        }
        if (src2[offset2]) {
          this.directivesEndMarker = new PlainValue$5.Range(offset2, offset2 + 3);
          return offset2 + 3;
        }
        if (hasDirectives) {
          this.error = new PlainValue$5.YAMLSemanticError(this, "Missing directives-end indicator line");
        } else if (this.directives.length > 0) {
          this.contents = this.directives;
          this.directives = [];
        }
        return offset2;
      }
      parseContents(start) {
        const {
          parseNode,
          src: src2
        } = this.context;
        if (!this.contents)
          this.contents = [];
        let lineStart = start;
        while (src2[lineStart - 1] === "-")
          lineStart -= 1;
        let offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, start);
        let atLineStart = lineStart === start;
        this.valueRange = new PlainValue$5.Range(offset2);
        while (!PlainValue$5.Node.atDocumentBoundary(src2, offset2, PlainValue$5.Char.DOCUMENT_END)) {
          switch (src2[offset2]) {
            case "\n":
              if (atLineStart) {
                const blankLine = new BlankLine();
                offset2 = blankLine.parse({
                  src: src2
                }, offset2);
                if (offset2 < src2.length) {
                  this.contents.push(blankLine);
                }
              } else {
                offset2 += 1;
                atLineStart = true;
              }
              lineStart = offset2;
              break;
            case "#":
              {
                const comment = new Comment();
                offset2 = comment.parse({
                  src: src2
                }, offset2);
                this.contents.push(comment);
                atLineStart = false;
              }
              break;
            default: {
              const iEnd = PlainValue$5.Node.endOfIndent(src2, offset2);
              const context2 = {
                atLineStart,
                indent: -1,
                inFlow: false,
                inCollection: false,
                lineStart,
                parent: this
              };
              const node2 = parseNode(context2, iEnd);
              if (!node2)
                return this.valueRange.end = iEnd;
              this.contents.push(node2);
              offset2 = node2.range.end;
              atLineStart = false;
              const ec = grabCollectionEndComments(node2);
              if (ec)
                Array.prototype.push.apply(this.contents, ec);
            }
          }
          offset2 = Document$3.startCommentOrEndBlankLine(src2, offset2);
        }
        this.valueRange.end = offset2;
        if (src2[offset2]) {
          this.documentEndMarker = new PlainValue$5.Range(offset2, offset2 + 3);
          offset2 += 3;
          if (src2[offset2]) {
            offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, offset2);
            if (src2[offset2] === "#") {
              const comment = new Comment();
              offset2 = comment.parse({
                src: src2
              }, offset2);
              this.contents.push(comment);
            }
            switch (src2[offset2]) {
              case "\n":
                offset2 += 1;
                break;
              case void 0:
                break;
              default:
                this.error = new PlainValue$5.YAMLSyntaxError(this, "Document end marker line cannot have a non-comment suffix");
            }
          }
        }
        return offset2;
      }
      parse(context2, start) {
        context2.root = this;
        this.context = context2;
        const {
          src: src2
        } = context2;
        let offset2 = src2.charCodeAt(start) === 65279 ? start + 1 : start;
        offset2 = this.parseDirectives(offset2);
        offset2 = this.parseContents(offset2);
        return offset2;
      }
      setOrigRanges(cr2, offset2) {
        offset2 = super.setOrigRanges(cr2, offset2);
        this.directives.forEach((node2) => {
          offset2 = node2.setOrigRanges(cr2, offset2);
        });
        if (this.directivesEndMarker)
          offset2 = this.directivesEndMarker.setOrigRange(cr2, offset2);
        this.contents.forEach((node2) => {
          offset2 = node2.setOrigRanges(cr2, offset2);
        });
        if (this.documentEndMarker)
          offset2 = this.documentEndMarker.setOrigRange(cr2, offset2);
        return offset2;
      }
      toString() {
        const {
          contents,
          directives,
          value
        } = this;
        if (value != null)
          return value;
        let str = directives.join("");
        if (contents.length > 0) {
          if (directives.length > 0 || contents[0].type === PlainValue$5.Type.COMMENT)
            str += "---\n";
          str += contents.join("");
        }
        if (str[str.length - 1] !== "\n")
          str += "\n";
        return str;
      }
    };
    var Alias$1 = class extends PlainValue$5.Node {
      parse(context2, start) {
        this.context = context2;
        const {
          src: src2
        } = context2;
        let offset2 = PlainValue$5.Node.endOfIdentifier(src2, start + 1);
        this.valueRange = new PlainValue$5.Range(start + 1, offset2);
        offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, offset2);
        offset2 = this.parseComment(offset2);
        return offset2;
      }
    };
    var Chomp = {
      CLIP: "CLIP",
      KEEP: "KEEP",
      STRIP: "STRIP"
    };
    var BlockValue = class extends PlainValue$5.Node {
      constructor(type, props) {
        super(type, props);
        this.blockIndent = null;
        this.chomping = Chomp.CLIP;
        this.header = null;
      }
      get includesTrailingLines() {
        return this.chomping === Chomp.KEEP;
      }
      get strValue() {
        if (!this.valueRange || !this.context)
          return null;
        let {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src: src2
        } = this.context;
        if (this.valueRange.isEmpty())
          return "";
        let lastNewLine = null;
        let ch2 = src2[end - 1];
        while (ch2 === "\n" || ch2 === "	" || ch2 === " ") {
          end -= 1;
          if (end <= start) {
            if (this.chomping === Chomp.KEEP)
              break;
            else
              return "";
          }
          if (ch2 === "\n")
            lastNewLine = end;
          ch2 = src2[end - 1];
        }
        let keepStart = end + 1;
        if (lastNewLine) {
          if (this.chomping === Chomp.KEEP) {
            keepStart = lastNewLine;
            end = this.valueRange.end;
          } else {
            end = lastNewLine;
          }
        }
        const bi2 = indent + this.blockIndent;
        const folded = this.type === PlainValue$5.Type.BLOCK_FOLDED;
        let atStart = true;
        let str = "";
        let sep = "";
        let prevMoreIndented = false;
        for (let i2 = start; i2 < end; ++i2) {
          for (let j2 = 0; j2 < bi2; ++j2) {
            if (src2[i2] !== " ")
              break;
            i2 += 1;
          }
          const ch3 = src2[i2];
          if (ch3 === "\n") {
            if (sep === "\n")
              str += "\n";
            else
              sep = "\n";
          } else {
            const lineEnd = PlainValue$5.Node.endOfLine(src2, i2);
            const line = src2.slice(i2, lineEnd);
            i2 = lineEnd;
            if (folded && (ch3 === " " || ch3 === "	") && i2 < keepStart) {
              if (sep === " ")
                sep = "\n";
              else if (!prevMoreIndented && !atStart && sep === "\n")
                sep = "\n\n";
              str += sep + line;
              sep = lineEnd < end && src2[lineEnd] || "";
              prevMoreIndented = true;
            } else {
              str += sep + line;
              sep = folded && i2 < keepStart ? " " : "\n";
              prevMoreIndented = false;
            }
            if (atStart && line !== "")
              atStart = false;
          }
        }
        return this.chomping === Chomp.STRIP ? str : str + "\n";
      }
      parseBlockHeader(start) {
        const {
          src: src2
        } = this.context;
        let offset2 = start + 1;
        let bi2 = "";
        while (true) {
          const ch2 = src2[offset2];
          switch (ch2) {
            case "-":
              this.chomping = Chomp.STRIP;
              break;
            case "+":
              this.chomping = Chomp.KEEP;
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              bi2 += ch2;
              break;
            default:
              this.blockIndent = Number(bi2) || null;
              this.header = new PlainValue$5.Range(start, offset2);
              return offset2;
          }
          offset2 += 1;
        }
      }
      parseBlockValue(start) {
        const {
          indent,
          src: src2
        } = this.context;
        const explicit = !!this.blockIndent;
        let offset2 = start;
        let valueEnd = start;
        let minBlockIndent = 1;
        for (let ch2 = src2[offset2]; ch2 === "\n"; ch2 = src2[offset2]) {
          offset2 += 1;
          if (PlainValue$5.Node.atDocumentBoundary(src2, offset2))
            break;
          const end = PlainValue$5.Node.endOfBlockIndent(src2, indent, offset2);
          if (end === null)
            break;
          const ch3 = src2[end];
          const lineIndent = end - (offset2 + indent);
          if (!this.blockIndent) {
            if (src2[end] !== "\n") {
              if (lineIndent < minBlockIndent) {
                const msg = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                this.error = new PlainValue$5.YAMLSemanticError(this, msg);
              }
              this.blockIndent = lineIndent;
            } else if (lineIndent > minBlockIndent) {
              minBlockIndent = lineIndent;
            }
          } else if (ch3 && ch3 !== "\n" && lineIndent < this.blockIndent) {
            if (src2[end] === "#")
              break;
            if (!this.error) {
              const src3 = explicit ? "explicit indentation indicator" : "first line";
              const msg = `Block scalars must not be less indented than their ${src3}`;
              this.error = new PlainValue$5.YAMLSemanticError(this, msg);
            }
          }
          if (src2[end] === "\n") {
            offset2 = end;
          } else {
            offset2 = valueEnd = PlainValue$5.Node.endOfLine(src2, end);
          }
        }
        if (this.chomping !== Chomp.KEEP) {
          offset2 = src2[valueEnd] ? valueEnd + 1 : valueEnd;
        }
        this.valueRange = new PlainValue$5.Range(start + 1, offset2);
        return offset2;
      }
      parse(context2, start) {
        this.context = context2;
        const {
          src: src2
        } = context2;
        let offset2 = this.parseBlockHeader(start);
        offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, offset2);
        offset2 = this.parseComment(offset2);
        offset2 = this.parseBlockValue(offset2);
        return offset2;
      }
      setOrigRanges(cr2, offset2) {
        offset2 = super.setOrigRanges(cr2, offset2);
        return this.header ? this.header.setOrigRange(cr2, offset2) : offset2;
      }
    };
    var FlowCollection = class extends PlainValue$5.Node {
      constructor(type, props) {
        super(type, props);
        this.items = null;
      }
      prevNodeIsJsonLike(idx = this.items.length) {
        const node2 = this.items[idx - 1];
        return !!node2 && (node2.jsonLike || node2.type === PlainValue$5.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
      }
      parse(context2, start) {
        this.context = context2;
        const {
          parseNode,
          src: src2
        } = context2;
        let {
          indent,
          lineStart
        } = context2;
        let char = src2[start];
        this.items = [{
          char,
          offset: start
        }];
        let offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, start + 1);
        char = src2[offset2];
        while (char && char !== "]" && char !== "}") {
          switch (char) {
            case "\n":
              {
                lineStart = offset2 + 1;
                const wsEnd = PlainValue$5.Node.endOfWhiteSpace(src2, lineStart);
                if (src2[wsEnd] === "\n") {
                  const blankLine = new BlankLine();
                  lineStart = blankLine.parse({
                    src: src2
                  }, lineStart);
                  this.items.push(blankLine);
                }
                offset2 = PlainValue$5.Node.endOfIndent(src2, lineStart);
                if (offset2 <= lineStart + indent) {
                  char = src2[offset2];
                  if (offset2 < lineStart + indent || char !== "]" && char !== "}") {
                    const msg = "Insufficient indentation in flow collection";
                    this.error = new PlainValue$5.YAMLSemanticError(this, msg);
                  }
                }
              }
              break;
            case ",":
              {
                this.items.push({
                  char,
                  offset: offset2
                });
                offset2 += 1;
              }
              break;
            case "#":
              {
                const comment = new Comment();
                offset2 = comment.parse({
                  src: src2
                }, offset2);
                this.items.push(comment);
              }
              break;
            case "?":
            case ":": {
              const next = src2[offset2 + 1];
              if (next === "\n" || next === "	" || next === " " || next === "," || char === ":" && this.prevNodeIsJsonLike()) {
                this.items.push({
                  char,
                  offset: offset2
                });
                offset2 += 1;
                break;
              }
            }
            default: {
              const node2 = parseNode({
                atLineStart: false,
                inCollection: false,
                inFlow: true,
                indent: -1,
                lineStart,
                parent: this
              }, offset2);
              if (!node2) {
                this.valueRange = new PlainValue$5.Range(start, offset2);
                return offset2;
              }
              this.items.push(node2);
              offset2 = PlainValue$5.Node.normalizeOffset(src2, node2.range.end);
            }
          }
          offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, offset2);
          char = src2[offset2];
        }
        this.valueRange = new PlainValue$5.Range(start, offset2 + 1);
        if (char) {
          this.items.push({
            char,
            offset: offset2
          });
          offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, offset2 + 1);
          offset2 = this.parseComment(offset2);
        }
        return offset2;
      }
      setOrigRanges(cr2, offset2) {
        offset2 = super.setOrigRanges(cr2, offset2);
        this.items.forEach((node2) => {
          if (node2 instanceof PlainValue$5.Node) {
            offset2 = node2.setOrigRanges(cr2, offset2);
          } else if (cr2.length === 0) {
            node2.origOffset = node2.offset;
          } else {
            let i2 = offset2;
            while (i2 < cr2.length) {
              if (cr2[i2] > node2.offset)
                break;
              else
                ++i2;
            }
            node2.origOffset = node2.offset + i2;
            offset2 = i2;
          }
        });
        return offset2;
      }
      toString() {
        const {
          context: {
            src: src2
          },
          items,
          range: range2,
          value
        } = this;
        if (value != null)
          return value;
        const nodes = items.filter((item) => item instanceof PlainValue$5.Node);
        let str = "";
        let prevEnd = range2.start;
        nodes.forEach((node2) => {
          const prefix = src2.slice(prevEnd, node2.range.start);
          prevEnd = node2.range.end;
          str += prefix + String(node2);
          if (str[str.length - 1] === "\n" && src2[prevEnd - 1] !== "\n" && src2[prevEnd] === "\n") {
            prevEnd += 1;
          }
        });
        str += src2.slice(prevEnd, range2.end);
        return PlainValue$5.Node.addStringTerminator(src2, range2.end, str);
      }
    };
    var QuoteDouble = class extends PlainValue$5.Node {
      static endOfQuote(src2, offset2) {
        let ch2 = src2[offset2];
        while (ch2 && ch2 !== '"') {
          offset2 += ch2 === "\\" ? 2 : 1;
          ch2 = src2[offset2];
        }
        return offset2 + 1;
      }
      get strValue() {
        if (!this.valueRange || !this.context)
          return null;
        const errors = [];
        const {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src: src2
        } = this.context;
        if (src2[end - 1] !== '"')
          errors.push(new PlainValue$5.YAMLSyntaxError(this, 'Missing closing "quote'));
        let str = "";
        for (let i2 = start + 1; i2 < end - 1; ++i2) {
          const ch2 = src2[i2];
          if (ch2 === "\n") {
            if (PlainValue$5.Node.atDocumentBoundary(src2, i2 + 1))
              errors.push(new PlainValue$5.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
            const {
              fold,
              offset: offset2,
              error: error2
            } = PlainValue$5.Node.foldNewline(src2, i2, indent);
            str += fold;
            i2 = offset2;
            if (error2)
              errors.push(new PlainValue$5.YAMLSemanticError(this, "Multi-line double-quoted string needs to be sufficiently indented"));
          } else if (ch2 === "\\") {
            i2 += 1;
            switch (src2[i2]) {
              case "0":
                str += "\0";
                break;
              case "a":
                str += "\x07";
                break;
              case "b":
                str += "\b";
                break;
              case "e":
                str += "";
                break;
              case "f":
                str += "\f";
                break;
              case "n":
                str += "\n";
                break;
              case "r":
                str += "\r";
                break;
              case "t":
                str += "	";
                break;
              case "v":
                str += "\v";
                break;
              case "N":
                str += "\x85";
                break;
              case "_":
                str += "\xA0";
                break;
              case "L":
                str += "\u2028";
                break;
              case "P":
                str += "\u2029";
                break;
              case " ":
                str += " ";
                break;
              case '"':
                str += '"';
                break;
              case "/":
                str += "/";
                break;
              case "\\":
                str += "\\";
                break;
              case "	":
                str += "	";
                break;
              case "x":
                str += this.parseCharCode(i2 + 1, 2, errors);
                i2 += 2;
                break;
              case "u":
                str += this.parseCharCode(i2 + 1, 4, errors);
                i2 += 4;
                break;
              case "U":
                str += this.parseCharCode(i2 + 1, 8, errors);
                i2 += 8;
                break;
              case "\n":
                while (src2[i2 + 1] === " " || src2[i2 + 1] === "	")
                  i2 += 1;
                break;
              default:
                errors.push(new PlainValue$5.YAMLSyntaxError(this, `Invalid escape sequence ${src2.substr(i2 - 1, 2)}`));
                str += "\\" + src2[i2];
            }
          } else if (ch2 === " " || ch2 === "	") {
            const wsStart = i2;
            let next = src2[i2 + 1];
            while (next === " " || next === "	") {
              i2 += 1;
              next = src2[i2 + 1];
            }
            if (next !== "\n")
              str += i2 > wsStart ? src2.slice(wsStart, i2 + 1) : ch2;
          } else {
            str += ch2;
          }
        }
        return errors.length > 0 ? {
          errors,
          str
        } : str;
      }
      parseCharCode(offset2, length, errors) {
        const {
          src: src2
        } = this.context;
        const cc = src2.substr(offset2, length);
        const ok2 = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
        const code = ok2 ? parseInt(cc, 16) : NaN;
        if (isNaN(code)) {
          errors.push(new PlainValue$5.YAMLSyntaxError(this, `Invalid escape sequence ${src2.substr(offset2 - 2, length + 2)}`));
          return src2.substr(offset2 - 2, length + 2);
        }
        return String.fromCodePoint(code);
      }
      parse(context2, start) {
        this.context = context2;
        const {
          src: src2
        } = context2;
        let offset2 = QuoteDouble.endOfQuote(src2, start + 1);
        this.valueRange = new PlainValue$5.Range(start, offset2);
        offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, offset2);
        offset2 = this.parseComment(offset2);
        return offset2;
      }
    };
    var QuoteSingle = class extends PlainValue$5.Node {
      static endOfQuote(src2, offset2) {
        let ch2 = src2[offset2];
        while (ch2) {
          if (ch2 === "'") {
            if (src2[offset2 + 1] !== "'")
              break;
            ch2 = src2[offset2 += 2];
          } else {
            ch2 = src2[offset2 += 1];
          }
        }
        return offset2 + 1;
      }
      get strValue() {
        if (!this.valueRange || !this.context)
          return null;
        const errors = [];
        const {
          start,
          end
        } = this.valueRange;
        const {
          indent,
          src: src2
        } = this.context;
        if (src2[end - 1] !== "'")
          errors.push(new PlainValue$5.YAMLSyntaxError(this, "Missing closing 'quote"));
        let str = "";
        for (let i2 = start + 1; i2 < end - 1; ++i2) {
          const ch2 = src2[i2];
          if (ch2 === "\n") {
            if (PlainValue$5.Node.atDocumentBoundary(src2, i2 + 1))
              errors.push(new PlainValue$5.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
            const {
              fold,
              offset: offset2,
              error: error2
            } = PlainValue$5.Node.foldNewline(src2, i2, indent);
            str += fold;
            i2 = offset2;
            if (error2)
              errors.push(new PlainValue$5.YAMLSemanticError(this, "Multi-line single-quoted string needs to be sufficiently indented"));
          } else if (ch2 === "'") {
            str += ch2;
            i2 += 1;
            if (src2[i2] !== "'")
              errors.push(new PlainValue$5.YAMLSyntaxError(this, "Unescaped single quote? This should not happen."));
          } else if (ch2 === " " || ch2 === "	") {
            const wsStart = i2;
            let next = src2[i2 + 1];
            while (next === " " || next === "	") {
              i2 += 1;
              next = src2[i2 + 1];
            }
            if (next !== "\n")
              str += i2 > wsStart ? src2.slice(wsStart, i2 + 1) : ch2;
          } else {
            str += ch2;
          }
        }
        return errors.length > 0 ? {
          errors,
          str
        } : str;
      }
      parse(context2, start) {
        this.context = context2;
        const {
          src: src2
        } = context2;
        let offset2 = QuoteSingle.endOfQuote(src2, start + 1);
        this.valueRange = new PlainValue$5.Range(start, offset2);
        offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, offset2);
        offset2 = this.parseComment(offset2);
        return offset2;
      }
    };
    function createNewNode(type, props) {
      switch (type) {
        case PlainValue$5.Type.ALIAS:
          return new Alias$1(type, props);
        case PlainValue$5.Type.BLOCK_FOLDED:
        case PlainValue$5.Type.BLOCK_LITERAL:
          return new BlockValue(type, props);
        case PlainValue$5.Type.FLOW_MAP:
        case PlainValue$5.Type.FLOW_SEQ:
          return new FlowCollection(type, props);
        case PlainValue$5.Type.MAP_KEY:
        case PlainValue$5.Type.MAP_VALUE:
        case PlainValue$5.Type.SEQ_ITEM:
          return new CollectionItem(type, props);
        case PlainValue$5.Type.COMMENT:
        case PlainValue$5.Type.PLAIN:
          return new PlainValue$5.PlainValue(type, props);
        case PlainValue$5.Type.QUOTE_DOUBLE:
          return new QuoteDouble(type, props);
        case PlainValue$5.Type.QUOTE_SINGLE:
          return new QuoteSingle(type, props);
        default:
          return null;
      }
    }
    var ParseContext = class {
      static parseType(src2, offset2, inFlow) {
        switch (src2[offset2]) {
          case "*":
            return PlainValue$5.Type.ALIAS;
          case ">":
            return PlainValue$5.Type.BLOCK_FOLDED;
          case "|":
            return PlainValue$5.Type.BLOCK_LITERAL;
          case "{":
            return PlainValue$5.Type.FLOW_MAP;
          case "[":
            return PlainValue$5.Type.FLOW_SEQ;
          case "?":
            return !inFlow && PlainValue$5.Node.atBlank(src2, offset2 + 1, true) ? PlainValue$5.Type.MAP_KEY : PlainValue$5.Type.PLAIN;
          case ":":
            return !inFlow && PlainValue$5.Node.atBlank(src2, offset2 + 1, true) ? PlainValue$5.Type.MAP_VALUE : PlainValue$5.Type.PLAIN;
          case "-":
            return !inFlow && PlainValue$5.Node.atBlank(src2, offset2 + 1, true) ? PlainValue$5.Type.SEQ_ITEM : PlainValue$5.Type.PLAIN;
          case '"':
            return PlainValue$5.Type.QUOTE_DOUBLE;
          case "'":
            return PlainValue$5.Type.QUOTE_SINGLE;
          default:
            return PlainValue$5.Type.PLAIN;
        }
      }
      constructor(orig = {}, {
        atLineStart,
        inCollection,
        inFlow,
        indent,
        lineStart,
        parent
      } = {}) {
        PlainValue$5._defineProperty(this, "parseNode", (overlay, start) => {
          if (PlainValue$5.Node.atDocumentBoundary(this.src, start))
            return null;
          const context2 = new ParseContext(this, overlay);
          const {
            props,
            type,
            valueStart
          } = context2.parseProps(start);
          const node2 = createNewNode(type, props);
          let offset2 = node2.parse(context2, valueStart);
          node2.range = new PlainValue$5.Range(start, offset2);
          if (offset2 <= start) {
            node2.error = new Error(`Node#parse consumed no characters`);
            node2.error.parseEnd = offset2;
            node2.error.source = node2;
            node2.range.end = start + 1;
          }
          if (context2.nodeStartsCollection(node2)) {
            if (!node2.error && !context2.atLineStart && context2.parent.type === PlainValue$5.Type.DOCUMENT) {
              node2.error = new PlainValue$5.YAMLSyntaxError(node2, "Block collection must not have preceding content here (e.g. directives-end indicator)");
            }
            const collection = new Collection$1(node2);
            offset2 = collection.parse(new ParseContext(context2), offset2);
            collection.range = new PlainValue$5.Range(start, offset2);
            return collection;
          }
          return node2;
        });
        this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
        this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
        this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
        this.indent = indent != null ? indent : orig.indent;
        this.lineStart = lineStart != null ? lineStart : orig.lineStart;
        this.parent = parent != null ? parent : orig.parent || {};
        this.root = orig.root;
        this.src = orig.src;
      }
      nodeStartsCollection(node2) {
        const {
          inCollection,
          inFlow,
          src: src2
        } = this;
        if (inCollection || inFlow)
          return false;
        if (node2 instanceof CollectionItem)
          return true;
        let offset2 = node2.range.end;
        if (src2[offset2] === "\n" || src2[offset2 - 1] === "\n")
          return false;
        offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, offset2);
        return src2[offset2] === ":";
      }
      parseProps(offset2) {
        const {
          inFlow,
          parent,
          src: src2
        } = this;
        const props = [];
        let lineHasProps = false;
        offset2 = this.atLineStart ? PlainValue$5.Node.endOfIndent(src2, offset2) : PlainValue$5.Node.endOfWhiteSpace(src2, offset2);
        let ch2 = src2[offset2];
        while (ch2 === PlainValue$5.Char.ANCHOR || ch2 === PlainValue$5.Char.COMMENT || ch2 === PlainValue$5.Char.TAG || ch2 === "\n") {
          if (ch2 === "\n") {
            let inEnd = offset2;
            let lineStart;
            do {
              lineStart = inEnd + 1;
              inEnd = PlainValue$5.Node.endOfIndent(src2, lineStart);
            } while (src2[inEnd] === "\n");
            const indentDiff = inEnd - (lineStart + this.indent);
            const noIndicatorAsIndent = parent.type === PlainValue$5.Type.SEQ_ITEM && parent.context.atLineStart;
            if (src2[inEnd] !== "#" && !PlainValue$5.Node.nextNodeIsIndented(src2[inEnd], indentDiff, !noIndicatorAsIndent))
              break;
            this.atLineStart = true;
            this.lineStart = lineStart;
            lineHasProps = false;
            offset2 = inEnd;
          } else if (ch2 === PlainValue$5.Char.COMMENT) {
            const end = PlainValue$5.Node.endOfLine(src2, offset2 + 1);
            props.push(new PlainValue$5.Range(offset2, end));
            offset2 = end;
          } else {
            let end = PlainValue$5.Node.endOfIdentifier(src2, offset2 + 1);
            if (ch2 === PlainValue$5.Char.TAG && src2[end] === "," && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src2.slice(offset2 + 1, end + 13))) {
              end = PlainValue$5.Node.endOfIdentifier(src2, end + 5);
            }
            props.push(new PlainValue$5.Range(offset2, end));
            lineHasProps = true;
            offset2 = PlainValue$5.Node.endOfWhiteSpace(src2, end);
          }
          ch2 = src2[offset2];
        }
        if (lineHasProps && ch2 === ":" && PlainValue$5.Node.atBlank(src2, offset2 + 1, true))
          offset2 -= 1;
        const type = ParseContext.parseType(src2, offset2, inFlow);
        return {
          props,
          type,
          valueStart: offset2
        };
      }
    };
    function parse$h(src2) {
      const cr2 = [];
      if (src2.indexOf("\r") !== -1) {
        src2 = src2.replace(/\r\n?/g, (match2, offset3) => {
          if (match2.length > 1)
            cr2.push(offset3);
          return "\n";
        });
      }
      const documents = [];
      let offset2 = 0;
      do {
        const doc = new Document$3();
        const context2 = new ParseContext({
          src: src2
        });
        offset2 = doc.parse(context2, offset2);
        documents.push(doc);
      } while (offset2 < src2.length);
      documents.setOrigRanges = () => {
        if (cr2.length === 0)
          return false;
        for (let i2 = 1; i2 < cr2.length; ++i2)
          cr2[i2] -= i2;
        let crOffset = 0;
        for (let i2 = 0; i2 < documents.length; ++i2) {
          crOffset = documents[i2].setOrigRanges(cr2, crOffset);
        }
        cr2.splice(0, cr2.length);
        return true;
      };
      documents.toString = () => documents.join("...\n");
      return documents;
    }
    parseCst$1.parse = parse$h;
    var Document9b4560a1 = {};
    var resolveSeqD03cb037 = {};
    var PlainValue$4 = PlainValueEc8e588e;
    function addCommentBefore(str, indent, comment) {
      if (!comment)
        return str;
      const cc = comment.replace(/[\s\S]^/gm, `$&${indent}#`);
      return `#${cc}
${indent}${str}`;
    }
    function addComment(str, indent, comment) {
      return !comment ? str : comment.indexOf("\n") === -1 ? `${str} #${comment}` : `${str}
` + comment.replace(/^/gm, `${indent || ""}#`);
    }
    var Node$1 = class {
    };
    function toJSON(value, arg, ctx) {
      if (Array.isArray(value))
        return value.map((v2, i2) => toJSON(v2, String(i2), ctx));
      if (value && typeof value.toJSON === "function") {
        const anchor = ctx && ctx.anchors && ctx.anchors.get(value);
        if (anchor)
          ctx.onCreate = (res2) => {
            anchor.res = res2;
            delete ctx.onCreate;
          };
        const res = value.toJSON(arg, ctx);
        if (anchor && ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if ((!ctx || !ctx.keep) && typeof value === "bigint")
        return Number(value);
      return value;
    }
    var Scalar = class extends Node$1 {
      constructor(value) {
        super();
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    function collectionFromPath(schema, path2, value) {
      let v2 = value;
      for (let i2 = path2.length - 1; i2 >= 0; --i2) {
        const k2 = path2[i2];
        if (Number.isInteger(k2) && k2 >= 0) {
          const a2 = [];
          a2[k2] = v2;
          v2 = a2;
        } else {
          const o2 = {};
          Object.defineProperty(o2, k2, {
            value: v2,
            writable: true,
            enumerable: true,
            configurable: true
          });
          v2 = o2;
        }
      }
      return schema.createNode(v2, false);
    }
    var isEmptyPath = (path2) => path2 == null || typeof path2 === "object" && path2[Symbol.iterator]().next().done;
    var Collection = class extends Node$1 {
      constructor(schema) {
        super();
        PlainValue$4._defineProperty(this, "items", []);
        this.schema = schema;
      }
      addIn(path2, value) {
        if (isEmptyPath(path2))
          this.add(value);
        else {
          const [key, ...rest] = path2;
          const node2 = this.get(key, true);
          if (node2 instanceof Collection)
            node2.addIn(rest, value);
          else if (node2 === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      deleteIn([key, ...rest]) {
        if (rest.length === 0)
          return this.delete(key);
        const node2 = this.get(key, true);
        if (node2 instanceof Collection)
          return node2.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      getIn([key, ...rest], keepScalar) {
        const node2 = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && node2 instanceof Scalar ? node2.value : node2;
        else
          return node2 instanceof Collection ? node2.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues() {
        return this.items.every((node2) => {
          if (!node2 || node2.type !== "PAIR")
            return false;
          const n3 = node2.value;
          return n3 == null || n3 instanceof Scalar && n3.value == null && !n3.commentBefore && !n3.comment && !n3.tag;
        });
      }
      hasIn([key, ...rest]) {
        if (rest.length === 0)
          return this.has(key);
        const node2 = this.get(key, true);
        return node2 instanceof Collection ? node2.hasIn(rest) : false;
      }
      setIn([key, ...rest], value) {
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node2 = this.get(key, true);
          if (node2 instanceof Collection)
            node2.setIn(rest, value);
          else if (node2 === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      toJSON() {
        return null;
      }
      toString(ctx, {
        blockItem,
        flowChars,
        isMap,
        itemIndent
      }, onComment, onChompKeep) {
        const {
          indent,
          indentStep,
          stringify: stringify2
        } = ctx;
        const inFlow = this.type === PlainValue$4.Type.FLOW_MAP || this.type === PlainValue$4.Type.FLOW_SEQ || ctx.inFlow;
        if (inFlow)
          itemIndent += indentStep;
        const allNullValues = isMap && this.hasAllNullValues();
        ctx = Object.assign({}, ctx, {
          allNullValues,
          indent: itemIndent,
          inFlow,
          type: null
        });
        let chompKeep = false;
        let hasItemWithNewLine = false;
        const nodes = this.items.reduce((nodes2, item, i2) => {
          let comment;
          if (item) {
            if (!chompKeep && item.spaceBefore)
              nodes2.push({
                type: "comment",
                str: ""
              });
            if (item.commentBefore)
              item.commentBefore.match(/^.*$/gm).forEach((line) => {
                nodes2.push({
                  type: "comment",
                  str: `#${line}`
                });
              });
            if (item.comment)
              comment = item.comment;
            if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment)))
              hasItemWithNewLine = true;
          }
          chompKeep = false;
          let str2 = stringify2(item, ctx, () => comment = null, () => chompKeep = true);
          if (inFlow && !hasItemWithNewLine && str2.includes("\n"))
            hasItemWithNewLine = true;
          if (inFlow && i2 < this.items.length - 1)
            str2 += ",";
          str2 = addComment(str2, itemIndent, comment);
          if (chompKeep && (comment || inFlow))
            chompKeep = false;
          nodes2.push({
            type: "item",
            str: str2
          });
          return nodes2;
        }, []);
        let str;
        if (nodes.length === 0) {
          str = flowChars.start + flowChars.end;
        } else if (inFlow) {
          const {
            start,
            end
          } = flowChars;
          const strings = nodes.map((n3) => n3.str);
          if (hasItemWithNewLine || strings.reduce((sum, str2) => sum + str2.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {
            str = start;
            for (const s2 of strings) {
              str += s2 ? `
${indentStep}${indent}${s2}` : "\n";
            }
            str += `
${indent}${end}`;
          } else {
            str = `${start} ${strings.join(" ")} ${end}`;
          }
        } else {
          const strings = nodes.map(blockItem);
          str = strings.shift();
          for (const s2 of strings)
            str += s2 ? `
${indent}${s2}` : "\n";
        }
        if (this.comment) {
          str += "\n" + this.comment.replace(/^/gm, `${indent}#`);
          if (onComment)
            onComment();
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str;
      }
    };
    PlainValue$4._defineProperty(Collection, "maxFlowStringSingleLineLength", 60);
    function asItemIndex(key) {
      let idx = key instanceof Scalar ? key.value : key;
      if (idx && typeof idx === "string")
        idx = Number(idx);
      return Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    var YAMLSeq = class extends Collection {
      add(value) {
        this.items.push(value);
      }
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it2 = this.items[idx];
        return !keepScalar && it2 instanceof Scalar ? it2.value : it2;
      }
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        this.items[idx] = value;
      }
      toJSON(_2, ctx) {
        const seq2 = [];
        if (ctx && ctx.onCreate)
          ctx.onCreate(seq2);
        let i2 = 0;
        for (const item of this.items)
          seq2.push(toJSON(item, String(i2++), ctx));
        return seq2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return super.toString(ctx, {
          blockItem: (n3) => n3.type === "comment" ? n3.str : `- ${n3.str}`,
          flowChars: {
            start: "[",
            end: "]"
          },
          isMap: false,
          itemIndent: (ctx.indent || "") + "  "
        }, onComment, onChompKeep);
      }
    };
    var stringifyKey = (key, jsKey, ctx) => {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (key instanceof Node$1 && ctx && ctx.doc)
        return key.toString({
          anchors: Object.create(null),
          doc: ctx.doc,
          indent: "",
          indentStep: ctx.indentStep,
          inFlow: true,
          inStringifyKey: true,
          stringify: ctx.stringify
        });
      return JSON.stringify(jsKey);
    };
    var Pair = class extends Node$1 {
      constructor(key, value = null) {
        super();
        this.key = key;
        this.value = value;
        this.type = Pair.Type.PAIR;
      }
      get commentBefore() {
        return this.key instanceof Node$1 ? this.key.commentBefore : void 0;
      }
      set commentBefore(cb) {
        if (this.key == null)
          this.key = new Scalar(null);
        if (this.key instanceof Node$1)
          this.key.commentBefore = cb;
        else {
          const msg = "Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";
          throw new Error(msg);
        }
      }
      addToJSMap(ctx, map2) {
        const key = toJSON(this.key, "", ctx);
        if (map2 instanceof Map) {
          const value = toJSON(this.value, key, ctx);
          map2.set(key, value);
        } else if (map2 instanceof Set) {
          map2.add(key);
        } else {
          const stringKey = stringifyKey(this.key, key, ctx);
          const value = toJSON(this.value, stringKey, ctx);
          if (stringKey in map2)
            Object.defineProperty(map2, stringKey, {
              value,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map2[stringKey] = value;
        }
        return map2;
      }
      toJSON(_2, ctx) {
        const pair = ctx && ctx.mapAsMap ? new Map() : {};
        return this.addToJSMap(ctx, pair);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx || !ctx.doc)
          return JSON.stringify(this);
        const {
          indent: indentSize,
          indentSeq,
          simpleKeys
        } = ctx.doc.options;
        let {
          key,
          value
        } = this;
        let keyComment = key instanceof Node$1 && key.comment;
        if (simpleKeys) {
          if (keyComment) {
            throw new Error("With simple keys, key nodes cannot have comments");
          }
          if (key instanceof Collection) {
            const msg = "With simple keys, collection cannot be used as a key value";
            throw new Error(msg);
          }
        }
        let explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node$1 ? key instanceof Collection || key.type === PlainValue$4.Type.BLOCK_FOLDED || key.type === PlainValue$4.Type.BLOCK_LITERAL : typeof key === "object"));
        const {
          doc,
          indent,
          indentStep,
          stringify: stringify2
        } = ctx;
        ctx = Object.assign({}, ctx, {
          implicitKey: !explicitKey,
          indent: indent + indentStep
        });
        let chompKeep = false;
        let str = stringify2(key, ctx, () => keyComment = null, () => chompKeep = true);
        str = addComment(str, ctx.indent, keyComment);
        if (!explicitKey && str.length > 1024) {
          if (simpleKeys)
            throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
          explicitKey = true;
        }
        if (ctx.allNullValues && !simpleKeys) {
          if (this.comment) {
            str = addComment(str, ctx.indent, this.comment);
            if (onComment)
              onComment();
          } else if (chompKeep && !keyComment && onChompKeep)
            onChompKeep();
          return ctx.inFlow && !explicitKey ? str : `? ${str}`;
        }
        str = explicitKey ? `? ${str}
${indent}:` : `${str}:`;
        if (this.comment) {
          str = addComment(str, ctx.indent, this.comment);
          if (onComment)
            onComment();
        }
        let vcb = "";
        let valueComment = null;
        if (value instanceof Node$1) {
          if (value.spaceBefore)
            vcb = "\n";
          if (value.commentBefore) {
            const cs2 = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);
            vcb += `
${cs2}`;
          }
          valueComment = value.comment;
        } else if (value && typeof value === "object") {
          value = doc.schema.createNode(value, true);
        }
        ctx.implicitKey = false;
        if (!explicitKey && !this.comment && value instanceof Scalar)
          ctx.indentAtStart = str.length + 1;
        chompKeep = false;
        if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue$4.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {
          ctx.indent = ctx.indent.substr(2);
        }
        const valueStr = stringify2(value, ctx, () => valueComment = null, () => chompKeep = true);
        let ws2 = " ";
        if (vcb || this.comment) {
          ws2 = `${vcb}
${ctx.indent}`;
        } else if (!explicitKey && value instanceof Collection) {
          const flow = valueStr[0] === "[" || valueStr[0] === "{";
          if (!flow || valueStr.includes("\n"))
            ws2 = `
${ctx.indent}`;
        } else if (valueStr[0] === "\n")
          ws2 = "";
        if (chompKeep && !valueComment && onChompKeep)
          onChompKeep();
        return addComment(str + ws2 + valueStr, ctx.indent, valueComment);
      }
    };
    PlainValue$4._defineProperty(Pair, "Type", {
      PAIR: "PAIR",
      MERGE_PAIR: "MERGE_PAIR"
    });
    var getAliasCount = (node2, anchors) => {
      if (node2 instanceof Alias) {
        const anchor = anchors.get(node2.source);
        return anchor.count * anchor.aliasCount;
      } else if (node2 instanceof Collection) {
        let count = 0;
        for (const item of node2.items) {
          const c2 = getAliasCount(item, anchors);
          if (c2 > count)
            count = c2;
        }
        return count;
      } else if (node2 instanceof Pair) {
        const kc = getAliasCount(node2.key, anchors);
        const vc = getAliasCount(node2.value, anchors);
        return Math.max(kc, vc);
      }
      return 1;
    };
    var Alias = class extends Node$1 {
      static stringify({
        range: range2,
        source: source2
      }, {
        anchors,
        doc,
        implicitKey,
        inStringifyKey
      }) {
        let anchor = Object.keys(anchors).find((a2) => anchors[a2] === source2);
        if (!anchor && inStringifyKey)
          anchor = doc.anchors.getName(source2) || doc.anchors.newName();
        if (anchor)
          return `*${anchor}${implicitKey ? " " : ""}`;
        const msg = doc.anchors.getName(source2) ? "Alias node must be after source node" : "Source node not found for alias node";
        throw new Error(`${msg} [${range2}]`);
      }
      constructor(source2) {
        super();
        this.source = source2;
        this.type = PlainValue$4.Type.ALIAS;
      }
      set tag(t) {
        throw new Error("Alias nodes cannot have tags");
      }
      toJSON(arg, ctx) {
        if (!ctx)
          return toJSON(this.source, arg, ctx);
        const {
          anchors,
          maxAliasCount
        } = ctx;
        const anchor = anchors.get(this.source);
        if (!anchor || anchor.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          if (this.cstNode)
            throw new PlainValue$4.YAMLReferenceError(this.cstNode, msg);
          else
            throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          anchor.count += 1;
          if (anchor.aliasCount === 0)
            anchor.aliasCount = getAliasCount(this.source, anchors);
          if (anchor.count * anchor.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            if (this.cstNode)
              throw new PlainValue$4.YAMLReferenceError(this.cstNode, msg);
            else
              throw new ReferenceError(msg);
          }
        }
        return anchor.res;
      }
      toString(ctx) {
        return Alias.stringify(this, ctx);
      }
    };
    PlainValue$4._defineProperty(Alias, "default", true);
    function findPair(items, key) {
      const k2 = key instanceof Scalar ? key.value : key;
      for (const it2 of items) {
        if (it2 instanceof Pair) {
          if (it2.key === key || it2.key === k2)
            return it2;
          if (it2.key && it2.key.value === k2)
            return it2;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection {
      add(pair, overwrite) {
        if (!pair)
          pair = new Pair(pair);
        else if (!(pair instanceof Pair))
          pair = new Pair(pair.key || pair, pair.value);
        const prev = findPair(this.items, pair.key);
        const sortEntries = this.schema && this.schema.sortMapEntries;
        if (prev) {
          if (overwrite)
            prev.value = pair.value;
          else
            throw new Error(`Key ${pair.key} already set`);
        } else if (sortEntries) {
          const i2 = this.items.findIndex((item) => sortEntries(pair, item) < 0);
          if (i2 === -1)
            this.items.push(pair);
          else
            this.items.splice(i2, 0, pair);
        } else {
          this.items.push(pair);
        }
      }
      delete(key) {
        const it2 = findPair(this.items, key);
        if (!it2)
          return false;
        const del = this.items.splice(this.items.indexOf(it2), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it2 = findPair(this.items, key);
        const node2 = it2 && it2.value;
        return !keepScalar && node2 instanceof Scalar ? node2.value : node2;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair(key, value), true);
      }
      toJSON(_2, ctx, Type2) {
        const map2 = Type2 ? new Type2() : ctx && ctx.mapAsMap ? new Map() : {};
        if (ctx && ctx.onCreate)
          ctx.onCreate(map2);
        for (const item of this.items)
          item.addToJSMap(ctx, map2);
        return map2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!(item instanceof Pair))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        return super.toString(ctx, {
          blockItem: (n3) => n3.str,
          flowChars: {
            start: "{",
            end: "}"
          },
          isMap: true,
          itemIndent: ctx.indent || ""
        }, onComment, onChompKeep);
      }
    };
    var MERGE_KEY = "<<";
    var Merge = class extends Pair {
      constructor(pair) {
        if (pair instanceof Pair) {
          let seq2 = pair.value;
          if (!(seq2 instanceof YAMLSeq)) {
            seq2 = new YAMLSeq();
            seq2.items.push(pair.value);
            seq2.range = pair.value.range;
          }
          super(pair.key, seq2);
          this.range = pair.range;
        } else {
          super(new Scalar(MERGE_KEY), new YAMLSeq());
        }
        this.type = Pair.Type.MERGE_PAIR;
      }
      addToJSMap(ctx, map2) {
        for (const {
          source: source2
        } of this.value.items) {
          if (!(source2 instanceof YAMLMap))
            throw new Error("Merge sources must be maps");
          const srcMap = source2.toJSON(null, ctx, Map);
          for (const [key, value] of srcMap) {
            if (map2 instanceof Map) {
              if (!map2.has(key))
                map2.set(key, value);
            } else if (map2 instanceof Set) {
              map2.add(key);
            } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
              Object.defineProperty(map2, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
        }
        return map2;
      }
      toString(ctx, onComment) {
        const seq2 = this.value;
        if (seq2.items.length > 1)
          return super.toString(ctx, onComment);
        this.value = seq2.items[0];
        const str = super.toString(ctx, onComment);
        this.value = seq2;
        return str;
      }
    };
    var binaryOptions = {
      defaultType: PlainValue$4.Type.BLOCK_LITERAL,
      lineWidth: 76
    };
    var boolOptions = {
      trueStr: "true",
      falseStr: "false"
    };
    var intOptions = {
      asBigInt: false
    };
    var nullOptions = {
      nullStr: "null"
    };
    var strOptions = {
      defaultType: PlainValue$4.Type.PLAIN,
      doubleQuoted: {
        jsonEncoding: false,
        minMultiLineLength: 40
      },
      fold: {
        lineWidth: 80,
        minContentWidth: 20
      }
    };
    function resolveScalar(str, tags2, scalarFallback) {
      for (const {
        format: format2,
        test,
        resolve: resolve2
      } of tags2) {
        if (test) {
          const match2 = str.match(test);
          if (match2) {
            let res = resolve2.apply(null, match2);
            if (!(res instanceof Scalar))
              res = new Scalar(res);
            if (format2)
              res.format = format2;
            return res;
          }
        }
      }
      if (scalarFallback)
        str = scalarFallback(str);
      return new Scalar(str);
    }
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    var consumeMoreIndentedLines = (text, i2) => {
      let ch2 = text[i2 + 1];
      while (ch2 === " " || ch2 === "	") {
        do {
          ch2 = text[i2 += 1];
        } while (ch2 && ch2 !== "\n");
        ch2 = text[i2 + 1];
      }
      return i2;
    };
    function foldFlowLines(text, indent, mode2, {
      indentAtStart,
      lineWidth = 80,
      minContentWidth = 20,
      onFold,
      onOverflow
    }) {
      if (!lineWidth || lineWidth < 0)
        return text;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep)
        return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end = lineWidth - indentAtStart;
      }
      let split2 = void 0;
      let prev = void 0;
      let overflow = false;
      let i2 = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode2 === FOLD_BLOCK) {
        i2 = consumeMoreIndentedLines(text, i2);
        if (i2 !== -1)
          end = i2 + endStep;
      }
      for (let ch2; ch2 = text[i2 += 1]; ) {
        if (mode2 === FOLD_QUOTED && ch2 === "\\") {
          escStart = i2;
          switch (text[i2 + 1]) {
            case "x":
              i2 += 3;
              break;
            case "u":
              i2 += 5;
              break;
            case "U":
              i2 += 9;
              break;
            default:
              i2 += 1;
          }
          escEnd = i2;
        }
        if (ch2 === "\n") {
          if (mode2 === FOLD_BLOCK)
            i2 = consumeMoreIndentedLines(text, i2);
          end = i2 + endStep;
          split2 = void 0;
        } else {
          if (ch2 === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text[i2 + 1];
            if (next && next !== " " && next !== "\n" && next !== "	")
              split2 = i2;
          }
          if (i2 >= end) {
            if (split2) {
              folds.push(split2);
              end = split2 + endStep;
              split2 = void 0;
            } else if (mode2 === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch2;
                ch2 = text[i2 += 1];
                overflow = true;
              }
              const j2 = i2 > escEnd + 1 ? i2 - 2 : escStart - 1;
              if (escapedFolds[j2])
                return text;
              folds.push(j2);
              escapedFolds[j2] = true;
              end = j2 + endStep;
              split2 = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch2;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text;
      if (onFold)
        onFold();
      let res = text.slice(0, folds[0]);
      for (let i3 = 0; i3 < folds.length; ++i3) {
        const fold = folds[i3];
        const end2 = folds[i3 + 1] || text.length;
        if (fold === 0)
          res = `
${indent}${text.slice(0, end2)}`;
        else {
          if (mode2 === FOLD_QUOTED && escapedFolds[fold])
            res += `${text[fold]}\\`;
          res += `
${indent}${text.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    var getFoldOptions = ({
      indentAtStart
    }) => indentAtStart ? Object.assign({
      indentAtStart
    }, strOptions.fold) : strOptions.fold;
    var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str.length;
      if (strLen <= limit)
        return false;
      for (let i2 = 0, start = 0; i2 < strLen; ++i2) {
        if (str[i2] === "\n") {
          if (i2 - start > limit)
            return true;
          start = i2 + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const {
        implicitKey
      } = ctx;
      const {
        jsonEncoding,
        minMultiLineLength
      } = strOptions.doubleQuoted;
      const json2 = JSON.stringify(value);
      if (jsonEncoding)
        return json2;
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str = "";
      let start = 0;
      for (let i2 = 0, ch2 = json2[i2]; ch2; ch2 = json2[++i2]) {
        if (ch2 === " " && json2[i2 + 1] === "\\" && json2[i2 + 2] === "n") {
          str += json2.slice(start, i2) + "\\ ";
          i2 += 1;
          start = i2;
          ch2 = "\\";
        }
        if (ch2 === "\\")
          switch (json2[i2 + 1]) {
            case "u":
              {
                str += json2.slice(start, i2);
                const code = json2.substr(i2 + 2, 4);
                switch (code) {
                  case "0000":
                    str += "\\0";
                    break;
                  case "0007":
                    str += "\\a";
                    break;
                  case "000b":
                    str += "\\v";
                    break;
                  case "001b":
                    str += "\\e";
                    break;
                  case "0085":
                    str += "\\N";
                    break;
                  case "00a0":
                    str += "\\_";
                    break;
                  case "2028":
                    str += "\\L";
                    break;
                  case "2029":
                    str += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str += "\\x" + code.substr(2);
                    else
                      str += json2.substr(i2, 6);
                }
                i2 += 5;
                start = i2 + 1;
              }
              break;
            case "n":
              if (implicitKey || json2[i2 + 2] === '"' || json2.length < minMultiLineLength) {
                i2 += 1;
              } else {
                str += json2.slice(start, i2) + "\n\n";
                while (json2[i2 + 2] === "\\" && json2[i2 + 3] === "n" && json2[i2 + 4] !== '"') {
                  str += "\n";
                  i2 += 2;
                }
                str += indent;
                if (json2[i2 + 2] === " ")
                  str += "\\";
                i2 += 1;
                start = i2 + 1;
              }
              break;
            default:
              i2 += 1;
          }
      }
      str = start ? str + json2.slice(start) : json2;
      return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.implicitKey) {
        if (/\n/.test(value))
          return doubleQuotedString(value, ctx);
      } else {
        if (/[ \t]\n|\n[ \t]/.test(value))
          return doubleQuotedString(value, ctx);
      }
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
    }
    function blockString({
      comment,
      type,
      value
    }, ctx, onComment, onChompKeep) {
      if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return doubleQuotedString(value, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const indentSize = indent ? "2" : "1";
      const literal2 = type === PlainValue$4.Type.BLOCK_FOLDED ? false : type === PlainValue$4.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);
      let header = literal2 ? "|" : ">";
      if (!value)
        return header + "\n";
      let wsStart = "";
      let wsEnd = "";
      value = value.replace(/[\n\t ]*$/, (ws2) => {
        const n3 = ws2.indexOf("\n");
        if (n3 === -1) {
          header += "-";
        } else if (value === ws2 || n3 !== ws2.length - 1) {
          header += "+";
          if (onChompKeep)
            onChompKeep();
        }
        wsEnd = ws2.replace(/\n$/, "");
        return "";
      }).replace(/^[\n ]*/, (ws2) => {
        if (ws2.indexOf(" ") !== -1)
          header += indentSize;
        const m3 = ws2.match(/ +$/);
        if (m3) {
          wsStart = ws2.slice(0, -m3[0].length);
          return m3[0];
        } else {
          wsStart = ws2;
          return "";
        }
      });
      if (wsEnd)
        wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, `$&${indent}`);
      if (wsStart)
        wsStart = wsStart.replace(/\n+/g, `$&${indent}`);
      if (comment) {
        header += " #" + comment.replace(/ ?[\r\n]+/g, " ");
        if (onComment)
          onComment();
      }
      if (!value)
        return `${header}${indentSize}
${indent}${wsEnd}`;
      if (literal2) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}
${indent}${wsStart}${value}${wsEnd}`;
      }
      value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);
      return `${header}
${indent}${body}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const {
        comment,
        type,
        value
      } = item;
      const {
        actualString,
        implicitKey,
        indent,
        inFlow
      } = ctx;
      if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
        return doubleQuotedString(value, ctx);
      }
      if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        return implicitKey || inFlow || value.indexOf("\n") === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== PlainValue$4.Type.PLAIN && value.indexOf("\n") !== -1) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (indent === "" && containsDocumentMarker(value)) {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      }
      const str = value.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        const {
          tags: tags2
        } = ctx.doc.schema;
        const resolved = resolveScalar(str, tags2, tags2.scalarFallback).value;
        if (typeof resolved !== "string")
          return doubleQuotedString(value, ctx);
      }
      const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
      if (comment && !inFlow && (body.indexOf("\n") !== -1 || comment.indexOf("\n") !== -1)) {
        if (onComment)
          onComment();
        return addCommentBefore(body, indent, comment);
      }
      return body;
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const {
        defaultType
      } = strOptions;
      const {
        implicitKey,
        inFlow
      } = ctx;
      let {
        type,
        value
      } = item;
      if (typeof value !== "string") {
        value = String(value);
        item = Object.assign({}, item, {
          value
        });
      }
      const _stringify = (_type) => {
        switch (_type) {
          case PlainValue$4.Type.BLOCK_FOLDED:
          case PlainValue$4.Type.BLOCK_LITERAL:
            return blockString(item, ctx, onComment, onChompKeep);
          case PlainValue$4.Type.QUOTE_DOUBLE:
            return doubleQuotedString(value, ctx);
          case PlainValue$4.Type.QUOTE_SINGLE:
            return singleQuotedString(value, ctx);
          case PlainValue$4.Type.PLAIN:
            return plainString(item, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      if (type !== PlainValue$4.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
        type = PlainValue$4.Type.QUOTE_DOUBLE;
      } else if ((implicitKey || inFlow) && (type === PlainValue$4.Type.BLOCK_FOLDED || type === PlainValue$4.Type.BLOCK_LITERAL)) {
        type = PlainValue$4.Type.QUOTE_DOUBLE;
      }
      let res = _stringify(type);
      if (res === null) {
        res = _stringify(defaultType);
        if (res === null)
          throw new Error(`Unsupported default string type ${defaultType}`);
      }
      return res;
    }
    function stringifyNumber({
      format: format2,
      minFractionDigits,
      tag,
      value
    }) {
      if (typeof value === "bigint")
        return String(value);
      if (!isFinite(value))
        return isNaN(value) ? ".nan" : value < 0 ? "-.inf" : ".inf";
      let n3 = JSON.stringify(value);
      if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n3)) {
        let i2 = n3.indexOf(".");
        if (i2 < 0) {
          i2 = n3.length;
          n3 += ".";
        }
        let d3 = minFractionDigits - (n3.length - i2 - 1);
        while (d3-- > 0)
          n3 += "0";
      }
      return n3;
    }
    function checkFlowCollectionEnd(errors, cst) {
      let char, name;
      switch (cst.type) {
        case PlainValue$4.Type.FLOW_MAP:
          char = "}";
          name = "flow map";
          break;
        case PlainValue$4.Type.FLOW_SEQ:
          char = "]";
          name = "flow sequence";
          break;
        default:
          errors.push(new PlainValue$4.YAMLSemanticError(cst, "Not a flow collection!?"));
          return;
      }
      let lastItem;
      for (let i2 = cst.items.length - 1; i2 >= 0; --i2) {
        const item = cst.items[i2];
        if (!item || item.type !== PlainValue$4.Type.COMMENT) {
          lastItem = item;
          break;
        }
      }
      if (lastItem && lastItem.char !== char) {
        const msg = `Expected ${name} to end with ${char}`;
        let err;
        if (typeof lastItem.offset === "number") {
          err = new PlainValue$4.YAMLSemanticError(cst, msg);
          err.offset = lastItem.offset + 1;
        } else {
          err = new PlainValue$4.YAMLSemanticError(lastItem, msg);
          if (lastItem.range && lastItem.range.end)
            err.offset = lastItem.range.end - lastItem.range.start;
        }
        errors.push(err);
      }
    }
    function checkFlowCommentSpace(errors, comment) {
      const prev = comment.context.src[comment.range.start - 1];
      if (prev !== "\n" && prev !== "	" && prev !== " ") {
        const msg = "Comments must be separated from other tokens by white space characters";
        errors.push(new PlainValue$4.YAMLSemanticError(comment, msg));
      }
    }
    function getLongKeyError(source2, key) {
      const sk = String(key);
      const k2 = sk.substr(0, 8) + "..." + sk.substr(-8);
      return new PlainValue$4.YAMLSemanticError(source2, `The "${k2}" key is too long`);
    }
    function resolveComments(collection, comments) {
      for (const {
        afterKey,
        before,
        comment
      } of comments) {
        let item = collection.items[before];
        if (!item) {
          if (comment !== void 0) {
            if (collection.comment)
              collection.comment += "\n" + comment;
            else
              collection.comment = comment;
          }
        } else {
          if (afterKey && item.value)
            item = item.value;
          if (comment === void 0) {
            if (afterKey || !item.commentBefore)
              item.spaceBefore = true;
          } else {
            if (item.commentBefore)
              item.commentBefore += "\n" + comment;
            else
              item.commentBefore = comment;
          }
        }
      }
    }
    function resolveString(doc, node2) {
      const res = node2.strValue;
      if (!res)
        return "";
      if (typeof res === "string")
        return res;
      res.errors.forEach((error2) => {
        if (!error2.source)
          error2.source = node2;
        doc.errors.push(error2);
      });
      return res.str;
    }
    function resolveTagHandle(doc, node2) {
      const {
        handle,
        suffix
      } = node2.tag;
      let prefix = doc.tagPrefixes.find((p2) => p2.handle === handle);
      if (!prefix) {
        const dtp = doc.getDefaults().tagPrefixes;
        if (dtp)
          prefix = dtp.find((p2) => p2.handle === handle);
        if (!prefix)
          throw new PlainValue$4.YAMLSemanticError(node2, `The ${handle} tag handle is non-default and was not declared.`);
      }
      if (!suffix)
        throw new PlainValue$4.YAMLSemanticError(node2, `The ${handle} tag has no suffix.`);
      if (handle === "!" && (doc.version || doc.options.version) === "1.0") {
        if (suffix[0] === "^") {
          doc.warnings.push(new PlainValue$4.YAMLWarning(node2, "YAML 1.0 ^ tag expansion is not supported"));
          return suffix;
        }
        if (/[:/]/.test(suffix)) {
          const vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
          return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;
        }
      }
      return prefix.prefix + decodeURIComponent(suffix);
    }
    function resolveTagName(doc, node2) {
      const {
        tag,
        type
      } = node2;
      let nonSpecific = false;
      if (tag) {
        const {
          handle,
          suffix,
          verbatim
        } = tag;
        if (verbatim) {
          if (verbatim !== "!" && verbatim !== "!!")
            return verbatim;
          const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;
          doc.errors.push(new PlainValue$4.YAMLSemanticError(node2, msg));
        } else if (handle === "!" && !suffix) {
          nonSpecific = true;
        } else {
          try {
            return resolveTagHandle(doc, node2);
          } catch (error2) {
            doc.errors.push(error2);
          }
        }
      }
      switch (type) {
        case PlainValue$4.Type.BLOCK_FOLDED:
        case PlainValue$4.Type.BLOCK_LITERAL:
        case PlainValue$4.Type.QUOTE_DOUBLE:
        case PlainValue$4.Type.QUOTE_SINGLE:
          return PlainValue$4.defaultTags.STR;
        case PlainValue$4.Type.FLOW_MAP:
        case PlainValue$4.Type.MAP:
          return PlainValue$4.defaultTags.MAP;
        case PlainValue$4.Type.FLOW_SEQ:
        case PlainValue$4.Type.SEQ:
          return PlainValue$4.defaultTags.SEQ;
        case PlainValue$4.Type.PLAIN:
          return nonSpecific ? PlainValue$4.defaultTags.STR : null;
        default:
          return null;
      }
    }
    function resolveByTagName(doc, node2, tagName) {
      const {
        tags: tags2
      } = doc.schema;
      const matchWithTest = [];
      for (const tag of tags2) {
        if (tag.tag === tagName) {
          if (tag.test)
            matchWithTest.push(tag);
          else {
            const res = tag.resolve(doc, node2);
            return res instanceof Collection ? res : new Scalar(res);
          }
        }
      }
      const str = resolveString(doc, node2);
      if (typeof str === "string" && matchWithTest.length > 0)
        return resolveScalar(str, matchWithTest, tags2.scalarFallback);
      return null;
    }
    function getFallbackTagName({
      type
    }) {
      switch (type) {
        case PlainValue$4.Type.FLOW_MAP:
        case PlainValue$4.Type.MAP:
          return PlainValue$4.defaultTags.MAP;
        case PlainValue$4.Type.FLOW_SEQ:
        case PlainValue$4.Type.SEQ:
          return PlainValue$4.defaultTags.SEQ;
        default:
          return PlainValue$4.defaultTags.STR;
      }
    }
    function resolveTag(doc, node2, tagName) {
      try {
        const res = resolveByTagName(doc, node2, tagName);
        if (res) {
          if (tagName && node2.tag)
            res.tag = tagName;
          return res;
        }
      } catch (error2) {
        if (!error2.source)
          error2.source = node2;
        doc.errors.push(error2);
        return null;
      }
      try {
        const fallback = getFallbackTagName(node2);
        if (!fallback)
          throw new Error(`The tag ${tagName} is unavailable`);
        const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;
        doc.warnings.push(new PlainValue$4.YAMLWarning(node2, msg));
        const res = resolveByTagName(doc, node2, fallback);
        res.tag = tagName;
        return res;
      } catch (error2) {
        const refError = new PlainValue$4.YAMLReferenceError(node2, error2.message);
        refError.stack = error2.stack;
        doc.errors.push(refError);
        return null;
      }
    }
    var isCollectionItem = (node2) => {
      if (!node2)
        return false;
      const {
        type
      } = node2;
      return type === PlainValue$4.Type.MAP_KEY || type === PlainValue$4.Type.MAP_VALUE || type === PlainValue$4.Type.SEQ_ITEM;
    };
    function resolveNodeProps(errors, node2) {
      const comments = {
        before: [],
        after: []
      };
      let hasAnchor = false;
      let hasTag = false;
      const props = isCollectionItem(node2.context.parent) ? node2.context.parent.props.concat(node2.props) : node2.props;
      for (const {
        start,
        end
      } of props) {
        switch (node2.context.src[start]) {
          case PlainValue$4.Char.COMMENT: {
            if (!node2.commentHasRequiredWhitespace(start)) {
              const msg = "Comments must be separated from other tokens by white space characters";
              errors.push(new PlainValue$4.YAMLSemanticError(node2, msg));
            }
            const {
              header,
              valueRange
            } = node2;
            const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;
            cc.push(node2.context.src.slice(start + 1, end));
            break;
          }
          case PlainValue$4.Char.ANCHOR:
            if (hasAnchor) {
              const msg = "A node can have at most one anchor";
              errors.push(new PlainValue$4.YAMLSemanticError(node2, msg));
            }
            hasAnchor = true;
            break;
          case PlainValue$4.Char.TAG:
            if (hasTag) {
              const msg = "A node can have at most one tag";
              errors.push(new PlainValue$4.YAMLSemanticError(node2, msg));
            }
            hasTag = true;
            break;
        }
      }
      return {
        comments,
        hasAnchor,
        hasTag
      };
    }
    function resolveNodeValue(doc, node2) {
      const {
        anchors,
        errors,
        schema
      } = doc;
      if (node2.type === PlainValue$4.Type.ALIAS) {
        const name = node2.rawValue;
        const src2 = anchors.getNode(name);
        if (!src2) {
          const msg = `Aliased anchor not found: ${name}`;
          errors.push(new PlainValue$4.YAMLReferenceError(node2, msg));
          return null;
        }
        const res = new Alias(src2);
        anchors._cstAliases.push(res);
        return res;
      }
      const tagName = resolveTagName(doc, node2);
      if (tagName)
        return resolveTag(doc, node2, tagName);
      if (node2.type !== PlainValue$4.Type.PLAIN) {
        const msg = `Failed to resolve ${node2.type} node here`;
        errors.push(new PlainValue$4.YAMLSyntaxError(node2, msg));
        return null;
      }
      try {
        const str = resolveString(doc, node2);
        return resolveScalar(str, schema.tags, schema.tags.scalarFallback);
      } catch (error2) {
        if (!error2.source)
          error2.source = node2;
        errors.push(error2);
        return null;
      }
    }
    function resolveNode(doc, node2) {
      if (!node2)
        return null;
      if (node2.error)
        doc.errors.push(node2.error);
      const {
        comments,
        hasAnchor,
        hasTag
      } = resolveNodeProps(doc.errors, node2);
      if (hasAnchor) {
        const {
          anchors
        } = doc;
        const name = node2.anchor;
        const prev = anchors.getNode(name);
        if (prev)
          anchors.map[anchors.newName(name)] = prev;
        anchors.map[name] = node2;
      }
      if (node2.type === PlainValue$4.Type.ALIAS && (hasAnchor || hasTag)) {
        const msg = "An alias node must not specify any properties";
        doc.errors.push(new PlainValue$4.YAMLSemanticError(node2, msg));
      }
      const res = resolveNodeValue(doc, node2);
      if (res) {
        res.range = [node2.range.start, node2.range.end];
        if (doc.options.keepCstNodes)
          res.cstNode = node2;
        if (doc.options.keepNodeTypes)
          res.type = node2.type;
        const cb = comments.before.join("\n");
        if (cb) {
          res.commentBefore = res.commentBefore ? `${res.commentBefore}
${cb}` : cb;
        }
        const ca2 = comments.after.join("\n");
        if (ca2)
          res.comment = res.comment ? `${res.comment}
${ca2}` : ca2;
      }
      return node2.resolved = res;
    }
    function resolveMap(doc, cst) {
      if (cst.type !== PlainValue$4.Type.MAP && cst.type !== PlainValue$4.Type.FLOW_MAP) {
        const msg = `A ${cst.type} node cannot be resolved as a mapping`;
        doc.errors.push(new PlainValue$4.YAMLSyntaxError(cst, msg));
        return null;
      }
      const {
        comments,
        items
      } = cst.type === PlainValue$4.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);
      const map2 = new YAMLMap();
      map2.items = items;
      resolveComments(map2, comments);
      let hasCollectionKey = false;
      for (let i2 = 0; i2 < items.length; ++i2) {
        const {
          key: iKey
        } = items[i2];
        if (iKey instanceof Collection)
          hasCollectionKey = true;
        if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
          items[i2] = new Merge(items[i2]);
          const sources = items[i2].value.items;
          let error2 = null;
          sources.some((node2) => {
            if (node2 instanceof Alias) {
              const {
                type
              } = node2.source;
              if (type === PlainValue$4.Type.MAP || type === PlainValue$4.Type.FLOW_MAP)
                return false;
              return error2 = "Merge nodes aliases can only point to maps";
            }
            return error2 = "Merge nodes can only have Alias nodes as values";
          });
          if (error2)
            doc.errors.push(new PlainValue$4.YAMLSemanticError(cst, error2));
        } else {
          for (let j2 = i2 + 1; j2 < items.length; ++j2) {
            const {
              key: jKey
            } = items[j2];
            if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, "value") && iKey.value === jKey.value) {
              const msg = `Map keys must be unique; "${iKey}" is repeated`;
              doc.errors.push(new PlainValue$4.YAMLSemanticError(cst, msg));
              break;
            }
          }
        }
      }
      if (hasCollectionKey && !doc.options.mapAsMap) {
        const warn2 = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
        doc.warnings.push(new PlainValue$4.YAMLWarning(cst, warn2));
      }
      cst.resolved = map2;
      return map2;
    }
    var valueHasPairComment = ({
      context: {
        lineStart,
        node: node2,
        src: src2
      },
      props
    }) => {
      if (props.length === 0)
        return false;
      const {
        start
      } = props[0];
      if (node2 && start > node2.valueRange.start)
        return false;
      if (src2[start] !== PlainValue$4.Char.COMMENT)
        return false;
      for (let i2 = lineStart; i2 < start; ++i2)
        if (src2[i2] === "\n")
          return false;
      return true;
    };
    function resolvePairComment(item, pair) {
      if (!valueHasPairComment(item))
        return;
      const comment = item.getPropValue(0, PlainValue$4.Char.COMMENT, true);
      let found = false;
      const cb = pair.value.commentBefore;
      if (cb && cb.startsWith(comment)) {
        pair.value.commentBefore = cb.substr(comment.length + 1);
        found = true;
      } else {
        const cc = pair.value.comment;
        if (!item.node && cc && cc.startsWith(comment)) {
          pair.value.comment = cc.substr(comment.length + 1);
          found = true;
        }
      }
      if (found)
        pair.comment = comment;
    }
    function resolveBlockMapItems(doc, cst) {
      const comments = [];
      const items = [];
      let key = void 0;
      let keyStart = null;
      for (let i2 = 0; i2 < cst.items.length; ++i2) {
        const item = cst.items[i2];
        switch (item.type) {
          case PlainValue$4.Type.BLANK_LINE:
            comments.push({
              afterKey: !!key,
              before: items.length
            });
            break;
          case PlainValue$4.Type.COMMENT:
            comments.push({
              afterKey: !!key,
              before: items.length,
              comment: item.comment
            });
            break;
          case PlainValue$4.Type.MAP_KEY:
            if (key !== void 0)
              items.push(new Pair(key));
            if (item.error)
              doc.errors.push(item.error);
            key = resolveNode(doc, item.node);
            keyStart = null;
            break;
          case PlainValue$4.Type.MAP_VALUE:
            {
              if (key === void 0)
                key = null;
              if (item.error)
                doc.errors.push(item.error);
              if (!item.context.atLineStart && item.node && item.node.type === PlainValue$4.Type.MAP && !item.node.context.atLineStart) {
                const msg = "Nested mappings are not allowed in compact mappings";
                doc.errors.push(new PlainValue$4.YAMLSemanticError(item.node, msg));
              }
              let valueNode = item.node;
              if (!valueNode && item.props.length > 0) {
                valueNode = new PlainValue$4.PlainValue(PlainValue$4.Type.PLAIN, []);
                valueNode.context = {
                  parent: item,
                  src: item.context.src
                };
                const pos = item.range.start + 1;
                valueNode.range = {
                  start: pos,
                  end: pos
                };
                valueNode.valueRange = {
                  start: pos,
                  end: pos
                };
                if (typeof item.range.origStart === "number") {
                  const origPos = item.range.origStart + 1;
                  valueNode.range.origStart = valueNode.range.origEnd = origPos;
                  valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
                }
              }
              const pair = new Pair(key, resolveNode(doc, valueNode));
              resolvePairComment(item, pair);
              items.push(pair);
              if (key && typeof keyStart === "number") {
                if (item.range.start > keyStart + 1024)
                  doc.errors.push(getLongKeyError(cst, key));
              }
              key = void 0;
              keyStart = null;
            }
            break;
          default:
            if (key !== void 0)
              items.push(new Pair(key));
            key = resolveNode(doc, item);
            keyStart = item.range.start;
            if (item.error)
              doc.errors.push(item.error);
            next:
              for (let j2 = i2 + 1; ; ++j2) {
                const nextItem = cst.items[j2];
                switch (nextItem && nextItem.type) {
                  case PlainValue$4.Type.BLANK_LINE:
                  case PlainValue$4.Type.COMMENT:
                    continue next;
                  case PlainValue$4.Type.MAP_VALUE:
                    break next;
                  default: {
                    const msg = "Implicit map keys need to be followed by map values";
                    doc.errors.push(new PlainValue$4.YAMLSemanticError(item, msg));
                    break next;
                  }
                }
              }
            if (item.valueRangeContainsNewline) {
              const msg = "Implicit map keys need to be on a single line";
              doc.errors.push(new PlainValue$4.YAMLSemanticError(item, msg));
            }
        }
      }
      if (key !== void 0)
        items.push(new Pair(key));
      return {
        comments,
        items
      };
    }
    function resolveFlowMapItems(doc, cst) {
      const comments = [];
      const items = [];
      let key = void 0;
      let explicitKey = false;
      let next = "{";
      for (let i2 = 0; i2 < cst.items.length; ++i2) {
        const item = cst.items[i2];
        if (typeof item.char === "string") {
          const {
            char,
            offset: offset2
          } = item;
          if (char === "?" && key === void 0 && !explicitKey) {
            explicitKey = true;
            next = ":";
            continue;
          }
          if (char === ":") {
            if (key === void 0)
              key = null;
            if (next === ":") {
              next = ",";
              continue;
            }
          } else {
            if (explicitKey) {
              if (key === void 0 && char !== ",")
                key = null;
              explicitKey = false;
            }
            if (key !== void 0) {
              items.push(new Pair(key));
              key = void 0;
              if (char === ",") {
                next = ":";
                continue;
              }
            }
          }
          if (char === "}") {
            if (i2 === cst.items.length - 1)
              continue;
          } else if (char === next) {
            next = ":";
            continue;
          }
          const msg = `Flow map contains an unexpected ${char}`;
          const err = new PlainValue$4.YAMLSyntaxError(cst, msg);
          err.offset = offset2;
          doc.errors.push(err);
        } else if (item.type === PlainValue$4.Type.BLANK_LINE) {
          comments.push({
            afterKey: !!key,
            before: items.length
          });
        } else if (item.type === PlainValue$4.Type.COMMENT) {
          checkFlowCommentSpace(doc.errors, item);
          comments.push({
            afterKey: !!key,
            before: items.length,
            comment: item.comment
          });
        } else if (key === void 0) {
          if (next === ",")
            doc.errors.push(new PlainValue$4.YAMLSemanticError(item, "Separator , missing in flow map"));
          key = resolveNode(doc, item);
        } else {
          if (next !== ",")
            doc.errors.push(new PlainValue$4.YAMLSemanticError(item, "Indicator : missing in flow map entry"));
          items.push(new Pair(key, resolveNode(doc, item)));
          key = void 0;
          explicitKey = false;
        }
      }
      checkFlowCollectionEnd(doc.errors, cst);
      if (key !== void 0)
        items.push(new Pair(key));
      return {
        comments,
        items
      };
    }
    function resolveSeq$3(doc, cst) {
      if (cst.type !== PlainValue$4.Type.SEQ && cst.type !== PlainValue$4.Type.FLOW_SEQ) {
        const msg = `A ${cst.type} node cannot be resolved as a sequence`;
        doc.errors.push(new PlainValue$4.YAMLSyntaxError(cst, msg));
        return null;
      }
      const {
        comments,
        items
      } = cst.type === PlainValue$4.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);
      const seq2 = new YAMLSeq();
      seq2.items = items;
      resolveComments(seq2, comments);
      if (!doc.options.mapAsMap && items.some((it2) => it2 instanceof Pair && it2.key instanceof Collection)) {
        const warn2 = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
        doc.warnings.push(new PlainValue$4.YAMLWarning(cst, warn2));
      }
      cst.resolved = seq2;
      return seq2;
    }
    function resolveBlockSeqItems(doc, cst) {
      const comments = [];
      const items = [];
      for (let i2 = 0; i2 < cst.items.length; ++i2) {
        const item = cst.items[i2];
        switch (item.type) {
          case PlainValue$4.Type.BLANK_LINE:
            comments.push({
              before: items.length
            });
            break;
          case PlainValue$4.Type.COMMENT:
            comments.push({
              comment: item.comment,
              before: items.length
            });
            break;
          case PlainValue$4.Type.SEQ_ITEM:
            if (item.error)
              doc.errors.push(item.error);
            items.push(resolveNode(doc, item.node));
            if (item.hasProps) {
              const msg = "Sequence items cannot have tags or anchors before the - indicator";
              doc.errors.push(new PlainValue$4.YAMLSemanticError(item, msg));
            }
            break;
          default:
            if (item.error)
              doc.errors.push(item.error);
            doc.errors.push(new PlainValue$4.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));
        }
      }
      return {
        comments,
        items
      };
    }
    function resolveFlowSeqItems(doc, cst) {
      const comments = [];
      const items = [];
      let explicitKey = false;
      let key = void 0;
      let keyStart = null;
      let next = "[";
      let prevItem = null;
      for (let i2 = 0; i2 < cst.items.length; ++i2) {
        const item = cst.items[i2];
        if (typeof item.char === "string") {
          const {
            char,
            offset: offset2
          } = item;
          if (char !== ":" && (explicitKey || key !== void 0)) {
            if (explicitKey && key === void 0)
              key = next ? items.pop() : null;
            items.push(new Pair(key));
            explicitKey = false;
            key = void 0;
            keyStart = null;
          }
          if (char === next) {
            next = null;
          } else if (!next && char === "?") {
            explicitKey = true;
          } else if (next !== "[" && char === ":" && key === void 0) {
            if (next === ",") {
              key = items.pop();
              if (key instanceof Pair) {
                const msg = "Chaining flow sequence pairs is invalid";
                const err = new PlainValue$4.YAMLSemanticError(cst, msg);
                err.offset = offset2;
                doc.errors.push(err);
              }
              if (!explicitKey && typeof keyStart === "number") {
                const keyEnd = item.range ? item.range.start : item.offset;
                if (keyEnd > keyStart + 1024)
                  doc.errors.push(getLongKeyError(cst, key));
                const {
                  src: src2
                } = prevItem.context;
                for (let i3 = keyStart; i3 < keyEnd; ++i3)
                  if (src2[i3] === "\n") {
                    const msg = "Implicit keys of flow sequence pairs need to be on a single line";
                    doc.errors.push(new PlainValue$4.YAMLSemanticError(prevItem, msg));
                    break;
                  }
              }
            } else {
              key = null;
            }
            keyStart = null;
            explicitKey = false;
            next = null;
          } else if (next === "[" || char !== "]" || i2 < cst.items.length - 1) {
            const msg = `Flow sequence contains an unexpected ${char}`;
            const err = new PlainValue$4.YAMLSyntaxError(cst, msg);
            err.offset = offset2;
            doc.errors.push(err);
          }
        } else if (item.type === PlainValue$4.Type.BLANK_LINE) {
          comments.push({
            before: items.length
          });
        } else if (item.type === PlainValue$4.Type.COMMENT) {
          checkFlowCommentSpace(doc.errors, item);
          comments.push({
            comment: item.comment,
            before: items.length
          });
        } else {
          if (next) {
            const msg = `Expected a ${next} in flow sequence`;
            doc.errors.push(new PlainValue$4.YAMLSemanticError(item, msg));
          }
          const value = resolveNode(doc, item);
          if (key === void 0) {
            items.push(value);
            prevItem = item;
          } else {
            items.push(new Pair(key, value));
            key = void 0;
          }
          keyStart = item.range.start;
          next = ",";
        }
      }
      checkFlowCollectionEnd(doc.errors, cst);
      if (key !== void 0)
        items.push(new Pair(key));
      return {
        comments,
        items
      };
    }
    resolveSeqD03cb037.Alias = Alias;
    resolveSeqD03cb037.Collection = Collection;
    resolveSeqD03cb037.Merge = Merge;
    resolveSeqD03cb037.Node = Node$1;
    resolveSeqD03cb037.Pair = Pair;
    resolveSeqD03cb037.Scalar = Scalar;
    resolveSeqD03cb037.YAMLMap = YAMLMap;
    resolveSeqD03cb037.YAMLSeq = YAMLSeq;
    resolveSeqD03cb037.addComment = addComment;
    resolveSeqD03cb037.binaryOptions = binaryOptions;
    resolveSeqD03cb037.boolOptions = boolOptions;
    resolveSeqD03cb037.findPair = findPair;
    resolveSeqD03cb037.intOptions = intOptions;
    resolveSeqD03cb037.isEmptyPath = isEmptyPath;
    resolveSeqD03cb037.nullOptions = nullOptions;
    resolveSeqD03cb037.resolveMap = resolveMap;
    resolveSeqD03cb037.resolveNode = resolveNode;
    resolveSeqD03cb037.resolveSeq = resolveSeq$3;
    resolveSeqD03cb037.resolveString = resolveString;
    resolveSeqD03cb037.strOptions = strOptions;
    resolveSeqD03cb037.stringifyNumber = stringifyNumber;
    resolveSeqD03cb037.stringifyString = stringifyString;
    resolveSeqD03cb037.toJSON = toJSON;
    var Schema88e323a7 = {};
    var warnings1000a372 = {};
    var PlainValue$3 = PlainValueEc8e588e;
    var resolveSeq$2 = resolveSeqD03cb037;
    var binary = {
      identify: (value) => value instanceof Uint8Array,
      default: false,
      tag: "tag:yaml.org,2002:binary",
      resolve: (doc, node2) => {
        const src2 = resolveSeq$2.resolveString(doc, node2);
        if (typeof Buffer === "function") {
          return Buffer.from(src2, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src2.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i2 = 0; i2 < str.length; ++i2)
            buffer[i2] = str.charCodeAt(i2);
          return buffer;
        } else {
          const msg = "This environment does not support reading binary tags; either Buffer or atob is required";
          doc.errors.push(new PlainValue$3.YAMLReferenceError(node2, msg));
          return null;
        }
      },
      options: resolveSeq$2.binaryOptions,
      stringify: ({
        comment,
        type,
        value
      }, ctx, onComment, onChompKeep) => {
        let src2;
        if (typeof Buffer === "function") {
          src2 = value instanceof Buffer ? value.toString("base64") : Buffer.from(value.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s2 = "";
          for (let i2 = 0; i2 < value.length; ++i2)
            s2 += String.fromCharCode(value[i2]);
          src2 = btoa(s2);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = resolveSeq$2.binaryOptions.defaultType;
        if (type === PlainValue$3.Type.QUOTE_DOUBLE) {
          value = src2;
        } else {
          const {
            lineWidth
          } = resolveSeq$2.binaryOptions;
          const n3 = Math.ceil(src2.length / lineWidth);
          const lines = new Array(n3);
          for (let i2 = 0, o2 = 0; i2 < n3; ++i2, o2 += lineWidth) {
            lines[i2] = src2.substr(o2, lineWidth);
          }
          value = lines.join(type === PlainValue$3.Type.BLOCK_LITERAL ? "\n" : " ");
        }
        return resolveSeq$2.stringifyString({
          comment,
          type,
          value
        }, ctx, onComment, onChompKeep);
      }
    };
    function parsePairs(doc, cst) {
      const seq2 = resolveSeq$2.resolveSeq(doc, cst);
      for (let i2 = 0; i2 < seq2.items.length; ++i2) {
        let item = seq2.items[i2];
        if (item instanceof resolveSeq$2.Pair)
          continue;
        else if (item instanceof resolveSeq$2.YAMLMap) {
          if (item.items.length > 1) {
            const msg = "Each pair must have its own sequence indicator";
            throw new PlainValue$3.YAMLSemanticError(cst, msg);
          }
          const pair = item.items[0] || new resolveSeq$2.Pair();
          if (item.commentBefore)
            pair.commentBefore = pair.commentBefore ? `${item.commentBefore}
${pair.commentBefore}` : item.commentBefore;
          if (item.comment)
            pair.comment = pair.comment ? `${item.comment}
${pair.comment}` : item.comment;
          item = pair;
        }
        seq2.items[i2] = item instanceof resolveSeq$2.Pair ? item : new resolveSeq$2.Pair(item);
      }
      return seq2;
    }
    function createPairs(schema, iterable, ctx) {
      const pairs2 = new resolveSeq$2.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      for (const it2 of iterable) {
        let key, value;
        if (Array.isArray(it2)) {
          if (it2.length === 2) {
            key = it2[0];
            value = it2[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it2}`);
        } else if (it2 && it2 instanceof Object) {
          const keys = Object.keys(it2);
          if (keys.length === 1) {
            key = keys[0];
            value = it2[key];
          } else
            throw new TypeError(`Expected { key: value } tuple: ${it2}`);
        } else {
          key = it2;
        }
        const pair = schema.createPair(key, value, ctx);
        pairs2.items.push(pair);
      }
      return pairs2;
    }
    var pairs = {
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: parsePairs,
      createNode: createPairs
    };
    var YAMLOMap = class extends resolveSeq$2.YAMLSeq {
      constructor() {
        super();
        PlainValue$3._defineProperty(this, "add", resolveSeq$2.YAMLMap.prototype.add.bind(this));
        PlainValue$3._defineProperty(this, "delete", resolveSeq$2.YAMLMap.prototype.delete.bind(this));
        PlainValue$3._defineProperty(this, "get", resolveSeq$2.YAMLMap.prototype.get.bind(this));
        PlainValue$3._defineProperty(this, "has", resolveSeq$2.YAMLMap.prototype.has.bind(this));
        PlainValue$3._defineProperty(this, "set", resolveSeq$2.YAMLMap.prototype.set.bind(this));
        this.tag = YAMLOMap.tag;
      }
      toJSON(_2, ctx) {
        const map2 = new Map();
        if (ctx && ctx.onCreate)
          ctx.onCreate(map2);
        for (const pair of this.items) {
          let key, value;
          if (pair instanceof resolveSeq$2.Pair) {
            key = resolveSeq$2.toJSON(pair.key, "", ctx);
            value = resolveSeq$2.toJSON(pair.value, key, ctx);
          } else {
            key = resolveSeq$2.toJSON(pair, "", ctx);
          }
          if (map2.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map2.set(key, value);
        }
        return map2;
      }
    };
    PlainValue$3._defineProperty(YAMLOMap, "tag", "tag:yaml.org,2002:omap");
    function parseOMap(doc, cst) {
      const pairs2 = parsePairs(doc, cst);
      const seenKeys = [];
      for (const {
        key
      } of pairs2.items) {
        if (key instanceof resolveSeq$2.Scalar) {
          if (seenKeys.includes(key.value)) {
            const msg = "Ordered maps must not include duplicate keys";
            throw new PlainValue$3.YAMLSemanticError(cst, msg);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
      return Object.assign(new YAMLOMap(), pairs2);
    }
    function createOMap(schema, iterable, ctx) {
      const pairs2 = createPairs(schema, iterable, ctx);
      const omap2 = new YAMLOMap();
      omap2.items = pairs2.items;
      return omap2;
    }
    var omap = {
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve: parseOMap,
      createNode: createOMap
    };
    var YAMLSet = class extends resolveSeq$2.YAMLMap {
      constructor() {
        super();
        this.tag = YAMLSet.tag;
      }
      add(key) {
        const pair = key instanceof resolveSeq$2.Pair ? key : new resolveSeq$2.Pair(key);
        const prev = resolveSeq$2.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      get(key, keepPair) {
        const pair = resolveSeq$2.findPair(this.items, key);
        return !keepPair && pair instanceof resolveSeq$2.Pair ? pair.key instanceof resolveSeq$2.Scalar ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = resolveSeq$2.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new resolveSeq$2.Pair(key));
        }
      }
      toJSON(_2, ctx) {
        return super.toJSON(_2, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues())
          return super.toString(ctx, onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
    };
    PlainValue$3._defineProperty(YAMLSet, "tag", "tag:yaml.org,2002:set");
    function parseSet(doc, cst) {
      const map2 = resolveSeq$2.resolveMap(doc, cst);
      if (!map2.hasAllNullValues())
        throw new PlainValue$3.YAMLSemanticError(cst, "Set items must all have null values");
      return Object.assign(new YAMLSet(), map2);
    }
    function createSet(schema, iterable, ctx) {
      const set2 = new YAMLSet();
      for (const value of iterable)
        set2.items.push(schema.createPair(value, null, ctx));
      return set2;
    }
    var set = {
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      resolve: parseSet,
      createNode: createSet
    };
    var parseSexagesimal = (sign, parts) => {
      const n3 = parts.split(":").reduce((n4, p2) => n4 * 60 + Number(p2), 0);
      return sign === "-" ? -n3 : n3;
    };
    var stringifySexagesimal = ({
      value
    }) => {
      if (isNaN(value) || !isFinite(value))
        return resolveSeq$2.stringifyNumber(value);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value = Math.abs(value);
      }
      const parts = [value % 60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = Math.round((value - parts[0]) / 60);
        parts.unshift(value % 60);
        if (value >= 60) {
          value = Math.round((value - parts[0]) / 60);
          parts.unshift(value);
        }
      }
      return sign + parts.map((n3) => n3 < 10 ? "0" + String(n3) : String(n3)).join(":").replace(/000000\d*$/, "");
    };
    var intTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
      resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, "")),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
      resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, "")),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),
      resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {
        if (millisec)
          millisec = (millisec + "00").substr(1, 3);
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);
        if (tz && tz !== "Z") {
          let d3 = parseSexagesimal(tz[0], tz.slice(1));
          if (Math.abs(d3) < 30)
            d3 *= 60;
          date -= 6e4 * d3;
        }
        return new Date(date);
      },
      stringify: ({
        value
      }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    function shouldWarn(deprecation) {
      const env2 = typeof process !== "undefined" && process.env || {};
      if (deprecation) {
        if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== "undefined")
          return !YAML_SILENCE_DEPRECATION_WARNINGS;
        return !env2.YAML_SILENCE_DEPRECATION_WARNINGS;
      }
      if (typeof YAML_SILENCE_WARNINGS !== "undefined")
        return !YAML_SILENCE_WARNINGS;
      return !env2.YAML_SILENCE_WARNINGS;
    }
    function warn(warning, type) {
      if (shouldWarn(false)) {
        const emit2 = typeof process !== "undefined" && process.emitWarning;
        if (emit2)
          emit2(warning, type);
        else {
          console.warn(type ? `${type}: ${warning}` : warning);
        }
      }
    }
    function warnFileDeprecation(filename2) {
      if (shouldWarn(true)) {
        const path2 = filename2.replace(/.*yaml[/\\]/i, "").replace(/\.js$/, "").replace(/\\/g, "/");
        warn(`The endpoint 'yaml/${path2}' will be removed in a future release.`, "DeprecationWarning");
      }
    }
    var warned = {};
    function warnOptionDeprecation(name, alternative) {
      if (!warned[name] && shouldWarn(true)) {
        warned[name] = true;
        let msg = `The option '${name}' will be removed in a future release`;
        msg += alternative ? `, use '${alternative}' instead.` : ".";
        warn(msg, "DeprecationWarning");
      }
    }
    warnings1000a372.binary = binary;
    warnings1000a372.floatTime = floatTime;
    warnings1000a372.intTime = intTime;
    warnings1000a372.omap = omap;
    warnings1000a372.pairs = pairs;
    warnings1000a372.set = set;
    warnings1000a372.timestamp = timestamp;
    warnings1000a372.warn = warn;
    warnings1000a372.warnFileDeprecation = warnFileDeprecation;
    warnings1000a372.warnOptionDeprecation = warnOptionDeprecation;
    var PlainValue$2 = PlainValueEc8e588e;
    var resolveSeq$1 = resolveSeqD03cb037;
    var warnings$1 = warnings1000a372;
    function createMap(schema, obj, ctx) {
      const map2 = new resolveSeq$1.YAMLMap(schema);
      if (obj instanceof Map) {
        for (const [key, value] of obj)
          map2.items.push(schema.createPair(key, value, ctx));
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj))
          map2.items.push(schema.createPair(key, obj[key], ctx));
      }
      if (typeof schema.sortMapEntries === "function") {
        map2.items.sort(schema.sortMapEntries);
      }
      return map2;
    }
    var map$1 = {
      createNode: createMap,
      default: true,
      nodeClass: resolveSeq$1.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve: resolveSeq$1.resolveMap
    };
    function createSeq(schema, obj, ctx) {
      const seq2 = new resolveSeq$1.YAMLSeq(schema);
      if (obj && obj[Symbol.iterator]) {
        for (const it2 of obj) {
          const v2 = schema.createNode(it2, ctx.wrapScalars, null, ctx);
          seq2.items.push(v2);
        }
      }
      return seq2;
    }
    var seq = {
      createNode: createSeq,
      default: true,
      nodeClass: resolveSeq$1.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve: resolveSeq$1.resolveSeq
    };
    var string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveSeq$1.resolveString,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({
          actualString: true
        }, ctx);
        return resolveSeq$1.stringifyString(item, ctx, onComment, onChompKeep);
      },
      options: resolveSeq$1.strOptions
    };
    var failsafe = [map$1, seq, string];
    var intIdentify$2 = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve$1 = (src2, part, radix) => resolveSeq$1.intOptions.asBigInt ? BigInt(src2) : parseInt(part, radix);
    function intStringify$1(node2, radix, prefix) {
      const {
        value
      } = node2;
      if (intIdentify$2(value) && value >= 0)
        return prefix + value.toString(radix);
      return resolveSeq$1.stringifyNumber(node2);
    }
    var nullObj = {
      identify: (value) => value == null,
      createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq$1.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => null,
      options: resolveSeq$1.nullOptions,
      stringify: () => resolveSeq$1.nullOptions.nullStr
    };
    var boolObj = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => str[0] === "t" || str[0] === "T",
      options: resolveSeq$1.boolOptions,
      stringify: ({
        value
      }) => value ? resolveSeq$1.boolOptions.trueStr : resolveSeq$1.boolOptions.falseStr
    };
    var octObj = {
      identify: (value) => intIdentify$2(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o([0-7]+)$/,
      resolve: (str, oct) => intResolve$1(str, oct, 8),
      options: resolveSeq$1.intOptions,
      stringify: (node2) => intStringify$1(node2, 8, "0o")
    };
    var intObj = {
      identify: intIdentify$2,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str) => intResolve$1(str, str, 10),
      options: resolveSeq$1.intOptions,
      stringify: resolveSeq$1.stringifyNumber
    };
    var hexObj = {
      identify: (value) => intIdentify$2(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x([0-9a-fA-F]+)$/,
      resolve: (str, hex) => intResolve$1(str, hex, 16),
      options: resolveSeq$1.intOptions,
      stringify: (node2) => intStringify$1(node2, 16, "0x")
    };
    var nanObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: (str, nan) => nan ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: resolveSeq$1.stringifyNumber
    };
    var expObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify: ({
        value
      }) => Number(value).toExponential()
    };
    var floatObj = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,
      resolve(str, frac1, frac2) {
        const frac = frac1 || frac2;
        const node2 = new resolveSeq$1.Scalar(parseFloat(str));
        if (frac && frac[frac.length - 1] === "0")
          node2.minFractionDigits = frac.length;
        return node2;
      },
      stringify: resolveSeq$1.stringifyNumber
    };
    var core$2 = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);
    var intIdentify$1 = (value) => typeof value === "bigint" || Number.isInteger(value);
    var stringifyJSON = ({
      value
    }) => JSON.stringify(value);
    var json = [map$1, seq, {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: resolveSeq$1.resolveString,
      stringify: stringifyJSON
    }, {
      identify: (value) => value == null,
      createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq$1.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true|false$/,
      resolve: (str) => str === "true",
      stringify: stringifyJSON
    }, {
      identify: intIdentify$1,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str) => resolveSeq$1.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),
      stringify: ({
        value
      }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str) => parseFloat(str),
      stringify: stringifyJSON
    }];
    json.scalarFallback = (str) => {
      throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    };
    var boolStringify = ({
      value
    }) => value ? resolveSeq$1.boolOptions.trueStr : resolveSeq$1.boolOptions.falseStr;
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(sign, src2, radix) {
      let str = src2.replace(/_/g, "");
      if (resolveSeq$1.intOptions.asBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        const n4 = BigInt(str);
        return sign === "-" ? BigInt(-1) * n4 : n4;
      }
      const n3 = parseInt(str, radix);
      return sign === "-" ? -1 * n3 : n3;
    }
    function intStringify(node2, radix, prefix) {
      const {
        value
      } = node2;
      if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return resolveSeq$1.stringifyNumber(node2);
    }
    var yaml11 = failsafe.concat([{
      identify: (value) => value == null,
      createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq$1.Scalar(null) : null,
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => null,
      options: resolveSeq$1.nullOptions,
      stringify: () => resolveSeq$1.nullOptions.nullStr
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => true,
      options: resolveSeq$1.boolOptions,
      stringify: boolStringify
    }, {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: () => false,
      options: resolveSeq$1.boolOptions,
      stringify: boolStringify
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^([-+]?)0b([0-1_]+)$/,
      resolve: (str, sign, bin) => intResolve(sign, bin, 2),
      stringify: (node2) => intStringify(node2, 2, "0b")
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^([-+]?)0([0-7_]+)$/,
      resolve: (str, sign, oct) => intResolve(sign, oct, 8),
      stringify: (node2) => intStringify(node2, 8, "0")
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^([-+]?)([0-9][0-9_]*)$/,
      resolve: (str, sign, abs) => intResolve(sign, abs, 10),
      stringify: resolveSeq$1.stringifyNumber
    }, {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
      resolve: (str, sign, hex) => intResolve(sign, hex, 16),
      stringify: (node2) => intStringify(node2, 16, "0x")
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.inf|(\.nan))$/i,
      resolve: (str, nan) => nan ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: resolveSeq$1.stringifyNumber
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify: ({
        value
      }) => Number(value).toExponential()
    }, {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,
      resolve(str, frac) {
        const node2 = new resolveSeq$1.Scalar(parseFloat(str.replace(/_/g, "")));
        if (frac) {
          const f2 = frac.replace(/_/g, "");
          if (f2[f2.length - 1] === "0")
            node2.minFractionDigits = f2.length;
        }
        return node2;
      },
      stringify: resolveSeq$1.stringifyNumber
    }], warnings$1.binary, warnings$1.omap, warnings$1.pairs, warnings$1.set, warnings$1.intTime, warnings$1.floatTime, warnings$1.timestamp);
    var schemas = {
      core: core$2,
      failsafe,
      json,
      yaml11
    };
    var tags = {
      binary: warnings$1.binary,
      bool: boolObj,
      float: floatObj,
      floatExp: expObj,
      floatNaN: nanObj,
      floatTime: warnings$1.floatTime,
      int: intObj,
      intHex: hexObj,
      intOct: octObj,
      intTime: warnings$1.intTime,
      map: map$1,
      null: nullObj,
      omap: warnings$1.omap,
      pairs: warnings$1.pairs,
      seq,
      set: warnings$1.set,
      timestamp: warnings$1.timestamp
    };
    function findTagObject(value, tagName, tags2) {
      if (tagName) {
        const match2 = tags2.filter((t) => t.tag === tagName);
        const tagObj = match2.find((t) => !t.format) || match2[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags2.find((t) => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);
    }
    function createNode$1(value, tagName, ctx) {
      if (value instanceof resolveSeq$1.Node)
        return value;
      const {
        defaultPrefix,
        onTagObj,
        prevObjects,
        schema,
        wrapScalars
      } = ctx;
      if (tagName && tagName.startsWith("!!"))
        tagName = defaultPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema.tags);
      if (!tagObj) {
        if (typeof value.toJSON === "function")
          value = value.toJSON();
        if (!value || typeof value !== "object")
          return wrapScalars ? new resolveSeq$1.Scalar(value) : value;
        tagObj = value instanceof Map ? map$1 : value[Symbol.iterator] ? seq : map$1;
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const obj = {
        value: void 0,
        node: void 0
      };
      if (value && typeof value === "object" && prevObjects) {
        const prev = prevObjects.get(value);
        if (prev) {
          const alias2 = new resolveSeq$1.Alias(prev);
          ctx.aliasNodes.push(alias2);
          return alias2;
        }
        obj.value = value;
        prevObjects.set(value, obj);
      }
      obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq$1.Scalar(value) : value;
      if (tagName && obj.node instanceof resolveSeq$1.Node)
        obj.node.tag = tagName;
      return obj.node;
    }
    function getSchemaTags(schemas2, knownTags, customTags, schemaId) {
      let tags2 = schemas2[schemaId.replace(/\W/g, "")];
      if (!tags2) {
        const keys = Object.keys(schemas2).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaId}"; use one of ${keys}`);
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags2 = tags2.concat(tag);
      } else if (typeof customTags === "function") {
        tags2 = customTags(tags2.slice());
      }
      for (let i2 = 0; i2 < tags2.length; ++i2) {
        const tag = tags2[i2];
        if (typeof tag === "string") {
          const tagObj = knownTags[tag];
          if (!tagObj) {
            const keys = Object.keys(knownTags).map((key) => JSON.stringify(key)).join(", ");
            throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
          }
          tags2[i2] = tagObj;
        }
      }
      return tags2;
    }
    var sortMapEntriesByKey = (a2, b2) => a2.key < b2.key ? -1 : a2.key > b2.key ? 1 : 0;
    var Schema$2 = class {
      constructor({
        customTags,
        merge: merge3,
        schema,
        sortMapEntries,
        tags: deprecatedCustomTags
      }) {
        this.merge = !!merge3;
        this.name = schema;
        this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
        if (!customTags && deprecatedCustomTags)
          warnings$1.warnOptionDeprecation("tags", "customTags");
        this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);
      }
      createNode(value, wrapScalars, tagName, ctx) {
        const baseCtx = {
          defaultPrefix: Schema$2.defaultPrefix,
          schema: this,
          wrapScalars
        };
        const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
        return createNode$1(value, tagName, createCtx);
      }
      createPair(key, value, ctx) {
        if (!ctx)
          ctx = {
            wrapScalars: true
          };
        const k2 = this.createNode(key, ctx.wrapScalars, null, ctx);
        const v2 = this.createNode(value, ctx.wrapScalars, null, ctx);
        return new resolveSeq$1.Pair(k2, v2);
      }
    };
    PlainValue$2._defineProperty(Schema$2, "defaultPrefix", PlainValue$2.defaultTagPrefix);
    PlainValue$2._defineProperty(Schema$2, "defaultTags", PlainValue$2.defaultTags);
    Schema88e323a7.Schema = Schema$2;
    var PlainValue$1 = PlainValueEc8e588e;
    var resolveSeq = resolveSeqD03cb037;
    var Schema$1 = Schema88e323a7;
    var defaultOptions$1 = {
      anchorPrefix: "a",
      customTags: null,
      indent: 2,
      indentSeq: true,
      keepCstNodes: false,
      keepNodeTypes: true,
      keepBlobsInJSON: true,
      mapAsMap: false,
      maxAliasCount: 100,
      prettyErrors: false,
      simpleKeys: false,
      version: "1.2"
    };
    var scalarOptions = {
      get binary() {
        return resolveSeq.binaryOptions;
      },
      set binary(opt) {
        Object.assign(resolveSeq.binaryOptions, opt);
      },
      get bool() {
        return resolveSeq.boolOptions;
      },
      set bool(opt) {
        Object.assign(resolveSeq.boolOptions, opt);
      },
      get int() {
        return resolveSeq.intOptions;
      },
      set int(opt) {
        Object.assign(resolveSeq.intOptions, opt);
      },
      get null() {
        return resolveSeq.nullOptions;
      },
      set null(opt) {
        Object.assign(resolveSeq.nullOptions, opt);
      },
      get str() {
        return resolveSeq.strOptions;
      },
      set str(opt) {
        Object.assign(resolveSeq.strOptions, opt);
      }
    };
    var documentOptions = {
      "1.0": {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: PlainValue$1.defaultTagPrefix
        }, {
          handle: "!!",
          prefix: "tag:private.yaml.org,2002:"
        }]
      },
      1.1: {
        schema: "yaml-1.1",
        merge: true,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: PlainValue$1.defaultTagPrefix
        }]
      },
      1.2: {
        schema: "core",
        merge: false,
        tagPrefixes: [{
          handle: "!",
          prefix: "!"
        }, {
          handle: "!!",
          prefix: PlainValue$1.defaultTagPrefix
        }]
      }
    };
    function stringifyTag(doc, tag) {
      if ((doc.version || doc.options.version) === "1.0") {
        const priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
        if (priv)
          return "!" + priv[1];
        const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
        return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, "")}`;
      }
      let p2 = doc.tagPrefixes.find((p3) => tag.indexOf(p3.prefix) === 0);
      if (!p2) {
        const dtp = doc.getDefaults().tagPrefixes;
        p2 = dtp && dtp.find((p3) => tag.indexOf(p3.prefix) === 0);
      }
      if (!p2)
        return tag[0] === "!" ? tag : `!<${tag}>`;
      const suffix = tag.substr(p2.prefix.length).replace(/[!,[\]{}]/g, (ch2) => ({
        "!": "%21",
        ",": "%2C",
        "[": "%5B",
        "]": "%5D",
        "{": "%7B",
        "}": "%7D"
      })[ch2]);
      return p2.handle + suffix;
    }
    function getTagObject(tags2, item) {
      if (item instanceof resolveSeq.Alias)
        return resolveSeq.Alias;
      if (item.tag) {
        const match2 = tags2.filter((t) => t.tag === item.tag);
        if (match2.length > 0)
          return match2.find((t) => t.format === item.format) || match2[0];
      }
      let tagObj, obj;
      if (item instanceof resolveSeq.Scalar) {
        obj = item.value;
        const match2 = tags2.filter((t) => t.identify && t.identify(obj) || t.class && obj instanceof t.class);
        tagObj = match2.find((t) => t.format === item.format) || match2.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags2.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    function stringifyProps(node2, tagObj, {
      anchors,
      doc
    }) {
      const props = [];
      const anchor = doc.anchors.getName(node2);
      if (anchor) {
        anchors[anchor] = node2;
        props.push(`&${anchor}`);
      }
      if (node2.tag) {
        props.push(stringifyTag(doc, node2.tag));
      } else if (!tagObj.default) {
        props.push(stringifyTag(doc, tagObj.tag));
      }
      return props.join(" ");
    }
    function stringify$2(item, ctx, onComment, onChompKeep) {
      const {
        anchors,
        schema
      } = ctx.doc;
      let tagObj;
      if (!(item instanceof resolveSeq.Node)) {
        const createCtx = {
          aliasNodes: [],
          onTagObj: (o2) => tagObj = o2,
          prevObjects: new Map()
        };
        item = schema.createNode(item, true, null, createCtx);
        for (const alias2 of createCtx.aliasNodes) {
          alias2.source = alias2.source.node;
          let name = anchors.getName(alias2.source);
          if (!name) {
            name = anchors.newName();
            anchors.map[name] = alias2.source;
          }
        }
      }
      if (item instanceof resolveSeq.Pair)
        return item.toString(ctx, onComment, onChompKeep);
      if (!tagObj)
        tagObj = getTagObject(schema.tags, item);
      const props = stringifyProps(item, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
      const str = typeof tagObj.stringify === "function" ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str;
      return item instanceof resolveSeq.Scalar || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
    }
    var Anchors = class {
      static validAnchorNode(node2) {
        return node2 instanceof resolveSeq.Scalar || node2 instanceof resolveSeq.YAMLSeq || node2 instanceof resolveSeq.YAMLMap;
      }
      constructor(prefix) {
        PlainValue$1._defineProperty(this, "map", Object.create(null));
        this.prefix = prefix;
      }
      createAlias(node2, name) {
        this.setAnchor(node2, name);
        return new resolveSeq.Alias(node2);
      }
      createMergePair(...sources) {
        const merge3 = new resolveSeq.Merge();
        merge3.value.items = sources.map((s2) => {
          if (s2 instanceof resolveSeq.Alias) {
            if (s2.source instanceof resolveSeq.YAMLMap)
              return s2;
          } else if (s2 instanceof resolveSeq.YAMLMap) {
            return this.createAlias(s2);
          }
          throw new Error("Merge sources must be Map nodes or their Aliases");
        });
        return merge3;
      }
      getName(node2) {
        const {
          map: map2
        } = this;
        return Object.keys(map2).find((a2) => map2[a2] === node2);
      }
      getNames() {
        return Object.keys(this.map);
      }
      getNode(name) {
        return this.map[name];
      }
      newName(prefix) {
        if (!prefix)
          prefix = this.prefix;
        const names = Object.keys(this.map);
        for (let i2 = 1; true; ++i2) {
          const name = `${prefix}${i2}`;
          if (!names.includes(name))
            return name;
        }
      }
      resolveNodes() {
        const {
          map: map2,
          _cstAliases
        } = this;
        Object.keys(map2).forEach((a2) => {
          map2[a2] = map2[a2].resolved;
        });
        _cstAliases.forEach((a2) => {
          a2.source = a2.source.resolved;
        });
        delete this._cstAliases;
      }
      setAnchor(node2, name) {
        if (node2 != null && !Anchors.validAnchorNode(node2)) {
          throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");
        }
        if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
          throw new Error("Anchor names must not contain whitespace or control characters");
        }
        const {
          map: map2
        } = this;
        const prev = node2 && Object.keys(map2).find((a2) => map2[a2] === node2);
        if (prev) {
          if (!name) {
            return prev;
          } else if (prev !== name) {
            delete map2[prev];
            map2[name] = node2;
          }
        } else {
          if (!name) {
            if (!node2)
              return null;
            name = this.newName();
          }
          map2[name] = node2;
        }
        return name;
      }
    };
    var visit$1 = (node2, tags2) => {
      if (node2 && typeof node2 === "object") {
        const {
          tag
        } = node2;
        if (node2 instanceof resolveSeq.Collection) {
          if (tag)
            tags2[tag] = true;
          node2.items.forEach((n3) => visit$1(n3, tags2));
        } else if (node2 instanceof resolveSeq.Pair) {
          visit$1(node2.key, tags2);
          visit$1(node2.value, tags2);
        } else if (node2 instanceof resolveSeq.Scalar) {
          if (tag)
            tags2[tag] = true;
        }
      }
      return tags2;
    };
    var listTagNames = (node2) => Object.keys(visit$1(node2, {}));
    function parseContents(doc, contents) {
      const comments = {
        before: [],
        after: []
      };
      let body = void 0;
      let spaceBefore = false;
      for (const node2 of contents) {
        if (node2.valueRange) {
          if (body !== void 0) {
            const msg = "Document contains trailing content not separated by a ... or --- line";
            doc.errors.push(new PlainValue$1.YAMLSyntaxError(node2, msg));
            break;
          }
          const res = resolveSeq.resolveNode(doc, node2);
          if (spaceBefore) {
            res.spaceBefore = true;
            spaceBefore = false;
          }
          body = res;
        } else if (node2.comment !== null) {
          const cc = body === void 0 ? comments.before : comments.after;
          cc.push(node2.comment);
        } else if (node2.type === PlainValue$1.Type.BLANK_LINE) {
          spaceBefore = true;
          if (body === void 0 && comments.before.length > 0 && !doc.commentBefore) {
            doc.commentBefore = comments.before.join("\n");
            comments.before = [];
          }
        }
      }
      doc.contents = body || null;
      if (!body) {
        doc.comment = comments.before.concat(comments.after).join("\n") || null;
      } else {
        const cb = comments.before.join("\n");
        if (cb) {
          const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;
          cbNode.commentBefore = cbNode.commentBefore ? `${cb}
${cbNode.commentBefore}` : cb;
        }
        doc.comment = comments.after.join("\n") || null;
      }
    }
    function resolveTagDirective({
      tagPrefixes
    }, directive) {
      const [handle, prefix] = directive.parameters;
      if (!handle || !prefix) {
        const msg = "Insufficient parameters given for %TAG directive";
        throw new PlainValue$1.YAMLSemanticError(directive, msg);
      }
      if (tagPrefixes.some((p2) => p2.handle === handle)) {
        const msg = "The %TAG directive must only be given at most once per handle in the same document.";
        throw new PlainValue$1.YAMLSemanticError(directive, msg);
      }
      return {
        handle,
        prefix
      };
    }
    function resolveYamlDirective(doc, directive) {
      let [version2] = directive.parameters;
      if (directive.name === "YAML:1.0")
        version2 = "1.0";
      if (!version2) {
        const msg = "Insufficient parameters given for %YAML directive";
        throw new PlainValue$1.YAMLSemanticError(directive, msg);
      }
      if (!documentOptions[version2]) {
        const v0 = doc.version || doc.options.version;
        const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version2}`;
        doc.warnings.push(new PlainValue$1.YAMLWarning(directive, msg));
      }
      return version2;
    }
    function parseDirectives(doc, directives, prevDoc) {
      const directiveComments = [];
      let hasDirectives = false;
      for (const directive of directives) {
        const {
          comment,
          name
        } = directive;
        switch (name) {
          case "TAG":
            try {
              doc.tagPrefixes.push(resolveTagDirective(doc, directive));
            } catch (error2) {
              doc.errors.push(error2);
            }
            hasDirectives = true;
            break;
          case "YAML":
          case "YAML:1.0":
            if (doc.version) {
              const msg = "The %YAML directive must only be given at most once per document.";
              doc.errors.push(new PlainValue$1.YAMLSemanticError(directive, msg));
            }
            try {
              doc.version = resolveYamlDirective(doc, directive);
            } catch (error2) {
              doc.errors.push(error2);
            }
            hasDirectives = true;
            break;
          default:
            if (name) {
              const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;
              doc.warnings.push(new PlainValue$1.YAMLWarning(directive, msg));
            }
        }
        if (comment)
          directiveComments.push(comment);
      }
      if (prevDoc && !hasDirectives && (doc.version || prevDoc.version || doc.options.version) === "1.1") {
        const copyTagPrefix = ({
          handle,
          prefix
        }) => ({
          handle,
          prefix
        });
        doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
        doc.version = prevDoc.version;
      }
      doc.commentBefore = directiveComments.join("\n") || null;
    }
    function assertCollection(contents) {
      if (contents instanceof resolveSeq.Collection)
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    var Document$2 = class {
      constructor(options2) {
        this.anchors = new Anchors(options2.anchorPrefix);
        this.commentBefore = null;
        this.comment = null;
        this.contents = null;
        this.directivesEndMarker = null;
        this.errors = [];
        this.options = options2;
        this.schema = null;
        this.tagPrefixes = [];
        this.version = null;
        this.warnings = [];
      }
      add(value) {
        assertCollection(this.contents);
        return this.contents.add(value);
      }
      addIn(path2, value) {
        assertCollection(this.contents);
        this.contents.addIn(path2, value);
      }
      delete(key) {
        assertCollection(this.contents);
        return this.contents.delete(key);
      }
      deleteIn(path2) {
        if (resolveSeq.isEmptyPath(path2)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        assertCollection(this.contents);
        return this.contents.deleteIn(path2);
      }
      getDefaults() {
        return Document$2.defaults[this.version] || Document$2.defaults[this.options.version] || {};
      }
      get(key, keepScalar) {
        return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : void 0;
      }
      getIn(path2, keepScalar) {
        if (resolveSeq.isEmptyPath(path2))
          return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;
        return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path2, keepScalar) : void 0;
      }
      has(key) {
        return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;
      }
      hasIn(path2) {
        if (resolveSeq.isEmptyPath(path2))
          return this.contents !== void 0;
        return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path2) : false;
      }
      set(key, value) {
        assertCollection(this.contents);
        this.contents.set(key, value);
      }
      setIn(path2, value) {
        if (resolveSeq.isEmptyPath(path2))
          this.contents = value;
        else {
          assertCollection(this.contents);
          this.contents.setIn(path2, value);
        }
      }
      setSchema(id, customTags) {
        if (!id && !customTags && this.schema)
          return;
        if (typeof id === "number")
          id = id.toFixed(1);
        if (id === "1.0" || id === "1.1" || id === "1.2") {
          if (this.version)
            this.version = id;
          else
            this.options.version = id;
          delete this.options.schema;
        } else if (id && typeof id === "string") {
          this.options.schema = id;
        }
        if (Array.isArray(customTags))
          this.options.customTags = customTags;
        const opt = Object.assign({}, this.getDefaults(), this.options);
        this.schema = new Schema$1.Schema(opt);
      }
      parse(node2, prevDoc) {
        if (this.options.keepCstNodes)
          this.cstNode = node2;
        if (this.options.keepNodeTypes)
          this.type = "DOCUMENT";
        const {
          directives = [],
          contents = [],
          directivesEndMarker,
          error: error2,
          valueRange
        } = node2;
        if (error2) {
          if (!error2.source)
            error2.source = this;
          this.errors.push(error2);
        }
        parseDirectives(this, directives, prevDoc);
        if (directivesEndMarker)
          this.directivesEndMarker = true;
        this.range = valueRange ? [valueRange.start, valueRange.end] : null;
        this.setSchema();
        this.anchors._cstAliases = [];
        parseContents(this, contents);
        this.anchors.resolveNodes();
        if (this.options.prettyErrors) {
          for (const error3 of this.errors)
            if (error3 instanceof PlainValue$1.YAMLError)
              error3.makePretty();
          for (const warn2 of this.warnings)
            if (warn2 instanceof PlainValue$1.YAMLError)
              warn2.makePretty();
        }
        return this;
      }
      listNonDefaultTags() {
        return listTagNames(this.contents).filter((t) => t.indexOf(Schema$1.Schema.defaultPrefix) !== 0);
      }
      setTagPrefix(handle, prefix) {
        if (handle[0] !== "!" || handle[handle.length - 1] !== "!")
          throw new Error("Handle must start and end with !");
        if (prefix) {
          const prev = this.tagPrefixes.find((p2) => p2.handle === handle);
          if (prev)
            prev.prefix = prefix;
          else
            this.tagPrefixes.push({
              handle,
              prefix
            });
        } else {
          this.tagPrefixes = this.tagPrefixes.filter((p2) => p2.handle !== handle);
        }
      }
      toJSON(arg, onAnchor) {
        const {
          keepBlobsInJSON,
          mapAsMap,
          maxAliasCount
        } = this.options;
        const keep = keepBlobsInJSON && (typeof arg !== "string" || !(this.contents instanceof resolveSeq.Scalar));
        const ctx = {
          doc: this,
          indentStep: "  ",
          keep,
          mapAsMap: keep && !!mapAsMap,
          maxAliasCount,
          stringify: stringify$2
        };
        const anchorNames = Object.keys(this.anchors.map);
        if (anchorNames.length > 0)
          ctx.anchors = new Map(anchorNames.map((name) => [this.anchors.map[name], {
            alias: [],
            aliasCount: 0,
            count: 1
          }]));
        const res = resolveSeq.toJSON(this.contents, arg, ctx);
        if (typeof onAnchor === "function" && ctx.anchors)
          for (const {
            count,
            res: res2
          } of ctx.anchors.values())
            onAnchor(res2, count);
        return res;
      }
      toString() {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        const indentSize = this.options.indent;
        if (!Number.isInteger(indentSize) || indentSize <= 0) {
          const s2 = JSON.stringify(indentSize);
          throw new Error(`"indent" option must be a positive integer, not ${s2}`);
        }
        this.setSchema();
        const lines = [];
        let hasDirectives = false;
        if (this.version) {
          let vd = "%YAML 1.2";
          if (this.schema.name === "yaml-1.1") {
            if (this.version === "1.0")
              vd = "%YAML:1.0";
            else if (this.version === "1.1")
              vd = "%YAML 1.1";
          }
          lines.push(vd);
          hasDirectives = true;
        }
        const tagNames = this.listNonDefaultTags();
        this.tagPrefixes.forEach(({
          handle,
          prefix
        }) => {
          if (tagNames.some((t) => t.indexOf(prefix) === 0)) {
            lines.push(`%TAG ${handle} ${prefix}`);
            hasDirectives = true;
          }
        });
        if (hasDirectives || this.directivesEndMarker)
          lines.push("---");
        if (this.commentBefore) {
          if (hasDirectives || !this.directivesEndMarker)
            lines.unshift("");
          lines.unshift(this.commentBefore.replace(/^/gm, "#"));
        }
        const ctx = {
          anchors: Object.create(null),
          doc: this,
          indent: "",
          indentStep: " ".repeat(indentSize),
          stringify: stringify$2
        };
        let chompKeep = false;
        let contentComment = null;
        if (this.contents) {
          if (this.contents instanceof resolveSeq.Node) {
            if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker))
              lines.push("");
            if (this.contents.commentBefore)
              lines.push(this.contents.commentBefore.replace(/^/gm, "#"));
            ctx.forceBlockIndent = !!this.comment;
            contentComment = this.contents.comment;
          }
          const onChompKeep = contentComment ? null : () => chompKeep = true;
          const body = stringify$2(this.contents, ctx, () => contentComment = null, onChompKeep);
          lines.push(resolveSeq.addComment(body, "", contentComment));
        } else if (this.contents !== void 0) {
          lines.push(stringify$2(this.contents, ctx));
        }
        if (this.comment) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
            lines.push("");
          lines.push(this.comment.replace(/^/gm, "#"));
        }
        return lines.join("\n") + "\n";
      }
    };
    PlainValue$1._defineProperty(Document$2, "defaults", documentOptions);
    Document9b4560a1.Document = Document$2;
    Document9b4560a1.defaultOptions = defaultOptions$1;
    Document9b4560a1.scalarOptions = scalarOptions;
    var parseCst = parseCst$1;
    var Document$1 = Document9b4560a1;
    var Schema = Schema88e323a7;
    var PlainValue = PlainValueEc8e588e;
    var warnings = warnings1000a372;
    function createNode(value, wrapScalars = true, tag) {
      if (tag === void 0 && typeof wrapScalars === "string") {
        tag = wrapScalars;
        wrapScalars = true;
      }
      const options2 = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);
      const schema = new Schema.Schema(options2);
      return schema.createNode(value, wrapScalars, tag);
    }
    var Document = class extends Document$1.Document {
      constructor(options2) {
        super(Object.assign({}, Document$1.defaultOptions, options2));
      }
    };
    function parseAllDocuments(src2, options2) {
      const stream2 = [];
      let prev;
      for (const cstDoc of parseCst.parse(src2)) {
        const doc = new Document(options2);
        doc.parse(cstDoc, prev);
        stream2.push(doc);
        prev = doc;
      }
      return stream2;
    }
    function parseDocument(src2, options2) {
      const cst = parseCst.parse(src2);
      const doc = new Document(options2).parse(cst[0]);
      if (cst.length > 1) {
        const errMsg = "Source contains multiple documents; please use YAML.parseAllDocuments()";
        doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));
      }
      return doc;
    }
    function parse$g(src2, options2) {
      const doc = parseDocument(src2, options2);
      doc.warnings.forEach((warning) => warnings.warn(warning));
      if (doc.errors.length > 0)
        throw doc.errors[0];
      return doc.toJSON();
    }
    function stringify$1(value, options2) {
      const doc = new Document(options2);
      doc.contents = value;
      return String(doc);
    }
    var YAML = {
      createNode,
      defaultOptions: Document$1.defaultOptions,
      Document,
      parse: parse$g,
      parseAllDocuments,
      parseCST: parseCst.parse,
      parseDocument,
      scalarOptions: Document$1.scalarOptions,
      stringify: stringify$1
    };
    dist$1.YAML = YAML;
    var yaml$1 = dist$1.YAML;
    var importCwd = { exports: {} };
    var importFrom$1 = { exports: {} };
    var resolveFrom$2 = { exports: {} };
    var path$i = path__default;
    var Module = require$$1__default;
    var fs$i = fs__default;
    var resolveFrom$1 = (fromDirectory2, moduleId2, silent) => {
      if (typeof fromDirectory2 !== "string") {
        throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDirectory2}\``);
      }
      if (typeof moduleId2 !== "string") {
        throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId2}\``);
      }
      try {
        fromDirectory2 = fs$i.realpathSync(fromDirectory2);
      } catch (error2) {
        if (error2.code === "ENOENT") {
          fromDirectory2 = path$i.resolve(fromDirectory2);
        } else if (silent) {
          return;
        } else {
          throw error2;
        }
      }
      const fromFile = path$i.join(fromDirectory2, "noop.js");
      const resolveFileName = () => Module._resolveFilename(moduleId2, {
        id: fromFile,
        filename: fromFile,
        paths: Module._nodeModulePaths(fromDirectory2)
      });
      if (silent) {
        try {
          return resolveFileName();
        } catch (error2) {
          return;
        }
      }
      return resolveFileName();
    };
    resolveFrom$2.exports = (fromDirectory2, moduleId2) => resolveFrom$1(fromDirectory2, moduleId2);
    resolveFrom$2.exports.silent = (fromDirectory2, moduleId2) => resolveFrom$1(fromDirectory2, moduleId2, true);
    var resolveFrom = resolveFrom$2.exports;
    importFrom$1.exports = (fromDirectory, moduleId) => eval("require")(resolveFrom(fromDirectory, moduleId));
    importFrom$1.exports.silent = (fromDirectory, moduleId) => {
      try {
        return eval("require")(resolveFrom(fromDirectory, moduleId));
      } catch (_2) {
      }
    };
    var importFrom = importFrom$1.exports;
    importCwd.exports = (moduleId2) => importFrom(process.cwd(), moduleId2);
    importCwd.exports.silent = (moduleId2) => importFrom.silent(process.cwd(), moduleId2);
    var req$1 = importCwd.exports;
    var options = (config2, file) => {
      if (config2.parser && typeof config2.parser === "string") {
        try {
          config2.parser = req$1(config2.parser);
        } catch (err) {
          throw new Error(`Loading PostCSS Parser failed: ${err.message}

(@${file})`);
        }
      }
      if (config2.syntax && typeof config2.syntax === "string") {
        try {
          config2.syntax = req$1(config2.syntax);
        } catch (err) {
          throw new Error(`Loading PostCSS Syntax failed: ${err.message}

(@${file})`);
        }
      }
      if (config2.stringifier && typeof config2.stringifier === "string") {
        try {
          config2.stringifier = req$1(config2.stringifier);
        } catch (err) {
          throw new Error(`Loading PostCSS Stringifier failed: ${err.message}

(@${file})`);
        }
      }
      if (config2.plugins) {
        delete config2.plugins;
      }
      return config2;
    };
    var options_1 = options;
    var req = importCwd.exports;
    var load$1 = (plugin, options2, file) => {
      try {
        if (options2 === null || options2 === void 0 || Object.keys(options2).length === 0) {
          return req(plugin);
        } else {
          return req(plugin)(options2);
        }
      } catch (err) {
        throw new Error(`Loading PostCSS Plugin failed: ${err.message}

(@${file})`);
      }
    };
    var plugins = (config2, file) => {
      let plugins2 = [];
      if (Array.isArray(config2.plugins)) {
        plugins2 = config2.plugins.filter(Boolean);
      } else {
        plugins2 = Object.keys(config2.plugins).filter((plugin) => {
          return config2.plugins[plugin] !== false ? plugin : "";
        }).map((plugin) => {
          return load$1(plugin, config2.plugins[plugin], file);
        });
      }
      if (plugins2.length && plugins2.length > 0) {
        plugins2.forEach((plugin, i2) => {
          if (plugin.default) {
            plugin = plugin.default;
          }
          if (plugin.postcss === true) {
            plugin = plugin();
          } else if (plugin.postcss) {
            plugin = plugin.postcss;
          }
          if (!(typeof plugin === "object" && Array.isArray(plugin.plugins) || typeof plugin === "object" && plugin.postcssPlugin || typeof plugin === "function")) {
            throw new TypeError(`Invalid PostCSS Plugin found at: plugins[${i2}]

(@${file})`);
          }
        });
      }
      return plugins2;
    };
    var plugins_1 = plugins;
    var resolve$1 = path__default.resolve;
    var config$1 = dist$2;
    var yaml = yaml$1;
    var loadOptions = options_1;
    var loadPlugins = plugins_1;
    var interopRequireDefault = (obj) => obj && obj.__esModule ? obj : { default: obj };
    var processResult = (ctx, result2) => {
      const file = result2.filepath || "";
      let config2 = interopRequireDefault(result2.config).default || {};
      if (typeof config2 === "function") {
        config2 = config2(ctx);
      } else {
        config2 = Object.assign({}, config2, ctx);
      }
      if (!config2.plugins) {
        config2.plugins = [];
      }
      return {
        plugins: loadPlugins(config2, file),
        options: loadOptions(config2, file),
        file
      };
    };
    var createContext = (ctx) => {
      ctx = Object.assign({
        cwd: process.cwd(),
        env: "development"
      }, ctx);
      if (!ctx.env) {
        "development" = "development";
      }
      return ctx;
    };
    var addTypeScriptLoader = (options2 = {}, loader) => {
      const moduleName = "postcss";
      return __spreadProps2(__spreadValues2({}, options2), {
        searchPlaces: [
          ...options2.searchPlaces || [],
          "package.json",
          `.${moduleName}rc`,
          `.${moduleName}rc.json`,
          `.${moduleName}rc.yaml`,
          `.${moduleName}rc.yml`,
          `.${moduleName}rc.ts`,
          `.${moduleName}rc.js`,
          `.${moduleName}rc.cjs`,
          `${moduleName}.config.ts`,
          `${moduleName}.config.js`,
          `${moduleName}.config.cjs`
        ],
        loaders: __spreadProps2(__spreadValues2({}, options2.loaders), {
          ".yaml": (filepath, content2) => yaml.parse(content2),
          ".yml": (filepath, content2) => yaml.parse(content2),
          ".ts": loader
        })
      });
    };
    var withTypeScriptLoader = (rcFunc) => {
      return (ctx, path2, options2) => {
        return rcFunc(ctx, path2, addTypeScriptLoader(options2, (configFile) => {
          let registerer = { enabled() {
          } };
          try {
            registerer = __require("ts-node").register();
            return commonjsRequire(configFile);
          } catch (err) {
            if (err.code === "MODULE_NOT_FOUND") {
              throw new Error(`'ts-node' is required for the TypeScript configuration files. Make sure it is installed
Error: ${err.message}`);
            }
            throw err;
          } finally {
            registerer.enabled(false);
          }
        }));
      };
    };
    var rc = withTypeScriptLoader((ctx, path2, options2) => {
      ctx = createContext(ctx);
      path2 = path2 ? resolve$1(path2) : process.cwd();
      return config$1.lilconfig("postcss", options2).search(path2).then((result2) => {
        if (!result2) {
          throw new Error(`No PostCSS Config found in: ${path2}`);
        }
        return processResult(ctx, result2);
      });
    });
    rc.sync = withTypeScriptLoader((ctx, path2, options2) => {
      ctx = createContext(ctx);
      path2 = path2 ? resolve$1(path2) : process.cwd();
      const result2 = config$1.lilconfigSync("postcss", options2).search(path2);
      if (!result2) {
        throw new Error(`No PostCSS Config found in: ${path2}`);
      }
      return processResult(ctx, result2);
    });
    var src$1 = rc;
    function isArray$3(arg) {
      return Array.isArray(arg);
    }
    function ensureArray$1(thing) {
      if (isArray$3(thing))
        return thing;
      if (thing == null)
        return [];
      return [thing];
    }
    var normalizePath$3 = function normalizePath2(filename2) {
      return filename2.split(path$t.win32.sep).join(path$t.posix.sep);
    };
    function getMatcherString$1(id, resolutionBase) {
      if (resolutionBase === false || path$t.isAbsolute(id) || id.startsWith("*")) {
        return id;
      }
      const basePath = normalizePath$3(path$t.resolve(resolutionBase || "")).replace(/[-^$*+?.()|[\]{}]/g, "\\$&");
      return path$t.posix.join(basePath, id);
    }
    var createFilter$1 = function createFilter2(include, exclude, options2) {
      const resolutionBase = options2 && options2.resolve;
      const getMatcher = (id) => id instanceof RegExp ? id : {
        test: (what) => {
          const pattern2 = getMatcherString$1(id, resolutionBase);
          const fn2 = picomatch$3(pattern2, { dot: true });
          const result2 = fn2(what);
          return result2;
        }
      };
      const includeMatchers = ensureArray$1(include).map(getMatcher);
      const excludeMatchers = ensureArray$1(exclude).map(getMatcher);
      return function result2(id) {
        if (typeof id !== "string")
          return false;
        if (/\0/.test(id))
          return false;
        const pathId = normalizePath$3(id);
        for (let i2 = 0; i2 < excludeMatchers.length; ++i2) {
          const matcher2 = excludeMatchers[i2];
          if (matcher2.test(pathId))
            return false;
        }
        for (let i2 = 0; i2 < includeMatchers.length; ++i2) {
          const matcher2 = includeMatchers[i2];
          if (matcher2.test(pathId))
            return true;
        }
        return !includeMatchers.length;
      };
    };
    var reservedWords$2 = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
    var builtins$1 = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
    var forbiddenIdentifiers$1 = new Set(`${reservedWords$2} ${builtins$1}`.split(" "));
    forbiddenIdentifiers$1.add("");
    var makeLegalIdentifier$1 = function makeLegalIdentifier2(str) {
      let identifier = str.replace(/-(\w)/g, (_2, letter) => letter.toUpperCase()).replace(/[^$_a-zA-Z0-9]/g, "_");
      if (/\d/.test(identifier[0]) || forbiddenIdentifiers$1.has(identifier)) {
        identifier = `_${identifier}`;
      }
      return identifier || "_";
    };
    function stringify(obj) {
      return (JSON.stringify(obj) || "undefined").replace(/[\u2028\u2029]/g, (char) => `\\u${`000${char.charCodeAt(0).toString(16)}`.slice(-4)}`);
    }
    function serializeArray(arr, indent, baseIndent) {
      let output = "[";
      const separator = indent ? `
${baseIndent}${indent}` : "";
      for (let i2 = 0; i2 < arr.length; i2++) {
        const key = arr[i2];
        output += `${i2 > 0 ? "," : ""}${separator}${serialize(key, indent, baseIndent + indent)}`;
      }
      return `${output}${indent ? `
${baseIndent}` : ""}]`;
    }
    function serializeObject(obj, indent, baseIndent) {
      let output = "{";
      const separator = indent ? `
${baseIndent}${indent}` : "";
      const entries = Object.entries(obj);
      for (let i2 = 0; i2 < entries.length; i2++) {
        const [key, value] = entries[i2];
        const stringKey = makeLegalIdentifier$1(key) === key ? key : stringify(key);
        output += `${i2 > 0 ? "," : ""}${separator}${stringKey}:${indent ? " " : ""}${serialize(value, indent, baseIndent + indent)}`;
      }
      return `${output}${indent ? `
${baseIndent}` : ""}}`;
    }
    function serialize(obj, indent, baseIndent) {
      if (obj === Infinity)
        return "Infinity";
      if (obj === -Infinity)
        return "-Infinity";
      if (obj === 0 && 1 / obj === -Infinity)
        return "-0";
      if (obj instanceof Date)
        return `new Date(${obj.getTime()})`;
      if (obj instanceof RegExp)
        return obj.toString();
      if (obj !== obj)
        return "NaN";
      if (Array.isArray(obj))
        return serializeArray(obj, indent, baseIndent);
      if (obj === null)
        return "null";
      if (typeof obj === "object")
        return serializeObject(obj, indent, baseIndent);
      return stringify(obj);
    }
    var dataToEsm = function dataToEsm2(data2, options2 = {}) {
      const t = options2.compact ? "" : "indent" in options2 ? options2.indent : "	";
      const _2 = options2.compact ? "" : " ";
      const n3 = options2.compact ? "" : "\n";
      const declarationType = options2.preferConst ? "const" : "var";
      if (options2.namedExports === false || typeof data2 !== "object" || Array.isArray(data2) || data2 instanceof Date || data2 instanceof RegExp || data2 === null) {
        const code = serialize(data2, options2.compact ? null : t, "");
        const magic = _2 || (/^[{[\-\/]/.test(code) ? "" : " ");
        return `export default${magic}${code};`;
      }
      let namedExportCode = "";
      const defaultExportRows = [];
      for (const [key, value] of Object.entries(data2)) {
        if (key === makeLegalIdentifier$1(key)) {
          if (options2.objectShorthand)
            defaultExportRows.push(key);
          else
            defaultExportRows.push(`${key}:${_2}${key}`);
          namedExportCode += `export ${declarationType} ${key}${_2}=${_2}${serialize(value, options2.compact ? null : t, "")};${n3}`;
        } else {
          defaultExportRows.push(`${stringify(key)}:${_2}${serialize(value, options2.compact ? null : t, "")}`);
        }
      }
      return `${namedExportCode}export default${_2}{${n3}${t}${defaultExportRows.join(`,${n3}${t}`)}${n3}};${n3}`;
    };
    var cssLangs = `\\.(css|less|sass|scss|styl|stylus|pcss|postcss)($|\\?)`;
    var cssLangRE = new RegExp(cssLangs);
    var cssModuleRE = new RegExp(`\\.module${cssLangs}`);
    var directRequestRE = /(\?|&)direct\b/;
    var commonjsProxyRE = /\?commonjs-proxy/;
    var inlineRE = /(\?|&)inline\b/;
    var usedRE = /(\?|&)used\b/;
    var isCSSRequest = (request) => cssLangRE.test(request);
    var isDirectCSSRequest = (request) => cssLangRE.test(request) && directRequestRE.test(request);
    var isDirectRequest = (request) => directRequestRE.test(request);
    var cssModulesCache = new WeakMap();
    var chunkToEmittedCssFileMap = new WeakMap();
    var removedPureCssFilesCache = new WeakMap();
    var postcssConfigCache = new WeakMap();
    function cssPlugin(config2) {
      let server2;
      let moduleCache;
      const resolveUrl = config2.createResolver({
        preferRelative: true,
        tryIndex: false,
        extensions: []
      });
      const atImportResolvers = createCSSResolvers(config2);
      return {
        name: "vite:css",
        configureServer(_server) {
          server2 = _server;
        },
        buildStart() {
          moduleCache = new Map();
          cssModulesCache.set(config2, moduleCache);
          removedPureCssFilesCache.set(config2, new Map());
        },
        async transform(raw, id) {
          var _a2, _b;
          if (!isCSSRequest(id) || commonjsProxyRE.test(id)) {
            return;
          }
          const urlReplacer = async (url2, importer) => {
            if (checkPublicFile(url2, config2)) {
              return config2.base + url2.slice(1);
            }
            const resolved = await resolveUrl(url2, importer);
            if (resolved) {
              return fileToUrl(resolved, config2, this);
            }
            return url2;
          };
          const { code: css, modules: modules2, deps } = await compileCSS(id, raw, config2, urlReplacer, atImportResolvers, server2);
          if (modules2) {
            moduleCache.set(id, modules2);
          }
          if (config2.command === "build" && config2.build.watch && deps) {
            for (const file of deps) {
              this.addWatchFile(file);
            }
          }
          if (server2) {
            const { moduleGraph } = server2;
            const thisModule = moduleGraph.getModuleById(id);
            if (thisModule) {
              const isSelfAccepting = !modules2 && !inlineRE.test(id);
              if (deps) {
                const depModules = new Set();
                for (const file of deps) {
                  depModules.add(isCSSRequest(file) ? moduleGraph.createFileOnlyEntry(file) : await moduleGraph.ensureEntryFromUrl((await fileToUrl(file, config2, this)).replace(((_b = (_a2 = config2.server) === null || _a2 === void 0 ? void 0 : _a2.origin) !== null && _b !== void 0 ? _b : "") + config2.base, "/")));
                }
                moduleGraph.updateModuleInfo(thisModule, depModules, new Set(), isSelfAccepting);
                for (const file of deps) {
                  this.addWatchFile(file);
                }
              } else {
                thisModule.isSelfAccepting = isSelfAccepting;
              }
            }
          }
          return {
            code: css,
            map: { mappings: "" }
          };
        }
      };
    }
    function cssPostPlugin(config2) {
      const styles2 = new Map();
      let pureCssChunks;
      let outputToExtractedCSSMap;
      let hasEmitted = false;
      return {
        name: "vite:css-post",
        buildStart() {
          pureCssChunks = new Set();
          outputToExtractedCSSMap = new Map();
          hasEmitted = false;
        },
        async transform(css, id, options2) {
          if (!isCSSRequest(id) || commonjsProxyRE.test(id)) {
            return;
          }
          const inlined = inlineRE.test(id);
          const modules2 = cssModulesCache.get(config2).get(id);
          const modulesCode = modules2 && dataToEsm(modules2, { namedExports: true, preferConst: true });
          if (config2.command === "serve") {
            if (isDirectCSSRequest(id)) {
              return css;
            } else {
              if (options2 === null || options2 === void 0 ? void 0 : options2.ssr) {
                return modulesCode || `export default ${JSON.stringify(css)}`;
              }
              if (inlined) {
                return `export default ${JSON.stringify(css)}`;
              }
              return [
                `import { updateStyle as __vite__updateStyle, removeStyle as __vite__removeStyle } from ${JSON.stringify(path__default.posix.join(config2.base, CLIENT_PUBLIC_PATH))}`,
                `const __vite__id = ${JSON.stringify(id)}`,
                `const __vite__css = ${JSON.stringify(css)}`,
                `__vite__updateStyle(__vite__id, __vite__css)`,
                `${modulesCode || `import.meta.hot.accept()
export default __vite__css`}`,
                `import.meta.hot.prune(() => __vite__removeStyle(__vite__id))`
              ].join("\n");
            }
          }
          if (!inlined) {
            styles2.set(id, css);
          }
          return {
            code: modulesCode || (usedRE.test(id) ? `export default ${JSON.stringify(inlined ? await minifyCSS(css, config2) : css)}` : `export default ''`),
            map: { mappings: "" },
            moduleSideEffects: inlined ? false : "no-treeshake"
          };
        },
        async renderChunk(code, chunk, opts) {
          let chunkCSS = "";
          let isPureCssChunk = true;
          const ids = Object.keys(chunk.modules);
          for (const id of ids) {
            if (!isCSSRequest(id) || cssModuleRE.test(id) || commonjsProxyRE.test(id)) {
              isPureCssChunk = false;
            }
            if (styles2.has(id)) {
              chunkCSS += styles2.get(id);
            }
          }
          if (!chunkCSS) {
            return null;
          }
          const processChunkCSS = async (css, { inlined, minify }) => {
            const isRelativeBase = config2.base === "" || config2.base.startsWith(".");
            css = css.replace(assetUrlRE, (_2, fileHash, postfix = "") => {
              const filename2 = getAssetFilename(fileHash, config2) + postfix;
              registerAssetToChunk(chunk, filename2);
              if (!isRelativeBase || inlined) {
                return config2.base + filename2;
              } else {
                return `./${path__default.posix.basename(filename2)}`;
              }
            });
            if (css.includes("@import")) {
              css = await hoistAtImports(css);
            }
            if (minify && config2.build.minify) {
              css = await minifyCSS(css, config2);
            }
            return css;
          };
          if (config2.build.cssCodeSplit) {
            if (isPureCssChunk) {
              pureCssChunks.add(chunk.fileName);
            }
            if (opts.format === "es" || opts.format === "cjs") {
              chunkCSS = await processChunkCSS(chunkCSS, {
                inlined: false,
                minify: true
              });
              const fileHandle = this.emitFile({
                name: chunk.name + ".css",
                type: "asset",
                source: chunkCSS
              });
              chunkToEmittedCssFileMap.set(chunk, new Set([this.getFileName(fileHandle)]));
            } else if (!config2.build.ssr) {
              chunkCSS = await processChunkCSS(chunkCSS, {
                inlined: true,
                minify: true
              });
              const style = `__vite_style__`;
              const injectCode = `var ${style} = document.createElement('style');${style}.innerHTML = ${JSON.stringify(chunkCSS)};document.head.appendChild(${style});`;
              if (config2.build.sourcemap) {
                const s2 = new MagicString(code);
                s2.prepend(injectCode);
                return {
                  code: s2.toString(),
                  map: s2.generateMap({ hires: true })
                };
              } else {
                return { code: injectCode + code };
              }
            }
          } else {
            chunkCSS = await processChunkCSS(chunkCSS, {
              inlined: false,
              minify: false
            });
            outputToExtractedCSSMap.set(opts, (outputToExtractedCSSMap.get(opts) || "") + chunkCSS);
          }
          return null;
        },
        async generateBundle(opts, bundle) {
          if (pureCssChunks.size) {
            const emptyChunkFiles = [...pureCssChunks].map((file) => path__default.basename(file)).join("|").replace(/\./g, "\\.");
            const emptyChunkRE = new RegExp(opts.format === "es" ? `\\bimport\\s*"[^"]*(?:${emptyChunkFiles})";
?` : `\\brequire\\(\\s*"[^"]*(?:${emptyChunkFiles})"\\);
?`, "g");
            for (const file in bundle) {
              const chunk = bundle[file];
              if (chunk.type === "chunk") {
                chunk.imports = chunk.imports.filter((file2) => {
                  if (pureCssChunks.has(file2)) {
                    const css = chunkToEmittedCssFileMap.get(bundle[file2]);
                    if (css) {
                      let existing = chunkToEmittedCssFileMap.get(chunk);
                      if (!existing) {
                        existing = new Set();
                      }
                      css.forEach((file3) => existing.add(file3));
                      chunkToEmittedCssFileMap.set(chunk, existing);
                    }
                    return false;
                  }
                  return true;
                });
                chunk.code = chunk.code.replace(emptyChunkRE, (m3) => `/* empty css ${"".padEnd(m3.length - 15)}*/`);
              }
            }
            const removedPureCssFiles = removedPureCssFilesCache.get(config2);
            pureCssChunks.forEach((fileName) => {
              removedPureCssFiles.set(fileName, bundle[fileName]);
              delete bundle[fileName];
            });
          }
          let extractedCss = outputToExtractedCSSMap.get(opts);
          if (extractedCss && !hasEmitted) {
            hasEmitted = true;
            if (config2.build.minify) {
              extractedCss = await minifyCSS(extractedCss, config2);
            }
            this.emitFile({
              name: "style.css",
              type: "asset",
              source: extractedCss
            });
          }
        }
      };
    }
    function createCSSResolvers(config2) {
      let cssResolve;
      let sassResolve;
      let lessResolve;
      return {
        get css() {
          return cssResolve || (cssResolve = config2.createResolver({
            extensions: [".css"],
            mainFields: ["style"],
            tryIndex: false,
            preferRelative: true
          }));
        },
        get sass() {
          return sassResolve || (sassResolve = config2.createResolver({
            extensions: [".scss", ".sass", ".css"],
            mainFields: ["sass", "style"],
            tryIndex: true,
            tryPrefix: "_",
            preferRelative: true
          }));
        },
        get less() {
          return lessResolve || (lessResolve = config2.createResolver({
            extensions: [".less", ".css"],
            mainFields: ["less", "style"],
            tryIndex: false,
            preferRelative: true
          }));
        }
      };
    }
    function getCssResolversKeys(resolvers) {
      return Object.keys(resolvers);
    }
    async function compileCSS(id, code, config2, urlReplacer, atImportResolvers, server2) {
      var _a2;
      const { modules: modulesOptions, preprocessorOptions } = config2.css || {};
      const isModule = modulesOptions !== false && cssModuleRE.test(id);
      const needInlineImport = code.includes("@import");
      const hasUrl = cssUrlRE.test(code) || cssImageSetRE.test(code);
      const postcssConfig = await resolvePostcssConfig(config2);
      const lang = (_a2 = id.match(cssLangRE)) === null || _a2 === void 0 ? void 0 : _a2[1];
      if (lang === "css" && !postcssConfig && !isModule && !needInlineImport && !hasUrl) {
        return { code };
      }
      let map2;
      let modules2;
      const deps = new Set();
      if (isPreProcessor(lang)) {
        const preProcessor = preProcessors[lang];
        let opts = preprocessorOptions && preprocessorOptions[lang] || {};
        switch (lang) {
          case "scss":
          case "sass":
            opts = __spreadValues2({
              includePaths: ["node_modules"],
              alias: config2.resolve.alias
            }, opts);
            break;
          case "less":
          case "styl":
          case "stylus":
            opts = __spreadValues2({
              paths: ["node_modules"],
              alias: config2.resolve.alias
            }, opts);
        }
        opts.filename = cleanUrl(id);
        const preprocessResult = await preProcessor(code, config2.root, opts, atImportResolvers);
        if (preprocessResult.errors.length) {
          throw preprocessResult.errors[0];
        }
        code = preprocessResult.code;
        map2 = preprocessResult.map;
        if (preprocessResult.deps) {
          preprocessResult.deps.forEach((dep) => {
            if (normalizePath$4(dep) !== normalizePath$4(opts.filename)) {
              deps.add(dep);
            }
          });
        }
      }
      const postcssOptions = postcssConfig && postcssConfig.options || {};
      const postcssPlugins = postcssConfig && postcssConfig.plugins ? postcssConfig.plugins.slice() : [];
      if (needInlineImport) {
        postcssPlugins.unshift((await Promise.resolve().then(function() {
          return require_dep_2d8e2cb1();
        }).then(function(n3) {
          return n3.index;
        })).default({
          async resolve(id2, basedir) {
            const resolved = await atImportResolvers.css(id2, path__default.join(basedir, "*"));
            if (resolved) {
              return path__default.resolve(resolved);
            }
            return id2;
          }
        }));
      }
      postcssPlugins.push(UrlRewritePostcssPlugin({
        replacer: urlReplacer
      }));
      if (isModule) {
        postcssPlugins.unshift((await Promise.resolve().then(function() {
          return require_dep_be90506c();
        }).then(function(n3) {
          return n3.index;
        })).default(__spreadProps2(__spreadValues2({}, modulesOptions), {
          getJSON(cssFileName, _modules, outputFileName) {
            modules2 = _modules;
            if (modulesOptions && typeof modulesOptions.getJSON === "function") {
              modulesOptions.getJSON(cssFileName, _modules, outputFileName);
            }
          },
          async resolve(id2) {
            for (const key of getCssResolversKeys(atImportResolvers)) {
              const resolved = await atImportResolvers[key](id2);
              if (resolved) {
                return path__default.resolve(resolved);
              }
            }
            return id2;
          }
        })));
      }
      if (!postcssPlugins.length) {
        return {
          code,
          map: map2
        };
      }
      const postcssResult = await (await Promise.resolve().then(function() {
        return _interopNamespace(require_postcss());
      })).default(postcssPlugins).process(code, __spreadProps2(__spreadValues2({}, postcssOptions), {
        to: id,
        from: id,
        map: {
          inline: false,
          annotation: false,
          prev: map2
        }
      }));
      for (const message of postcssResult.messages) {
        if (message.type === "dependency") {
          deps.add(message.file);
        } else if (message.type === "dir-dependency") {
          const { dir, glob: globPattern = "**" } = message;
          const pattern2 = normalizePath$4(path__default.resolve(path__default.dirname(id), dir)) + `/` + globPattern;
          const files = out.sync(pattern2, {
            ignore: ["**/node_modules/**"]
          });
          for (let i2 = 0; i2 < files.length; i2++) {
            deps.add(files[i2]);
          }
          if (server2) {
            if (!(id in server2._globImporters)) {
              server2._globImporters[id] = {
                module: server2.moduleGraph.getModuleById(id),
                importGlobs: []
              };
            }
            server2._globImporters[id].importGlobs.push({
              base: config2.root,
              pattern: pattern2
            });
          }
        } else if (message.type === "warning") {
          let msg = `[vite:css] ${message.text}`;
          if (message.line && message.column) {
            msg += `
${generateCodeFrame(code, {
              line: message.line,
              column: message.column
            })}`;
          }
          config2.logger.warn(source.yellow(msg));
        }
      }
      return {
        ast: postcssResult,
        code: postcssResult.css,
        map: postcssResult.map,
        modules: modules2,
        deps
      };
    }
    async function resolvePostcssConfig(config2) {
      var _a2;
      let result2 = postcssConfigCache.get(config2);
      if (result2 !== void 0) {
        return result2;
      }
      const inlineOptions = (_a2 = config2.css) === null || _a2 === void 0 ? void 0 : _a2.postcss;
      if (isObject$3(inlineOptions)) {
        const options2 = __spreadValues2({}, inlineOptions);
        delete options2.plugins;
        result2 = {
          options: options2,
          plugins: inlineOptions.plugins || []
        };
      } else {
        try {
          const searchPath = typeof inlineOptions === "string" ? inlineOptions : config2.root;
          result2 = await src$1({}, searchPath);
        } catch (e2) {
          if (!/No PostCSS Config found/.test(e2.message)) {
            throw e2;
          }
          result2 = null;
        }
      }
      postcssConfigCache.set(config2, result2);
      return result2;
    }
    var cssUrlRE = /(?<=^|[^\w\-\u0080-\uffff])url\(\s*('[^']+'|"[^"]+"|[^'")]+)\s*\)/;
    var cssImageSetRE = /image-set\(([^)]+)\)/;
    var UrlRewritePostcssPlugin = (opts) => {
      if (!opts) {
        throw new Error("base or replace is required");
      }
      return {
        postcssPlugin: "vite-url-rewrite",
        Once(root) {
          const promises = [];
          root.walkDecls((declaration) => {
            const isCssUrl = cssUrlRE.test(declaration.value);
            const isCssImageSet = cssImageSetRE.test(declaration.value);
            if (isCssUrl || isCssImageSet) {
              const replacerForDeclaration = (rawUrl) => {
                var _a2;
                const importer = (_a2 = declaration.source) === null || _a2 === void 0 ? void 0 : _a2.input.file;
                return opts.replacer(rawUrl, importer);
              };
              const rewriterToUse = isCssUrl ? rewriteCssUrls : rewriteCssImageSet;
              promises.push(rewriterToUse(declaration.value, replacerForDeclaration).then((url2) => {
                declaration.value = url2;
              }));
            }
          });
          if (promises.length) {
            return Promise.all(promises);
          }
        }
      };
    };
    UrlRewritePostcssPlugin.postcss = true;
    function rewriteCssUrls(css, replacer) {
      return asyncReplace(css, cssUrlRE, async (match2) => {
        const [matched, rawUrl] = match2;
        return await doUrlReplace(rawUrl, matched, replacer);
      });
    }
    function rewriteCssImageSet(css, replacer) {
      return asyncReplace(css, cssImageSetRE, async (match2) => {
        const [matched, rawUrl] = match2;
        const url2 = await processSrcSet(rawUrl, ({ url: url3 }) => doUrlReplace(url3, matched, replacer));
        return `image-set(${url2})`;
      });
    }
    async function doUrlReplace(rawUrl, matched, replacer) {
      let wrap2 = "";
      const first2 = rawUrl[0];
      if (first2 === `"` || first2 === `'`) {
        wrap2 = first2;
        rawUrl = rawUrl.slice(1, -1);
      }
      if (isExternalUrl(rawUrl) || isDataUrl(rawUrl) || rawUrl.startsWith("#")) {
        return matched;
      }
      return `url(${wrap2}${await replacer(rawUrl)}${wrap2})`;
    }
    async function minifyCSS(css, config2) {
      const { code, warnings: warnings2 } = await esbuild.transform(css, {
        loader: "css",
        minify: true,
        target: config2.build.cssTarget || void 0
      });
      if (warnings2.length) {
        const msgs = await esbuild.formatMessages(warnings2, { kind: "warning" });
        config2.logger.warn(source.yellow(`warnings when minifying css:
${msgs.join("\n")}`));
      }
      return code;
    }
    async function hoistAtImports(css) {
      const postcss2 = await Promise.resolve().then(function() {
        return _interopNamespace(require_postcss());
      });
      return (await postcss2.default([AtImportHoistPlugin]).process(css)).css;
    }
    var AtImportHoistPlugin = () => {
      return {
        postcssPlugin: "vite-hoist-at-imports",
        Once(root) {
          const imports = [];
          root.walkAtRules((rule) => {
            if (rule.name === "import") {
              imports.unshift(rule);
            }
          });
          imports.forEach((i2) => root.prepend(i2));
        }
      };
    };
    AtImportHoistPlugin.postcss = true;
    var loadedPreprocessors = {};
    function loadPreprocessor(lang, root) {
      var _a2, _b;
      if (lang in loadedPreprocessors) {
        return loadedPreprocessors[lang];
      }
      try {
        const fallbackPaths = ((_b = (_a2 = __require.resolve).paths) === null || _b === void 0 ? void 0 : _b.call(_a2, lang)) || [];
        const resolved = __require.resolve(lang, { paths: [root, ...fallbackPaths] });
        return loadedPreprocessors[lang] = __require(resolved);
      } catch (e2) {
        if (e2.code === "MODULE_NOT_FOUND") {
          throw new Error(`Preprocessor dependency "${lang}" not found. Did you install it?`);
        } else {
          const message = new Error(`Preprocessor dependency "${lang}" failed to load:
${e2.message}`);
          message.stack = e2.stack + "\n" + message.stack;
          throw message;
        }
      }
    }
    var scss = async (source2, root, options2, resolvers) => {
      const render = loadPreprocessor("sass", root).render;
      const internalImporter = (url2, importer2, done) => {
        resolvers.sass(url2, importer2).then((resolved) => {
          if (resolved) {
            rebaseUrls(resolved, options2.filename, options2.alias).then((data2) => done === null || done === void 0 ? void 0 : done(data2)).catch((data2) => done === null || done === void 0 ? void 0 : done(data2));
          } else {
            done === null || done === void 0 ? void 0 : done(null);
          }
        });
      };
      const importer = [internalImporter];
      if (options2.importer) {
        Array.isArray(options2.importer) ? importer.push(...options2.importer) : importer.push(options2.importer);
      }
      const finalOptions = __spreadProps2(__spreadValues2({}, options2), {
        data: await getSource(source2, options2.filename, options2.additionalData),
        file: options2.filename,
        outFile: options2.filename,
        importer
      });
      try {
        const result2 = await new Promise((resolve2, reject) => {
          render(finalOptions, (err, res) => {
            if (err) {
              reject(err);
            } else {
              resolve2(res);
            }
          });
        });
        const deps = result2.stats.includedFiles;
        return {
          code: result2.css.toString(),
          errors: [],
          deps
        };
      } catch (e2) {
        e2.id = e2.file;
        e2.frame = e2.formatted;
        return { code: "", errors: [e2], deps: [] };
      }
    };
    var sass = (source2, root, options2, aliasResolver) => scss(source2, root, __spreadProps2(__spreadValues2({}, options2), {
      indentedSyntax: true
    }), aliasResolver);
    async function rebaseUrls(file, rootFile, alias2) {
      file = path__default.resolve(file);
      const fileDir = path__default.dirname(file);
      const rootDir = path__default.dirname(rootFile);
      if (fileDir === rootDir) {
        return { file };
      }
      const content2 = fs__default.readFileSync(file, "utf-8");
      if (!cssUrlRE.test(content2)) {
        return { file };
      }
      const rebased = await rewriteCssUrls(content2, (url2) => {
        if (url2.startsWith("/"))
          return url2;
        for (const { find: find2 } of alias2) {
          const matches2 = typeof find2 === "string" ? url2.startsWith(find2) : find2.test(url2);
          if (matches2) {
            return url2;
          }
        }
        const absolute = path__default.resolve(fileDir, url2);
        const relative = path__default.relative(rootDir, absolute);
        return normalizePath$4(relative);
      });
      return {
        file,
        contents: rebased
      };
    }
    var less = async (source2, root, options2, resolvers) => {
      const nodeLess = loadPreprocessor("less", root);
      const viteResolverPlugin = createViteLessPlugin(nodeLess, options2.filename, options2.alias, resolvers);
      source2 = await getSource(source2, options2.filename, options2.additionalData);
      let result2;
      try {
        result2 = await nodeLess.render(source2, __spreadProps2(__spreadValues2({}, options2), {
          plugins: [viteResolverPlugin, ...options2.plugins || []]
        }));
      } catch (e2) {
        const error2 = e2;
        const normalizedError = new Error(error2.message || error2.type);
        normalizedError.loc = {
          file: error2.filename || options2.filename,
          line: error2.line,
          column: error2.column
        };
        return { code: "", errors: [normalizedError], deps: [] };
      }
      return {
        code: result2.css.toString(),
        deps: result2.imports,
        errors: []
      };
    };
    var ViteLessManager;
    function createViteLessPlugin(less2, rootFile, alias2, resolvers) {
      if (!ViteLessManager) {
        ViteLessManager = class ViteManager extends less2.FileManager {
          constructor(rootFile2, resolvers2, alias3) {
            super();
            this.rootFile = rootFile2;
            this.resolvers = resolvers2;
            this.alias = alias3;
          }
          supports() {
            return true;
          }
          supportsSync() {
            return false;
          }
          async loadFile(filename2, dir, opts, env2) {
            const resolved = await this.resolvers.less(filename2, path__default.join(dir, "*"));
            if (resolved) {
              const result2 = await rebaseUrls(resolved, this.rootFile, this.alias);
              let contents;
              if (result2 && "contents" in result2) {
                contents = result2.contents;
              } else {
                contents = fs__default.readFileSync(resolved, "utf-8");
              }
              return {
                filename: path__default.resolve(resolved),
                contents
              };
            } else {
              return super.loadFile(filename2, dir, opts, env2);
            }
          }
        };
      }
      return {
        install(_2, pluginManager) {
          pluginManager.addFileManager(new ViteLessManager(rootFile, resolvers, alias2));
        },
        minVersion: [3, 0, 0]
      };
    }
    var styl = async (source2, root, options2) => {
      var _a2;
      const nodeStylus = loadPreprocessor("stylus", root);
      source2 = await getSource(source2, options2.filename, options2.additionalData, "\n");
      const importsDeps = ((_a2 = options2.imports) !== null && _a2 !== void 0 ? _a2 : []).map((dep) => path__default.resolve(dep));
      try {
        const ref2 = nodeStylus(source2, options2);
        const result2 = ref2.render();
        const deps = [...ref2.deps(), ...importsDeps];
        return { code: result2, errors: [], deps };
      } catch (e2) {
        return { code: "", errors: [e2], deps: [] };
      }
    };
    function getSource(source2, filename2, additionalData, sep = "") {
      if (!additionalData)
        return source2;
      if (typeof additionalData === "function") {
        return additionalData(source2, filename2);
      }
      return additionalData + sep + source2;
    }
    var preProcessors = Object.freeze({
      ["less"]: less,
      ["sass"]: sass,
      ["scss"]: scss,
      ["styl"]: styl,
      ["stylus"]: styl
    });
    function isPreProcessor(lang) {
      return lang && lang in preProcessors;
    }
    var A = new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
    function parse$f(E3, I2 = "@") {
      if (!B)
        return init.then(() => parse$f(E3));
      const g2 = E3.length + 1, D2 = (B.__heap_base.value || B.__heap_base) + 4 * g2 - B.memory.buffer.byteLength;
      D2 > 0 && B.memory.grow(Math.ceil(D2 / 65536));
      const w3 = B.sa(g2 - 1);
      if ((A ? C : Q)(E3, new Uint16Array(B.memory.buffer, w3, g2)), !B.parse())
        throw Object.assign(new Error(`Parse error ${I2}:${E3.slice(0, B.e()).split("\n").length}:${B.e() - E3.lastIndexOf("\n", B.e() - 1)}`), { idx: B.e() });
      const L2 = [], k2 = [];
      for (; B.ri(); ) {
        const A3 = B.is(), Q3 = B.ie(), C3 = B.ai(), I3 = B.id(), g3 = B.ss(), D3 = B.se();
        let w4;
        B.ip() && (w4 = J2(E3.slice(I3 === -1 ? A3 - 1 : A3, I3 === -1 ? Q3 + 1 : Q3))), L2.push({ n: w4, s: A3, e: Q3, ss: g3, se: D3, d: I3, a: C3 });
      }
      for (; B.re(); ) {
        const A3 = E3.slice(B.es(), B.ee()), Q3 = A3[0];
        k2.push(Q3 === '"' || Q3 === "'" ? J2(A3) : A3);
      }
      function J2(A3) {
        try {
          return (0, eval)(A3);
        } catch (A4) {
        }
      }
      return [L2, k2, !!B.f()];
    }
    function Q(A3, Q3) {
      const C3 = A3.length;
      let B3 = 0;
      for (; B3 < C3; ) {
        const C4 = A3.charCodeAt(B3);
        Q3[B3++] = (255 & C4) << 8 | C4 >>> 8;
      }
    }
    function C(A3, Q3) {
      const C3 = A3.length;
      let B3 = 0;
      for (; B3 < C3; )
        Q3[B3] = A3.charCodeAt(B3++);
    }
    var B;
    var init = WebAssembly.compile((E = "AGFzbQEAAAABXA1gAX8Bf2AEf39/fwBgAn9/AGAAAX9gBn9/f39/fwF/YAAAYAF/AGAEf39/fwF/YAN/f38Bf2AHf39/f39/fwF/YAV/f39/fwF/YAJ/fwF/YAh/f39/f39/fwF/AzEwAAECAwMDAwMDAwMDAwMDAwAABAUFBQYFBgAAAAAFBQAEBwgJCgsMAAIAAAALAwkMBAUBcAEBAQUDAQABBg8CfwFB8PAAC38AQfDwAAsHZBEGbWVtb3J5AgACc2EAAAFlAAMCaXMABAJpZQAFAnNzAAYCc2UABwJhaQAIAmlkAAkCaXAACgJlcwALAmVlAAwCcmkADQJyZQAOAWYADwVwYXJzZQAQC19faGVhcF9iYXNlAwEK8jkwaAEBf0EAIAA2ArgIQQAoApAIIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgK8CEEAIAA2AsAIQQBBADYClAhBAEEANgKkCEEAQQA2ApwIQQBBADYCmAhBAEEANgKsCEEAQQA2AqAIIAELsgEBAn9BACgCpAgiBEEcakGUCCAEG0EAKALACCIFNgIAQQAgBTYCpAhBACAENgKoCEEAIAVBIGo2AsAIIAUgADYCCAJAAkBBACgCiAggA0cNACAFIAI2AgwMAQsCQEEAKAKECCADRw0AIAUgAkECajYCDAwBCyAFQQAoApAINgIMCyAFIAE2AgAgBSADNgIUIAVBADYCECAFIAI2AgQgBUEANgIcIAVBACgChAggA0Y6ABgLSAEBf0EAKAKsCCICQQhqQZgIIAIbQQAoAsAIIgI2AgBBACACNgKsCEEAIAJBDGo2AsAIIAJBADYCCCACIAE2AgQgAiAANgIACwgAQQAoAsQICxUAQQAoApwIKAIAQQAoApAIa0EBdQsVAEEAKAKcCCgCBEEAKAKQCGtBAXULFQBBACgCnAgoAghBACgCkAhrQQF1CxUAQQAoApwIKAIMQQAoApAIa0EBdQseAQF/QQAoApwIKAIQIgBBACgCkAhrQQF1QX8gABsLOwEBfwJAQQAoApwIKAIUIgBBACgChAhHDQBBfw8LAkAgAEEAKAKICEcNAEF+DwsgAEEAKAKQCGtBAXULCwBBACgCnAgtABgLFQBBACgCoAgoAgBBACgCkAhrQQF1CxUAQQAoAqAIKAIEQQAoApAIa0EBdQslAQF/QQBBACgCnAgiAEEcakGUCCAAGygCACIANgKcCCAAQQBHCyUBAX9BAEEAKAKgCCIAQQhqQZgIIAAbKAIAIgA2AqAIIABBAEcLCABBAC0AyAgL9gsBBH8jAEGA8ABrIgEkAEEAQQE6AMgIQQBB//8DOwHOCEEAQQAoAowINgLQCEEAQQAoApAIQX5qIgI2AuQIQQAgAkEAKAK4CEEBdGoiAzYC6AhBAEEAOwHKCEEAQQA7AcwIQQBBADoA1AhBAEEANgLECEEAQQA6ALQIQQAgAUGA0ABqNgLYCEEAIAFBgBBqNgLcCEEAQQA6AOAIAkACQAJAAkADQEEAIAJBAmoiBDYC5AggAiADTw0BAkAgBC8BACIDQXdqQQVJDQACQAJAAkACQAJAIANBm39qDgUBCAgIAgALIANBIEYNBCADQS9GDQMgA0E7Rg0CDAcLQQAvAcwIDQEgBBARRQ0BIAJBBGpB+ABB8ABB7wBB8gBB9AAQEkUNARATQQAtAMgIDQFBAEEAKALkCCICNgLQCAwHCyAEEBFFDQAgAkEEakHtAEHwAEHvAEHyAEH0ABASRQ0AEBQLQQBBACgC5Ag2AtAIDAELAkAgAi8BBCIEQSpGDQAgBEEvRw0EEBUMAQtBARAWC0EAKALoCCEDQQAoAuQIIQIMAAsLQQAhAyAEIQJBAC0AtAgNAgwBC0EAIAI2AuQIQQBBADoAyAgLA0BBACACQQJqIgQ2AuQIAkACQAJAAkACQAJAIAJBACgC6AhPDQAgBC8BACIDQXdqQQVJDQUCQAJAAkACQAJAAkACQAJAAkACQCADQWBqDgoPDggODg4OBwECAAsCQAJAAkACQCADQaB/ag4KCBERAxEBERERAgALIANBhX9qDgMFEAYLC0EALwHMCA0PIAQQEUUNDyACQQRqQfgAQfAAQe8AQfIAQfQAEBJFDQ8QEwwPCyAEEBFFDQ4gAkEEakHtAEHwAEHvAEHyAEH0ABASRQ0OEBQMDgsgBBARRQ0NIAIvAQpB8wBHDQ0gAi8BCEHzAEcNDSACLwEGQeEARw0NIAIvAQRB7ABHDQ0gAi8BDCIEQXdqIgJBF0sNC0EBIAJ0QZ+AgARxRQ0LDAwLQQBBAC8BzAgiAkEBajsBzAhBACgC3AggAkECdGpBACgC0Ag2AgAMDAtBAC8BzAgiAkUNCEEAIAJBf2oiAzsBzAhBACgCsAgiAkUNCyACKAIUQQAoAtwIIANB//8DcUECdGooAgBHDQsCQCACKAIEDQAgAiAENgIECyACIAQ2AgxBAEEANgKwCAwLCwJAQQAoAtAIIgQvAQBBKUcNAEEAKAKkCCICRQ0AIAIoAgQgBEcNAEEAQQAoAqgIIgI2AqQIAkAgAkUNACACQQA2AhwMAQtBAEEANgKUCAsgAUEALwHMCCICakEALQDgCDoAAEEAIAJBAWo7AcwIQQAoAtwIIAJBAnRqIAQ2AgBBAEEAOgDgCAwKC0EALwHMCCICRQ0GQQAgAkF/aiIDOwHMCCACQQAvAc4IIgRHDQFBAEEALwHKCEF/aiICOwHKCEEAQQAoAtgIIAJB//8DcUEBdGovAQA7Ac4ICxAXDAgLIARB//8DRg0HIANB//8DcSAESQ0EDAcLQScQGAwGC0EiEBgMBQsgA0EvRw0EAkACQCACLwEEIgJBKkYNACACQS9HDQEQFQwHC0EBEBYMBgsCQAJAAkACQEEAKALQCCIELwEAIgIQGUUNAAJAAkACQCACQVVqDgQBBQIABQsgBEF+ai8BAEFQakH//wNxQQpJDQMMBAsgBEF+ai8BAEErRg0CDAMLIARBfmovAQBBLUYNAQwCCwJAIAJB/QBGDQAgAkEpRw0BQQAoAtwIQQAvAcwIQQJ0aigCABAaRQ0BDAILQQAoAtwIQQAvAcwIIgNBAnRqKAIAEBsNASABIANqLQAADQELIAQQHA0AIAJFDQBBASEEIAJBL0ZBAC0A1AhBAEdxRQ0BCxAdQQAhBAtBACAEOgDUCAwEC0EALwHOCEH//wNGQQAvAcwIRXFBAC0AtAhFcSEDDAYLEB5BACEDDAULIARBoAFHDQELQQBBAToA4AgLQQBBACgC5Ag2AtAIC0EAKALkCCECDAALCyABQYDwAGokACADCx0AAkBBACgCkAggAEcNAEEBDwsgAEF+ai8BABAfCz8BAX9BACEGAkAgAC8BCCAFRw0AIAAvAQYgBEcNACAALwEEIANHDQAgAC8BAiACRw0AIAAvAQAgAUYhBgsgBgvUBgEEf0EAQQAoAuQIIgBBDGoiATYC5AhBARAnIQICQAJAAkACQAJAQQAoAuQIIgMgAUcNACACECtFDQELAkACQAJAAkACQCACQZ9/ag4MBgEDCAEHAQEBAQEEAAsCQAJAIAJBKkYNACACQfYARg0FIAJB+wBHDQJBACADQQJqNgLkCEEBECchA0EAKALkCCEBA0ACQAJAIANB//8DcSICQSJGDQAgAkEnRg0AIAIQKhpBACgC5AghAgwBCyACEBhBAEEAKALkCEECaiICNgLkCAtBARAnGgJAIAEgAhAsIgNBLEcNAEEAQQAoAuQIQQJqNgLkCEEBECchAwtBACgC5AghAgJAIANB/QBGDQAgAiABRg0FIAIhASACQQAoAugITQ0BDAULC0EAIAJBAmo2AuQIDAELQQAgA0ECajYC5AhBARAnGkEAKALkCCICIAIQLBoLQQEQJyECC0EAKALkCCEDAkAgAkHmAEcNACADLwEGQe0ARw0AIAMvAQRB7wBHDQAgAy8BAkHyAEcNAEEAIANBCGo2AuQIIABBARAnECgPC0EAIANBfmo2AuQIDAMLEB4PCwJAIAMvAQhB8wBHDQAgAy8BBkHzAEcNACADLwEEQeEARw0AIAMvAQJB7ABHDQAgAy8BChAfRQ0AQQAgA0EKajYC5AhBARAnIQJBACgC5AghAyACECoaIANBACgC5AgQAkEAQQAoAuQIQX5qNgLkCA8LQQAgA0EEaiIDNgLkCAtBACADQQRqIgI2AuQIQQBBADoAyAgDQEEAIAJBAmo2AuQIQQEQJyEDQQAoAuQIIQICQCADECpBIHJB+wBHDQBBAEEAKALkCEF+ajYC5AgPC0EAKALkCCIDIAJGDQEgAiADEAICQEEBECciAkEsRg0AAkAgAkE9Rw0AQQBBACgC5AhBfmo2AuQIDwtBAEEAKALkCEF+ajYC5AgPC0EAKALkCCECDAALCw8LQQAgA0EKajYC5AhBARAnGkEAKALkCCEDC0EAIANBEGo2AuQIAkBBARAnIgJBKkcNAEEAQQAoAuQIQQJqNgLkCEEBECchAgtBACgC5AghAyACECoaIANBACgC5AgQAkEAQQAoAuQIQX5qNgLkCA8LIAMgA0EOahACC64GAQR/QQBBACgC5AgiAEEMaiIBNgLkCAJAAkACQAJAAkACQAJAAkACQAJAQQEQJyICQVlqDggCCAECAQEBBwALIAJBIkYNASACQfsARg0CC0EAKALkCCABRg0HC0EALwHMCA0BQQAoAuQIIQJBACgC6AghAwNAIAIgA08NBAJAAkAgAi8BACIBQSdGDQAgAUEiRw0BCyAAIAEQKA8LQQAgAkECaiICNgLkCAwACwtBACgC5AghAkEALwHMCA0BAkADQAJAAkACQCACQQAoAugITw0AQQEQJyICQSJGDQEgAkEnRg0BIAJB/QBHDQJBAEEAKALkCEECajYC5AgLQQEQJxpBACgC5AgiAi8BBkHtAEcNBiACLwEEQe8ARw0GIAIvAQJB8gBHDQYgAi8BAEHmAEcNBkEAIAJBCGo2AuQIQQEQJyICQSJGDQMgAkEnRg0DDAYLIAIQGAtBAEEAKALkCEECaiICNgLkCAwACwsgACACECgMBQtBAEEAKALkCEF+ajYC5AgPC0EAIAJBfmo2AuQIDwsQHg8LQQBBACgC5AhBAmo2AuQIQQEQJ0HtAEcNAUEAKALkCCICLwEGQeEARw0BIAIvAQRB9ABHDQEgAi8BAkHlAEcNAUEAKALQCC8BAEEuRg0BIAAgACACQQhqQQAoAogIEAEPC0EAKALcCEEALwHMCCICQQJ0aiAANgIAQQAgAkEBajsBzAhBACgC0AgvAQBBLkYNACAAQQAoAuQIQQJqQQAgABABQQBBACgCpAg2ArAIQQBBACgC5AhBAmo2AuQIAkBBARAnIgJBIkYNACACQSdGDQBBAEEAKALkCEF+ajYC5AgPCyACEBhBAEEAKALkCEECajYC5AgCQAJAAkBBARAnQVdqDgQBAgIAAgtBACgCpAhBACgC5AgiAjYCBEEAIAJBAmo2AuQIQQEQJxpBACgCpAgiAkEBOgAYIAJBACgC5AgiATYCEEEAIAFBfmo2AuQIDwtBACgCpAgiAkEBOgAYIAJBACgC5AgiATYCDCACIAE2AgRBAEEALwHMCEF/ajsBzAgPC0EAQQAoAuQIQX5qNgLkCA8LC0cBA39BACgC5AhBAmohAEEAKALoCCEBAkADQCAAIgJBfmogAU8NASACQQJqIQAgAi8BAEF2ag4EAQAAAQALC0EAIAI2AuQIC5gBAQN/QQBBACgC5AgiAUECajYC5AggAUEGaiEBQQAoAugIIQIDQAJAAkACQCABQXxqIAJPDQAgAUF+ai8BACEDAkACQCAADQAgA0EqRg0BIANBdmoOBAIEBAIECyADQSpHDQMLIAEvAQBBL0cNAkEAIAFBfmo2AuQIDAELIAFBfmohAQtBACABNgLkCA8LIAFBAmohAQwACwu/AQEEf0EAKALkCCEAQQAoAugIIQECQAJAA0AgACICQQJqIQAgAiABTw0BAkACQCAALwEAIgNBpH9qDgUBAgICBAALIANBJEcNASACLwEEQfsARw0BQQBBAC8ByggiAEEBajsByghBACgC2AggAEEBdGpBAC8Bzgg7AQBBACACQQRqNgLkCEEAQQAvAcwIQQFqIgA7Ac4IQQAgADsBzAgPCyACQQRqIQAMAAsLQQAgADYC5AgQHg8LQQAgADYC5AgLiAEBBH9BACgC5AghAUEAKALoCCECAkACQANAIAEiA0ECaiEBIAMgAk8NASABLwEAIgQgAEYNAgJAIARB3ABGDQAgBEF2ag4EAgEBAgELIANBBGohASADLwEEQQ1HDQAgA0EGaiABIAMvAQZBCkYbIQEMAAsLQQAgATYC5AgQHg8LQQAgATYC5AgLbAEBfwJAAkAgAEFfaiIBQQVLDQBBASABdEExcQ0BCyAAQUZqQf//A3FBBkkNACAAQSlHIABBWGpB//8DcUEHSXENAAJAIABBpX9qDgQBAAABAAsgAEH9AEcgAEGFf2pB//8DcUEESXEPC0EBCz0BAX9BASEBAkAgAEH3AEHoAEHpAEHsAEHlABAgDQAgAEHmAEHvAEHyABAhDQAgAEHpAEHmABAiIQELIAELmwEBAn9BASEBAkACQAJAAkACQAJAIAAvAQAiAkFFag4EBQQEAQALAkAgAkGbf2oOBAMEBAIACyACQSlGDQQgAkH5AEcNAyAAQX5qQeYAQekAQe4AQeEAQewAQewAECMPCyAAQX5qLwEAQT1GDwsgAEF+akHjAEHhAEH0AEHjABAkDwsgAEF+akHlAEHsAEHzABAhDwtBACEBCyABC9IDAQJ/QQAhAQJAAkACQAJAAkACQAJAAkACQCAALwEAQZx/ag4UAAECCAgICAgICAMECAgFCAYICAcICwJAAkAgAEF+ai8BAEGXf2oOBAAJCQEJCyAAQXxqQfYAQe8AECIPCyAAQXxqQfkAQekAQeUAECEPCwJAAkAgAEF+ai8BAEGNf2oOAgABCAsCQCAAQXxqLwEAIgJB4QBGDQAgAkHsAEcNCCAAQXpqQeUAECUPCyAAQXpqQeMAECUPCyAAQXxqQeQAQeUAQewAQeUAECQPCyAAQX5qLwEAQe8ARw0FIABBfGovAQBB5QBHDQUCQCAAQXpqLwEAIgJB8ABGDQAgAkHjAEcNBiAAQXhqQekAQe4AQfMAQfQAQeEAQe4AECMPCyAAQXhqQfQAQfkAECIPC0EBIQEgAEF+aiIAQekAECUNBCAAQfIAQeUAQfQAQfUAQfIAECAPCyAAQX5qQeQAECUPCyAAQX5qQeQAQeUAQeIAQfUAQecAQecAQeUAECYPCyAAQX5qQeEAQfcAQeEAQekAECQPCwJAIABBfmovAQAiAkHvAEYNACACQeUARw0BIABBfGpB7gAQJQ8LIABBfGpB9ABB6ABB8gAQISEBCyABC3ABAn8CQAJAA0BBAEEAKALkCCIAQQJqIgE2AuQIIABBACgC6AhPDQECQAJAAkAgAS8BACIBQaV/ag4CAQIACwJAIAFBdmoOBAQDAwQACyABQS9HDQIMBAsQLRoMAQtBACAAQQRqNgLkCAwACwsQHgsLNQEBf0EAQQE6ALQIQQAoAuQIIQBBAEEAKALoCEECajYC5AhBACAAQQAoApAIa0EBdTYCxAgLNAEBf0EBIQECQCAAQXdqQf//A3FBBUkNACAAQYABckGgAUYNACAAQS5HIAAQK3EhAQsgAQtJAQN/QQAhBgJAIABBeGoiB0EAKAKQCCIISQ0AIAcgASACIAMgBCAFEBJFDQACQCAHIAhHDQBBAQ8LIABBdmovAQAQHyEGCyAGC1kBA39BACEEAkAgAEF8aiIFQQAoApAIIgZJDQAgAC8BACADRw0AIABBfmovAQAgAkcNACAFLwEAIAFHDQACQCAFIAZHDQBBAQ8LIABBemovAQAQHyEECyAEC0wBA39BACEDAkAgAEF+aiIEQQAoApAIIgVJDQAgAC8BACACRw0AIAQvAQAgAUcNAAJAIAQgBUcNAEEBDwsgAEF8ai8BABAfIQMLIAMLSwEDf0EAIQcCQCAAQXZqIghBACgCkAgiCUkNACAIIAEgAiADIAQgBSAGEC5FDQACQCAIIAlHDQBBAQ8LIABBdGovAQAQHyEHCyAHC2YBA39BACEFAkAgAEF6aiIGQQAoApAIIgdJDQAgAC8BACAERw0AIABBfmovAQAgA0cNACAAQXxqLwEAIAJHDQAgBi8BACABRw0AAkAgBiAHRw0AQQEPCyAAQXhqLwEAEB8hBQsgBQs9AQJ/QQAhAgJAQQAoApAIIgMgAEsNACAALwEAIAFHDQACQCADIABHDQBBAQ8LIABBfmovAQAQHyECCyACC00BA39BACEIAkAgAEF0aiIJQQAoApAIIgpJDQAgCSABIAIgAyAEIAUgBiAHEC9FDQACQCAJIApHDQBBAQ8LIABBcmovAQAQHyEICyAIC5wBAQN/QQAoAuQIIQECQANAAkACQCABLwEAIgJBL0cNAAJAIAEvAQIiAUEqRg0AIAFBL0cNBBAVDAILIAAQFgwBCwJAAkAgAEUNACACQXdqIgFBF0sNAUEBIAF0QZ+AgARxRQ0BDAILIAIQKUUNAwwBCyACQaABRw0CC0EAQQAoAuQIIgNBAmoiATYC5AggA0EAKALoCEkNAAsLIAILywMBAX8CQCABQSJGDQAgAUEnRg0AEB4PC0EAKALkCCECIAEQGCAAIAJBAmpBACgC5AhBACgChAgQAUEAQQAoAuQIQQJqNgLkCEEAECchAEEAKALkCCEBAkACQCAAQeEARw0AIAFBAmpB8wBB8wBB5QBB8gBB9AAQEg0BC0EAIAFBfmo2AuQIDwtBACABQQxqNgLkCAJAQQEQJ0H7AEYNAEEAIAE2AuQIDwtBACgC5AgiAiEAA0BBACAAQQJqNgLkCAJAAkACQEEBECciAEEiRg0AIABBJ0cNAUEnEBhBAEEAKALkCEECajYC5AhBARAnIQAMAgtBIhAYQQBBACgC5AhBAmo2AuQIQQEQJyEADAELIAAQKiEACwJAIABBOkYNAEEAIAE2AuQIDwtBAEEAKALkCEECajYC5AgCQEEBECciAEEiRg0AIABBJ0YNAEEAIAE2AuQIDwsgABAYQQBBACgC5AhBAmo2AuQIAkACQEEBECciAEEsRg0AIABB/QBGDQFBACABNgLkCA8LQQBBACgC5AhBAmo2AuQIQQEQJ0H9AEYNAEEAKALkCCEADAELC0EAKAKkCCIBIAI2AhAgAUEAKALkCEECajYCDAswAQF/AkACQCAAQXdqIgFBF0sNAEEBIAF0QY2AgARxDQELIABBoAFGDQBBAA8LQQELbQECfwJAAkADQAJAIABB//8DcSIBQXdqIgJBF0sNAEEBIAJ0QZ+AgARxDQILIAFBoAFGDQEgACECIAEQKw0CQQAhAkEAQQAoAuQIIgBBAmo2AuQIIAAvAQIiAA0ADAILCyAAIQILIAJB//8DcQtoAQJ/QQEhAQJAAkAgAEFfaiICQQVLDQBBASACdEExcQ0BCyAAQfj/A3FBKEYNACAAQUZqQf//A3FBBkkNAAJAIABBpX9qIgJBA0sNACACQQFHDQELIABBhX9qQf//A3FBBEkhAQsgAQuLAQECfwJAQQAoAuQIIgIvAQAiA0HhAEcNAEEAIAJBBGo2AuQIQQEQJyECQQAoAuQIIQACQAJAIAJBIkYNACACQSdGDQAgAhAqGkEAKALkCCEBDAELIAIQGEEAQQAoAuQIQQJqIgE2AuQIC0EBECchA0EAKALkCCECCwJAIAIgAEYNACAAIAEQAgsgAwtyAQR/QQAoAuQIIQBBACgC6AghAQJAAkADQCAAQQJqIQIgACABTw0BAkACQCACLwEAIgNBpH9qDgIBBAALIAIhACADQXZqDgQCAQECAQsgAEEEaiEADAALC0EAIAI2AuQIEB5BAA8LQQAgAjYC5AhB3QALSQEBf0EAIQcCQCAALwEKIAZHDQAgAC8BCCAFRw0AIAAvAQYgBEcNACAALwEEIANHDQAgAC8BAiACRw0AIAAvAQAgAUYhBwsgBwtTAQF/QQAhCAJAIAAvAQwgB0cNACAALwEKIAZHDQAgAC8BCCAFRw0AIAAvAQYgBEcNACAALwEEIANHDQAgAC8BAiACRw0AIAAvAQAgAUYhCAsgCAsLHwIAQYAICwIAAABBhAgLEAEAAAACAAAAAAQAAHA4AAA=", typeof Buffer != "undefined" ? Buffer.from(E, "base64") : Uint8Array.from(atob(E), (A3) => A3.charCodeAt(0)))).then(WebAssembly.instantiate).then(({ exports: A3 }) => {
      B = A3;
    });
    var E;
    async function transformImportGlob(source2, pos, importer, importIndex, root, normalizeUrl, preload2 = true) {
      const isEager = source2.slice(pos, pos + 21) === "import.meta.globEager";
      const isEagerDefault = isEager && source2.slice(pos + 21, pos + 28) === "Default";
      const err = (msg) => {
        const e2 = new Error(`Invalid glob import syntax: ${msg}`);
        e2.pos = pos;
        return e2;
      };
      importer = cleanUrl(importer);
      const importerBasename = path__default.basename(importer);
      let [pattern2, endIndex] = lexGlobPattern(source2, pos);
      if (!pattern2.startsWith(".") && !pattern2.startsWith("/")) {
        throw err(`pattern must start with "." or "/" (relative to project root)`);
      }
      let base2;
      let parentDepth = 0;
      const isAbsolute2 = pattern2.startsWith("/");
      if (isAbsolute2) {
        base2 = path__default.resolve(root);
        pattern2 = pattern2.slice(1);
      } else {
        base2 = path__default.dirname(importer);
        while (pattern2.startsWith("../")) {
          pattern2 = pattern2.slice(3);
          base2 = path__default.resolve(base2, "../");
          parentDepth++;
        }
        if (pattern2.startsWith("./")) {
          pattern2 = pattern2.slice(2);
        }
      }
      const files = out.sync(pattern2, {
        cwd: base2,
        ignore: ["**/node_modules/**"]
      });
      const imports = [];
      let importsString = ``;
      let entries = ``;
      for (let i2 = 0; i2 < files.length; i2++) {
        if (files[i2] === importerBasename)
          continue;
        const file = isAbsolute2 ? `/${files[i2]}` : parentDepth ? `${"../".repeat(parentDepth)}${files[i2]}` : `./${files[i2]}`;
        let importee = file;
        if (normalizeUrl) {
          [importee] = await normalizeUrl(file, pos);
        }
        imports.push(importee);
        const identifier = `__glob_${importIndex}_${i2}`;
        if (isEager) {
          importsString += `import ${isEagerDefault ? `` : `* as `}${identifier} from ${JSON.stringify(importee)};`;
          entries += ` ${JSON.stringify(file)}: ${identifier},`;
        } else {
          let imp = `import(${JSON.stringify(importee)})`;
          if (!normalizeUrl && preload2) {
            imp = `(${isModernFlag}? ${preloadMethod}(()=>${imp},"${preloadMarker}"): ${imp})`;
          }
          entries += ` ${JSON.stringify(file)}: () => ${imp},`;
        }
      }
      return {
        imports,
        importsString,
        exp: `{${entries}}`,
        endIndex,
        isEager,
        pattern: pattern2,
        base: base2
      };
    }
    function lexGlobPattern(code, pos) {
      let state = 0;
      let pattern2 = "";
      let i2 = code.indexOf(`(`, pos) + 1;
      outer:
        for (; i2 < code.length; i2++) {
          const char = code.charAt(i2);
          switch (state) {
            case 0:
              if (char === `'`) {
                state = 1;
              } else if (char === `"`) {
                state = 2;
              } else if (char === "`") {
                state = 3;
              } else if (/\s/.test(char)) {
                continue;
              } else {
                error$3(i2);
              }
              break;
            case 1:
              if (char === `'`) {
                break outer;
              } else {
                pattern2 += char;
              }
              break;
            case 2:
              if (char === `"`) {
                break outer;
              } else {
                pattern2 += char;
              }
              break;
            case 3:
              if (char === "`") {
                break outer;
              } else {
                pattern2 += char;
              }
              break;
            default:
              throw new Error("unknown import.meta.glob lexer state");
          }
        }
      const endIndex = getEndIndex(code, i2);
      return [pattern2, endIndex + 1];
    }
    var multilineCommentsRE = /\/\*(.|[\r\n])*?\*\//m;
    var singlelineCommentsRE = /\/\/.*/;
    function getEndIndex(code, i2) {
      var _a2;
      const findStart = i2;
      const endIndex = code.indexOf(`)`, findStart);
      const subCode = code.substring(findStart);
      const matched = (_a2 = subCode.match(singlelineCommentsRE)) !== null && _a2 !== void 0 ? _a2 : subCode.match(multilineCommentsRE);
      if (!matched) {
        return endIndex;
      }
      const str = matched[0];
      const index2 = matched.index;
      if (!index2) {
        return endIndex;
      }
      const commentStart = findStart + index2;
      const commentEnd = commentStart + str.length;
      if (endIndex > commentStart && endIndex < commentEnd) {
        return getEndIndex(code, commentEnd);
      } else {
        return endIndex;
      }
    }
    function error$3(pos) {
      const err = new Error(`import.meta.glob() can only accept string literals.`);
      err.pos = pos;
      throw err;
    }
    var isModernFlag = `__VITE_IS_MODERN__`;
    var preloadMethod = `__vitePreload`;
    var preloadMarker = `__VITE_PRELOAD__`;
    var preloadBaseMarker = `__VITE_PRELOAD_BASE__`;
    var preloadHelperId = "vite/preload-helper";
    var preloadMarkerRE = new RegExp(`"${preloadMarker}"`, "g");
    function detectScriptRel() {
      const relList = document.createElement("link").relList;
      return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
    }
    function preload(baseModule, deps) {
      if (!__VITE_IS_MODERN__ || !deps || deps.length === 0) {
        return baseModule();
      }
      return Promise.all(deps.map((dep) => {
        dep = `${base}${dep}`;
        if (dep in seen)
          return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link2 = document.createElement("link");
        link2.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link2.as = "script";
          link2.crossOrigin = "";
        }
        link2.href = dep;
        document.head.appendChild(link2);
        if (isCss) {
          return new Promise((res, rej) => {
            link2.addEventListener("load", res);
            link2.addEventListener("error", rej);
          });
        }
      })).then(() => baseModule());
    }
    function buildImportAnalysisPlugin(config2) {
      const ssr = !!config2.build.ssr;
      const insertPreload = !(ssr || !!config2.build.lib);
      const scriptRel2 = config2.build.polyfillModulePreload ? `'modulepreload'` : `(${detectScriptRel.toString()})()`;
      const preloadCode = `const scriptRel = ${scriptRel2};const seen = {};const base = '${preloadBaseMarker}';export const ${preloadMethod} = ${preload.toString()}`;
      return {
        name: "vite:build-import-analysis",
        resolveId(id) {
          if (id === preloadHelperId) {
            return id;
          }
        },
        load(id) {
          if (id === preloadHelperId) {
            return preloadCode.replace(preloadBaseMarker, config2.base);
          }
        },
        async transform(source2, importer) {
          if (importer.includes("node_modules") && !source2.includes("import.meta.glob")) {
            return;
          }
          await init;
          let imports = [];
          try {
            imports = parse$f(source2)[0];
          } catch (e2) {
            this.error(e2, e2.idx);
          }
          if (!imports.length) {
            return null;
          }
          let s2;
          const str = () => s2 || (s2 = new MagicString(source2));
          let needPreloadHelper = false;
          for (let index2 = 0; index2 < imports.length; index2++) {
            const { s: start, e: end, ss: expStart, n: specifier, d: dynamicIndex } = imports[index2];
            if (source2.slice(start, end) === "import.meta" && source2.slice(end, end + 5) === ".glob") {
              const { importsString, exp, endIndex, isEager } = await transformImportGlob(source2, start, importer, index2, config2.root, void 0, insertPreload);
              str().prepend(importsString);
              str().overwrite(expStart, endIndex, exp);
              if (!isEager) {
                needPreloadHelper = true;
              }
              continue;
            }
            if (dynamicIndex > -1 && insertPreload) {
              needPreloadHelper = true;
              const dynamicEnd = source2.indexOf(`)`, end) + 1;
              const original = source2.slice(dynamicIndex, dynamicEnd);
              const replacement2 = `${preloadMethod}(() => ${original},${isModernFlag}?"${preloadMarker}":void 0)`;
              str().overwrite(dynamicIndex, dynamicEnd, replacement2);
            }
            if (specifier && isCSSRequest(specifier) && source2.slice(expStart, start).includes("from") && !(bareImportRE.test(specifier) && !specifier.includes("/"))) {
              const url2 = specifier.replace(/\?|$/, (m3) => `?used${m3 ? "&" : ""}`);
              str().overwrite(start, end, dynamicIndex > -1 ? `'${url2}'` : url2);
            }
          }
          if (needPreloadHelper && insertPreload && !source2.includes(`const ${preloadMethod} =`)) {
            str().prepend(`import { ${preloadMethod} } from "${preloadHelperId}";`);
          }
          if (s2) {
            return {
              code: s2.toString(),
              map: config2.build.sourcemap ? s2.generateMap({ hires: true }) : null
            };
          }
        },
        renderChunk(code, _2, { format: format2 }) {
          if (code.indexOf(isModernFlag) > -1) {
            const re2 = new RegExp(isModernFlag, "g");
            const isModern = String(format2 === "es");
            if (config2.build.sourcemap) {
              const s2 = new MagicString(code);
              let match2;
              while (match2 = re2.exec(code)) {
                s2.overwrite(match2.index, match2.index + isModernFlag.length, isModern);
              }
              return {
                code: s2.toString(),
                map: s2.generateMap({ hires: true })
              };
            } else {
              return code.replace(re2, isModern);
            }
          }
          return null;
        },
        generateBundle({ format: format2 }, bundle) {
          if (format2 !== "es" || ssr) {
            return;
          }
          for (const file in bundle) {
            const chunk = bundle[file];
            if (chunk.type === "chunk" && chunk.code.indexOf(preloadMarker) > -1) {
              const code = chunk.code;
              let imports;
              try {
                imports = parse$f(code)[0].filter((i2) => i2.d > -1);
              } catch (e2) {
                this.error(e2, e2.idx);
              }
              if (imports.length) {
                const s2 = new MagicString(code);
                for (let index2 = 0; index2 < imports.length; index2++) {
                  const { n: name, s: start, e: end, d: dynamicIndex } = imports[index2];
                  let url2 = name;
                  if (!url2) {
                    const rawUrl = code.slice(start, end);
                    if (rawUrl[0] === `"` && rawUrl[rawUrl.length - 1] === `"`)
                      url2 = rawUrl.slice(1, -1);
                  }
                  const deps = new Set();
                  let hasRemovedPureCssChunk = false;
                  if (url2) {
                    const ownerFilename = chunk.fileName;
                    const analyzed = new Set();
                    const addDeps = (filename2) => {
                      if (filename2 === ownerFilename)
                        return;
                      if (analyzed.has(filename2))
                        return;
                      analyzed.add(filename2);
                      const chunk2 = bundle[filename2];
                      if (chunk2) {
                        deps.add(chunk2.fileName);
                        const cssFiles = chunkToEmittedCssFileMap.get(chunk2);
                        if (cssFiles) {
                          cssFiles.forEach((file2) => {
                            deps.add(file2);
                          });
                        }
                        chunk2.imports.forEach(addDeps);
                      } else {
                        const removedPureCssFiles = removedPureCssFilesCache.get(config2);
                        const chunk3 = removedPureCssFiles.get(filename2);
                        if (chunk3) {
                          const cssFiles = chunkToEmittedCssFileMap.get(chunk3);
                          if (cssFiles && cssFiles.size > 0) {
                            cssFiles.forEach((file2) => {
                              deps.add(file2);
                            });
                            hasRemovedPureCssChunk = true;
                          }
                          s2.overwrite(dynamicIndex, end + 1, "Promise.resolve({})");
                        }
                      }
                    };
                    const normalizedFile = path__default.posix.join(path__default.posix.dirname(chunk.fileName), url2);
                    addDeps(normalizedFile);
                  }
                  let markPos = code.indexOf(preloadMarker, end);
                  if (markPos === -1 && imports.length === 1) {
                    markPos = code.indexOf(preloadMarker);
                  }
                  if (markPos > 0) {
                    s2.overwrite(markPos - 1, markPos + preloadMarker.length + 1, deps.size > 1 || hasRemovedPureCssChunk && deps.size > 0 ? `[${[...deps].map((d3) => JSON.stringify(d3)).join(",")}]` : `[]`);
                  }
                }
                chunk.code = s2.toString();
              }
              chunk.code = chunk.code.replace(preloadMarkerRE, "void 0");
            }
          }
        }
      };
    }
    var modulePreloadPolyfillId = "vite/modulepreload-polyfill";
    function modulePreloadPolyfillPlugin(config2) {
      const skip = config2.build.ssr;
      let polyfillString;
      return {
        name: "vite:modulepreload-polyfill",
        resolveId(id) {
          if (id === modulePreloadPolyfillId) {
            return id;
          }
        },
        load(id) {
          if (id === modulePreloadPolyfillId) {
            if (skip) {
              return "";
            }
            if (!polyfillString) {
              polyfillString = `const p = ${polyfill.toString()};${isModernFlag}&&p();`;
            }
            return polyfillString;
          }
        }
      };
    }
    function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link2);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node2 of mutation.addedNodes) {
            if (node2.tagName === "LINK" && node2.rel === "modulepreload")
              processPreload(node2);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(script) {
        const fetchOpts = {};
        if (script.integrity)
          fetchOpts.integrity = script.integrity;
        if (script.referrerpolicy)
          fetchOpts.referrerPolicy = script.referrerpolicy;
        if (script.crossorigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (script.crossorigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link2) {
        if (link2.ep)
          return;
        link2.ep = true;
        const fetchOpts = getFetchOpts(link2);
        fetch(link2.href, fetchOpts);
      }
    }
    var htmlProxyRE = /\?html-proxy&index=(\d+)\.js$/;
    var isHTMLProxy = (id) => htmlProxyRE.test(id);
    var htmlProxyMap = new WeakMap();
    function htmlInlineScriptProxyPlugin(config2) {
      return {
        name: "vite:html-inline-script-proxy",
        resolveId(id) {
          if (htmlProxyRE.test(id)) {
            return id;
          }
        },
        buildStart() {
          htmlProxyMap.set(config2, new Map());
        },
        load(id) {
          const proxyMatch = id.match(htmlProxyRE);
          if (proxyMatch) {
            const index2 = Number(proxyMatch[1]);
            const file = cleanUrl(id);
            const url2 = file.replace(normalizePath$4(config2.root), "");
            const result2 = htmlProxyMap.get(config2).get(url2)[index2];
            if (typeof result2 === "string") {
              return result2;
            } else {
              throw new Error(`No matching HTML proxy module found from ${id}`);
            }
          }
        }
      };
    }
    function addToHTMLProxyCache(config2, filePath, index2, code) {
      if (!htmlProxyMap.get(config2)) {
        htmlProxyMap.set(config2, new Map());
      }
      if (!htmlProxyMap.get(config2).get(filePath)) {
        htmlProxyMap.get(config2).set(filePath, []);
      }
      htmlProxyMap.get(config2).get(filePath)[index2] = code;
    }
    var assetAttrsConfig = {
      link: ["href"],
      video: ["src", "poster"],
      source: ["src", "srcset"],
      img: ["src", "srcset"],
      image: ["xlink:href", "href"],
      use: ["xlink:href", "href"]
    };
    var isAsyncScriptMap = new WeakMap();
    async function traverseHtml(html, filePath, visitor) {
      const { parse: parse2, transform: transform2 } = await Promise.resolve().then(function() {
        return require_dep_6899098c();
      }).then(function(n3) {
        return n3.compilerDom_cjs;
      });
      html = html.replace(/<!doctype\s/i, "<!DOCTYPE ");
      try {
        const ast = parse2(html, { comments: true });
        transform2(ast, {
          nodeTransforms: [visitor]
        });
      } catch (e2) {
        handleParseError(e2, html, filePath);
      }
    }
    function getScriptInfo(node2) {
      let src2;
      let isModule = false;
      let isAsync = false;
      for (let i2 = 0; i2 < node2.props.length; i2++) {
        const p2 = node2.props[i2];
        if (p2.type === 6) {
          if (p2.name === "src") {
            src2 = p2;
          } else if (p2.name === "type" && p2.value && p2.value.content === "module") {
            isModule = true;
          } else if (p2.name === "async") {
            isAsync = true;
          }
        }
      }
      return { src: src2, isModule, isAsync };
    }
    function formatParseError(compilerError, id, html) {
      const formattedError = __spreadValues2({}, compilerError);
      if (compilerError.loc) {
        formattedError.frame = generateCodeFrame(html, compilerError.loc.start.offset);
        formattedError.loc = {
          file: id,
          line: compilerError.loc.start.line,
          column: compilerError.loc.start.column
        };
      }
      return formattedError;
    }
    function handleParseError(compilerError, html, filePath) {
      const parseError = __spreadValues2({
        loc: filePath,
        frame: ""
      }, formatParseError(compilerError, filePath, html));
      throw new Error(`Unable to parse HTML; ${compilerError.message}
 at ${JSON.stringify(parseError.loc)}
${parseError.frame}`);
    }
    function buildHtmlPlugin(config2) {
      const [preHooks, postHooks] = resolveHtmlTransforms(config2.plugins);
      const processedHtml = new Map();
      const isExcludedUrl = (url2) => url2.startsWith("#") || isExternalUrl(url2) || isDataUrl(url2) || checkPublicFile(url2, config2);
      return {
        name: "vite:build-html",
        buildStart() {
          isAsyncScriptMap.set(config2, new Map());
        },
        async transform(html, id) {
          var _a2, _b;
          if (id.endsWith(".html")) {
            const publicPath = `/${slash$3(path__default.relative(config2.root, id))}`;
            html = await applyHtmlTransforms(html, preHooks, {
              path: publicPath,
              filename: id
            });
            let js2 = "";
            const s2 = new MagicString(html);
            const assetUrls = [];
            let inlineModuleIndex = -1;
            let everyScriptIsAsync = true;
            let someScriptsAreAsync = false;
            let someScriptsAreDefer = false;
            await traverseHtml(html, id, (node2) => {
              if (node2.type !== 1) {
                return;
              }
              let shouldRemove = false;
              if (node2.tag === "script") {
                const { src: src2, isModule, isAsync } = getScriptInfo(node2);
                const url2 = src2 && src2.value && src2.value.content;
                const isPublicFile = !!(url2 && checkPublicFile(url2, config2));
                if (isPublicFile) {
                  s2.overwrite(src2.value.loc.start.offset, src2.value.loc.end.offset, `"${config2.base + url2.slice(1)}"`);
                }
                if (isModule) {
                  inlineModuleIndex++;
                  if (url2 && !isExcludedUrl(url2)) {
                    js2 += `
import ${JSON.stringify(url2)}`;
                    shouldRemove = true;
                  } else if (node2.children.length) {
                    const contents = node2.children.map((child) => child.content || "").join("");
                    const filePath = id.replace(normalizePath$4(config2.root), "");
                    addToHTMLProxyCache(config2, filePath, inlineModuleIndex, contents);
                    js2 += `
import "${id}?html-proxy&index=${inlineModuleIndex}.js"`;
                    shouldRemove = true;
                  }
                  everyScriptIsAsync && (everyScriptIsAsync = isAsync);
                  someScriptsAreAsync || (someScriptsAreAsync = isAsync);
                  someScriptsAreDefer || (someScriptsAreDefer = !isAsync);
                } else if (url2 && !isPublicFile) {
                  config2.logger.warn(`<script src="${url2}"> in "${publicPath}" can't be bundled without type="module" attribute`);
                }
              }
              const assetAttrs = assetAttrsConfig[node2.tag];
              if (assetAttrs) {
                for (const p2 of node2.props) {
                  if (p2.type === 6 && p2.value && assetAttrs.includes(p2.name)) {
                    const url2 = decodeURI(p2.value.content);
                    if (!isExcludedUrl(url2)) {
                      if (node2.tag === "link" && isCSSRequest(url2)) {
                        js2 += `
import ${JSON.stringify(url2)}`;
                        shouldRemove = true;
                      } else {
                        assetUrls.push(p2);
                      }
                    } else if (checkPublicFile(url2, config2)) {
                      s2.overwrite(p2.value.loc.start.offset, p2.value.loc.end.offset, `"${config2.base + url2.slice(1)}"`);
                    }
                  }
                }
              }
              if (shouldRemove) {
                s2.remove(node2.loc.start.offset, node2.loc.end.offset);
              }
            });
            isAsyncScriptMap.get(config2).set(id, everyScriptIsAsync);
            if (someScriptsAreAsync && someScriptsAreDefer) {
              config2.logger.warn(`
Mixed async and defer script modules in ${id}, output script will fallback to defer. Every script, including inline ones, need to be marked as async for your output script to be async.`);
            }
            const namedOutput = Object.keys(((_b = (_a2 = config2 === null || config2 === void 0 ? void 0 : config2.build) === null || _a2 === void 0 ? void 0 : _a2.rollupOptions) === null || _b === void 0 ? void 0 : _b.input) || {});
            for (const attr of assetUrls) {
              const value = attr.value;
              const content2 = decodeURI(value.content);
              if (content2 !== "" && !namedOutput.includes(content2) && !namedOutput.includes(content2.replace(/^\//, ""))) {
                try {
                  const url2 = attr.name === "srcset" ? await processSrcSet(content2, ({ url: url3 }) => urlToBuiltUrl(url3, id, config2, this)) : await urlToBuiltUrl(content2, id, config2, this);
                  s2.overwrite(value.loc.start.offset, value.loc.end.offset, `"${url2}"`);
                } catch (e2) {
                  if (e2.code !== "ENOENT") {
                    throw e2;
                  }
                }
              }
            }
            processedHtml.set(id, s2.toString());
            if (config2.build.polyfillModulePreload && (someScriptsAreAsync || someScriptsAreDefer)) {
              js2 = `import "${modulePreloadPolyfillId}";
${js2}`;
            }
            return js2;
          }
        },
        async generateBundle(options2, bundle) {
          const analyzedChunk = new Map();
          const getImportedChunks = (chunk, seen2 = new Set()) => {
            const chunks = [];
            chunk.imports.forEach((file) => {
              const importee = bundle[file];
              if ((importee === null || importee === void 0 ? void 0 : importee.type) === "chunk" && !seen2.has(file)) {
                seen2.add(file);
                chunks.push(...getImportedChunks(importee, seen2));
                chunks.push(importee);
              }
            });
            return chunks;
          };
          const toScriptTag = (chunk, isAsync) => ({
            tag: "script",
            attrs: __spreadProps2(__spreadValues2({}, isAsync ? { async: true } : {}), {
              type: "module",
              crossorigin: true,
              src: toPublicPath(chunk.fileName, config2)
            })
          });
          const toPreloadTag = (chunk) => ({
            tag: "link",
            attrs: {
              rel: "modulepreload",
              href: toPublicPath(chunk.fileName, config2)
            }
          });
          const getCssTagsForChunk = (chunk, seen2 = new Set()) => {
            const tags2 = [];
            if (!analyzedChunk.has(chunk)) {
              analyzedChunk.set(chunk, 1);
              chunk.imports.forEach((file) => {
                const importee = bundle[file];
                if ((importee === null || importee === void 0 ? void 0 : importee.type) === "chunk") {
                  tags2.push(...getCssTagsForChunk(importee, seen2));
                }
              });
            }
            const cssFiles = chunkToEmittedCssFileMap.get(chunk);
            if (cssFiles) {
              cssFiles.forEach((file) => {
                if (!seen2.has(file)) {
                  seen2.add(file);
                  tags2.push({
                    tag: "link",
                    attrs: {
                      rel: "stylesheet",
                      href: toPublicPath(file, config2)
                    }
                  });
                }
              });
            }
            return tags2;
          };
          for (const [id, html] of processedHtml) {
            const isAsync = isAsyncScriptMap.get(config2).get(id);
            let result2 = html.replace(assetUrlRE, (_2, fileHash, postfix = "") => {
              return config2.base + getAssetFilename(fileHash, config2) + postfix;
            });
            const chunk = Object.values(bundle).find((chunk2) => chunk2.type === "chunk" && chunk2.isEntry && chunk2.facadeModuleId === id);
            let canInlineEntry = false;
            if (chunk) {
              if (options2.format === "es" && isEntirelyImport(chunk.code)) {
                canInlineEntry = true;
              }
              const imports = getImportedChunks(chunk);
              const assetTags = canInlineEntry ? imports.map((chunk2) => toScriptTag(chunk2, isAsync)) : [toScriptTag(chunk, isAsync), ...imports.map(toPreloadTag)];
              assetTags.push(...getCssTagsForChunk(chunk));
              result2 = injectToHead(result2, assetTags);
            }
            if (!config2.build.cssCodeSplit) {
              const cssChunk = Object.values(bundle).find((chunk2) => chunk2.type === "asset" && chunk2.name === "style.css");
              if (cssChunk) {
                result2 = injectToHead(result2, [
                  {
                    tag: "link",
                    attrs: {
                      rel: "stylesheet",
                      href: toPublicPath(cssChunk.fileName, config2)
                    }
                  }
                ]);
              }
            }
            const shortEmitName = path__default.posix.relative(config2.root, id);
            result2 = await applyHtmlTransforms(result2, postHooks, {
              path: "/" + shortEmitName,
              filename: id,
              bundle,
              chunk
            });
            if (chunk && canInlineEntry) {
              delete bundle[chunk.fileName];
            }
            this.emitFile({
              type: "asset",
              fileName: shortEmitName,
              source: result2
            });
          }
        }
      };
    }
    function resolveHtmlTransforms(plugins2) {
      const preHooks = [];
      const postHooks = [];
      for (const plugin of plugins2) {
        const hook = plugin.transformIndexHtml;
        if (hook) {
          if (typeof hook === "function") {
            postHooks.push(hook);
          } else if (hook.enforce === "pre") {
            preHooks.push(hook.transform);
          } else {
            postHooks.push(hook.transform);
          }
        }
      }
      return [preHooks, postHooks];
    }
    async function applyHtmlTransforms(html, hooks, ctx) {
      const headTags = [];
      const headPrependTags = [];
      const bodyTags = [];
      const bodyPrependTags = [];
      for (const hook of hooks) {
        const res = await hook(html, ctx);
        if (!res) {
          continue;
        }
        if (typeof res === "string") {
          html = res;
        } else {
          let tags2;
          if (Array.isArray(res)) {
            tags2 = res;
          } else {
            html = res.html || html;
            tags2 = res.tags;
          }
          for (const tag of tags2) {
            if (tag.injectTo === "body") {
              bodyTags.push(tag);
            } else if (tag.injectTo === "body-prepend") {
              bodyPrependTags.push(tag);
            } else if (tag.injectTo === "head") {
              headTags.push(tag);
            } else {
              headPrependTags.push(tag);
            }
          }
        }
      }
      if (headPrependTags.length) {
        html = injectToHead(html, headPrependTags, true);
      }
      if (headTags.length) {
        html = injectToHead(html, headTags);
      }
      if (bodyPrependTags.length) {
        html = injectToBody(html, bodyPrependTags, true);
      }
      if (bodyTags.length) {
        html = injectToBody(html, bodyTags);
      }
      return html;
    }
    var importRE = /\bimport\s*("[^"]*[^\\]"|'[^']*[^\\]');*/g;
    var commentRE$1 = /\/\*[\s\S]*?\*\/|\/\/.*$/gm;
    function isEntirelyImport(code) {
      return !code.replace(importRE, "").replace(commentRE$1, "").trim().length;
    }
    function toPublicPath(filename2, config2) {
      return isExternalUrl(filename2) ? filename2 : config2.base + filename2;
    }
    var headInjectRE = /([ \t]*)<\/head>/i;
    var headPrependInjectRE = /([ \t]*)<head[^>]*>/i;
    var htmlInjectRE = /<\/html>/i;
    var htmlPrependInjectRE = /([ \t]*)<html[^>]*>/i;
    var bodyInjectRE = /([ \t]*)<\/body>/i;
    var bodyPrependInjectRE = /([ \t]*)<body[^>]*>/i;
    var doctypePrependInjectRE = /<!doctype html>/i;
    function injectToHead(html, tags2, prepend = false) {
      if (prepend) {
        if (headPrependInjectRE.test(html)) {
          return html.replace(headPrependInjectRE, (match2, p1) => `${match2}
${serializeTags(tags2, incrementIndent(p1))}`);
        }
      } else {
        if (headInjectRE.test(html)) {
          return html.replace(headInjectRE, (match2, p1) => `${serializeTags(tags2, incrementIndent(p1))}${match2}`);
        }
        if (bodyPrependInjectRE.test(html)) {
          return html.replace(bodyPrependInjectRE, (match2, p1) => `${serializeTags(tags2, p1)}
${match2}`);
        }
      }
      return prependInjectFallback(html, tags2);
    }
    function injectToBody(html, tags2, prepend = false) {
      if (prepend) {
        if (bodyPrependInjectRE.test(html)) {
          return html.replace(bodyPrependInjectRE, (match2, p1) => `${match2}
${serializeTags(tags2, incrementIndent(p1))}`);
        }
        if (headInjectRE.test(html)) {
          return html.replace(headInjectRE, (match2, p1) => `${match2}
${serializeTags(tags2, p1)}`);
        }
        return prependInjectFallback(html, tags2);
      } else {
        if (bodyInjectRE.test(html)) {
          return html.replace(bodyInjectRE, (match2, p1) => `${serializeTags(tags2, incrementIndent(p1))}${match2}`);
        }
        if (htmlInjectRE.test(html)) {
          return html.replace(htmlInjectRE, `${serializeTags(tags2)}
$&`);
        }
        return html + `
` + serializeTags(tags2);
      }
    }
    function prependInjectFallback(html, tags2) {
      if (htmlPrependInjectRE.test(html)) {
        return html.replace(htmlPrependInjectRE, `$&
${serializeTags(tags2)}`);
      }
      if (doctypePrependInjectRE.test(html)) {
        return html.replace(doctypePrependInjectRE, `$&
${serializeTags(tags2)}`);
      }
      return serializeTags(tags2) + html;
    }
    var unaryTags = new Set(["link", "meta", "base"]);
    function serializeTag({ tag, attrs, children }, indent = "") {
      if (unaryTags.has(tag)) {
        return `<${tag}${serializeAttrs(attrs)}>`;
      } else {
        return `<${tag}${serializeAttrs(attrs)}>${serializeTags(children, incrementIndent(indent))}</${tag}>`;
      }
    }
    function serializeTags(tags2, indent = "") {
      if (typeof tags2 === "string") {
        return tags2;
      } else if (tags2 && tags2.length) {
        return tags2.map((tag) => `${indent}${serializeTag(tag, indent)}
`).join("");
      }
      return "";
    }
    function serializeAttrs(attrs) {
      let res = "";
      for (const key in attrs) {
        if (typeof attrs[key] === "boolean") {
          res += attrs[key] ? ` ${key}` : ``;
        } else {
          res += ` ${key}=${JSON.stringify(attrs[key])}`;
        }
      }
      return res;
    }
    function incrementIndent(indent = "") {
      return `${indent}${indent[0] === "	" ? "	" : "  "}`;
    }
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a2, b2) => {
      for (var prop in b2 || (b2 = {}))
        if (__hasOwnProp.call(b2, prop))
          __defNormalProp(a2, prop, b2[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b2)) {
          if (__propIsEnum.call(b2, prop))
            __defNormalProp(a2, prop, b2[prop]);
        }
      return a2;
    };
    var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
    async function find(filename2) {
      let dir = path__default.dirname(path__default.resolve(filename2));
      while (dir) {
        const tsconfig = await tsconfigInDir(dir);
        if (tsconfig) {
          return tsconfig;
        } else {
          const parent = path__default.dirname(dir);
          if (parent === dir) {
            break;
          } else {
            dir = parent;
          }
        }
      }
      throw new Error(`no tsconfig file found for ${filename2}`);
    }
    async function tsconfigInDir(dir) {
      const tsconfig = path__default.join(dir, "tsconfig.json");
      try {
        const stat2 = await fs$r.promises.stat(tsconfig);
        if (stat2.isFile() || stat2.isFIFO()) {
          return tsconfig;
        }
      } catch (e2) {
        if (e2.code !== "ENOENT") {
          throw e2;
        }
      }
    }
    function toJson(tsconfigJson) {
      const stripped = stripDanglingComma(stripJsonComments(stripBom(tsconfigJson)));
      if (stripped.trim() === "") {
        return "{}";
      } else {
        return stripped;
      }
    }
    function stripDanglingComma(pseudoJson) {
      let insideString = false;
      let offset2 = 0;
      let result2 = "";
      let danglingCommaPos = null;
      for (let i2 = 0; i2 < pseudoJson.length; i2++) {
        const currentCharacter = pseudoJson[i2];
        if (currentCharacter === '"') {
          const escaped2 = isEscaped(pseudoJson, i2);
          if (!escaped2) {
            insideString = !insideString;
          }
        }
        if (insideString) {
          danglingCommaPos = null;
          continue;
        }
        if (currentCharacter === ",") {
          danglingCommaPos = i2;
          continue;
        }
        if (danglingCommaPos) {
          if (currentCharacter === "}" || currentCharacter === "]") {
            result2 += pseudoJson.slice(offset2, danglingCommaPos) + " ";
            offset2 = danglingCommaPos + 1;
            danglingCommaPos = null;
          } else if (!currentCharacter.match(/\s/)) {
            danglingCommaPos = null;
          }
        }
      }
      return result2 + pseudoJson.substring(offset2);
    }
    function isEscaped(jsonString, quotePosition) {
      let index2 = quotePosition - 1;
      let backslashCount = 0;
      while (jsonString[index2] === "\\") {
        index2 -= 1;
        backslashCount += 1;
      }
      return Boolean(backslashCount % 2);
    }
    function strip(string2, start, end) {
      return string2.slice(start, end).replace(/\S/g, " ");
    }
    var singleComment = Symbol("singleComment");
    var multiComment = Symbol("multiComment");
    function stripJsonComments(jsonString) {
      let isInsideString = false;
      let isInsideComment = false;
      let offset2 = 0;
      let result2 = "";
      for (let index2 = 0; index2 < jsonString.length; index2++) {
        const currentCharacter = jsonString[index2];
        const nextCharacter = jsonString[index2 + 1];
        if (!isInsideComment && currentCharacter === '"') {
          const escaped2 = isEscaped(jsonString, index2);
          if (!escaped2) {
            isInsideString = !isInsideString;
          }
        }
        if (isInsideString) {
          continue;
        }
        if (!isInsideComment && currentCharacter + nextCharacter === "//") {
          result2 += jsonString.slice(offset2, index2);
          offset2 = index2;
          isInsideComment = singleComment;
          index2++;
        } else if (isInsideComment === singleComment && currentCharacter + nextCharacter === "\r\n") {
          index2++;
          isInsideComment = false;
          result2 += strip(jsonString, offset2, index2);
          offset2 = index2;
        } else if (isInsideComment === singleComment && currentCharacter === "\n") {
          isInsideComment = false;
          result2 += strip(jsonString, offset2, index2);
          offset2 = index2;
        } else if (!isInsideComment && currentCharacter + nextCharacter === "/*") {
          result2 += jsonString.slice(offset2, index2);
          offset2 = index2;
          isInsideComment = multiComment;
          index2++;
        } else if (isInsideComment === multiComment && currentCharacter + nextCharacter === "*/") {
          index2++;
          isInsideComment = false;
          result2 += strip(jsonString, offset2, index2 + 1);
          offset2 = index2 + 1;
        }
      }
      return result2 + (isInsideComment ? strip(jsonString.slice(offset2)) : jsonString.slice(offset2));
    }
    function stripBom(string2) {
      if (string2.charCodeAt(0) === 65279) {
        return string2.slice(1);
      }
      return string2;
    }
    var POSIX_SEP_RE = new RegExp("\\" + path__default.posix.sep, "g");
    var NATIVE_SEP_RE = new RegExp("\\" + path__default.sep, "g");
    var PATTERN_REGEX_CACHE = new Map();
    var GLOB_ALL_PATTERN = `**/*`;
    var DEFAULT_EXTENSIONS = [".ts", ".tsx", ".mts", ".cts"];
    var DEFAULT_EXTENSIONS_RE_GROUP = `\\.(?:${DEFAULT_EXTENSIONS.map((ext2) => ext2.substring(1)).join("|")})`;
    new Function("path", "return import(path).then(m => m.default)");
    async function resolveTSConfig(filename2) {
      const basename = path__default.basename(filename2);
      if (basename !== "tsconfig.json") {
        return;
      }
      const tsconfig = path__default.resolve(filename2);
      try {
        const stat2 = await fs$r.promises.stat(tsconfig);
        if (stat2.isFile() || stat2.isFIFO()) {
          return tsconfig;
        }
      } catch (e2) {
        if (e2.code !== "ENOENT") {
          throw e2;
        }
      }
      throw new Error(`no tsconfig file found for ${filename2}`);
    }
    function posix2native(filename2) {
      return path__default.posix.sep !== path__default.sep && filename2.includes(path__default.posix.sep) ? filename2.replace(POSIX_SEP_RE, path__default.sep) : filename2;
    }
    function native2posix(filename2) {
      return path__default.posix.sep !== path__default.sep && filename2.includes(path__default.sep) ? filename2.replace(NATIVE_SEP_RE, path__default.posix.sep) : filename2;
    }
    function resolve2posix(dir, filename2) {
      if (path__default.sep === path__default.posix.sep) {
        return dir ? path__default.resolve(dir, filename2) : path__default.resolve(filename2);
      }
      return native2posix(dir ? path__default.resolve(posix2native(dir), posix2native(filename2)) : path__default.resolve(posix2native(filename2)));
    }
    function resolveReferencedTSConfigFiles(result2) {
      const dir = path__default.dirname(result2.tsconfigFile);
      return result2.tsconfig.references.map((ref2) => {
        const refPath = ref2.path.endsWith(".json") ? ref2.path : path__default.join(ref2.path, "tsconfig.json");
        return resolve2posix(dir, refPath);
      });
    }
    function resolveSolutionTSConfig(filename2, result2) {
      if (result2.referenced && DEFAULT_EXTENSIONS.some((ext2) => filename2.endsWith(ext2)) && !isIncluded(filename2, result2)) {
        const solutionTSConfig = result2.referenced.find((referenced) => isIncluded(filename2, referenced));
        if (solutionTSConfig) {
          return __spreadProps(__spreadValues({}, solutionTSConfig), {
            solution: result2
          });
        }
      }
      return result2;
    }
    function isIncluded(filename2, result2) {
      const dir = native2posix(path__default.dirname(result2.tsconfigFile));
      const files = (result2.tsconfig.files || []).map((file) => resolve2posix(dir, file));
      const absoluteFilename = resolve2posix(null, filename2);
      if (files.includes(filename2)) {
        return true;
      }
      const isIncluded2 = isGlobMatch(absoluteFilename, dir, result2.tsconfig.include || (result2.tsconfig.files ? [] : [GLOB_ALL_PATTERN]));
      if (isIncluded2) {
        const isExcluded = isGlobMatch(absoluteFilename, dir, result2.tsconfig.exclude || []);
        return !isExcluded;
      }
      return false;
    }
    function isGlobMatch(filename2, dir, patterns) {
      return patterns.some((pattern2) => {
        let lastWildcardIndex = pattern2.length;
        let hasWildcard = false;
        for (let i2 = pattern2.length - 1; i2 > -1; i2--) {
          if (pattern2[i2] === "*" || pattern2[i2] === "?") {
            lastWildcardIndex = i2;
            hasWildcard = true;
            break;
          }
        }
        if (lastWildcardIndex < pattern2.length - 1 && !filename2.endsWith(pattern2.slice(lastWildcardIndex + 1))) {
          return false;
        }
        if (pattern2.endsWith("*") && !DEFAULT_EXTENSIONS.some((ext2) => filename2.endsWith(ext2))) {
          return false;
        }
        if (pattern2 === GLOB_ALL_PATTERN) {
          return filename2.startsWith(`${dir}/`);
        }
        const resolvedPattern = resolve2posix(dir, pattern2);
        let firstWildcardIndex = -1;
        for (let i2 = 0; i2 < resolvedPattern.length; i2++) {
          if (resolvedPattern[i2] === "*" || resolvedPattern[i2] === "?") {
            firstWildcardIndex = i2;
            hasWildcard = true;
            break;
          }
        }
        if (firstWildcardIndex > 1 && !filename2.startsWith(resolvedPattern.slice(0, firstWildcardIndex - 1))) {
          return false;
        }
        if (!hasWildcard) {
          return filename2 === resolvedPattern;
        }
        if (PATTERN_REGEX_CACHE.has(resolvedPattern)) {
          return PATTERN_REGEX_CACHE.get(resolvedPattern).test(filename2);
        }
        const regex = pattern2regex(resolvedPattern);
        PATTERN_REGEX_CACHE.set(resolvedPattern, regex);
        return regex.test(filename2);
      });
    }
    function pattern2regex(resolvedPattern) {
      let regexStr = "^";
      for (let i2 = 0; i2 < resolvedPattern.length; i2++) {
        const char = resolvedPattern[i2];
        if (char === "?") {
          regexStr += "[^\\/]";
          continue;
        }
        if (char === "*") {
          if (resolvedPattern[i2 + 1] === "*" && resolvedPattern[i2 + 2] === "/") {
            i2 += 2;
            regexStr += "(?:[^\\/]*\\/)*";
            continue;
          }
          regexStr += "[^\\/]*";
          continue;
        }
        if ("/.+^${}()|[]\\".includes(char)) {
          regexStr += `\\`;
        }
        regexStr += char;
      }
      if (resolvedPattern.endsWith("*")) {
        regexStr += DEFAULT_EXTENSIONS_RE_GROUP;
      }
      regexStr += "$";
      return new RegExp(regexStr);
    }
    async function parse$e(filename2, options2) {
      const cache2 = options2 == null ? void 0 : options2.cache;
      if (cache2 == null ? void 0 : cache2.has(filename2)) {
        return cache2.get(filename2);
      }
      let tsconfigFile;
      if (options2 == null ? void 0 : options2.resolveWithEmptyIfConfigNotFound) {
        try {
          tsconfigFile = await resolveTSConfig(filename2) || await find(filename2);
        } catch (e2) {
          const notFoundResult = {
            tsconfigFile: "no_tsconfig_file_found",
            tsconfig: {}
          };
          cache2 == null ? void 0 : cache2.set(filename2, notFoundResult);
          return notFoundResult;
        }
      } else {
        tsconfigFile = await resolveTSConfig(filename2) || await find(filename2);
      }
      let result2;
      if (cache2 == null ? void 0 : cache2.has(tsconfigFile)) {
        result2 = cache2.get(tsconfigFile);
      } else {
        result2 = await parseFile$1(tsconfigFile, cache2);
        await Promise.all([parseExtends(result2, cache2), parseReferences(result2, cache2)]);
        cache2 == null ? void 0 : cache2.set(tsconfigFile, result2);
      }
      result2 = resolveSolutionTSConfig(filename2, result2);
      cache2 == null ? void 0 : cache2.set(filename2, result2);
      return result2;
    }
    async function parseFile$1(tsconfigFile, cache2) {
      if (cache2 == null ? void 0 : cache2.has(tsconfigFile)) {
        return cache2.get(tsconfigFile);
      }
      try {
        const tsconfigJson = await fs$r.promises.readFile(tsconfigFile, "utf-8");
        const json2 = toJson(tsconfigJson);
        const result2 = {
          tsconfigFile,
          tsconfig: normalizeTSConfig(JSON.parse(json2), path__default.dirname(tsconfigFile))
        };
        cache2 == null ? void 0 : cache2.set(tsconfigFile, result2);
        return result2;
      } catch (e2) {
        throw new TSConfckParseError(`parsing ${tsconfigFile} failed: ${e2}`, "PARSE_FILE", tsconfigFile, e2);
      }
    }
    function normalizeTSConfig(tsconfig, dir) {
      var _a2;
      if (((_a2 = tsconfig.compilerOptions) == null ? void 0 : _a2.baseUrl) && !path__default.isAbsolute(tsconfig.compilerOptions.baseUrl)) {
        tsconfig.compilerOptions.baseUrl = resolve2posix(dir, tsconfig.compilerOptions.baseUrl);
      }
      return tsconfig;
    }
    async function parseReferences(result2, cache2) {
      if (!result2.tsconfig.references) {
        return;
      }
      const referencedFiles = resolveReferencedTSConfigFiles(result2);
      const referenced = await Promise.all(referencedFiles.map((file) => parseFile$1(file, cache2)));
      await Promise.all(referenced.map((ref2) => parseExtends(ref2, cache2)));
      result2.referenced = referenced;
    }
    async function parseExtends(result2, cache2) {
      if (!result2.tsconfig.extends) {
        return;
      }
      const extended = [
        { tsconfigFile: result2.tsconfigFile, tsconfig: JSON.parse(JSON.stringify(result2.tsconfig)) }
      ];
      while (extended[extended.length - 1].tsconfig.extends) {
        const extending = extended[extended.length - 1];
        const extendedTSConfigFile = resolveExtends(extending.tsconfig.extends, extending.tsconfigFile);
        if (extended.some((x2) => x2.tsconfigFile === extendedTSConfigFile)) {
          const circle = extended.concat({ tsconfigFile: extendedTSConfigFile, tsconfig: null }).map((e2) => e2.tsconfigFile).join(" -> ");
          throw new TSConfckParseError(`Circular dependency in "extends": ${circle}`, "EXTENDS_CIRCULAR", result2.tsconfigFile);
        }
        extended.push(await parseFile$1(extendedTSConfigFile, cache2));
      }
      result2.extended = extended;
      for (const ext2 of result2.extended.slice(1)) {
        extendTSConfig(result2, ext2);
      }
    }
    function resolveExtends(extended, from) {
      try {
        return require$$1.createRequire(from).resolve(extended);
      } catch (e2) {
        throw new TSConfckParseError(`failed to resolve "extends":"${extended}" in ${from}`, "EXTENDS_RESOLVE", from, e2);
      }
    }
    var EXTENDABLE_KEYS = [
      "compilerOptions",
      "files",
      "include",
      "exclude",
      "watchOptions",
      "compileOnSave",
      "typeAcquisition",
      "buildOptions"
    ];
    function extendTSConfig(extending, extended) {
      const extendingConfig = extending.tsconfig;
      const extendedConfig = extended.tsconfig;
      const relativePath = native2posix(path__default.relative(path__default.dirname(extending.tsconfigFile), path__default.dirname(extended.tsconfigFile)));
      for (const key of Object.keys(extendedConfig).filter((key2) => EXTENDABLE_KEYS.includes(key2))) {
        if (key === "compilerOptions") {
          if (!extendingConfig.compilerOptions) {
            extendingConfig.compilerOptions = {};
          }
          for (const option of Object.keys(extendedConfig.compilerOptions)) {
            if (Object.prototype.hasOwnProperty.call(extendingConfig.compilerOptions, option)) {
              continue;
            }
            extendingConfig.compilerOptions[option] = rebaseRelative(option, extendedConfig.compilerOptions[option], relativePath);
          }
        } else if (extendingConfig[key] === void 0) {
          if (key === "watchOptions") {
            extendingConfig.watchOptions = {};
            for (const option of Object.keys(extendedConfig.watchOptions)) {
              extendingConfig.watchOptions[option] = rebaseRelative(option, extendedConfig.watchOptions[option], relativePath);
            }
          } else {
            extendingConfig[key] = rebaseRelative(key, extendedConfig[key], relativePath);
          }
        }
      }
    }
    var REBASE_KEYS = [
      "files",
      "include",
      "exclude",
      "baseUrl",
      "rootDir",
      "rootDirs",
      "typeRoots",
      "outDir",
      "outFile",
      "declarationDir",
      "excludeDirectories",
      "excludeFiles"
    ];
    function rebaseRelative(key, value, prependPath) {
      if (!REBASE_KEYS.includes(key)) {
        return value;
      }
      if (Array.isArray(value)) {
        return value.map((x2) => rebasePath(x2, prependPath));
      } else {
        return rebasePath(value, prependPath);
      }
    }
    function rebasePath(value, prependPath) {
      if (path__default.isAbsolute(value)) {
        return value;
      } else {
        return path__default.posix.normalize(path__default.posix.join(prependPath, value));
      }
    }
    var TSConfckParseError = class extends Error {
      constructor(message, code, tsconfigFile, cause) {
        super(message);
        Object.setPrototypeOf(this, TSConfckParseError.prototype);
        this.name = TSConfckParseError.name;
        this.code = code;
        this.cause = cause;
        this.tsconfigFile = tsconfigFile;
      }
    };
    var debug$f = createDebugger("vite:esbuild");
    var server;
    async function transformWithEsbuild(code, filename2, options2, inMap) {
      var _a2, _b, _c;
      let loader = options2 === null || options2 === void 0 ? void 0 : options2.loader;
      if (!loader) {
        const ext2 = path__default.extname(/\.\w+$/.test(filename2) ? filename2 : cleanUrl(filename2)).slice(1);
        if (ext2 === "cjs" || ext2 === "mjs") {
          loader = "js";
        } else {
          loader = ext2;
        }
      }
      let tsconfigRaw = options2 === null || options2 === void 0 ? void 0 : options2.tsconfigRaw;
      if (typeof tsconfigRaw !== "string") {
        const meaningfulFields = [
          "jsxFactory",
          "jsxFragmentFactory",
          "useDefineForClassFields",
          "importsNotUsedAsValues"
        ];
        const compilerOptionsForFile = {};
        if (loader === "ts" || loader === "tsx") {
          const loadedTsconfig = await loadTsconfigJsonForFile(filename2);
          const loadedCompilerOptions = (_a2 = loadedTsconfig.compilerOptions) !== null && _a2 !== void 0 ? _a2 : {};
          for (const field of meaningfulFields) {
            if (field in loadedCompilerOptions) {
              compilerOptionsForFile[field] = loadedCompilerOptions[field];
            }
          }
          if (((_b = loadedCompilerOptions.target) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === "esnext") {
            compilerOptionsForFile.useDefineForClassFields = (_c = loadedCompilerOptions.useDefineForClassFields) !== null && _c !== void 0 ? _c : true;
          }
        }
        tsconfigRaw = __spreadProps2(__spreadValues2({}, tsconfigRaw), {
          compilerOptions: __spreadValues2(__spreadValues2({}, compilerOptionsForFile), tsconfigRaw === null || tsconfigRaw === void 0 ? void 0 : tsconfigRaw.compilerOptions)
        });
      }
      const resolvedOptions = __spreadProps2(__spreadValues2({
        sourcemap: true,
        sourcefile: filename2
      }, options2), {
        loader,
        tsconfigRaw
      });
      delete resolvedOptions.include;
      delete resolvedOptions.exclude;
      delete resolvedOptions.jsxInject;
      try {
        const result2 = await esbuild.transform(code, resolvedOptions);
        let map2;
        if (inMap && resolvedOptions.sourcemap) {
          const nextMap = JSON.parse(result2.map);
          nextMap.sourcesContent = [];
          map2 = combineSourcemaps(filename2, [
            nextMap,
            inMap
          ]);
        } else {
          map2 = resolvedOptions.sourcemap ? JSON.parse(result2.map) : { mappings: "" };
        }
        if (Array.isArray(map2.sources)) {
          map2.sources = map2.sources.map((it2) => toUpperCaseDriveLetter(it2));
        }
        return __spreadProps2(__spreadValues2({}, result2), {
          map: map2
        });
      } catch (e2) {
        debug$f(`esbuild error with options used: `, resolvedOptions);
        if (e2.errors) {
          e2.frame = "";
          e2.errors.forEach((m3) => {
            e2.frame += `
` + prettifyMessage(m3, code);
          });
          e2.loc = e2.errors[0].location;
        }
        throw e2;
      }
    }
    function esbuildPlugin(options2 = {}) {
      const filter2 = createFilter$1(options2.include || /\.(tsx?|jsx)$/, options2.exclude || /\.js$/);
      return {
        name: "vite:esbuild",
        configureServer(_server) {
          server = _server;
          server.watcher.on("add", reloadOnTsconfigChange).on("change", reloadOnTsconfigChange).on("unlink", reloadOnTsconfigChange);
        },
        async transform(code, id) {
          if (filter2(id) || filter2(cleanUrl(id))) {
            const result2 = await transformWithEsbuild(code, id, options2);
            if (result2.warnings.length) {
              result2.warnings.forEach((m3) => {
                this.warn(prettifyMessage(m3, code));
              });
            }
            if (options2.jsxInject && /\.(?:j|t)sx\b/.test(id)) {
              result2.code = options2.jsxInject + ";" + result2.code;
            }
            return {
              code: result2.code,
              map: result2.map
            };
          }
        }
      };
    }
    var rollupToEsbuildFormatMap = {
      es: "esm",
      cjs: "cjs",
      iife: void 0
    };
    var buildEsbuildPlugin = (config2) => {
      return {
        name: "vite:esbuild-transpile",
        async renderChunk(code, chunk, opts) {
          if (opts.__vite_skip_esbuild__) {
            return null;
          }
          const target = config2.build.target;
          const minify = config2.build.minify === "esbuild" && !(config2.build.lib && opts.format === "es");
          if ((!target || target === "esnext") && !minify) {
            return null;
          }
          const res = await transformWithEsbuild(code, chunk.fileName, __spreadValues2(__spreadProps2(__spreadValues2({}, config2.esbuild), {
            target: target || void 0
          }), minify ? {
            minify,
            treeShaking: true,
            format: rollupToEsbuildFormatMap[opts.format]
          } : void 0));
          return res;
        }
      };
    };
    function prettifyMessage(m3, code) {
      let res = source.yellow(m3.text);
      if (m3.location) {
        const lines = code.split(/\r?\n/g);
        const line = Number(m3.location.line);
        const column = Number(m3.location.column);
        const offset2 = lines.slice(0, line - 1).map((l2) => l2.length).reduce((total, l2) => total + l2 + 1, 0) + column;
        res += `
` + generateCodeFrame(code, offset2, offset2 + 1);
      }
      return res + `
`;
    }
    var tsconfigCache = new Map();
    async function loadTsconfigJsonForFile(filename2) {
      try {
        const result2 = await parse$e(filename2, {
          cache: tsconfigCache,
          resolveWithEmptyIfConfigNotFound: true
        });
        if (server && result2.tsconfigFile !== "no_tsconfig_file_found") {
          ensureWatchedFile(server.watcher, result2.tsconfigFile, server.config.root);
        }
        return result2.tsconfig;
      } catch (e2) {
        if (e2 instanceof TSConfckParseError) {
          if (server && e2.tsconfigFile) {
            ensureWatchedFile(server.watcher, e2.tsconfigFile, server.config.root);
          }
        }
        throw e2;
      }
    }
    function reloadOnTsconfigChange(changedFile) {
      if (path__default.basename(changedFile) === "tsconfig.json" || changedFile.endsWith(".json") && tsconfigCache.has(changedFile)) {
        server.config.logger.info(`changed tsconfig file detected: ${changedFile} - Clearing cache and forcing full-reload to ensure typescript is compiled with updated config values.`, { clear: server.config.clearScreen, timestamp: true });
        tsconfigCache.clear();
        server.moduleGraph.invalidateAll();
        server.ws.send({
          type: "full-reload",
          path: "*"
        });
      }
    }
    var dist = {};
    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(dist, "__esModule", { value: true });
    var Worker_1 = dist.Worker = void 0;
    var os_1 = __importDefault(require$$0__default$1);
    var worker_threads_1 = require$$1__default$1;
    var Worker = class {
      constructor(fn2, options2 = {}) {
        this.code = genWorkerCode(fn2);
        this.max = options2.max || Math.max(1, os_1.default.cpus().length - 1);
        this.pool = [];
        this.idlePool = [];
        this.queue = [];
      }
      async run(...args) {
        const worker = await this._getAvailableWorker();
        return new Promise((resolve2, reject) => {
          worker.currentResolve = resolve2;
          worker.currentReject = reject;
          worker.postMessage(args);
        });
      }
      stop() {
        this.pool.forEach((w3) => w3.unref());
        this.queue.forEach(([_2, reject]) => reject(new Error("Main worker pool stopped before a worker was available.")));
        this.pool = [];
        this.idlePool = [];
        this.queue = [];
      }
      async _getAvailableWorker() {
        if (this.idlePool.length) {
          return this.idlePool.shift();
        }
        if (this.pool.length < this.max) {
          const worker = new worker_threads_1.Worker(this.code, { eval: true });
          worker.on("message", (res) => {
            worker.currentResolve && worker.currentResolve(res);
            worker.currentResolve = null;
            this._assignDoneWorker(worker);
          });
          worker.on("error", (err) => {
            worker.currentReject && worker.currentReject(err);
            worker.currentReject = null;
          });
          worker.on("exit", (code) => {
            const i2 = this.pool.indexOf(worker);
            if (i2 > -1)
              this.pool.splice(i2, 1);
            if (code !== 0 && worker.currentReject) {
              worker.currentReject(new Error(`Wroker stopped with non-0 exit code ${code}`));
              worker.currentReject = null;
            }
          });
          this.pool.push(worker);
          return worker;
        }
        let resolve2;
        let reject;
        const onWorkerAvailablePromise = new Promise((r2, rj) => {
          resolve2 = r2;
          reject = rj;
        });
        this.queue.push([resolve2, reject]);
        return onWorkerAvailablePromise;
      }
      _assignDoneWorker(worker) {
        if (this.queue.length) {
          const [resolve2] = this.queue.shift();
          resolve2(worker);
          return;
        }
        this.idlePool.push(worker);
      }
    };
    Worker_1 = dist.Worker = Worker;
    function genWorkerCode(fn2) {
      return `
const doWork = ${fn2.toString()}

const { parentPort } = require('worker_threads')

parentPort.on('message', async (args) => {
  const res = await doWork(...args)
  parentPort.postMessage(res)
})
  `;
    }
    function terserPlugin(config2) {
      const worker = new Worker_1((basedir, code, options2) => {
        const terserPath = __require.resolve("vite/dist/node/terser", {
          paths: [basedir]
        });
        return __require(terserPath).minify(code, options2);
      });
      return {
        name: "vite:terser",
        async renderChunk(code, _chunk, outputOptions) {
          if (config2.build.lib && outputOptions.format === "es") {
            return null;
          }
          const res = await worker.run(__dirname, code, __spreadProps2(__spreadValues2({
            safari10: true
          }, config2.build.terserOptions), {
            sourceMap: !!outputOptions.sourcemap,
            module: outputOptions.format.startsWith("es"),
            toplevel: outputOptions.format === "cjs"
          }));
          return {
            code: res.code,
            map: res.map
          };
        },
        closeBundle() {
          worker.stop();
        }
      };
    }
    function manifestPlugin(config2) {
      const manifest = {};
      let outputCount;
      return {
        name: "vite:manifest",
        buildStart() {
          outputCount = 0;
        },
        generateBundle({ format: format2 }, bundle) {
          var _a2;
          function getChunkName(chunk) {
            if (chunk.facadeModuleId) {
              let name = normalizePath$4(path__default.relative(config2.root, chunk.facadeModuleId));
              if (format2 === "system" && !chunk.name.includes("-legacy")) {
                const ext2 = path__default.extname(name);
                name = name.slice(0, -ext2.length) + `-legacy` + ext2;
              }
              return name.replace(/\0/g, "");
            } else {
              return `_` + path__default.basename(chunk.fileName);
            }
          }
          function getInternalImports(imports) {
            const filteredImports = [];
            for (const file of imports) {
              if (bundle[file] === void 0) {
                continue;
              }
              filteredImports.push(getChunkName(bundle[file]));
            }
            return filteredImports;
          }
          function createChunk(chunk) {
            const manifestChunk = {
              file: chunk.fileName
            };
            if (chunk.facadeModuleId) {
              manifestChunk.src = getChunkName(chunk);
            }
            if (chunk.isEntry) {
              manifestChunk.isEntry = true;
            }
            if (chunk.isDynamicEntry) {
              manifestChunk.isDynamicEntry = true;
            }
            if (chunk.imports.length) {
              const internalImports = getInternalImports(chunk.imports);
              if (internalImports.length > 0) {
                manifestChunk.imports = internalImports;
              }
            }
            if (chunk.dynamicImports.length) {
              const internalImports = getInternalImports(chunk.dynamicImports);
              if (internalImports.length > 0) {
                manifestChunk.dynamicImports = internalImports;
              }
            }
            const cssFiles = chunkToEmittedCssFileMap.get(chunk);
            if (cssFiles) {
              manifestChunk.css = [...cssFiles];
            }
            const assets = chunkToEmittedAssetsMap.get(chunk);
            if (assets)
              [manifestChunk.assets = [...assets]];
            return manifestChunk;
          }
          for (const file in bundle) {
            const chunk = bundle[file];
            if (chunk.type === "chunk") {
              manifest[getChunkName(chunk)] = createChunk(chunk);
            }
          }
          outputCount++;
          const output = (_a2 = config2.build.rollupOptions) === null || _a2 === void 0 ? void 0 : _a2.output;
          const outputLength = Array.isArray(output) ? output.length : 1;
          if (outputCount >= outputLength) {
            this.emitFile({
              fileName: `manifest.json`,
              type: "asset",
              source: JSON.stringify(manifest, null, 2)
            });
          }
        }
      };
    }
    function walk$2(ast, { enter, leave }) {
      return visit(ast, null, enter, leave);
    }
    var should_skip = false;
    var should_remove = false;
    var replacement = null;
    var context = {
      skip: () => should_skip = true,
      remove: () => should_remove = true,
      replace: (node2) => replacement = node2
    };
    function replace(parent, prop, index2, node2) {
      if (parent) {
        if (index2 !== null) {
          parent[prop][index2] = node2;
        } else {
          parent[prop] = node2;
        }
      }
    }
    function remove(parent, prop, index2) {
      if (parent) {
        if (index2 !== null) {
          parent[prop].splice(index2, 1);
        } else {
          delete parent[prop];
        }
      }
    }
    function visit(node2, parent, enter, leave, prop, index2) {
      if (node2) {
        if (enter) {
          const _should_skip = should_skip;
          const _should_remove = should_remove;
          const _replacement = replacement;
          should_skip = false;
          should_remove = false;
          replacement = null;
          enter.call(context, node2, parent, prop, index2);
          if (replacement) {
            node2 = replacement;
            replace(parent, prop, index2, node2);
          }
          if (should_remove) {
            remove(parent, prop, index2);
          }
          const skipped = should_skip;
          const removed = should_remove;
          should_skip = _should_skip;
          should_remove = _should_remove;
          replacement = _replacement;
          if (skipped)
            return node2;
          if (removed)
            return null;
        }
        for (const key in node2) {
          const value = node2[key];
          if (typeof value !== "object") {
            continue;
          } else if (Array.isArray(value)) {
            for (let j2 = 0, k2 = 0; j2 < value.length; j2 += 1, k2 += 1) {
              if (value[j2] !== null && typeof value[j2].type === "string") {
                if (!visit(value[j2], node2, enter, leave, key, k2)) {
                  j2--;
                }
              }
            }
          } else if (value !== null && typeof value.type === "string") {
            visit(value, node2, enter, leave, key, null);
          }
        }
        if (leave) {
          const _replacement = replacement;
          const _should_remove = should_remove;
          replacement = null;
          should_remove = false;
          leave.call(context, node2, parent, prop, index2);
          if (replacement) {
            node2 = replacement;
            replace(parent, prop, index2, node2);
          }
          if (should_remove) {
            remove(parent, prop, index2);
          }
          const removed = should_remove;
          replacement = _replacement;
          should_remove = _should_remove;
          if (removed)
            return null;
        }
      }
      return node2;
    }
    var extractors = {
      ArrayPattern(names, param) {
        for (const element of param.elements) {
          if (element)
            extractors[element.type](names, element);
        }
      },
      AssignmentPattern(names, param) {
        extractors[param.left.type](names, param.left);
      },
      Identifier(names, param) {
        names.push(param.name);
      },
      MemberExpression() {
      },
      ObjectPattern(names, param) {
        for (const prop of param.properties) {
          if (prop.type === "RestElement") {
            extractors.RestElement(names, prop);
          } else {
            extractors[prop.value.type](names, prop.value);
          }
        }
      },
      RestElement(names, param) {
        extractors[param.argument.type](names, param.argument);
      }
    };
    var extractAssignedNames = function extractAssignedNames2(param) {
      const names = [];
      extractors[param.type](names, param);
      return names;
    };
    var blockDeclarations = {
      const: true,
      let: true
    };
    var Scope$1 = class {
      constructor(options2 = {}) {
        this.parent = options2.parent;
        this.isBlockScope = !!options2.block;
        this.declarations = Object.create(null);
        if (options2.params) {
          options2.params.forEach((param) => {
            extractAssignedNames(param).forEach((name) => {
              this.declarations[name] = true;
            });
          });
        }
      }
      addDeclaration(node2, isBlockDeclaration, isVar) {
        if (!isBlockDeclaration && this.isBlockScope) {
          this.parent.addDeclaration(node2, isBlockDeclaration, isVar);
        } else if (node2.id) {
          extractAssignedNames(node2.id).forEach((name) => {
            this.declarations[name] = true;
          });
        }
      }
      contains(name) {
        return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);
      }
    };
    var attachScopes = function attachScopes2(ast, propertyName = "scope") {
      let scope = new Scope$1();
      walk$2(ast, {
        enter(n3, parent) {
          const node2 = n3;
          if (/(Function|Class)Declaration/.test(node2.type)) {
            scope.addDeclaration(node2, false, false);
          }
          if (node2.type === "VariableDeclaration") {
            const { kind } = node2;
            const isBlockDeclaration = blockDeclarations[kind];
            const parentType = parent ? parent.type : "";
            if (!(isBlockDeclaration && /ForOfStatement/.test(parentType))) {
              node2.declarations.forEach((declaration) => {
                scope.addDeclaration(declaration, isBlockDeclaration, true);
              });
            }
          }
          let newScope;
          if (/Function/.test(node2.type)) {
            const func = node2;
            newScope = new Scope$1({
              parent: scope,
              block: false,
              params: func.params
            });
            if (func.type === "FunctionExpression" && func.id) {
              newScope.addDeclaration(func, false, false);
            }
          }
          if (node2.type === "BlockStatement" && !/Function/.test(parent.type)) {
            newScope = new Scope$1({
              parent: scope,
              block: true
            });
          }
          if (node2.type === "CatchClause") {
            newScope = new Scope$1({
              parent: scope,
              params: node2.param ? [node2.param] : [],
              block: true
            });
          }
          if (newScope) {
            Object.defineProperty(node2, propertyName, {
              value: newScope,
              configurable: true
            });
            scope = newScope;
          }
        },
        leave(n3) {
          const node2 = n3;
          if (node2[propertyName])
            scope = scope.parent;
        }
      });
      return scope;
    };
    function isArray$2(arg) {
      return Array.isArray(arg);
    }
    function ensureArray(thing) {
      if (isArray$2(thing))
        return thing;
      if (thing == null)
        return [];
      return [thing];
    }
    function getMatcherString(id, resolutionBase) {
      if (resolutionBase === false) {
        return id;
      }
      const basePath = path$t.resolve(resolutionBase || "").split(path$t.sep).join("/").replace(/[-^$*+?.()|[\]{}]/g, "\\$&");
      return path$t.posix.join(basePath, id);
    }
    var createFilter = function createFilter2(include, exclude, options2) {
      const resolutionBase = options2 && options2.resolve;
      const getMatcher = (id) => id instanceof RegExp ? id : {
        test: (what) => {
          const pattern2 = getMatcherString(id, resolutionBase);
          const fn2 = picomatch$3(pattern2, { dot: true });
          const result2 = fn2(what);
          return result2;
        }
      };
      const includeMatchers = ensureArray(include).map(getMatcher);
      const excludeMatchers = ensureArray(exclude).map(getMatcher);
      return function result2(id) {
        if (typeof id !== "string")
          return false;
        if (/\0/.test(id))
          return false;
        const pathId = id.split(path$t.sep).join("/");
        for (let i2 = 0; i2 < excludeMatchers.length; ++i2) {
          const matcher2 = excludeMatchers[i2];
          if (matcher2.test(pathId))
            return false;
        }
        for (let i2 = 0; i2 < includeMatchers.length; ++i2) {
          const matcher2 = includeMatchers[i2];
          if (matcher2.test(pathId))
            return true;
        }
        return !includeMatchers.length;
      };
    };
    var reservedWords$1 = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
    var builtins = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
    var forbiddenIdentifiers = new Set(`${reservedWords$1} ${builtins}`.split(" "));
    forbiddenIdentifiers.add("");
    var makeLegalIdentifier = function makeLegalIdentifier2(str) {
      let identifier = str.replace(/-(\w)/g, (_2, letter) => letter.toUpperCase()).replace(/[^$_a-zA-Z0-9]/g, "_");
      if (/\d/.test(identifier[0]) || forbiddenIdentifiers.has(identifier)) {
        identifier = `_${identifier}`;
      }
      return identifier || "_";
    };
    var path$h = path__default;
    var commondir = function(basedir, relfiles) {
      if (relfiles) {
        var files = relfiles.map(function(r2) {
          return path$h.resolve(basedir, r2);
        });
      } else {
        var files = basedir;
      }
      var res = files.slice(1).reduce(function(ps2, file) {
        if (!file.match(/^([A-Za-z]:)?\/|\\/)) {
          throw new Error("relative path without a basedir");
        }
        var xs2 = file.split(/\/+|\\+/);
        for (var i2 = 0; ps2[i2] === xs2[i2] && i2 < Math.min(ps2.length, xs2.length); i2++)
          ;
        return ps2.slice(0, i2);
      }, files[0].split(/\/+|\\+/));
      return res.length > 1 ? res.join("/") : "/";
    };
    var old$1 = {};
    var pathModule = path__default;
    var isWindows$3 = process.platform === "win32";
    var fs$h = fs__default;
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    if (isWindows$3) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows$3) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    old$1.realpathSync = function realpathSync2(p2, cache2) {
      p2 = pathModule.resolve(p2);
      if (cache2 && Object.prototype.hasOwnProperty.call(cache2, p2)) {
        return cache2[p2];
      }
      var original = p2, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base2;
      var previous;
      start();
      function start() {
        var m3 = splitRootRe.exec(p2);
        pos = m3[0].length;
        current = m3[0];
        base2 = m3[0];
        previous = "";
        if (isWindows$3 && !knownHard[base2]) {
          fs$h.lstatSync(base2);
          knownHard[base2] = true;
        }
      }
      while (pos < p2.length) {
        nextPartRe.lastIndex = pos;
        var result2 = nextPartRe.exec(p2);
        previous = current;
        current += result2[0];
        base2 = previous + result2[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base2] || cache2 && cache2[base2] === base2) {
          continue;
        }
        var resolvedLink;
        if (cache2 && Object.prototype.hasOwnProperty.call(cache2, base2)) {
          resolvedLink = cache2[base2];
        } else {
          var stat2 = fs$h.lstatSync(base2);
          if (!stat2.isSymbolicLink()) {
            knownHard[base2] = true;
            if (cache2)
              cache2[base2] = base2;
            continue;
          }
          var linkTarget = null;
          if (!isWindows$3) {
            var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs$h.statSync(base2);
            linkTarget = fs$h.readlinkSync(base2);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache2)
            cache2[base2] = resolvedLink;
          if (!isWindows$3)
            seenLinks[id] = linkTarget;
        }
        p2 = pathModule.resolve(resolvedLink, p2.slice(pos));
        start();
      }
      if (cache2)
        cache2[original] = p2;
      return p2;
    };
    old$1.realpath = function realpath2(p2, cache2, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache2);
        cache2 = null;
      }
      p2 = pathModule.resolve(p2);
      if (cache2 && Object.prototype.hasOwnProperty.call(cache2, p2)) {
        return process.nextTick(cb.bind(null, null, cache2[p2]));
      }
      var original = p2, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base2;
      var previous;
      start();
      function start() {
        var m3 = splitRootRe.exec(p2);
        pos = m3[0].length;
        current = m3[0];
        base2 = m3[0];
        previous = "";
        if (isWindows$3 && !knownHard[base2]) {
          fs$h.lstat(base2, function(err) {
            if (err)
              return cb(err);
            knownHard[base2] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p2.length) {
          if (cache2)
            cache2[original] = p2;
          return cb(null, p2);
        }
        nextPartRe.lastIndex = pos;
        var result2 = nextPartRe.exec(p2);
        previous = current;
        current += result2[0];
        base2 = previous + result2[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base2] || cache2 && cache2[base2] === base2) {
          return process.nextTick(LOOP);
        }
        if (cache2 && Object.prototype.hasOwnProperty.call(cache2, base2)) {
          return gotResolvedLink(cache2[base2]);
        }
        return fs$h.lstat(base2, gotStat);
      }
      function gotStat(err, stat2) {
        if (err)
          return cb(err);
        if (!stat2.isSymbolicLink()) {
          knownHard[base2] = true;
          if (cache2)
            cache2[base2] = base2;
          return process.nextTick(LOOP);
        }
        if (!isWindows$3) {
          var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base2);
          }
        }
        fs$h.stat(base2, function(err2) {
          if (err2)
            return cb(err2);
          fs$h.readlink(base2, function(err3, target) {
            if (!isWindows$3)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base3) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache2)
          cache2[base3] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p2 = pathModule.resolve(resolvedLink, p2.slice(pos));
        start();
      }
    };
    var fs_realpath = realpath$2;
    realpath$2.realpath = realpath$2;
    realpath$2.sync = realpathSync;
    realpath$2.realpathSync = realpathSync;
    realpath$2.monkeypatch = monkeypatch;
    realpath$2.unmonkeypatch = unmonkeypatch;
    var fs$g = fs__default;
    var origRealpath = fs$g.realpath;
    var origRealpathSync = fs$g.realpathSync;
    var version$1 = process.version;
    var ok = /^v[0-5]\./.test(version$1);
    var old = old$1;
    function newError(er2) {
      return er2 && er2.syscall === "realpath" && (er2.code === "ELOOP" || er2.code === "ENOMEM" || er2.code === "ENAMETOOLONG");
    }
    function realpath$2(p2, cache2, cb) {
      if (ok) {
        return origRealpath(p2, cache2, cb);
      }
      if (typeof cache2 === "function") {
        cb = cache2;
        cache2 = null;
      }
      origRealpath(p2, cache2, function(er2, result2) {
        if (newError(er2)) {
          old.realpath(p2, cache2, cb);
        } else {
          cb(er2, result2);
        }
      });
    }
    function realpathSync(p2, cache2) {
      if (ok) {
        return origRealpathSync(p2, cache2);
      }
      try {
        return origRealpathSync(p2, cache2);
      } catch (er2) {
        if (newError(er2)) {
          return old.realpathSync(p2, cache2);
        } else {
          throw er2;
        }
      }
    }
    function monkeypatch() {
      fs$g.realpath = realpath$2;
      fs$g.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs$g.realpath = origRealpath;
      fs$g.realpathSync = origRealpathSync;
    }
    var concatMap$1 = function(xs2, fn2) {
      var res = [];
      for (var i2 = 0; i2 < xs2.length; i2++) {
        var x2 = fn2(xs2[i2], i2);
        if (isArray$1(x2))
          res.push.apply(res, x2);
        else
          res.push(x2);
      }
      return res;
    };
    var isArray$1 = Array.isArray || function(xs2) {
      return Object.prototype.toString.call(xs2) === "[object Array]";
    };
    var balancedMatch = balanced$1;
    function balanced$1(a2, b2, str) {
      if (a2 instanceof RegExp)
        a2 = maybeMatch(a2, str);
      if (b2 instanceof RegExp)
        b2 = maybeMatch(b2, str);
      var r2 = range(a2, b2, str);
      return r2 && {
        start: r2[0],
        end: r2[1],
        pre: str.slice(0, r2[0]),
        body: str.slice(r2[0] + a2.length, r2[1]),
        post: str.slice(r2[1] + b2.length)
      };
    }
    function maybeMatch(reg, str) {
      var m3 = str.match(reg);
      return m3 ? m3[0] : null;
    }
    balanced$1.range = range;
    function range(a2, b2, str) {
      var begs, beg, left, right, result2;
      var ai2 = str.indexOf(a2);
      var bi2 = str.indexOf(b2, ai2 + 1);
      var i2 = ai2;
      if (ai2 >= 0 && bi2 > 0) {
        if (a2 === b2) {
          return [ai2, bi2];
        }
        begs = [];
        left = str.length;
        while (i2 >= 0 && !result2) {
          if (i2 == ai2) {
            begs.push(i2);
            ai2 = str.indexOf(a2, i2 + 1);
          } else if (begs.length == 1) {
            result2 = [begs.pop(), bi2];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi2;
            }
            bi2 = str.indexOf(b2, i2 + 1);
          }
          i2 = ai2 < bi2 && ai2 >= 0 ? ai2 : bi2;
        }
        if (begs.length) {
          result2 = [left, right];
        }
      }
      return result2;
    }
    var concatMap = concatMap$1;
    var balanced = balancedMatch;
    var braceExpansion = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m3 = balanced("{", "}", str);
      if (!m3)
        return str.split(",");
      var pre = m3.pre;
      var body = m3.body;
      var post = m3.post;
      var p2 = pre.split(",");
      p2[p2.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p2[p2.length - 1] += postParts.shift();
        p2.push.apply(p2, postParts);
      }
      parts.push.apply(parts, p2);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand$1(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i2, y3) {
      return i2 <= y3;
    }
    function gte(i2, y3) {
      return i2 >= y3;
    }
    function expand$1(str, isTop) {
      var expansions = [];
      var m3 = balanced("{", "}", str);
      if (!m3 || /\$$/.test(m3.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m3.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m3.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m3.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m3.post.match(/,.*\}/)) {
          str = m3.pre + "{" + m3.body + escClose + m3.post;
          return expand$1(str);
        }
        return [str];
      }
      var n3;
      if (isSequence) {
        n3 = m3.body.split(/\.\./);
      } else {
        n3 = parseCommaParts(m3.body);
        if (n3.length === 1) {
          n3 = expand$1(n3[0], false).map(embrace);
          if (n3.length === 1) {
            var post = m3.post.length ? expand$1(m3.post, false) : [""];
            return post.map(function(p2) {
              return m3.pre + n3[0] + p2;
            });
          }
        }
      }
      var pre = m3.pre;
      var post = m3.post.length ? expand$1(m3.post, false) : [""];
      var N2;
      if (isSequence) {
        var x2 = numeric(n3[0]);
        var y3 = numeric(n3[1]);
        var width = Math.max(n3[0].length, n3[1].length);
        var incr = n3.length == 3 ? Math.abs(numeric(n3[2])) : 1;
        var test = lte;
        var reverse = y3 < x2;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad2 = n3.some(isPadded);
        N2 = [];
        for (var i2 = x2; test(i2, y3); i2 += incr) {
          var c2;
          if (isAlphaSequence) {
            c2 = String.fromCharCode(i2);
            if (c2 === "\\")
              c2 = "";
          } else {
            c2 = String(i2);
            if (pad2) {
              var need = width - c2.length;
              if (need > 0) {
                var z2 = new Array(need + 1).join("0");
                if (i2 < 0)
                  c2 = "-" + z2 + c2.slice(1);
                else
                  c2 = z2 + c2;
              }
            }
          }
          N2.push(c2);
        }
      } else {
        N2 = concatMap(n3, function(el) {
          return expand$1(el, false);
        });
      }
      for (var j2 = 0; j2 < N2.length; j2++) {
        for (var k2 = 0; k2 < post.length; k2++) {
          var expansion = pre + N2[j2] + post[k2];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
    var minimatch_1 = minimatch$3;
    minimatch$3.Minimatch = Minimatch$1;
    var path$g = { sep: "/" };
    try {
      path$g = (init_path(), path_exports);
    } catch (er2) {
    }
    var GLOBSTAR$1 = minimatch$3.GLOBSTAR = Minimatch$1.GLOBSTAR = {};
    var expand = braceExpansion;
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s2) {
      return s2.split("").reduce(function(set2, c2) {
        set2[c2] = true;
        return set2;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch$3.filter = filter;
    function filter(pattern2, options2) {
      options2 = options2 || {};
      return function(p2, i2, list2) {
        return minimatch$3(p2, pattern2, options2);
      };
    }
    function ext(a2, b2) {
      a2 = a2 || {};
      b2 = b2 || {};
      var t = {};
      Object.keys(b2).forEach(function(k2) {
        t[k2] = b2[k2];
      });
      Object.keys(a2).forEach(function(k2) {
        t[k2] = a2[k2];
      });
      return t;
    }
    minimatch$3.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch$3;
      var orig = minimatch$3;
      var m3 = function minimatch2(p2, pattern2, options2) {
        return orig.minimatch(p2, pattern2, ext(def, options2));
      };
      m3.Minimatch = function Minimatch2(pattern2, options2) {
        return new orig.Minimatch(pattern2, ext(def, options2));
      };
      return m3;
    };
    Minimatch$1.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch$1;
      return minimatch$3.defaults(def).Minimatch;
    };
    function minimatch$3(p2, pattern2, options2) {
      if (typeof pattern2 !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options2)
        options2 = {};
      if (!options2.nocomment && pattern2.charAt(0) === "#") {
        return false;
      }
      if (pattern2.trim() === "")
        return p2 === "";
      return new Minimatch$1(pattern2, options2).match(p2);
    }
    function Minimatch$1(pattern2, options2) {
      if (!(this instanceof Minimatch$1)) {
        return new Minimatch$1(pattern2, options2);
      }
      if (typeof pattern2 !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options2)
        options2 = {};
      pattern2 = pattern2.trim();
      if (path$g.sep !== "/") {
        pattern2 = pattern2.split(path$g.sep).join("/");
      }
      this.options = options2;
      this.set = [];
      this.pattern = pattern2;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch$1.prototype.debug = function() {
    };
    Minimatch$1.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern2 = this.pattern;
      var options2 = this.options;
      if (!options2.nocomment && pattern2.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern2) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set2 = this.globSet = this.braceExpand();
      if (options2.debug)
        this.debug = console.error;
      this.debug(this.pattern, set2);
      set2 = this.globParts = set2.map(function(s2) {
        return s2.split(slashSplit);
      });
      this.debug(this.pattern, set2);
      set2 = set2.map(function(s2, si2, set3) {
        return s2.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set2);
      set2 = set2.filter(function(s2) {
        return s2.indexOf(false) === -1;
      });
      this.debug(this.pattern, set2);
      this.set = set2;
    }
    Minimatch$1.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern2 = this.pattern;
      var negate = false;
      var options2 = this.options;
      var negateOffset = 0;
      if (options2.nonegate)
        return;
      for (var i2 = 0, l2 = pattern2.length; i2 < l2 && pattern2.charAt(i2) === "!"; i2++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern2.substr(negateOffset);
      this.negate = negate;
    }
    minimatch$3.braceExpand = function(pattern2, options2) {
      return braceExpand(pattern2, options2);
    };
    Minimatch$1.prototype.braceExpand = braceExpand;
    function braceExpand(pattern2, options2) {
      if (!options2) {
        if (this instanceof Minimatch$1) {
          options2 = this.options;
        } else {
          options2 = {};
        }
      }
      pattern2 = typeof pattern2 === "undefined" ? this.pattern : pattern2;
      if (typeof pattern2 === "undefined") {
        throw new TypeError("undefined pattern");
      }
      if (options2.nobrace || !pattern2.match(/\{.*\}/)) {
        return [pattern2];
      }
      return expand(pattern2);
    }
    Minimatch$1.prototype.parse = parse$d;
    var SUBPARSE = {};
    function parse$d(pattern2, isSub) {
      if (pattern2.length > 1024 * 64) {
        throw new TypeError("pattern is too long");
      }
      var options2 = this.options;
      if (!options2.noglobstar && pattern2 === "**")
        return GLOBSTAR$1;
      if (pattern2 === "")
        return "";
      var re2 = "";
      var hasMagic = !!options2.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern2.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re2 += star;
              hasMagic = true;
              break;
            case "?":
              re2 += qmark;
              hasMagic = true;
              break;
            default:
              re2 += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re2);
          stateChar = false;
        }
      }
      for (var i2 = 0, len = pattern2.length, c2; i2 < len && (c2 = pattern2.charAt(i2)); i2++) {
        this.debug("%s	%s %s %j", pattern2, i2, re2, c2);
        if (escaping && reSpecials[c2]) {
          re2 += "\\" + c2;
          escaping = false;
          continue;
        }
        switch (c2) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern2, i2, re2, c2);
            if (inClass) {
              this.debug("  in class");
              if (c2 === "!" && i2 === classStart + 1)
                c2 = "^";
              re2 += c2;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c2;
            if (options2.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re2 += "(";
              continue;
            }
            if (!stateChar) {
              re2 += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i2 - 1,
              reStart: re2.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re2 += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re2);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re2 += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re2 += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re2.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re2 += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re2 += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re2 += "\\" + c2;
              continue;
            }
            inClass = true;
            classStart = i2;
            reClassStart = re2.length;
            re2 += c2;
            continue;
          case "]":
            if (i2 === classStart + 1 || !inClass) {
              re2 += "\\" + c2;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs2 = pattern2.substring(classStart + 1, i2);
              try {
              } catch (er2) {
                var sp = this.parse(cs2, SUBPARSE);
                re2 = re2.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re2 += c2;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c2] && !(c2 === "^" && inClass)) {
              re2 += "\\";
            }
            re2 += c2;
        }
      }
      if (inClass) {
        cs2 = pattern2.substr(classStart + 1);
        sp = this.parse(cs2, SUBPARSE);
        re2 = re2.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re2.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re2, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_2, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re2);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re2 = re2.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re2 += "\\\\";
      }
      var addPatternStart = false;
      switch (re2.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n3 = negativeLists.length - 1; n3 > -1; n3--) {
        var nl = negativeLists[n3];
        var nlBefore = re2.slice(0, nl.reStart);
        var nlFirst = re2.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re2.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re2.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i2 = 0; i2 < openParensBefore; i2++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re2 = newRe;
      }
      if (re2 !== "" && hasMagic) {
        re2 = "(?=.)" + re2;
      }
      if (addPatternStart) {
        re2 = patternStart + re2;
      }
      if (isSub === SUBPARSE) {
        return [re2, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern2);
      }
      var flags = options2.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re2 + "$", flags);
      } catch (er2) {
        return new RegExp("$.");
      }
      regExp._glob = pattern2;
      regExp._src = re2;
      return regExp;
    }
    minimatch$3.makeRe = function(pattern2, options2) {
      return new Minimatch$1(pattern2, options2 || {}).makeRe();
    };
    Minimatch$1.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set2 = this.set;
      if (!set2.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options2 = this.options;
      var twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
      var flags = options2.nocase ? "i" : "";
      var re2 = set2.map(function(pattern2) {
        return pattern2.map(function(p2) {
          return p2 === GLOBSTAR$1 ? twoStar : typeof p2 === "string" ? regExpEscape(p2) : p2._src;
        }).join("\\/");
      }).join("|");
      re2 = "^(?:" + re2 + ")$";
      if (this.negate)
        re2 = "^(?!" + re2 + ").*$";
      try {
        this.regexp = new RegExp(re2, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch$3.match = function(list2, pattern2, options2) {
      options2 = options2 || {};
      var mm = new Minimatch$1(pattern2, options2);
      list2 = list2.filter(function(f2) {
        return mm.match(f2);
      });
      if (mm.options.nonull && !list2.length) {
        list2.push(pattern2);
      }
      return list2;
    };
    Minimatch$1.prototype.match = match;
    function match(f2, partial2) {
      this.debug("match", f2, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f2 === "";
      if (f2 === "/" && partial2)
        return true;
      var options2 = this.options;
      if (path$g.sep !== "/") {
        f2 = f2.split(path$g.sep).join("/");
      }
      f2 = f2.split(slashSplit);
      this.debug(this.pattern, "split", f2);
      var set2 = this.set;
      this.debug(this.pattern, "set", set2);
      var filename2;
      var i2;
      for (i2 = f2.length - 1; i2 >= 0; i2--) {
        filename2 = f2[i2];
        if (filename2)
          break;
      }
      for (i2 = 0; i2 < set2.length; i2++) {
        var pattern2 = set2[i2];
        var file = f2;
        if (options2.matchBase && pattern2.length === 1) {
          file = [filename2];
        }
        var hit = this.matchOne(file, pattern2, partial2);
        if (hit) {
          if (options2.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options2.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch$1.prototype.matchOne = function(file, pattern2, partial2) {
      var options2 = this.options;
      this.debug("matchOne", { "this": this, file, pattern: pattern2 });
      this.debug("matchOne", file.length, pattern2.length);
      for (var fi2 = 0, pi2 = 0, fl = file.length, pl = pattern2.length; fi2 < fl && pi2 < pl; fi2++, pi2++) {
        this.debug("matchOne loop");
        var p2 = pattern2[pi2];
        var f2 = file[fi2];
        this.debug(pattern2, p2, f2);
        if (p2 === false)
          return false;
        if (p2 === GLOBSTAR$1) {
          this.debug("GLOBSTAR", [pattern2, p2, f2]);
          var fr2 = fi2;
          var pr2 = pi2 + 1;
          if (pr2 === pl) {
            this.debug("** at the end");
            for (; fi2 < fl; fi2++) {
              if (file[fi2] === "." || file[fi2] === ".." || !options2.dot && file[fi2].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr2 < fl) {
            var swallowee = file[fr2];
            this.debug("\nglobstar while", file, fr2, pattern2, pr2, swallowee);
            if (this.matchOne(file.slice(fr2), pattern2.slice(pr2), partial2)) {
              this.debug("globstar found match!", fr2, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr2, pattern2, pr2);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr2++;
            }
          }
          if (partial2) {
            this.debug("\n>>> no match, partial?", file, fr2, pattern2, pr2);
            if (fr2 === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p2 === "string") {
          if (options2.nocase) {
            hit = f2.toLowerCase() === p2.toLowerCase();
          } else {
            hit = f2 === p2;
          }
          this.debug("string match", p2, f2, hit);
        } else {
          hit = f2.match(p2);
          this.debug("pattern match", p2, f2, hit);
        }
        if (!hit)
          return false;
      }
      if (fi2 === fl && pi2 === pl) {
        return true;
      } else if (fi2 === fl) {
        return partial2;
      } else if (pi2 === pl) {
        var emptyFileEnd = fi2 === fl - 1 && file[fi2] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s2) {
      return s2.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s2) {
      return s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
    var inherits$1 = { exports: {} };
    var inherits_browser = { exports: {} };
    if (typeof Object.create === "function") {
      inherits_browser.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      inherits_browser.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
    try {
      util$6 = (init_util(), util_exports);
      if (typeof util$6.inherits !== "function")
        throw "";
      inherits$1.exports = util$6.inherits;
    } catch (e2) {
      inherits$1.exports = inherits_browser.exports;
    }
    var util$6;
    var pathIsAbsolute = { exports: {} };
    function posix(path2) {
      return path2.charAt(0) === "/";
    }
    function win32(path2) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result2 = splitDeviceRe.exec(path2);
      var device = result2[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result2[2] || isUnc);
    }
    pathIsAbsolute.exports = process.platform === "win32" ? win32 : posix;
    pathIsAbsolute.exports.posix = posix;
    pathIsAbsolute.exports.win32 = win32;
    var common$6 = {};
    common$6.setopts = setopts$2;
    common$6.ownProp = ownProp$2;
    common$6.makeAbs = makeAbs;
    common$6.finish = finish;
    common$6.mark = mark;
    common$6.isIgnored = isIgnored$2;
    common$6.childrenIgnored = childrenIgnored$2;
    function ownProp$2(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs$f = fs__default;
    var path$f = path__default;
    var minimatch$2 = minimatch_1;
    var isAbsolute$2 = pathIsAbsolute.exports;
    var Minimatch = minimatch$2.Minimatch;
    function alphasort(a2, b2) {
      return a2.localeCompare(b2, "en");
    }
    function setupIgnores(self2, options2) {
      self2.ignore = options2.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern2) {
      var gmatcher = null;
      if (pattern2.slice(-3) === "/**") {
        var gpattern = pattern2.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern2, { dot: true }),
        gmatcher
      };
    }
    function setopts$2(self2, pattern2, options2) {
      if (!options2)
        options2 = {};
      if (options2.matchBase && pattern2.indexOf("/") === -1) {
        if (options2.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern2 = "**/" + pattern2;
      }
      self2.silent = !!options2.silent;
      self2.pattern = pattern2;
      self2.strict = options2.strict !== false;
      self2.realpath = !!options2.realpath;
      self2.realpathCache = options2.realpathCache || Object.create(null);
      self2.follow = !!options2.follow;
      self2.dot = !!options2.dot;
      self2.mark = !!options2.mark;
      self2.nodir = !!options2.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options2.sync;
      self2.nounique = !!options2.nounique;
      self2.nonull = !!options2.nonull;
      self2.nosort = !!options2.nosort;
      self2.nocase = !!options2.nocase;
      self2.stat = !!options2.stat;
      self2.noprocess = !!options2.noprocess;
      self2.absolute = !!options2.absolute;
      self2.fs = options2.fs || fs$f;
      self2.maxLength = options2.maxLength || Infinity;
      self2.cache = options2.cache || Object.create(null);
      self2.statCache = options2.statCache || Object.create(null);
      self2.symlinks = options2.symlinks || Object.create(null);
      setupIgnores(self2, options2);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp$2(options2, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path$f.resolve(options2.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options2.root || path$f.resolve(self2.cwd, "/");
      self2.root = path$f.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = isAbsolute$2(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      if (process.platform === "win32")
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      self2.nomount = !!options2.nomount;
      options2.nonegate = true;
      options2.nocomment = true;
      self2.minimatch = new Minimatch(pattern2, options2);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : Object.create(null);
      for (var i2 = 0, l2 = self2.matches.length; i2 < l2; i2++) {
        var matches2 = self2.matches[i2];
        if (!matches2 || Object.keys(matches2).length === 0) {
          if (self2.nonull) {
            var literal2 = self2.minimatch.globSet[i2];
            if (nou)
              all.push(literal2);
            else
              all[literal2] = true;
          }
        } else {
          var m3 = Object.keys(matches2);
          if (nou)
            all.push.apply(all, m3);
          else
            m3.forEach(function(m4) {
              all[m4] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(alphasort);
      if (self2.mark) {
        for (var i2 = 0; i2 < all.length; i2++) {
          all[i2] = self2._mark(all[i2]);
        }
        if (self2.nodir) {
          all = all.filter(function(e2) {
            var notDir = !/\/$/.test(e2);
            var c2 = self2.cache[e2] || self2.cache[makeAbs(self2, e2)];
            if (notDir && c2)
              notDir = c2 !== "DIR" && !Array.isArray(c2);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m4) {
          return !isIgnored$2(self2, m4);
        });
      self2.found = all;
    }
    function mark(self2, p2) {
      var abs = makeAbs(self2, p2);
      var c2 = self2.cache[abs];
      var m3 = p2;
      if (c2) {
        var isDir = c2 === "DIR" || Array.isArray(c2);
        var slash2 = p2.slice(-1) === "/";
        if (isDir && !slash2)
          m3 += "/";
        else if (!isDir && slash2)
          m3 = m3.slice(0, -1);
        if (m3 !== p2) {
          var mabs = makeAbs(self2, m3);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m3;
    }
    function makeAbs(self2, f2) {
      var abs = f2;
      if (f2.charAt(0) === "/") {
        abs = path$f.join(self2.root, f2);
      } else if (isAbsolute$2(f2) || f2 === "") {
        abs = f2;
      } else if (self2.changedCwd) {
        abs = path$f.resolve(self2.cwd, f2);
      } else {
        abs = path$f.resolve(f2);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored$2(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored$2(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    var sync$3 = globSync$1;
    globSync$1.GlobSync = GlobSync$1;
    var rp$1 = fs_realpath;
    var minimatch$1 = minimatch_1;
    var path$e = path__default;
    var assert$3 = require$$5__default;
    var isAbsolute$1 = pathIsAbsolute.exports;
    var common$5 = common$6;
    var setopts$1 = common$5.setopts;
    var ownProp$1 = common$5.ownProp;
    var childrenIgnored$1 = common$5.childrenIgnored;
    var isIgnored$1 = common$5.isIgnored;
    function globSync$1(pattern2, options2) {
      if (typeof options2 === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync$1(pattern2, options2).found;
    }
    function GlobSync$1(pattern2, options2) {
      if (!pattern2)
        throw new Error("must provide pattern");
      if (typeof options2 === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync$1))
        return new GlobSync$1(pattern2, options2);
      setopts$1(this, pattern2, options2);
      if (this.noprocess)
        return this;
      var n3 = this.minimatch.set.length;
      this.matches = new Array(n3);
      for (var i2 = 0; i2 < n3; i2++) {
        this._process(this.minimatch.set[i2], i2, false);
      }
      this._finish();
    }
    GlobSync$1.prototype._finish = function() {
      assert$3(this instanceof GlobSync$1);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index2) {
          var set2 = self2.matches[index2] = Object.create(null);
          for (var p2 in matchset) {
            try {
              p2 = self2._makeAbs(p2);
              var real = rp$1.realpathSync(p2, self2.realpathCache);
              set2[real] = true;
            } catch (er2) {
              if (er2.syscall === "stat")
                set2[self2._makeAbs(p2)] = true;
              else
                throw er2;
            }
          }
        });
      }
      common$5.finish(this);
    };
    GlobSync$1.prototype._process = function(pattern2, index2, inGlobStar) {
      assert$3(this instanceof GlobSync$1);
      var n3 = 0;
      while (typeof pattern2[n3] === "string") {
        n3++;
      }
      var prefix;
      switch (n3) {
        case pattern2.length:
          this._processSimple(pattern2.join("/"), index2);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern2.slice(0, n3).join("/");
          break;
      }
      var remain = pattern2.slice(n3);
      var read2;
      if (prefix === null)
        read2 = ".";
      else if (isAbsolute$1(prefix) || isAbsolute$1(pattern2.join("/"))) {
        if (!prefix || !isAbsolute$1(prefix))
          prefix = "/" + prefix;
        read2 = prefix;
      } else
        read2 = prefix;
      var abs = this._makeAbs(read2);
      if (childrenIgnored$1(this, read2))
        return;
      var isGlobStar = remain[0] === minimatch$1.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read2, abs, remain, index2, inGlobStar);
      else
        this._processReaddir(prefix, read2, abs, remain, index2, inGlobStar);
    };
    GlobSync$1.prototype._processReaddir = function(prefix, read2, abs, remain, index2, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn2 = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn2._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i2 = 0; i2 < entries.length; i2++) {
        var e2 = entries[i2];
        if (e2.charAt(0) !== "." || dotOk) {
          var m3;
          if (negate && !prefix) {
            m3 = !e2.match(pn2);
          } else {
            m3 = e2.match(pn2);
          }
          if (m3)
            matchedEntries.push(e2);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index2])
          this.matches[index2] = Object.create(null);
        for (var i2 = 0; i2 < len; i2++) {
          var e2 = matchedEntries[i2];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e2 = prefix + "/" + e2;
            else
              e2 = prefix + e2;
          }
          if (e2.charAt(0) === "/" && !this.nomount) {
            e2 = path$e.join(this.root, e2);
          }
          this._emitMatch(index2, e2);
        }
        return;
      }
      remain.shift();
      for (var i2 = 0; i2 < len; i2++) {
        var e2 = matchedEntries[i2];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e2];
        else
          newPattern = [e2];
        this._process(newPattern.concat(remain), index2, inGlobStar);
      }
    };
    GlobSync$1.prototype._emitMatch = function(index2, e2) {
      if (isIgnored$1(this, e2))
        return;
      var abs = this._makeAbs(e2);
      if (this.mark)
        e2 = this._mark(e2);
      if (this.absolute) {
        e2 = abs;
      }
      if (this.matches[index2][e2])
        return;
      if (this.nodir) {
        var c2 = this.cache[abs];
        if (c2 === "DIR" || Array.isArray(c2))
          return;
      }
      this.matches[index2][e2] = true;
      if (this.stat)
        this._stat(e2);
    };
    GlobSync$1.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat2;
      try {
        lstat2 = this.fs.lstatSync(abs);
      } catch (er2) {
        if (er2.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat2 && lstat2.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat2 && !lstat2.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync$1.prototype._readdir = function(abs, inGlobStar) {
      if (inGlobStar && !ownProp$1(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp$1(this.cache, abs)) {
        var c2 = this.cache[abs];
        if (!c2 || c2 === "FILE")
          return null;
        if (Array.isArray(c2))
          return c2;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er2) {
        this._readdirError(abs, er2);
        return null;
      }
    };
    GlobSync$1.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i2 = 0; i2 < entries.length; i2++) {
          var e2 = entries[i2];
          if (abs === "/")
            e2 = abs + e2;
          else
            e2 = abs + "/" + e2;
          this.cache[e2] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync$1.prototype._readdirError = function(f2, er2) {
      switch (er2.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f2);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error2 = new Error(er2.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd;
            error2.code = er2.code;
            throw error2;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f2)] = false;
          break;
        default:
          this.cache[this._makeAbs(f2)] = false;
          if (this.strict)
            throw er2;
          if (!this.silent)
            console.error("glob error", er2);
          break;
      }
    };
    GlobSync$1.prototype._processGlobStar = function(prefix, read2, abs, remain, index2, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index2, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i2 = 0; i2 < len; i2++) {
        var e2 = entries[i2];
        if (e2.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
        this._process(instead, index2, true);
        var below = gspref.concat(entries[i2], remain);
        this._process(below, index2, true);
      }
    };
    GlobSync$1.prototype._processSimple = function(prefix, index2) {
      var exists = this._stat(prefix);
      if (!this.matches[index2])
        this.matches[index2] = Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute$1(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path$e.join(this.root, prefix);
        } else {
          prefix = path$e.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index2, prefix);
    };
    GlobSync$1.prototype._stat = function(f2) {
      var abs = this._makeAbs(f2);
      var needDir = f2.slice(-1) === "/";
      if (f2.length > this.maxLength)
        return false;
      if (!this.stat && ownProp$1(this.cache, abs)) {
        var c2 = this.cache[abs];
        if (Array.isArray(c2))
          c2 = "DIR";
        if (!needDir || c2 === "DIR")
          return c2;
        if (needDir && c2 === "FILE")
          return false;
      }
      var stat2 = this.statCache[abs];
      if (!stat2) {
        var lstat2;
        try {
          lstat2 = this.fs.lstatSync(abs);
        } catch (er2) {
          if (er2 && (er2.code === "ENOENT" || er2.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat2 && lstat2.isSymbolicLink()) {
          try {
            stat2 = this.fs.statSync(abs);
          } catch (er2) {
            stat2 = lstat2;
          }
        } else {
          stat2 = lstat2;
        }
      }
      this.statCache[abs] = stat2;
      var c2 = true;
      if (stat2)
        c2 = stat2.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c2;
      if (needDir && c2 === "FILE")
        return false;
      return c2;
    };
    GlobSync$1.prototype._mark = function(p2) {
      return common$5.mark(this, p2);
    };
    GlobSync$1.prototype._makeAbs = function(f2) {
      return common$5.makeAbs(this, f2);
    };
    var wrappy_1 = wrappy$2;
    function wrappy$2(fn2, cb) {
      if (fn2 && cb)
        return wrappy$2(fn2)(cb);
      if (typeof fn2 !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn2).forEach(function(k2) {
        wrapper[k2] = fn2[k2];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        var ret = fn2.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k2) {
            ret[k2] = cb2[k2];
          });
        }
        return ret;
      }
    }
    var once$3 = { exports: {} };
    var wrappy$1 = wrappy_1;
    once$3.exports = wrappy$1(once$2);
    once$3.exports.strict = wrappy$1(onceStrict);
    once$2.proto = once$2(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once$2(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once$2(fn2) {
      var f2 = function() {
        if (f2.called)
          return f2.value;
        f2.called = true;
        return f2.value = fn2.apply(this, arguments);
      };
      f2.called = false;
      return f2;
    }
    function onceStrict(fn2) {
      var f2 = function() {
        if (f2.called)
          throw new Error(f2.onceError);
        f2.called = true;
        return f2.value = fn2.apply(this, arguments);
      };
      var name = fn2.name || "Function wrapped with `once`";
      f2.onceError = name + " shouldn't be called more than once";
      f2.called = false;
      return f2;
    }
    var wrappy = wrappy_1;
    var reqs = Object.create(null);
    var once$1 = once$3.exports;
    var inflight_1 = wrappy(inflight$1);
    function inflight$1(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once$1(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i2 = 0; i2 < len; i2++) {
            cbs[i2].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array2 = [];
      for (var i2 = 0; i2 < length; i2++)
        array2[i2] = args[i2];
      return array2;
    }
    var glob_1 = glob;
    var rp = fs_realpath;
    var minimatch = minimatch_1;
    var inherits = inherits$1.exports;
    var EE$1 = require$$0__default$4.EventEmitter;
    var path$d = path__default;
    var assert$2 = require$$5__default;
    var isAbsolute = pathIsAbsolute.exports;
    var globSync = sync$3;
    var common$4 = common$6;
    var setopts = common$4.setopts;
    var ownProp = common$4.ownProp;
    var inflight = inflight_1;
    var childrenIgnored = common$4.childrenIgnored;
    var isIgnored = common$4.isIgnored;
    var once = once$3.exports;
    function glob(pattern2, options2, cb) {
      if (typeof options2 === "function")
        cb = options2, options2 = {};
      if (!options2)
        options2 = {};
      if (options2.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern2, options2);
      }
      return new Glob(pattern2, options2, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i2 = keys.length;
      while (i2--) {
        origin[keys[i2]] = add[keys[i2]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern2, options_) {
      var options2 = extend({}, options_);
      options2.noprocess = true;
      var g2 = new Glob(pattern2, options2);
      var set2 = g2.minimatch.set;
      if (!pattern2)
        return false;
      if (set2.length > 1)
        return true;
      for (var j2 = 0; j2 < set2[0].length; j2++) {
        if (typeof set2[0][j2] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE$1);
    function Glob(pattern2, options2, cb) {
      if (typeof options2 === "function") {
        cb = options2;
        options2 = null;
      }
      if (options2 && options2.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern2, options2);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern2, options2, cb);
      setopts(this, pattern2, options2);
      this._didRealPath = false;
      var n3 = this.minimatch.set.length;
      this.matches = new Array(n3);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches2) {
          cb(null, matches2);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n3 === 0)
        return done();
      var sync2 = true;
      for (var i2 = 0; i2 < n3; i2++) {
        this._process(this.minimatch.set[i2], i2, false, done);
      }
      sync2 = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync2) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert$2(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common$4.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n3 = this.matches.length;
      if (n3 === 0)
        return this._finish();
      var self2 = this;
      for (var i2 = 0; i2 < this.matches.length; i2++)
        this._realpathSet(i2, next);
      function next() {
        if (--n3 === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index2, cb) {
      var matchset = this.matches[index2];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n3 = found.length;
      if (n3 === 0)
        return cb();
      var set2 = this.matches[index2] = Object.create(null);
      found.forEach(function(p2, i2) {
        p2 = self2._makeAbs(p2);
        rp.realpath(p2, self2.realpathCache, function(er2, real) {
          if (!er2)
            set2[real] = true;
          else if (er2.syscall === "stat")
            set2[p2] = true;
          else
            self2.emit("error", er2);
          if (--n3 === 0) {
            self2.matches[index2] = set2;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p2) {
      return common$4.mark(this, p2);
    };
    Glob.prototype._makeAbs = function(f2) {
      return common$4.makeAbs(this, f2);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i2 = 0; i2 < eq.length; i2++) {
            var e2 = eq[i2];
            this._emitMatch(e2[0], e2[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i2 = 0; i2 < pq.length; i2++) {
            var p2 = pq[i2];
            this._processing--;
            this._process(p2[0], p2[1], p2[2], p2[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern2, index2, inGlobStar, cb) {
      assert$2(this instanceof Glob);
      assert$2(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern2, index2, inGlobStar, cb]);
        return;
      }
      var n3 = 0;
      while (typeof pattern2[n3] === "string") {
        n3++;
      }
      var prefix;
      switch (n3) {
        case pattern2.length:
          this._processSimple(pattern2.join("/"), index2, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern2.slice(0, n3).join("/");
          break;
      }
      var remain = pattern2.slice(n3);
      var read2;
      if (prefix === null)
        read2 = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern2.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read2 = prefix;
      } else
        read2 = prefix;
      var abs = this._makeAbs(read2);
      if (childrenIgnored(this, read2))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read2, abs, remain, index2, inGlobStar, cb);
      else
        this._processReaddir(prefix, read2, abs, remain, index2, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read2, abs, remain, index2, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er2, entries) {
        return self2._processReaddir2(prefix, read2, abs, remain, index2, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read2, abs, remain, index2, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn2 = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn2._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i2 = 0; i2 < entries.length; i2++) {
        var e2 = entries[i2];
        if (e2.charAt(0) !== "." || dotOk) {
          var m3;
          if (negate && !prefix) {
            m3 = !e2.match(pn2);
          } else {
            m3 = e2.match(pn2);
          }
          if (m3)
            matchedEntries.push(e2);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index2])
          this.matches[index2] = Object.create(null);
        for (var i2 = 0; i2 < len; i2++) {
          var e2 = matchedEntries[i2];
          if (prefix) {
            if (prefix !== "/")
              e2 = prefix + "/" + e2;
            else
              e2 = prefix + e2;
          }
          if (e2.charAt(0) === "/" && !this.nomount) {
            e2 = path$d.join(this.root, e2);
          }
          this._emitMatch(index2, e2);
        }
        return cb();
      }
      remain.shift();
      for (var i2 = 0; i2 < len; i2++) {
        var e2 = matchedEntries[i2];
        if (prefix) {
          if (prefix !== "/")
            e2 = prefix + "/" + e2;
          else
            e2 = prefix + e2;
        }
        this._process([e2].concat(remain), index2, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index2, e2) {
      if (this.aborted)
        return;
      if (isIgnored(this, e2))
        return;
      if (this.paused) {
        this._emitQueue.push([index2, e2]);
        return;
      }
      var abs = isAbsolute(e2) ? e2 : this._makeAbs(e2);
      if (this.mark)
        e2 = this._mark(e2);
      if (this.absolute)
        e2 = abs;
      if (this.matches[index2][e2])
        return;
      if (this.nodir) {
        var c2 = this.cache[abs];
        if (c2 === "DIR" || Array.isArray(c2))
          return;
      }
      this.matches[index2][e2] = true;
      var st2 = this.statCache[abs];
      if (st2)
        this.emit("stat", e2, st2);
      this.emit("match", e2);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self2.fs.lstat(abs, lstatcb);
      function lstatcb_(er2, lstat2) {
        if (er2 && er2.code === "ENOENT")
          return cb();
        var isSym = lstat2 && lstat2.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat2 && !lstat2.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c2 = this.cache[abs];
        if (!c2 || c2 === "FILE")
          return cb();
        if (Array.isArray(c2))
          return cb(null, c2);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er2, entries) {
        if (er2)
          self2._readdirError(abs, er2, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i2 = 0; i2 < entries.length; i2++) {
          var e2 = entries[i2];
          if (abs === "/")
            e2 = abs + e2;
          else
            e2 = abs + "/" + e2;
          this.cache[e2] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f2, er2, cb) {
      if (this.aborted)
        return;
      switch (er2.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f2);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error2 = new Error(er2.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd;
            error2.code = er2.code;
            this.emit("error", error2);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f2)] = false;
          break;
        default:
          this.cache[this._makeAbs(f2)] = false;
          if (this.strict) {
            this.emit("error", er2);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er2);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read2, abs, remain, index2, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er2, entries) {
        self2._processGlobStar2(prefix, read2, abs, remain, index2, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read2, abs, remain, index2, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index2, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i2 = 0; i2 < len; i2++) {
        var e2 = entries[i2];
        if (e2.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
        this._process(instead, index2, true, cb);
        var below = gspref.concat(entries[i2], remain);
        this._process(below, index2, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index2, cb) {
      var self2 = this;
      this._stat(prefix, function(er2, exists) {
        self2._processSimple2(prefix, index2, er2, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index2, er2, exists, cb) {
      if (!this.matches[index2])
        this.matches[index2] = Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path$d.join(this.root, prefix);
        } else {
          prefix = path$d.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index2, prefix);
      cb();
    };
    Glob.prototype._stat = function(f2, cb) {
      var abs = this._makeAbs(f2);
      var needDir = f2.slice(-1) === "/";
      if (f2.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c2 = this.cache[abs];
        if (Array.isArray(c2))
          c2 = "DIR";
        if (!needDir || c2 === "DIR")
          return cb(null, c2);
        if (needDir && c2 === "FILE")
          return cb();
      }
      var stat2 = this.statCache[abs];
      if (stat2 !== void 0) {
        if (stat2 === false)
          return cb(null, stat2);
        else {
          var type = stat2.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat2);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self2.fs.lstat(abs, statcb);
      function lstatcb_(er2, lstat2) {
        if (lstat2 && lstat2.isSymbolicLink()) {
          return self2.fs.stat(abs, function(er3, stat3) {
            if (er3)
              self2._stat2(f2, abs, null, lstat2, cb);
            else
              self2._stat2(f2, abs, er3, stat3, cb);
          });
        } else {
          self2._stat2(f2, abs, er2, lstat2, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f2, abs, er2, stat2, cb) {
      if (er2 && (er2.code === "ENOENT" || er2.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f2.slice(-1) === "/";
      this.statCache[abs] = stat2;
      if (abs.slice(-1) === "/" && stat2 && !stat2.isDirectory())
        return cb(null, false, stat2);
      var c2 = true;
      if (stat2)
        c2 = stat2.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c2;
      if (needDir && c2 === "FILE")
        return cb();
      return cb(null, c2, stat2);
    };
    var WalkerBase = class {
      constructor() {
        this.should_skip = false;
        this.should_remove = false;
        this.replacement = null;
        this.context = {
          skip: () => this.should_skip = true,
          remove: () => this.should_remove = true,
          replace: (node2) => this.replacement = node2
        };
      }
      replace(parent, prop, index2, node2) {
        if (parent) {
          if (index2 !== null) {
            parent[prop][index2] = node2;
          } else {
            parent[prop] = node2;
          }
        }
      }
      remove(parent, prop, index2) {
        if (parent) {
          if (index2 !== null) {
            parent[prop].splice(index2, 1);
          } else {
            delete parent[prop];
          }
        }
      }
    };
    var SyncWalker = class extends WalkerBase {
      constructor(enter, leave) {
        super();
        this.enter = enter;
        this.leave = leave;
      }
      visit(node2, parent, prop, index2) {
        if (node2) {
          if (this.enter) {
            const _should_skip = this.should_skip;
            const _should_remove = this.should_remove;
            const _replacement = this.replacement;
            this.should_skip = false;
            this.should_remove = false;
            this.replacement = null;
            this.enter.call(this.context, node2, parent, prop, index2);
            if (this.replacement) {
              node2 = this.replacement;
              this.replace(parent, prop, index2, node2);
            }
            if (this.should_remove) {
              this.remove(parent, prop, index2);
            }
            const skipped = this.should_skip;
            const removed = this.should_remove;
            this.should_skip = _should_skip;
            this.should_remove = _should_remove;
            this.replacement = _replacement;
            if (skipped)
              return node2;
            if (removed)
              return null;
          }
          for (const key in node2) {
            const value = node2[key];
            if (typeof value !== "object") {
              continue;
            } else if (Array.isArray(value)) {
              for (let i2 = 0; i2 < value.length; i2 += 1) {
                if (value[i2] !== null && typeof value[i2].type === "string") {
                  if (!this.visit(value[i2], node2, key, i2)) {
                    i2--;
                  }
                }
              }
            } else if (value !== null && typeof value.type === "string") {
              this.visit(value, node2, key, null);
            }
          }
          if (this.leave) {
            const _replacement = this.replacement;
            const _should_remove = this.should_remove;
            this.replacement = null;
            this.should_remove = false;
            this.leave.call(this.context, node2, parent, prop, index2);
            if (this.replacement) {
              node2 = this.replacement;
              this.replace(parent, prop, index2, node2);
            }
            if (this.should_remove) {
              this.remove(parent, prop, index2);
            }
            const removed = this.should_remove;
            this.replacement = _replacement;
            this.should_remove = _should_remove;
            if (removed)
              return null;
          }
        }
        return node2;
      }
    };
    function walk$1(ast, { enter, leave }) {
      const instance = new SyncWalker(enter, leave);
      return instance.visit(ast, null);
    }
    function isReference(node2, parent) {
      if (node2.type === "MemberExpression") {
        return !node2.computed && isReference(node2.object, node2);
      }
      if (node2.type === "Identifier") {
        if (!parent)
          return true;
        switch (parent.type) {
          case "MemberExpression":
            return parent.computed || node2 === parent.object;
          case "MethodDefinition":
            return parent.computed;
          case "FieldDefinition":
            return parent.computed || node2 === parent.value;
          case "Property":
            return parent.computed || node2 === parent.value;
          case "ExportSpecifier":
          case "ImportSpecifier":
            return node2 === parent.local;
          case "LabeledStatement":
          case "BreakStatement":
          case "ContinueStatement":
            return false;
          default:
            return true;
        }
      }
      return false;
    }
    var peerDependencies = {
      rollup: "^2.38.3"
    };
    function tryParse(parse2, code, id) {
      try {
        return parse2(code, { allowReturnOutsideFunction: true });
      } catch (err) {
        err.message += ` in ${id}`;
        throw err;
      }
    }
    var firstpassGlobal = /\b(?:require|module|exports|global)\b/;
    var firstpassNoGlobal = /\b(?:require|module|exports)\b/;
    function hasCjsKeywords(code, ignoreGlobal) {
      const firstpass = ignoreGlobal ? firstpassNoGlobal : firstpassGlobal;
      return firstpass.test(code);
    }
    function analyzeTopLevelStatements(parse2, code, id) {
      const ast = tryParse(parse2, code, id);
      let isEsModule = false;
      let hasDefaultExport = false;
      let hasNamedExports = false;
      for (const node2 of ast.body) {
        switch (node2.type) {
          case "ExportDefaultDeclaration":
            isEsModule = true;
            hasDefaultExport = true;
            break;
          case "ExportNamedDeclaration":
            isEsModule = true;
            if (node2.declaration) {
              hasNamedExports = true;
            } else {
              for (const specifier of node2.specifiers) {
                if (specifier.exported.name === "default") {
                  hasDefaultExport = true;
                } else {
                  hasNamedExports = true;
                }
              }
            }
            break;
          case "ExportAllDeclaration":
            isEsModule = true;
            if (node2.exported && node2.exported.name === "default") {
              hasDefaultExport = true;
            } else {
              hasNamedExports = true;
            }
            break;
          case "ImportDeclaration":
            isEsModule = true;
            break;
        }
      }
      return { isEsModule, hasDefaultExport, hasNamedExports, ast };
    }
    var isWrappedId = (id, suffix) => id.endsWith(suffix);
    var wrapId = (id, suffix) => `\0${id}${suffix}`;
    var unwrapId = (wrappedId, suffix) => wrappedId.slice(1, -suffix.length);
    var PROXY_SUFFIX = "?commonjs-proxy";
    var REQUIRE_SUFFIX = "?commonjs-require";
    var EXTERNAL_SUFFIX = "?commonjs-external";
    var EXPORTS_SUFFIX = "?commonjs-exports";
    var MODULE_SUFFIX = "?commonjs-module";
    var DYNAMIC_REGISTER_SUFFIX = "?commonjs-dynamic-register";
    var DYNAMIC_JSON_PREFIX = "\0commonjs-dynamic-json:";
    var DYNAMIC_PACKAGES_ID = "\0commonjs-dynamic-packages";
    var HELPERS_ID = "\0commonjsHelpers.js";
    var HELPERS = `
export var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

export function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

export function getDefaultExportFromNamespaceIfPresent (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
}

export function getDefaultExportFromNamespaceIfNotNamed (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}

export function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}
`;
    var FAILED_REQUIRE_ERROR = `throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');`;
    var HELPER_NON_DYNAMIC = `
export function commonjsRequire (path) {
	${FAILED_REQUIRE_ERROR}
}
`;
    var getDynamicHelpers = (ignoreDynamicRequires) => `
export function createModule(modulePath) {
	return {
		path: modulePath,
		exports: {},
		require: function (path, base) {
			return commonjsRequire(path, base == null ? modulePath : base);
		}
	};
}

export function commonjsRegister (path, loader) {
	DYNAMIC_REQUIRE_LOADERS[path] = loader;
}

export function commonjsRegisterOrShort (path, to) {
	const resolvedPath = commonjsResolveImpl(path, null, true);
	if (resolvedPath !== null && DYNAMIC_REQUIRE_CACHE[resolvedPath]) {
	  DYNAMIC_REQUIRE_CACHE[path] = DYNAMIC_REQUIRE_CACHE[resolvedPath];
	} else {
	  DYNAMIC_REQUIRE_SHORTS[path] = to;
	}
}

const DYNAMIC_REQUIRE_LOADERS = Object.create(null);
const DYNAMIC_REQUIRE_CACHE = Object.create(null);
const DYNAMIC_REQUIRE_SHORTS = Object.create(null);
const DEFAULT_PARENT_MODULE = {
	id: '<' + 'rollup>', exports: {}, parent: undefined, filename: null, loaded: false, children: [], paths: []
};
const CHECKED_EXTENSIONS = ['', '.js', '.json'];

function normalize (path) {
	path = path.replace(/\\\\/g, '/');
	const parts = path.split('/');
	const slashed = parts[0] === '';
	for (let i = 1; i < parts.length; i++) {
		if (parts[i] === '.' || parts[i] === '') {
			parts.splice(i--, 1);
		}
	}
	for (let i = 1; i < parts.length; i++) {
		if (parts[i] !== '..') continue;
		if (i > 0 && parts[i - 1] !== '..' && parts[i - 1] !== '.') {
			parts.splice(--i, 2);
			i--;
		}
	}
	path = parts.join('/');
	if (slashed && path[0] !== '/')
	  path = '/' + path;
	else if (path.length === 0)
	  path = '.';
	return path;
}

function join () {
	if (arguments.length === 0)
	  return '.';
	let joined;
	for (let i = 0; i < arguments.length; ++i) {
	  let arg = arguments[i];
	  if (arg.length > 0) {
		if (joined === undefined)
		  joined = arg;
		else
		  joined += '/' + arg;
	  }
	}
	if (joined === undefined)
	  return '.';

	return joined;
}

function isPossibleNodeModulesPath (modulePath) {
	let c0 = modulePath[0];
	if (c0 === '/' || c0 === '\\\\') return false;
	let c1 = modulePath[1], c2 = modulePath[2];
	if ((c0 === '.' && (!c1 || c1 === '/' || c1 === '\\\\')) ||
		(c0 === '.' && c1 === '.' && (!c2 || c2 === '/' || c2 === '\\\\'))) return false;
	if (c1 === ':' && (c2 === '/' || c2 === '\\\\'))
		return false;
	return true;
}

function dirname (path) {
  if (path.length === 0)
    return '.';

  let i = path.length - 1;
  while (i > 0) {
    const c = path.charCodeAt(i);
    if ((c === 47 || c === 92) && i !== path.length - 1)
      break;
    i--;
  }

  if (i > 0)
    return path.substr(0, i);

  if (path.chartCodeAt(0) === 47 || path.chartCodeAt(0) === 92)
    return path.charAt(0);

  return '.';
}

export function commonjsResolveImpl (path, originalModuleDir, testCache) {
	const shouldTryNodeModules = isPossibleNodeModulesPath(path);
	path = normalize(path);
	let relPath;
	if (path[0] === '/') {
		originalModuleDir = '/';
	}
	while (true) {
		if (!shouldTryNodeModules) {
			relPath = originalModuleDir ? normalize(originalModuleDir + '/' + path) : path;
		} else if (originalModuleDir) {
			relPath = normalize(originalModuleDir + '/node_modules/' + path);
		} else {
			relPath = normalize(join('node_modules', path));
		}

		if (relPath.endsWith('/..')) {
			break; // Travelled too far up, avoid infinite loop
		}

		for (let extensionIndex = 0; extensionIndex < CHECKED_EXTENSIONS.length; extensionIndex++) {
			const resolvedPath = relPath + CHECKED_EXTENSIONS[extensionIndex];
			if (DYNAMIC_REQUIRE_CACHE[resolvedPath]) {
				return resolvedPath;
			}
			if (DYNAMIC_REQUIRE_SHORTS[resolvedPath]) {
			  return resolvedPath;
			}
			if (DYNAMIC_REQUIRE_LOADERS[resolvedPath]) {
				return resolvedPath;
			}
		}
		if (!shouldTryNodeModules) break;
		const nextDir = normalize(originalModuleDir + '/..');
		if (nextDir === originalModuleDir) break;
		originalModuleDir = nextDir;
	}
	return null;
}

export function commonjsResolve (path, originalModuleDir) {
	const resolvedPath = commonjsResolveImpl(path, originalModuleDir);
	if (resolvedPath !== null) {
		return resolvedPath;
	}
	return require.resolve(path);
}

export function commonjsRequire (path, originalModuleDir) {
	let resolvedPath = commonjsResolveImpl(path, originalModuleDir, true);
	if (resolvedPath !== null) {
    let cachedModule = DYNAMIC_REQUIRE_CACHE[resolvedPath];
    if (cachedModule) return cachedModule.exports;
    let shortTo = DYNAMIC_REQUIRE_SHORTS[resolvedPath];
    if (shortTo) {
      cachedModule = DYNAMIC_REQUIRE_CACHE[shortTo];
      if (cachedModule)
        return cachedModule.exports;
      resolvedPath = commonjsResolveImpl(shortTo, null, true);
    }
    const loader = DYNAMIC_REQUIRE_LOADERS[resolvedPath];
    if (loader) {
      DYNAMIC_REQUIRE_CACHE[resolvedPath] = cachedModule = {
        id: resolvedPath,
        filename: resolvedPath,
        path: dirname(resolvedPath),
        exports: {},
        parent: DEFAULT_PARENT_MODULE,
        loaded: false,
        children: [],
        paths: [],
        require: function (path, base) {
          return commonjsRequire(path, (base === undefined || base === null) ? cachedModule.path : base);
        }
      };
      try {
        loader.call(commonjsGlobal, cachedModule, cachedModule.exports);
      } catch (error) {
        delete DYNAMIC_REQUIRE_CACHE[resolvedPath];
        throw error;
      }
      cachedModule.loaded = true;
      return cachedModule.exports;
    };
	}
	${ignoreDynamicRequires ? "return require(path);" : FAILED_REQUIRE_ERROR}
}

commonjsRequire.cache = DYNAMIC_REQUIRE_CACHE;
commonjsRequire.resolve = commonjsResolve;
`;
    function getHelpersModule(isDynamicRequireModulesEnabled, ignoreDynamicRequires) {
      return `${HELPERS}${isDynamicRequireModulesEnabled ? getDynamicHelpers(ignoreDynamicRequires) : HELPER_NON_DYNAMIC}`;
    }
    function deconflict(scopes, globals, identifier) {
      let i2 = 1;
      let deconflicted = makeLegalIdentifier(identifier);
      const hasConflicts = () => scopes.some((scope) => scope.contains(deconflicted)) || globals.has(deconflicted);
      while (hasConflicts()) {
        deconflicted = makeLegalIdentifier(`${identifier}_${i2}`);
        i2 += 1;
      }
      for (const scope of scopes) {
        scope.declarations[deconflicted] = true;
      }
      return deconflicted;
    }
    function getName(id) {
      const name = makeLegalIdentifier(path$t.basename(id, path$t.extname(id)));
      if (name !== "index") {
        return name;
      }
      return makeLegalIdentifier(path$t.basename(path$t.dirname(id)));
    }
    function normalizePathSlashes(path2) {
      return path2.replace(/\\/g, "/");
    }
    var VIRTUAL_PATH_BASE = "/$$rollup_base$$";
    var getVirtualPathForDynamicRequirePath = (path2, commonDir) => {
      const normalizedPath = normalizePathSlashes(path2);
      return normalizedPath.startsWith(commonDir) ? VIRTUAL_PATH_BASE + normalizedPath.slice(commonDir.length) : normalizedPath;
    };
    function getPackageEntryPoint(dirPath) {
      let entryPoint = "index.js";
      try {
        if (fs$r.existsSync(path$t.join(dirPath, "package.json"))) {
          entryPoint = JSON.parse(fs$r.readFileSync(path$t.join(dirPath, "package.json"), { encoding: "utf8" })).main || entryPoint;
        }
      } catch (ignored) {
      }
      return entryPoint;
    }
    function getDynamicPackagesModule(dynamicRequireModuleDirPaths, commonDir) {
      let code = `const commonjsRegisterOrShort = require('${HELPERS_ID}?commonjsRegisterOrShort');`;
      for (const dir of dynamicRequireModuleDirPaths) {
        const entryPoint = getPackageEntryPoint(dir);
        code += `
commonjsRegisterOrShort(${JSON.stringify(getVirtualPathForDynamicRequirePath(dir, commonDir))}, ${JSON.stringify(getVirtualPathForDynamicRequirePath(path$t.join(dir, entryPoint), commonDir))});`;
      }
      return code;
    }
    function getDynamicPackagesEntryIntro(dynamicRequireModuleDirPaths, dynamicRequireModuleSet) {
      let dynamicImports = Array.from(dynamicRequireModuleSet, (dynamicId) => `require(${JSON.stringify(wrapId(dynamicId, DYNAMIC_REGISTER_SUFFIX))});`).join("\n");
      if (dynamicRequireModuleDirPaths.length) {
        dynamicImports += `require(${JSON.stringify(wrapId(DYNAMIC_PACKAGES_ID, DYNAMIC_REGISTER_SUFFIX))});`;
      }
      return dynamicImports;
    }
    function isDynamicModuleImport(id, dynamicRequireModuleSet) {
      const normalizedPath = normalizePathSlashes(id);
      return dynamicRequireModuleSet.has(normalizedPath) && !normalizedPath.endsWith(".json");
    }
    function isDirectory(path2) {
      try {
        if (fs$r.statSync(path2).isDirectory())
          return true;
      } catch (ignored) {
      }
      return false;
    }
    function getDynamicRequirePaths(patterns) {
      const dynamicRequireModuleSet = new Set();
      for (const pattern2 of !patterns || Array.isArray(patterns) ? patterns || [] : [patterns]) {
        const isNegated = pattern2.startsWith("!");
        const modifySet = Set.prototype[isNegated ? "delete" : "add"].bind(dynamicRequireModuleSet);
        for (const path2 of glob_1.sync(isNegated ? pattern2.substr(1) : pattern2)) {
          modifySet(normalizePathSlashes(path$t.resolve(path2)));
          if (isDirectory(path2)) {
            modifySet(normalizePathSlashes(path$t.resolve(path$t.join(path2, getPackageEntryPoint(path2)))));
          }
        }
      }
      const dynamicRequireModuleDirPaths = Array.from(dynamicRequireModuleSet.values()).filter((path2) => isDirectory(path2));
      return { dynamicRequireModuleSet, dynamicRequireModuleDirPaths };
    }
    function getCommonJSMetaPromise(commonJSMetaPromises, id) {
      let commonJSMetaPromise = commonJSMetaPromises.get(id);
      if (commonJSMetaPromise)
        return commonJSMetaPromise.promise;
      const promise2 = new Promise((resolve2) => {
        commonJSMetaPromise = {
          resolve: resolve2,
          promise: null
        };
        commonJSMetaPromises.set(id, commonJSMetaPromise);
      });
      commonJSMetaPromise.promise = promise2;
      return promise2;
    }
    function setCommonJSMetaPromise(commonJSMetaPromises, id, commonjsMeta) {
      const commonJSMetaPromise = commonJSMetaPromises.get(id);
      if (commonJSMetaPromise) {
        if (commonJSMetaPromise.resolve) {
          commonJSMetaPromise.resolve(commonjsMeta);
          commonJSMetaPromise.resolve = null;
        }
      } else {
        commonJSMetaPromises.set(id, { promise: Promise.resolve(commonjsMeta), resolve: null });
      }
    }
    function getSpecificHelperProxy(id) {
      return `export {${id.split("?")[1]} as default} from "${HELPERS_ID}";`;
    }
    function getUnknownRequireProxy(id, requireReturnsDefault) {
      if (requireReturnsDefault === true || id.endsWith(".json")) {
        return `export {default} from ${JSON.stringify(id)};`;
      }
      const name = getName(id);
      const exported = requireReturnsDefault === "auto" ? `import {getDefaultExportFromNamespaceIfNotNamed} from "${HELPERS_ID}"; export default /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(${name});` : requireReturnsDefault === "preferred" ? `import {getDefaultExportFromNamespaceIfPresent} from "${HELPERS_ID}"; export default /*@__PURE__*/getDefaultExportFromNamespaceIfPresent(${name});` : !requireReturnsDefault ? `import {getAugmentedNamespace} from "${HELPERS_ID}"; export default /*@__PURE__*/getAugmentedNamespace(${name});` : `export default ${name};`;
      return `import * as ${name} from ${JSON.stringify(id)}; ${exported}`;
    }
    function getDynamicJsonProxy(id, commonDir) {
      const normalizedPath = normalizePathSlashes(id.slice(DYNAMIC_JSON_PREFIX.length));
      return `const commonjsRegister = require('${HELPERS_ID}?commonjsRegister');
commonjsRegister(${JSON.stringify(getVirtualPathForDynamicRequirePath(normalizedPath, commonDir))}, function (module, exports) {
  module.exports = require(${JSON.stringify(normalizedPath)});
});`;
    }
    function getDynamicRequireProxy(normalizedPath, commonDir) {
      return `const commonjsRegister = require('${HELPERS_ID}?commonjsRegister');
commonjsRegister(${JSON.stringify(getVirtualPathForDynamicRequirePath(normalizedPath, commonDir))}, function (module, exports) {
  ${fs$r.readFileSync(normalizedPath, { encoding: "utf8" })}
});`;
    }
    async function getStaticRequireProxy(id, requireReturnsDefault, esModulesWithDefaultExport, esModulesWithNamedExports, commonJsMetaPromises) {
      const name = getName(id);
      const commonjsMeta = await getCommonJSMetaPromise(commonJsMetaPromises, id);
      if (commonjsMeta && commonjsMeta.isCommonJS) {
        return `export { __moduleExports as default } from ${JSON.stringify(id)};`;
      } else if (commonjsMeta === null) {
        return getUnknownRequireProxy(id, requireReturnsDefault);
      } else if (!requireReturnsDefault) {
        return `import { getAugmentedNamespace } from "${HELPERS_ID}"; import * as ${name} from ${JSON.stringify(id)}; export default /*@__PURE__*/getAugmentedNamespace(${name});`;
      } else if (requireReturnsDefault !== true && (requireReturnsDefault === "namespace" || !esModulesWithDefaultExport.has(id) || requireReturnsDefault === "auto" && esModulesWithNamedExports.has(id))) {
        return `import * as ${name} from ${JSON.stringify(id)}; export default ${name};`;
      }
      return `export { default } from ${JSON.stringify(id)};`;
    }
    function getCandidatesForExtension(resolved, extension2) {
      return [resolved + extension2, `${resolved}${path$t.sep}index${extension2}`];
    }
    function getCandidates(resolved, extensions2) {
      return extensions2.reduce((paths, extension2) => paths.concat(getCandidatesForExtension(resolved, extension2)), [resolved]);
    }
    function getResolveId(extensions2) {
      function resolveExtensions(importee, importer) {
        if (importee[0] !== "." || !importer)
          return void 0;
        const resolved = path$t.resolve(path$t.dirname(importer), importee);
        const candidates = getCandidates(resolved, extensions2);
        for (let i2 = 0; i2 < candidates.length; i2 += 1) {
          try {
            const stats = fs$r.statSync(candidates[i2]);
            if (stats.isFile())
              return { id: candidates[i2] };
          } catch (err) {
          }
        }
        return void 0;
      }
      return function resolveId2(importee, rawImporter, resolveOptions) {
        if (isWrappedId(importee, MODULE_SUFFIX) || isWrappedId(importee, EXPORTS_SUFFIX)) {
          return importee;
        }
        const importer = rawImporter && isWrappedId(rawImporter, DYNAMIC_REGISTER_SUFFIX) ? unwrapId(rawImporter, DYNAMIC_REGISTER_SUFFIX) : rawImporter;
        if (importer && isWrappedId(importer, PROXY_SUFFIX)) {
          return importee;
        }
        const isProxyModule = isWrappedId(importee, PROXY_SUFFIX);
        const isRequiredModule = isWrappedId(importee, REQUIRE_SUFFIX);
        let isModuleRegistration = false;
        if (isProxyModule) {
          importee = unwrapId(importee, PROXY_SUFFIX);
        } else if (isRequiredModule) {
          importee = unwrapId(importee, REQUIRE_SUFFIX);
          isModuleRegistration = isWrappedId(importee, DYNAMIC_REGISTER_SUFFIX);
          if (isModuleRegistration) {
            importee = unwrapId(importee, DYNAMIC_REGISTER_SUFFIX);
          }
        }
        if (importee.startsWith(HELPERS_ID) || importee === DYNAMIC_PACKAGES_ID || importee.startsWith(DYNAMIC_JSON_PREFIX)) {
          return importee;
        }
        if (importee.startsWith("\0")) {
          return null;
        }
        return this.resolve(importee, importer, Object.assign({}, resolveOptions, {
          skipSelf: true,
          custom: Object.assign({}, resolveOptions.custom, {
            "node-resolve": { isRequire: isProxyModule || isRequiredModule }
          })
        })).then((resolved) => {
          if (!resolved) {
            resolved = resolveExtensions(importee, importer);
          }
          if (resolved && isProxyModule) {
            resolved.id = wrapId(resolved.id, resolved.external ? EXTERNAL_SUFFIX : PROXY_SUFFIX);
            resolved.external = false;
          } else if (resolved && isModuleRegistration) {
            resolved.id = wrapId(resolved.id, DYNAMIC_REGISTER_SUFFIX);
          } else if (!resolved && (isProxyModule || isRequiredModule)) {
            return { id: wrapId(importee, EXTERNAL_SUFFIX), external: false };
          }
          return resolved;
        });
      };
    }
    function validateRollupVersion(rollupVersion, peerDependencyVersion) {
      const [major, minor] = rollupVersion.split(".").map(Number);
      const versionRegexp = /\^(\d+\.\d+)\.\d+/g;
      let minMajor = Infinity;
      let minMinor = Infinity;
      let foundVersion;
      while (foundVersion = versionRegexp.exec(peerDependencyVersion)) {
        const [foundMajor, foundMinor] = foundVersion[1].split(".").map(Number);
        if (foundMajor < minMajor) {
          minMajor = foundMajor;
          minMinor = foundMinor;
        }
      }
      if (major < minMajor || major === minMajor && minor < minMinor) {
        throw new Error(`Insufficient Rollup version: "@rollup/plugin-commonjs" requires at least rollup@${minMajor}.${minMinor} but found rollup@${rollupVersion}.`);
      }
    }
    var operators = {
      "==": (x2) => equals(x2.left, x2.right, false),
      "!=": (x2) => not(operators["=="](x2)),
      "===": (x2) => equals(x2.left, x2.right, true),
      "!==": (x2) => not(operators["==="](x2)),
      "!": (x2) => isFalsy(x2.argument),
      "&&": (x2) => isTruthy(x2.left) && isTruthy(x2.right),
      "||": (x2) => isTruthy(x2.left) || isTruthy(x2.right)
    };
    function not(value) {
      return value === null ? value : !value;
    }
    function equals(a2, b2, strict) {
      if (a2.type !== b2.type)
        return null;
      if (a2.type === "Literal")
        return strict ? a2.value === b2.value : a2.value == b2.value;
      return null;
    }
    function isTruthy(node2) {
      if (!node2)
        return false;
      if (node2.type === "Literal")
        return !!node2.value;
      if (node2.type === "ParenthesizedExpression")
        return isTruthy(node2.expression);
      if (node2.operator in operators)
        return operators[node2.operator](node2);
      return null;
    }
    function isFalsy(node2) {
      return not(isTruthy(node2));
    }
    function getKeypath(node2) {
      const parts = [];
      while (node2.type === "MemberExpression") {
        if (node2.computed)
          return null;
        parts.unshift(node2.property.name);
        node2 = node2.object;
      }
      if (node2.type !== "Identifier")
        return null;
      const { name } = node2;
      parts.unshift(name);
      return { name, keypath: parts.join(".") };
    }
    var KEY_COMPILED_ESM = "__esModule";
    function isDefineCompiledEsm(node2) {
      const definedProperty = getDefinePropertyCallName(node2, "exports") || getDefinePropertyCallName(node2, "module.exports");
      if (definedProperty && definedProperty.key === KEY_COMPILED_ESM) {
        return isTruthy(definedProperty.value);
      }
      return false;
    }
    function getDefinePropertyCallName(node2, targetName) {
      const {
        callee: { object, property }
      } = node2;
      if (!object || object.type !== "Identifier" || object.name !== "Object")
        return;
      if (!property || property.type !== "Identifier" || property.name !== "defineProperty")
        return;
      if (node2.arguments.length !== 3)
        return;
      const targetNames = targetName.split(".");
      const [target, key, value] = node2.arguments;
      if (targetNames.length === 1) {
        if (target.type !== "Identifier" || target.name !== targetNames[0]) {
          return;
        }
      }
      if (targetNames.length === 2) {
        if (target.type !== "MemberExpression" || target.object.name !== targetNames[0] || target.property.name !== targetNames[1]) {
          return;
        }
      }
      if (value.type !== "ObjectExpression" || !value.properties)
        return;
      const valueProperty = value.properties.find((p2) => p2.key && p2.key.name === "value");
      if (!valueProperty || !valueProperty.value)
        return;
      return { key: key.value, value: valueProperty.value };
    }
    function isShorthandProperty(parent) {
      return parent && parent.type === "Property" && parent.shorthand;
    }
    function hasDefineEsmProperty(node2) {
      return node2.properties.some((property) => {
        if (property.type === "Property" && property.key.type === "Identifier" && property.key.name === "__esModule" && isTruthy(property.value)) {
          return true;
        }
        return false;
      });
    }
    function wrapCode(magicString, uses, moduleName, exportsName) {
      const args = [];
      const passedArgs = [];
      if (uses.module) {
        args.push("module");
        passedArgs.push(moduleName);
      }
      if (uses.exports) {
        args.push("exports");
        passedArgs.push(exportsName);
      }
      magicString.trim().prepend(`(function (${args.join(", ")}) {
`).append(`
}(${passedArgs.join(", ")}));`);
    }
    function rewriteExportsAndGetExportsBlock(magicString, moduleName, exportsName, wrapped, moduleExportsAssignments, firstTopLevelModuleExportsAssignment, exportsAssignmentsByName, topLevelAssignments, defineCompiledEsmExpressions, deconflictedExportNames, code, HELPERS_NAME, exportMode, detectWrappedDefault, defaultIsModuleExports) {
      const exports2 = [];
      const exportDeclarations = [];
      if (exportMode === "replace") {
        getExportsForReplacedModuleExports(magicString, exports2, exportDeclarations, moduleExportsAssignments, firstTopLevelModuleExportsAssignment, exportsName);
      } else {
        exports2.push(`${exportsName} as __moduleExports`);
        if (wrapped) {
          getExportsWhenWrapping(exportDeclarations, exportsName, detectWrappedDefault, HELPERS_NAME, defaultIsModuleExports);
        } else {
          getExports(magicString, exports2, exportDeclarations, moduleExportsAssignments, exportsAssignmentsByName, deconflictedExportNames, topLevelAssignments, moduleName, exportsName, defineCompiledEsmExpressions, HELPERS_NAME, defaultIsModuleExports);
        }
      }
      if (exports2.length) {
        exportDeclarations.push(`export { ${exports2.join(", ")} };`);
      }
      return `

${exportDeclarations.join("\n")}`;
    }
    function getExportsForReplacedModuleExports(magicString, exports2, exportDeclarations, moduleExportsAssignments, firstTopLevelModuleExportsAssignment, exportsName) {
      for (const { left } of moduleExportsAssignments) {
        magicString.overwrite(left.start, left.end, exportsName);
      }
      magicString.prependRight(firstTopLevelModuleExportsAssignment.left.start, "var ");
      exports2.push(`${exportsName} as __moduleExports`);
      exportDeclarations.push(`export default ${exportsName};`);
    }
    function getExportsWhenWrapping(exportDeclarations, exportsName, detectWrappedDefault, HELPERS_NAME, defaultIsModuleExports) {
      exportDeclarations.push(`export default ${detectWrappedDefault && defaultIsModuleExports === "auto" ? `/*@__PURE__*/${HELPERS_NAME}.getDefaultExportFromCjs(${exportsName})` : defaultIsModuleExports === false ? `${exportsName}.default` : exportsName};`);
    }
    function getExports(magicString, exports2, exportDeclarations, moduleExportsAssignments, exportsAssignmentsByName, deconflictedExportNames, topLevelAssignments, moduleName, exportsName, defineCompiledEsmExpressions, HELPERS_NAME, defaultIsModuleExports) {
      let deconflictedDefaultExportName;
      for (const { left } of moduleExportsAssignments) {
        magicString.overwrite(left.start, left.end, `${moduleName}.exports`);
      }
      for (const [exportName, { nodes }] of exportsAssignmentsByName) {
        const deconflicted = deconflictedExportNames[exportName];
        let needsDeclaration = true;
        for (const node2 of nodes) {
          let replacement2 = `${deconflicted} = ${exportsName}.${exportName}`;
          if (needsDeclaration && topLevelAssignments.has(node2)) {
            replacement2 = `var ${replacement2}`;
            needsDeclaration = false;
          }
          magicString.overwrite(node2.start, node2.left.end, replacement2);
        }
        if (needsDeclaration) {
          magicString.prepend(`var ${deconflicted};
`);
        }
        if (exportName === "default") {
          deconflictedDefaultExportName = deconflicted;
        } else {
          exports2.push(exportName === deconflicted ? exportName : `${deconflicted} as ${exportName}`);
        }
      }
      let isRestorableCompiledEsm = false;
      for (const expression of defineCompiledEsmExpressions) {
        isRestorableCompiledEsm = true;
        const moduleExportsExpression = expression.type === "CallExpression" ? expression.arguments[0] : expression.left.object;
        magicString.overwrite(moduleExportsExpression.start, moduleExportsExpression.end, exportsName);
      }
      if (!isRestorableCompiledEsm || defaultIsModuleExports === true) {
        exportDeclarations.push(`export default ${exportsName};`);
      } else if (moduleExportsAssignments.length === 0 || defaultIsModuleExports === false) {
        exports2.push(`${deconflictedDefaultExportName || exportsName} as default`);
      } else {
        exportDeclarations.push(`export default /*@__PURE__*/${HELPERS_NAME}.getDefaultExportFromCjs(${exportsName});`);
      }
    }
    function isRequireStatement(node2, scope) {
      if (!node2)
        return false;
      if (node2.type !== "CallExpression")
        return false;
      if (node2.arguments.length === 0)
        return false;
      return isRequire(node2.callee, scope);
    }
    function isRequire(node2, scope) {
      return node2.type === "Identifier" && node2.name === "require" && !scope.contains("require") || node2.type === "MemberExpression" && isModuleRequire(node2, scope);
    }
    function isModuleRequire({ object, property }, scope) {
      return object.type === "Identifier" && object.name === "module" && property.type === "Identifier" && property.name === "require" && !scope.contains("module");
    }
    function isStaticRequireStatement(node2, scope) {
      if (!isRequireStatement(node2, scope))
        return false;
      return !hasDynamicArguments(node2);
    }
    function hasDynamicArguments(node2) {
      return node2.arguments.length > 1 || node2.arguments[0].type !== "Literal" && (node2.arguments[0].type !== "TemplateLiteral" || node2.arguments[0].expressions.length > 0);
    }
    var reservedMethod = { resolve: true, cache: true, main: true };
    function isNodeRequirePropertyAccess(parent) {
      return parent && parent.property && reservedMethod[parent.property.name];
    }
    function isIgnoredRequireStatement(requiredNode, ignoreRequire) {
      return ignoreRequire(requiredNode.arguments[0].value);
    }
    function getRequireStringArg(node2) {
      return node2.arguments[0].type === "Literal" ? node2.arguments[0].value : node2.arguments[0].quasis[0].value.cooked;
    }
    function hasDynamicModuleForPath(source2, id, dynamicRequireModuleSet) {
      if (!/^(?:\.{0,2}[/\\]|[A-Za-z]:[/\\])/.test(source2)) {
        try {
          const resolvedPath = normalizePathSlashes(resolve$3.sync(source2, { basedir: path$t.dirname(id) }));
          if (dynamicRequireModuleSet.has(resolvedPath)) {
            return true;
          }
        } catch (ex) {
          return false;
        }
        return false;
      }
      for (const attemptExt of ["", ".js", ".json"]) {
        const resolvedPath = normalizePathSlashes(path$t.resolve(path$t.dirname(id), source2 + attemptExt));
        if (dynamicRequireModuleSet.has(resolvedPath)) {
          return true;
        }
      }
      return false;
    }
    function getRequireHandlers() {
      const requiredSources = [];
      const requiredBySource = Object.create(null);
      const requiredByNode = new Map();
      const requireExpressionsWithUsedReturnValue = [];
      function addRequireStatement(sourceId, node2, scope, usesReturnValue) {
        const required = getRequired(sourceId);
        requiredByNode.set(node2, { scope, required });
        if (usesReturnValue) {
          required.nodesUsingRequired.push(node2);
          requireExpressionsWithUsedReturnValue.push(node2);
        }
      }
      function getRequired(sourceId) {
        if (!requiredBySource[sourceId]) {
          requiredSources.push(sourceId);
          requiredBySource[sourceId] = {
            source: sourceId,
            name: null,
            nodesUsingRequired: []
          };
        }
        return requiredBySource[sourceId];
      }
      function rewriteRequireExpressionsAndGetImportBlock(magicString, topLevelDeclarations, topLevelRequireDeclarators, reassignedNames, helpersName, dynamicRegisterSources, moduleName, exportsName, id, exportMode) {
        setRemainingImportNamesAndRewriteRequires(requireExpressionsWithUsedReturnValue, requiredByNode, magicString);
        const imports = [];
        imports.push(`import * as ${helpersName} from "${HELPERS_ID}";`);
        if (exportMode === "module") {
          imports.push(`import { __module as ${moduleName}, exports as ${exportsName} } from ${JSON.stringify(wrapId(id, MODULE_SUFFIX))}`);
        } else if (exportMode === "exports") {
          imports.push(`import { __exports as ${exportsName} } from ${JSON.stringify(wrapId(id, EXPORTS_SUFFIX))}`);
        }
        for (const source2 of dynamicRegisterSources) {
          imports.push(`import ${JSON.stringify(wrapId(source2, REQUIRE_SUFFIX))};`);
        }
        for (const source2 of requiredSources) {
          if (!source2.startsWith("\0")) {
            imports.push(`import ${JSON.stringify(wrapId(source2, REQUIRE_SUFFIX))};`);
          }
          const { name, nodesUsingRequired } = requiredBySource[source2];
          imports.push(`import ${nodesUsingRequired.length ? `${name} from ` : ""}${JSON.stringify(source2.startsWith("\0") ? source2 : wrapId(source2, PROXY_SUFFIX))};`);
        }
        return imports.length ? `${imports.join("\n")}

` : "";
      }
      return {
        addRequireStatement,
        requiredSources,
        rewriteRequireExpressionsAndGetImportBlock
      };
    }
    function setRemainingImportNamesAndRewriteRequires(requireExpressionsWithUsedReturnValue, requiredByNode, magicString) {
      let uid = 0;
      for (const requireExpression of requireExpressionsWithUsedReturnValue) {
        const { required } = requiredByNode.get(requireExpression);
        if (!required.name) {
          let potentialName;
          const isUsedName = (node2) => requiredByNode.get(node2).scope.contains(potentialName);
          do {
            potentialName = `require$$${uid}`;
            uid += 1;
          } while (required.nodesUsingRequired.some(isUsedName));
          required.name = potentialName;
        }
        magicString.overwrite(requireExpression.start, requireExpression.end, required.name);
      }
    }
    var exportsPattern = /^(?:module\.)?exports(?:\.([a-zA-Z_$][a-zA-Z_$0-9]*))?$/;
    var functionType = /^(?:FunctionDeclaration|FunctionExpression|ArrowFunctionExpression)$/;
    function transformCommonjs(parse2, code, id, isEsModule, ignoreGlobal, ignoreRequire, ignoreDynamicRequires, getIgnoreTryCatchRequireStatementMode, sourceMap, isDynamicRequireModulesEnabled, dynamicRequireModuleSet, disableWrap, commonDir, astCache, defaultIsModuleExports) {
      const ast = astCache || tryParse(parse2, code, id);
      const magicString = new MagicString(code);
      const uses = {
        module: false,
        exports: false,
        global: false,
        require: false
      };
      let usesDynamicRequire = false;
      const virtualDynamicRequirePath = isDynamicRequireModulesEnabled && getVirtualPathForDynamicRequirePath(path$t.dirname(id), commonDir);
      let scope = attachScopes(ast, "scope");
      let lexicalDepth = 0;
      let programDepth = 0;
      let currentTryBlockEnd = null;
      let shouldWrap = false;
      const globals = new Set();
      const HELPERS_NAME = deconflict([scope], globals, "commonjsHelpers");
      const dynamicRegisterSources = new Set();
      let hasRemovedRequire = false;
      const {
        addRequireStatement,
        requiredSources,
        rewriteRequireExpressionsAndGetImportBlock
      } = getRequireHandlers();
      const reassignedNames = new Set();
      const topLevelDeclarations = [];
      const topLevelRequireDeclarators = new Set();
      const skippedNodes = new Set();
      const moduleAccessScopes = new Set([scope]);
      const exportsAccessScopes = new Set([scope]);
      const moduleExportsAssignments = [];
      let firstTopLevelModuleExportsAssignment = null;
      const exportsAssignmentsByName = new Map();
      const topLevelAssignments = new Set();
      const topLevelDefineCompiledEsmExpressions = [];
      walk$1(ast, {
        enter(node2, parent) {
          if (skippedNodes.has(node2)) {
            this.skip();
            return;
          }
          if (currentTryBlockEnd !== null && node2.start > currentTryBlockEnd) {
            currentTryBlockEnd = null;
          }
          programDepth += 1;
          if (node2.scope)
            ({ scope } = node2);
          if (functionType.test(node2.type))
            lexicalDepth += 1;
          if (sourceMap) {
            magicString.addSourcemapLocation(node2.start);
            magicString.addSourcemapLocation(node2.end);
          }
          switch (node2.type) {
            case "TryStatement":
              if (currentTryBlockEnd === null) {
                currentTryBlockEnd = node2.block.end;
              }
              return;
            case "AssignmentExpression":
              if (node2.left.type === "MemberExpression") {
                const flattened = getKeypath(node2.left);
                if (!flattened || scope.contains(flattened.name))
                  return;
                const exportsPatternMatch = exportsPattern.exec(flattened.keypath);
                if (!exportsPatternMatch || flattened.keypath === "exports")
                  return;
                const [, exportName] = exportsPatternMatch;
                uses[flattened.name] = true;
                if (flattened.keypath === "module.exports") {
                  moduleExportsAssignments.push(node2);
                  if (programDepth > 3) {
                    moduleAccessScopes.add(scope);
                  } else if (!firstTopLevelModuleExportsAssignment) {
                    firstTopLevelModuleExportsAssignment = node2;
                  }
                  if (defaultIsModuleExports === false) {
                    shouldWrap = true;
                  } else if (defaultIsModuleExports === "auto") {
                    if (node2.right.type === "ObjectExpression") {
                      if (hasDefineEsmProperty(node2.right)) {
                        shouldWrap = true;
                      }
                    } else if (defaultIsModuleExports === false) {
                      shouldWrap = true;
                    }
                  }
                } else if (exportName === KEY_COMPILED_ESM) {
                  if (programDepth > 3) {
                    shouldWrap = true;
                  } else {
                    topLevelDefineCompiledEsmExpressions.push(node2);
                  }
                } else {
                  const exportsAssignments = exportsAssignmentsByName.get(exportName) || {
                    nodes: [],
                    scopes: new Set()
                  };
                  exportsAssignments.nodes.push(node2);
                  exportsAssignments.scopes.add(scope);
                  exportsAccessScopes.add(scope);
                  exportsAssignmentsByName.set(exportName, exportsAssignments);
                  if (programDepth <= 3) {
                    topLevelAssignments.add(node2);
                  }
                }
                skippedNodes.add(node2.left);
              } else {
                for (const name of extractAssignedNames(node2.left)) {
                  reassignedNames.add(name);
                }
              }
              return;
            case "CallExpression": {
              if (isDefineCompiledEsm(node2)) {
                if (programDepth === 3 && parent.type === "ExpressionStatement") {
                  skippedNodes.add(node2.arguments[0]);
                  topLevelDefineCompiledEsmExpressions.push(node2);
                } else {
                  shouldWrap = true;
                }
                return;
              }
              if (node2.callee.object && node2.callee.object.name === "require" && node2.callee.property.name === "resolve" && hasDynamicModuleForPath(id, "/", dynamicRequireModuleSet)) {
                const requireNode = node2.callee.object;
                magicString.appendLeft(node2.end - 1, `,${JSON.stringify(path$t.dirname(id) === "." ? null : virtualDynamicRequirePath)}`);
                magicString.overwrite(requireNode.start, requireNode.end, `${HELPERS_NAME}.commonjsRequire`, {
                  storeName: true
                });
                return;
              }
              if (!isStaticRequireStatement(node2, scope))
                return;
              if (!isDynamicRequireModulesEnabled) {
                skippedNodes.add(node2.callee);
              }
              if (!isIgnoredRequireStatement(node2, ignoreRequire)) {
                skippedNodes.add(node2.callee);
                const usesReturnValue = parent.type !== "ExpressionStatement";
                let canConvertRequire = true;
                let shouldRemoveRequireStatement = false;
                if (currentTryBlockEnd !== null) {
                  ({
                    canConvertRequire,
                    shouldRemoveRequireStatement
                  } = getIgnoreTryCatchRequireStatementMode(node2.arguments[0].value));
                  if (shouldRemoveRequireStatement) {
                    hasRemovedRequire = true;
                  }
                }
                let sourceId = getRequireStringArg(node2);
                const isDynamicRegister = isWrappedId(sourceId, DYNAMIC_REGISTER_SUFFIX);
                if (isDynamicRegister) {
                  sourceId = unwrapId(sourceId, DYNAMIC_REGISTER_SUFFIX);
                  if (sourceId.endsWith(".json")) {
                    sourceId = DYNAMIC_JSON_PREFIX + sourceId;
                  }
                  dynamicRegisterSources.add(wrapId(sourceId, DYNAMIC_REGISTER_SUFFIX));
                } else {
                  if (!sourceId.endsWith(".json") && hasDynamicModuleForPath(sourceId, id, dynamicRequireModuleSet)) {
                    if (shouldRemoveRequireStatement) {
                      magicString.overwrite(node2.start, node2.end, `undefined`);
                    } else if (canConvertRequire) {
                      magicString.overwrite(node2.start, node2.end, `${HELPERS_NAME}.commonjsRequire(${JSON.stringify(getVirtualPathForDynamicRequirePath(sourceId, commonDir))}, ${JSON.stringify(path$t.dirname(id) === "." ? null : virtualDynamicRequirePath)})`);
                      usesDynamicRequire = true;
                    }
                    return;
                  }
                  if (canConvertRequire) {
                    addRequireStatement(sourceId, node2, scope, usesReturnValue);
                  }
                }
                if (usesReturnValue) {
                  if (shouldRemoveRequireStatement) {
                    magicString.overwrite(node2.start, node2.end, `undefined`);
                    return;
                  }
                  if (parent.type === "VariableDeclarator" && !scope.parent && parent.id.type === "Identifier") {
                    topLevelRequireDeclarators.add(parent);
                  }
                } else {
                  if (!canConvertRequire && !shouldRemoveRequireStatement) {
                    return;
                  }
                  magicString.remove(parent.start, parent.end);
                }
              }
              return;
            }
            case "ConditionalExpression":
            case "IfStatement":
              if (isFalsy(node2.test)) {
                skippedNodes.add(node2.consequent);
              } else if (node2.alternate && isTruthy(node2.test)) {
                skippedNodes.add(node2.alternate);
              }
              return;
            case "Identifier": {
              const { name } = node2;
              if (!(isReference(node2, parent) && !scope.contains(name)))
                return;
              switch (name) {
                case "require":
                  if (isNodeRequirePropertyAccess(parent)) {
                    if (hasDynamicModuleForPath(id, "/", dynamicRequireModuleSet)) {
                      if (parent.property.name === "cache") {
                        magicString.overwrite(node2.start, node2.end, `${HELPERS_NAME}.commonjsRequire`, {
                          storeName: true
                        });
                      }
                    }
                    return;
                  }
                  if (isDynamicRequireModulesEnabled && isRequireStatement(parent, scope)) {
                    magicString.appendLeft(parent.end - 1, `,${JSON.stringify(path$t.dirname(id) === "." ? null : virtualDynamicRequirePath)}`);
                  }
                  if (!ignoreDynamicRequires) {
                    if (isShorthandProperty(parent)) {
                      magicString.appendRight(node2.end, `: ${HELPERS_NAME}.commonjsRequire`);
                    } else {
                      magicString.overwrite(node2.start, node2.end, `${HELPERS_NAME}.commonjsRequire`, {
                        storeName: true
                      });
                    }
                  }
                  usesDynamicRequire = true;
                  return;
                case "module":
                case "exports":
                  shouldWrap = true;
                  uses[name] = true;
                  return;
                case "global":
                  uses.global = true;
                  if (!ignoreGlobal) {
                    magicString.overwrite(node2.start, node2.end, `${HELPERS_NAME}.commonjsGlobal`, {
                      storeName: true
                    });
                  }
                  return;
                case "define":
                  magicString.overwrite(node2.start, node2.end, "undefined", {
                    storeName: true
                  });
                  return;
                default:
                  globals.add(name);
                  return;
              }
            }
            case "MemberExpression":
              if (!isDynamicRequireModulesEnabled && isModuleRequire(node2, scope)) {
                magicString.overwrite(node2.start, node2.end, `${HELPERS_NAME}.commonjsRequire`, {
                  storeName: true
                });
                skippedNodes.add(node2.object);
                skippedNodes.add(node2.property);
              }
              return;
            case "ReturnStatement":
              if (lexicalDepth === 0) {
                shouldWrap = true;
              }
              return;
            case "ThisExpression":
              if (lexicalDepth === 0) {
                uses.global = true;
                if (!ignoreGlobal) {
                  magicString.overwrite(node2.start, node2.end, `${HELPERS_NAME}.commonjsGlobal`, {
                    storeName: true
                  });
                }
              }
              return;
            case "UnaryExpression":
              if (node2.operator === "typeof") {
                const flattened = getKeypath(node2.argument);
                if (!flattened)
                  return;
                if (scope.contains(flattened.name))
                  return;
                if (flattened.keypath === "module.exports" || flattened.keypath === "module" || flattened.keypath === "exports") {
                  magicString.overwrite(node2.start, node2.end, `'object'`, {
                    storeName: false
                  });
                }
              }
              return;
            case "VariableDeclaration":
              if (!scope.parent) {
                topLevelDeclarations.push(node2);
              }
          }
        },
        leave(node2) {
          programDepth -= 1;
          if (node2.scope)
            scope = scope.parent;
          if (functionType.test(node2.type))
            lexicalDepth -= 1;
        }
      });
      const nameBase = getName(id);
      const exportsName = deconflict([...exportsAccessScopes], globals, nameBase);
      const moduleName = deconflict([...moduleAccessScopes], globals, `${nameBase}Module`);
      const deconflictedExportNames = Object.create(null);
      for (const [exportName, { scopes }] of exportsAssignmentsByName) {
        deconflictedExportNames[exportName] = deconflict([...scopes], globals, exportName);
      }
      shouldWrap = !isEsModule && !disableWrap && (shouldWrap || uses.exports && moduleExportsAssignments.length > 0);
      const detectWrappedDefault = shouldWrap && (topLevelDefineCompiledEsmExpressions.length > 0 || code.indexOf("__esModule") >= 0);
      if (!(requiredSources.length || dynamicRegisterSources.size || uses.module || uses.exports || uses.require || usesDynamicRequire || hasRemovedRequire || topLevelDefineCompiledEsmExpressions.length > 0) && (ignoreGlobal || !uses.global)) {
        return { meta: { commonjs: { isCommonJS: false } } };
      }
      let leadingComment = "";
      if (code.startsWith("/*")) {
        const commentEnd = code.indexOf("*/", 2) + 2;
        leadingComment = `${code.slice(0, commentEnd)}
`;
        magicString.remove(0, commentEnd).trim();
      }
      const exportMode = shouldWrap ? uses.module ? "module" : "exports" : firstTopLevelModuleExportsAssignment ? exportsAssignmentsByName.size === 0 && topLevelDefineCompiledEsmExpressions.length === 0 ? "replace" : "module" : moduleExportsAssignments.length === 0 ? "exports" : "module";
      const importBlock = rewriteRequireExpressionsAndGetImportBlock(magicString, topLevelDeclarations, topLevelRequireDeclarators, reassignedNames, HELPERS_NAME, dynamicRegisterSources, moduleName, exportsName, id, exportMode);
      const exportBlock = isEsModule ? "" : rewriteExportsAndGetExportsBlock(magicString, moduleName, exportsName, shouldWrap, moduleExportsAssignments, firstTopLevelModuleExportsAssignment, exportsAssignmentsByName, topLevelAssignments, topLevelDefineCompiledEsmExpressions, deconflictedExportNames, code, HELPERS_NAME, exportMode, detectWrappedDefault, defaultIsModuleExports);
      if (shouldWrap) {
        wrapCode(magicString, uses, moduleName, exportsName);
      }
      magicString.trim().prepend(leadingComment + importBlock).append(exportBlock);
      return {
        code: magicString.toString(),
        map: sourceMap ? magicString.generateMap() : null,
        syntheticNamedExports: isEsModule ? false : "__moduleExports",
        meta: { commonjs: { isCommonJS: !isEsModule } }
      };
    }
    function commonjs(options2 = {}) {
      const extensions2 = options2.extensions || [".js"];
      const filter2 = createFilter(options2.include, options2.exclude);
      const {
        ignoreGlobal,
        ignoreDynamicRequires,
        requireReturnsDefault: requireReturnsDefaultOption,
        esmExternals
      } = options2;
      const getRequireReturnsDefault = typeof requireReturnsDefaultOption === "function" ? requireReturnsDefaultOption : () => requireReturnsDefaultOption;
      let esmExternalIds;
      const isEsmExternal = typeof esmExternals === "function" ? esmExternals : Array.isArray(esmExternals) ? (esmExternalIds = new Set(esmExternals), (id) => esmExternalIds.has(id)) : () => esmExternals;
      const defaultIsModuleExports = typeof options2.defaultIsModuleExports === "boolean" ? options2.defaultIsModuleExports : "auto";
      const { dynamicRequireModuleSet, dynamicRequireModuleDirPaths } = getDynamicRequirePaths(options2.dynamicRequireTargets);
      const isDynamicRequireModulesEnabled = dynamicRequireModuleSet.size > 0;
      const commonDir = isDynamicRequireModulesEnabled ? commondir(null, Array.from(dynamicRequireModuleSet).concat(process.cwd())) : null;
      const esModulesWithDefaultExport = new Set();
      const esModulesWithNamedExports = new Set();
      const commonJsMetaPromises = new Map();
      const ignoreRequire = typeof options2.ignore === "function" ? options2.ignore : Array.isArray(options2.ignore) ? (id) => options2.ignore.includes(id) : () => false;
      const getIgnoreTryCatchRequireStatementMode = (id) => {
        const mode2 = typeof options2.ignoreTryCatch === "function" ? options2.ignoreTryCatch(id) : Array.isArray(options2.ignoreTryCatch) ? options2.ignoreTryCatch.includes(id) : typeof options2.ignoreTryCatch !== "undefined" ? options2.ignoreTryCatch : true;
        return {
          canConvertRequire: mode2 !== "remove" && mode2 !== true,
          shouldRemoveRequireStatement: mode2 === "remove"
        };
      };
      const resolveId2 = getResolveId(extensions2);
      const sourceMap = options2.sourceMap !== false;
      function transformAndCheckExports(code, id) {
        if (isDynamicRequireModulesEnabled && this.getModuleInfo(id).isEntry) {
          code = getDynamicPackagesEntryIntro(dynamicRequireModuleDirPaths, dynamicRequireModuleSet) + code;
        }
        const { isEsModule, hasDefaultExport, hasNamedExports, ast } = analyzeTopLevelStatements(this.parse, code, id);
        if (hasDefaultExport) {
          esModulesWithDefaultExport.add(id);
        }
        if (hasNamedExports) {
          esModulesWithNamedExports.add(id);
        }
        if (!dynamicRequireModuleSet.has(normalizePathSlashes(id)) && (!hasCjsKeywords(code, ignoreGlobal) || isEsModule && !options2.transformMixedEsModules)) {
          return { meta: { commonjs: { isCommonJS: false } } };
        }
        const disableWrap = isWrappedId(id, DYNAMIC_REGISTER_SUFFIX);
        if (disableWrap) {
          id = unwrapId(id, DYNAMIC_REGISTER_SUFFIX);
        }
        return transformCommonjs(this.parse, code, id, isEsModule, ignoreGlobal || isEsModule, ignoreRequire, ignoreDynamicRequires && !isDynamicRequireModulesEnabled, getIgnoreTryCatchRequireStatementMode, sourceMap, isDynamicRequireModulesEnabled, dynamicRequireModuleSet, disableWrap, commonDir, ast, defaultIsModuleExports);
      }
      return {
        name: "commonjs",
        buildStart() {
          validateRollupVersion(this.meta.rollupVersion, peerDependencies.rollup);
          if (options2.namedExports != null) {
            this.warn('The namedExports option from "@rollup/plugin-commonjs" is deprecated. Named exports are now handled automatically.');
          }
        },
        resolveId: resolveId2,
        load(id) {
          if (id === HELPERS_ID) {
            return getHelpersModule(isDynamicRequireModulesEnabled, ignoreDynamicRequires);
          }
          if (id.startsWith(HELPERS_ID)) {
            return getSpecificHelperProxy(id);
          }
          if (isWrappedId(id, MODULE_SUFFIX)) {
            const actualId = unwrapId(id, MODULE_SUFFIX);
            let name = getName(actualId);
            let code;
            if (isDynamicRequireModulesEnabled) {
              if (["modulePath", "commonjsRequire", "createModule"].includes(name)) {
                name = `${name}_`;
              }
              code = `import {commonjsRequire, createModule} from "${HELPERS_ID}";
var ${name} = createModule(${JSON.stringify(getVirtualPathForDynamicRequirePath(path$t.dirname(actualId), commonDir))});
export {${name} as __module}`;
            } else {
              code = `var ${name} = {exports: {}}; export {${name} as __module}`;
            }
            return {
              code,
              syntheticNamedExports: "__module",
              meta: { commonjs: { isCommonJS: false } }
            };
          }
          if (isWrappedId(id, EXPORTS_SUFFIX)) {
            const actualId = unwrapId(id, EXPORTS_SUFFIX);
            const name = getName(actualId);
            return {
              code: `var ${name} = {}; export {${name} as __exports}`,
              meta: { commonjs: { isCommonJS: false } }
            };
          }
          if (isWrappedId(id, EXTERNAL_SUFFIX)) {
            const actualId = unwrapId(id, EXTERNAL_SUFFIX);
            return getUnknownRequireProxy(actualId, isEsmExternal(actualId) ? getRequireReturnsDefault(actualId) : true);
          }
          if (id === DYNAMIC_PACKAGES_ID) {
            return getDynamicPackagesModule(dynamicRequireModuleDirPaths, commonDir);
          }
          if (id.startsWith(DYNAMIC_JSON_PREFIX)) {
            return getDynamicJsonProxy(id, commonDir);
          }
          if (isDynamicModuleImport(id, dynamicRequireModuleSet)) {
            return `export default require(${JSON.stringify(normalizePathSlashes(id))});`;
          }
          if (isWrappedId(id, DYNAMIC_REGISTER_SUFFIX)) {
            return getDynamicRequireProxy(normalizePathSlashes(unwrapId(id, DYNAMIC_REGISTER_SUFFIX)), commonDir);
          }
          if (isWrappedId(id, PROXY_SUFFIX)) {
            const actualId = unwrapId(id, PROXY_SUFFIX);
            return getStaticRequireProxy(actualId, getRequireReturnsDefault(actualId), esModulesWithDefaultExport, esModulesWithNamedExports, commonJsMetaPromises);
          }
          return null;
        },
        transform(code, rawId) {
          let id = rawId;
          if (isWrappedId(id, DYNAMIC_REGISTER_SUFFIX)) {
            id = unwrapId(id, DYNAMIC_REGISTER_SUFFIX);
          }
          const extName = path$t.extname(id);
          if (extName !== ".cjs" && id !== DYNAMIC_PACKAGES_ID && !id.startsWith(DYNAMIC_JSON_PREFIX) && (!filter2(id) || !extensions2.includes(extName))) {
            return null;
          }
          try {
            return transformAndCheckExports.call(this, code, rawId);
          } catch (err) {
            return this.error(err, err.loc);
          }
        },
        moduleParsed({ id, meta: { commonjs: commonjsMeta } }) {
          if (commonjsMeta && commonjsMeta.isCommonJS != null) {
            setCommonJSMetaPromise(commonJsMetaPromises, id, commonjsMeta);
            return;
          }
          setCommonJSMetaPromise(commonJsMetaPromises, id, null);
        }
      };
    }
    var globby$1 = { exports: {} };
    var arrayUnion$1 = (...arguments_) => {
      return [...new Set([].concat(...arguments_))];
    };
    var dirGlob$1 = { exports: {} };
    var pathType$1 = {};
    var { promisify: promisify$6 } = require$$0__default$2;
    var fs$e = fs__default;
    async function isType(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        const stats = await promisify$6(fs$e[fsStatType])(filePath);
        return stats[statsMethodName]();
      } catch (error2) {
        if (error2.code === "ENOENT") {
          return false;
        }
        throw error2;
      }
    }
    function isTypeSync(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        return fs$e[fsStatType](filePath)[statsMethodName]();
      } catch (error2) {
        if (error2.code === "ENOENT") {
          return false;
        }
        throw error2;
      }
    }
    pathType$1.isFile = isType.bind(null, "stat", "isFile");
    pathType$1.isDirectory = isType.bind(null, "stat", "isDirectory");
    pathType$1.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
    pathType$1.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
    pathType$1.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
    pathType$1.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
    var path$c = path__default;
    var pathType = pathType$1;
    var getExtensions = (extensions2) => extensions2.length > 1 ? `{${extensions2.join(",")}}` : extensions2[0];
    var getPath = (filepath, cwd) => {
      const pth = filepath[0] === "!" ? filepath.slice(1) : filepath;
      return path$c.isAbsolute(pth) ? pth : path$c.join(cwd, pth);
    };
    var addExtensions = (file, extensions2) => {
      if (path$c.extname(file)) {
        return `**/${file}`;
      }
      return `**/${file}.${getExtensions(extensions2)}`;
    };
    var getGlob = (directory, options2) => {
      if (options2.files && !Array.isArray(options2.files)) {
        throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options2.files}\``);
      }
      if (options2.extensions && !Array.isArray(options2.extensions)) {
        throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options2.extensions}\``);
      }
      if (options2.files && options2.extensions) {
        return options2.files.map((x2) => path$c.posix.join(directory, addExtensions(x2, options2.extensions)));
      }
      if (options2.files) {
        return options2.files.map((x2) => path$c.posix.join(directory, `**/${x2}`));
      }
      if (options2.extensions) {
        return [path$c.posix.join(directory, `**/*.${getExtensions(options2.extensions)}`)];
      }
      return [path$c.posix.join(directory, "**")];
    };
    dirGlob$1.exports = async (input, options2) => {
      options2 = __spreadValues2({
        cwd: process.cwd()
      }, options2);
      if (typeof options2.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options2.cwd}\``);
      }
      const globs = await Promise.all([].concat(input).map(async (x2) => {
        const isDirectory2 = await pathType.isDirectory(getPath(x2, options2.cwd));
        return isDirectory2 ? getGlob(x2, options2) : x2;
      }));
      return [].concat.apply([], globs);
    };
    dirGlob$1.exports.sync = (input, options2) => {
      options2 = __spreadValues2({
        cwd: process.cwd()
      }, options2);
      if (typeof options2.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options2.cwd}\``);
      }
      const globs = [].concat(input).map((x2) => pathType.isDirectorySync(getPath(x2, options2.cwd)) ? getGlob(x2, options2) : x2);
      return [].concat.apply([], globs);
    };
    var gitignore$1 = { exports: {} };
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH$1 = "/";
    var KEY_IGNORE = typeof Symbol !== "undefined" ? Symbol.for("node-ignore") : "node-ignore";
    var define = (object, key, value) => Object.defineProperty(object, key, { value });
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var sanitizeRange = (range2) => range2.replace(REGEX_REGEXP_RANGE, (match2, from, to2) => from.charCodeAt(0) <= to2.charCodeAt(0) ? match2 : EMPTY);
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      [
        /\\?\s+$/,
        (match2) => match2.indexOf("\\") === 0 ? SPACE : EMPTY
      ],
      [
        /\\\s/g,
        () => SPACE
      ],
      [
        /[\\$.|*+(){^]/g,
        (match2) => `\\${match2}`
      ],
      [
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      [
        /^\//,
        () => "^"
      ],
      [
        /\//g,
        () => "\\/"
      ],
      [
        /^\^*\\\*\\\*\\\//,
        () => "^(?:.*\\/)?"
      ],
      [
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      [
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        (_2, index2, str) => index2 + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      [
        /(^|[^\\]+)\\\*(?=.+)/g,
        (_2, p1) => `${p1}[^\\/]*`
      ],
      [
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        /\\\\/g,
        () => ESCAPE
      ],
      [
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match2, leadEscape, range2, endEscape, close2) => leadEscape === ESCAPE ? `\\[${range2}${cleanRangeBackSlash(endEscape)}${close2}` : close2 === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range2)}${endEscape}]` : "[]" : "[]"
      ],
      [
        /(?:[^*])$/,
        (match2) => /\/$/.test(match2) ? `${match2}$` : `${match2}(?=$|\\/$)`
      ],
      [
        /(\^|\\\/)?\\\*$/,
        (_2, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = Object.create(null);
    var makeRegex = (pattern2, ignorecase) => {
      let source2 = regexCache[pattern2];
      if (!source2) {
        source2 = REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern2)), pattern2);
        regexCache[pattern2] = source2;
      }
      return ignorecase ? new RegExp(source2, "i") : new RegExp(source2);
    };
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern2) => pattern2 && isString(pattern2) && !REGEX_TEST_BLANK_LINE.test(pattern2) && pattern2.indexOf("#") !== 0;
    var splitPattern = (pattern2) => pattern2.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern2, negative, regex) {
        this.origin = origin;
        this.pattern = pattern2;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern2, ignorecase) => {
      const origin = pattern2;
      let negative = false;
      if (pattern2.indexOf("!") === 0) {
        negative = true;
        pattern2 = pattern2.substr(1);
      }
      pattern2 = pattern2.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern2, ignorecase);
      return new IgnoreRule(origin, pattern2, negative, regex);
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path2, originalPath, doThrow) => {
      if (!isString(path2)) {
        return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
      }
      if (!path2) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path2)) {
        const r2 = "`path.relative()`d";
        return doThrow(`path should be a ${r2} string, but got "${originalPath}"`, RangeError);
      }
      return true;
    };
    var isNotRelative = (path2) => REGEX_TEST_INVALID_PATH.test(path2);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p2) => p2;
    var Ignore = class {
      constructor({
        ignorecase = true
      } = {}) {
        define(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignorecase = ignorecase;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = Object.create(null);
        this._testCache = Object.create(null);
      }
      _addPattern(pattern2) {
        if (pattern2 && pattern2[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern2._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern2)) {
          const rule = createRule(pattern2, this._ignorecase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      add(pattern2) {
        this._added = false;
        makeArray(isString(pattern2) ? splitPattern(pattern2) : pattern2).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      addPattern(pattern2) {
        return this.add(pattern2);
      }
      _testOne(path2, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path2);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      _test(originalPath, cache2, checkUnignored, slices) {
        const path2 = originalPath && checkPath.convert(originalPath);
        checkPath(path2, originalPath, throwError);
        return this._t(path2, cache2, checkUnignored, slices);
      }
      _t(path2, cache2, checkUnignored, slices) {
        if (path2 in cache2) {
          return cache2[path2];
        }
        if (!slices) {
          slices = path2.split(SLASH$1);
        }
        slices.pop();
        if (!slices.length) {
          return cache2[path2] = this._testOne(path2, checkUnignored);
        }
        const parent = this._t(slices.join(SLASH$1) + SLASH$1, cache2, checkUnignored, slices);
        return cache2[path2] = parent.ignored ? parent : this._testOne(path2, checkUnignored);
      }
      ignores(path2) {
        return this._test(path2, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path2) => !this.ignores(path2);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      test(path2) {
        return this._test(path2, this._testCache, true);
      }
    };
    var factory = (options2) => new Ignore(options2);
    var returnFalse = () => false;
    var isPathValid = (path2) => checkPath(path2 && checkPath.convert(path2), path2, returnFalse);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    var ignore = factory;
    if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path2) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path2) || isNotRelative(path2);
    }
    var slash$1 = (path2) => {
      const isExtendedLengthPath = /^\\\\\?\\/.test(path2);
      const hasNonAscii = /[^\u0000-\u0080]+/.test(path2);
      if (isExtendedLengthPath || hasNonAscii) {
        return path2;
      }
      return path2.replace(/\\/g, "/");
    };
    var { promisify: promisify$5 } = require$$0__default$2;
    var fs$d = fs__default;
    var path$b = path__default;
    var fastGlob$1 = out;
    var gitIgnore = ignore;
    var slash = slash$1;
    var DEFAULT_IGNORE = [
      "**/node_modules/**",
      "**/flow-typed/**",
      "**/coverage/**",
      "**/.git"
    ];
    var readFileP = promisify$5(fs$d.readFile);
    var mapGitIgnorePatternTo = (base2) => (ignore2) => {
      if (ignore2.startsWith("!")) {
        return "!" + path$b.posix.join(base2, ignore2.slice(1));
      }
      return path$b.posix.join(base2, ignore2);
    };
    var parseGitIgnore = (content2, options2) => {
      const base2 = slash(path$b.relative(options2.cwd, path$b.dirname(options2.fileName)));
      return content2.split(/\r?\n/).filter(Boolean).filter((line) => !line.startsWith("#")).map(mapGitIgnorePatternTo(base2));
    };
    var reduceIgnore = (files) => {
      const ignores = gitIgnore();
      for (const file of files) {
        ignores.add(parseGitIgnore(file.content, {
          cwd: file.cwd,
          fileName: file.filePath
        }));
      }
      return ignores;
    };
    var ensureAbsolutePathForCwd = (cwd, p2) => {
      cwd = slash(cwd);
      if (path$b.isAbsolute(p2)) {
        if (slash(p2).startsWith(cwd)) {
          return p2;
        }
        throw new Error(`Path ${p2} is not in cwd ${cwd}`);
      }
      return path$b.join(cwd, p2);
    };
    var getIsIgnoredPredecate = (ignores, cwd) => {
      return (p2) => ignores.ignores(slash(path$b.relative(cwd, ensureAbsolutePathForCwd(cwd, p2.path || p2))));
    };
    var getFile = async (file, cwd) => {
      const filePath = path$b.join(cwd, file);
      const content2 = await readFileP(filePath, "utf8");
      return {
        cwd,
        filePath,
        content: content2
      };
    };
    var getFileSync = (file, cwd) => {
      const filePath = path$b.join(cwd, file);
      const content2 = fs$d.readFileSync(filePath, "utf8");
      return {
        cwd,
        filePath,
        content: content2
      };
    };
    var normalizeOptions = ({
      ignore: ignore2 = [],
      cwd = slash(process.cwd())
    } = {}) => {
      return { ignore: ignore2, cwd };
    };
    gitignore$1.exports = async (options2) => {
      options2 = normalizeOptions(options2);
      const paths = await fastGlob$1("**/.gitignore", {
        ignore: DEFAULT_IGNORE.concat(options2.ignore),
        cwd: options2.cwd
      });
      const files = await Promise.all(paths.map((file) => getFile(file, options2.cwd)));
      const ignores = reduceIgnore(files);
      return getIsIgnoredPredecate(ignores, options2.cwd);
    };
    gitignore$1.exports.sync = (options2) => {
      options2 = normalizeOptions(options2);
      const paths = fastGlob$1.sync("**/.gitignore", {
        ignore: DEFAULT_IGNORE.concat(options2.ignore),
        cwd: options2.cwd
      });
      const files = paths.map((file) => getFileSync(file, options2.cwd));
      const ignores = reduceIgnore(files);
      return getIsIgnoredPredecate(ignores, options2.cwd);
    };
    var { Transform } = require$$0__default$3;
    var ObjectTransform = class extends Transform {
      constructor() {
        super({
          objectMode: true
        });
      }
    };
    var FilterStream$1 = class extends ObjectTransform {
      constructor(filter2) {
        super();
        this._filter = filter2;
      }
      _transform(data2, encoding2, callback) {
        if (this._filter(data2)) {
          this.push(data2);
        }
        callback();
      }
    };
    var UniqueStream$1 = class extends ObjectTransform {
      constructor() {
        super();
        this._pushed = new Set();
      }
      _transform(data2, encoding2, callback) {
        if (!this._pushed.has(data2)) {
          this.push(data2);
          this._pushed.add(data2);
        }
        callback();
      }
    };
    var streamUtils = {
      FilterStream: FilterStream$1,
      UniqueStream: UniqueStream$1
    };
    var fs$c = fs__default;
    var arrayUnion = arrayUnion$1;
    var merge2 = merge2_1;
    var fastGlob = out;
    var dirGlob = dirGlob$1.exports;
    var gitignore = gitignore$1.exports;
    var { FilterStream, UniqueStream } = streamUtils;
    var DEFAULT_FILTER = () => false;
    var isNegative = (pattern2) => pattern2[0] === "!";
    var assertPatternsInput = (patterns) => {
      if (!patterns.every((pattern2) => typeof pattern2 === "string")) {
        throw new TypeError("Patterns must be a string or an array of strings");
      }
    };
    var checkCwdOption = (options2 = {}) => {
      if (!options2.cwd) {
        return;
      }
      let stat2;
      try {
        stat2 = fs$c.statSync(options2.cwd);
      } catch {
        return;
      }
      if (!stat2.isDirectory()) {
        throw new Error("The `cwd` option must be a path to a directory");
      }
    };
    var getPathString = (p2) => p2.stats instanceof fs$c.Stats ? p2.path : p2;
    var generateGlobTasks = (patterns, taskOptions) => {
      patterns = arrayUnion([].concat(patterns));
      assertPatternsInput(patterns);
      checkCwdOption(taskOptions);
      const globTasks = [];
      taskOptions = __spreadValues2({
        ignore: [],
        expandDirectories: true
      }, taskOptions);
      for (const [index2, pattern2] of patterns.entries()) {
        if (isNegative(pattern2)) {
          continue;
        }
        const ignore2 = patterns.slice(index2).filter((pattern3) => isNegative(pattern3)).map((pattern3) => pattern3.slice(1));
        const options2 = __spreadProps2(__spreadValues2({}, taskOptions), {
          ignore: taskOptions.ignore.concat(ignore2)
        });
        globTasks.push({ pattern: pattern2, options: options2 });
      }
      return globTasks;
    };
    var globDirs = (task, fn2) => {
      let options2 = {};
      if (task.options.cwd) {
        options2.cwd = task.options.cwd;
      }
      if (Array.isArray(task.options.expandDirectories)) {
        options2 = __spreadProps2(__spreadValues2({}, options2), {
          files: task.options.expandDirectories
        });
      } else if (typeof task.options.expandDirectories === "object") {
        options2 = __spreadValues2(__spreadValues2({}, options2), task.options.expandDirectories);
      }
      return fn2(task.pattern, options2);
    };
    var getPattern = (task, fn2) => task.options.expandDirectories ? globDirs(task, fn2) : [task.pattern];
    var getFilterSync = (options2) => {
      return options2 && options2.gitignore ? gitignore.sync({ cwd: options2.cwd, ignore: options2.ignore }) : DEFAULT_FILTER;
    };
    var globToTask = (task) => (glob2) => {
      const { options: options2 } = task;
      if (options2.ignore && Array.isArray(options2.ignore) && options2.expandDirectories) {
        options2.ignore = dirGlob.sync(options2.ignore);
      }
      return {
        pattern: glob2,
        options: options2
      };
    };
    globby$1.exports = async (patterns, options2) => {
      const globTasks = generateGlobTasks(patterns, options2);
      const getFilter = async () => {
        return options2 && options2.gitignore ? gitignore({ cwd: options2.cwd, ignore: options2.ignore }) : DEFAULT_FILTER;
      };
      const getTasks = async () => {
        const tasks3 = await Promise.all(globTasks.map(async (task) => {
          const globs = await getPattern(task, dirGlob);
          return Promise.all(globs.map(globToTask(task)));
        }));
        return arrayUnion(...tasks3);
      };
      const [filter2, tasks2] = await Promise.all([getFilter(), getTasks()]);
      const paths = await Promise.all(tasks2.map((task) => fastGlob(task.pattern, task.options)));
      return arrayUnion(...paths).filter((path_) => !filter2(getPathString(path_)));
    };
    globby$1.exports.sync = (patterns, options2) => {
      const globTasks = generateGlobTasks(patterns, options2);
      const tasks2 = [];
      for (const task of globTasks) {
        const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
        tasks2.push(...newTask);
      }
      const filter2 = getFilterSync(options2);
      let matches2 = [];
      for (const task of tasks2) {
        matches2 = arrayUnion(matches2, fastGlob.sync(task.pattern, task.options));
      }
      return matches2.filter((path_) => !filter2(path_));
    };
    globby$1.exports.stream = (patterns, options2) => {
      const globTasks = generateGlobTasks(patterns, options2);
      const tasks2 = [];
      for (const task of globTasks) {
        const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
        tasks2.push(...newTask);
      }
      const filter2 = getFilterSync(options2);
      const filterStream = new FilterStream((p2) => !filter2(p2));
      const uniqueStream = new UniqueStream();
      return merge2(tasks2.map((task) => fastGlob.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);
    };
    globby$1.exports.generateGlobTasks = generateGlobTasks;
    globby$1.exports.hasMagic = (patterns, options2) => [].concat(patterns).some((pattern2) => fastGlob.isDynamicPattern(pattern2, options2));
    globby$1.exports.gitignore = gitignore;
    var globby = globby$1.exports;
    var VariableDynamicImportError = class extends Error {
    };
    var example = "For example: import(`./foo/${bar}.js`).";
    function sanitizeString(str) {
      if (str.includes("*")) {
        throw new VariableDynamicImportError("A dynamic import cannot contain * characters.");
      }
      return str;
    }
    function templateLiteralToGlob(node2) {
      let glob2 = "";
      for (let i2 = 0; i2 < node2.quasis.length; i2 += 1) {
        glob2 += sanitizeString(node2.quasis[i2].value.raw);
        if (node2.expressions[i2]) {
          glob2 += expressionToGlob(node2.expressions[i2]);
        }
      }
      return glob2;
    }
    function callExpressionToGlob(node2) {
      const { callee } = node2;
      if (callee.type === "MemberExpression" && callee.property.type === "Identifier" && callee.property.name === "concat") {
        return `${expressionToGlob(callee.object)}${node2.arguments.map(expressionToGlob).join("")}`;
      }
      return "*";
    }
    function binaryExpressionToGlob(node2) {
      if (node2.operator !== "+") {
        throw new VariableDynamicImportError(`${node2.operator} operator is not supported.`);
      }
      return `${expressionToGlob(node2.left)}${expressionToGlob(node2.right)}`;
    }
    function expressionToGlob(node2) {
      switch (node2.type) {
        case "TemplateLiteral":
          return templateLiteralToGlob(node2);
        case "CallExpression":
          return callExpressionToGlob(node2);
        case "BinaryExpression":
          return binaryExpressionToGlob(node2);
        case "Literal": {
          return sanitizeString(node2.value);
        }
        default:
          return "*";
      }
    }
    function dynamicImportToGlob(node2, sourceString) {
      let glob2 = expressionToGlob(node2);
      if (!glob2.includes("*") || glob2.startsWith("data:")) {
        return null;
      }
      glob2 = glob2.replace(/\*\*/g, "*");
      if (glob2.startsWith("*")) {
        throw new VariableDynamicImportError(`invalid import "${sourceString}". It cannot be statically analyzed. Variable dynamic imports must start with ./ and be limited to a specific directory. ${example}`);
      }
      if (glob2.startsWith("/")) {
        throw new VariableDynamicImportError(`invalid import "${sourceString}". Variable absolute imports are not supported, imports must start with ./ in the static part of the import. ${example}`);
      }
      if (!glob2.startsWith("./") && !glob2.startsWith("../")) {
        throw new VariableDynamicImportError(`invalid import "${sourceString}". Variable bare imports are not supported, imports must start with ./ in the static part of the import. ${example}`);
      }
      const ownDirectoryStarExtension = /^\.\/\*\.[\w]+$/;
      if (ownDirectoryStarExtension.test(glob2)) {
        throw new VariableDynamicImportError(`${`invalid import "${sourceString}". Variable imports cannot import their own directory, place imports in a separate directory or make the import filename more specific. `}${example}`);
      }
      if (path__default.extname(glob2) === "") {
        throw new VariableDynamicImportError(`invalid import "${sourceString}". A file extension must be included in the static part of the import. ${example}`);
      }
      return glob2;
    }
    function dynamicImportVariables({ include, exclude, warnOnError } = {}) {
      const filter2 = createFilter(include, exclude);
      return {
        name: "rollup-plugin-dynamic-import-variables",
        transform(code, id) {
          if (!filter2(id)) {
            return null;
          }
          const parsed = this.parse(code);
          let dynamicImportIndex = -1;
          let ms3;
          walk$1(parsed, {
            enter: (node2) => {
              if (node2.type !== "ImportExpression") {
                return;
              }
              dynamicImportIndex += 1;
              try {
                const glob2 = dynamicImportToGlob(node2.source, code.substring(node2.start, node2.end));
                if (!glob2) {
                  return;
                }
                const result2 = globby.sync(glob2, { cwd: path__default.dirname(id) });
                const paths = result2.map((r2) => r2.startsWith("./") || r2.startsWith("../") ? r2 : `./${r2}`);
                ms3 = ms3 || new MagicString(code);
                ms3.prepend(`function __variableDynamicImportRuntime${dynamicImportIndex}__(path) {
  switch (path) {
${paths.map((p2) => `    case '${p2}': return import('${p2}');`).join("\n")}
${`    default: return new Promise(function(resolve, reject) {
      (typeof queueMicrotask === 'function' ? queueMicrotask : setTimeout)(
        reject.bind(null, new Error("Unknown variable dynamic import: " + path))
      );
    })
`}   }
 }

`);
                ms3.overwrite(node2.start, node2.start + 6, `__variableDynamicImportRuntime${dynamicImportIndex}__`);
              } catch (error2) {
                if (error2 instanceof VariableDynamicImportError) {
                  if (warnOnError) {
                    this.warn(error2);
                  } else {
                    this.error(error2);
                  }
                } else {
                  this.error(error2);
                }
              }
            }
          });
          if (ms3 && dynamicImportIndex !== -1) {
            return {
              code: ms3.toString(),
              map: ms3.generateMap({
                file: id,
                includeContent: true,
                hires: true
              })
            };
          }
          return null;
        }
      };
    }
    var dataUriRE = /^([^/]+\/[^;,]+)(;base64)?,([\s\S]*)$/;
    var dataUriPrefix = `/@data-uri/`;
    function dataURIPlugin() {
      let resolved;
      return {
        name: "vite:data-uri",
        buildStart() {
          resolved = {};
        },
        resolveId(id) {
          if (!dataUriRE.test(id)) {
            return null;
          }
          const uri = new require$$0$6.URL(id);
          if (uri.protocol !== "data:") {
            return null;
          }
          const match2 = uri.pathname.match(dataUriRE);
          if (!match2) {
            return null;
          }
          const [, mime2, format2, data2] = match2;
          if (mime2 !== "text/javascript") {
            throw new Error(`data URI with non-JavaScript mime type is not supported.`);
          }
          const base642 = format2 && /base64/i.test(format2.substring(1));
          const content2 = base642 ? Buffer.from(data2, "base64").toString("utf-8") : data2;
          resolved[id] = content2;
          return dataUriPrefix + id;
        },
        load(id) {
          if (id.startsWith(dataUriPrefix)) {
            id = id.slice(dataUriPrefix.length);
            return resolved[id] || null;
          }
        }
      };
    }
    function loop(exports2, keys) {
      if (typeof exports2 === "string") {
        return exports2;
      }
      if (exports2) {
        let idx, tmp;
        if (Array.isArray(exports2)) {
          for (idx = 0; idx < exports2.length; idx++) {
            if (tmp = loop(exports2[idx], keys))
              return tmp;
          }
        } else {
          for (idx in exports2) {
            if (keys.has(idx)) {
              return loop(exports2[idx], keys);
            }
          }
        }
      }
    }
    function bail(name, entry2, condition) {
      throw new Error(condition ? `No known conditions for "${entry2}" entry in "${name}" package` : `Missing "${entry2}" export in "${name}" package`);
    }
    function toName(name, entry2) {
      return entry2 === name ? "." : entry2[0] === "." ? entry2 : entry2.replace(new RegExp("^" + name + "/"), "./");
    }
    function resolve(pkg, entry2 = ".", options2 = {}) {
      let { name, exports: exports2 } = pkg;
      if (exports2) {
        let { browser: browser2, require: require2, unsafe, conditions = [] } = options2;
        let target = toName(name, entry2);
        if (target[0] !== ".")
          target = "./" + target;
        if (typeof exports2 === "string") {
          return target === "." ? exports2 : bail(name, target);
        }
        let allows = new Set(["default", ...conditions]);
        unsafe || allows.add(require2 ? "require" : "import");
        unsafe || allows.add(browser2 ? "browser" : "node");
        let key, tmp, isSingle = false;
        for (key in exports2) {
          isSingle = key[0] !== ".";
          break;
        }
        if (isSingle) {
          return target === "." ? loop(exports2, allows) || bail(name, target, 1) : bail(name, target);
        }
        if (tmp = exports2[target]) {
          return loop(tmp, allows) || bail(name, target, 1);
        }
        for (key in exports2) {
          tmp = key[key.length - 1];
          if (tmp === "/" && target.startsWith(key)) {
            return (tmp = loop(exports2[key], allows)) ? tmp + target.substring(key.length) : bail(name, target, 1);
          }
          if (tmp === "*" && target.startsWith(key.slice(0, -1))) {
            if (target.substring(key.length - 1).length > 0) {
              return (tmp = loop(exports2[key], allows)) ? tmp.replace("*", target.substring(key.length - 1)) : bail(name, target, 1);
            }
          }
        }
        return bail(name, target);
      }
    }
    var isDebug$6 = process.env.DEBUG;
    var debug$e = createDebugger("vite:resolve-details", {
      onlyWhenFocused: true
    });
    function invalidatePackageData(packageCache, pkgPath) {
      packageCache.delete(pkgPath);
      const pkgDir = path__default.dirname(pkgPath);
      packageCache.forEach((pkg, cacheKey) => {
        if (pkg.dir === pkgDir) {
          packageCache.delete(cacheKey);
        }
      });
    }
    function resolvePackageData(id, basedir, preserveSymlinks = false, packageCache) {
      let pkg;
      let cacheKey;
      if (packageCache) {
        cacheKey = `${id}&${basedir}&${preserveSymlinks}`;
        if (pkg = packageCache.get(cacheKey)) {
          return pkg;
        }
      }
      let pkgPath;
      try {
        pkgPath = resolveFrom$3(`${id}/package.json`, basedir, preserveSymlinks);
        pkg = loadPackageData(pkgPath, true, packageCache);
        if (packageCache) {
          packageCache.set(cacheKey, pkg);
        }
        return pkg;
      } catch (e2) {
        if (e2 instanceof SyntaxError) {
          isDebug$6 && debug$e(`Parsing failed: ${pkgPath}`);
        } else if (e2.code !== "MODULE_NOT_FOUND") {
          throw e2;
        }
      }
      return null;
    }
    function loadPackageData(pkgPath, preserveSymlinks, packageCache) {
      if (!preserveSymlinks) {
        pkgPath = fs__default.realpathSync.native(pkgPath);
      }
      let cached;
      if (cached = packageCache === null || packageCache === void 0 ? void 0 : packageCache.get(pkgPath)) {
        return cached;
      }
      const data2 = JSON.parse(fs__default.readFileSync(pkgPath, "utf-8"));
      const pkgDir = path__default.dirname(pkgPath);
      const { sideEffects } = data2;
      let hasSideEffects;
      if (typeof sideEffects === "boolean") {
        hasSideEffects = () => sideEffects;
      } else if (Array.isArray(sideEffects)) {
        hasSideEffects = createFilter$1(sideEffects, null, { resolve: pkgDir });
      } else {
        hasSideEffects = () => true;
      }
      const pkg = {
        dir: pkgDir,
        data: data2,
        hasSideEffects,
        webResolvedImports: {},
        nodeResolvedImports: {},
        setResolvedCache(key, entry2, targetWeb) {
          if (targetWeb) {
            pkg.webResolvedImports[key] = entry2;
          } else {
            pkg.nodeResolvedImports[key] = entry2;
          }
        },
        getResolvedCache(key, targetWeb) {
          if (targetWeb) {
            return pkg.webResolvedImports[key];
          } else {
            return pkg.nodeResolvedImports[key];
          }
        }
      };
      packageCache === null || packageCache === void 0 ? void 0 : packageCache.set(pkgPath, pkg);
      return pkg;
    }
    function watchPackageDataPlugin(config2) {
      const watchQueue = new Set();
      let watchFile = (id) => {
        watchQueue.add(id);
      };
      const { packageCache } = config2;
      const setPackageData = packageCache.set.bind(packageCache);
      packageCache.set = (id, pkg) => {
        if (id.endsWith(".json")) {
          watchFile(id);
        }
        return setPackageData(id, pkg);
      };
      return {
        name: "vite:watch-package-data",
        buildStart() {
          watchFile = this.addWatchFile;
          watchQueue.forEach(watchFile);
          watchQueue.clear();
        },
        buildEnd() {
          watchFile = (id) => watchQueue.add(id);
        },
        watchChange(id) {
          if (id.endsWith("/package.json")) {
            invalidatePackageData(packageCache, id);
          }
        }
      };
    }
    var browserExternalId = "__vite-browser-external";
    var isDebug$5 = process.env.DEBUG;
    var debug$d = createDebugger("vite:resolve-details", {
      onlyWhenFocused: true
    });
    function resolvePlugin(baseOptions) {
      const { root, isProduction, asSrc, ssrConfig, preferRelative = false } = baseOptions;
      let server2;
      const { target: ssrTarget, noExternal: ssrNoExternal } = ssrConfig !== null && ssrConfig !== void 0 ? ssrConfig : {};
      return {
        name: "vite:resolve",
        configureServer(_server) {
          server2 = _server;
        },
        resolveId(id, importer, resolveOpts) {
          var _a2, _b, _c;
          const ssr = (resolveOpts === null || resolveOpts === void 0 ? void 0 : resolveOpts.ssr) === true;
          if (id.startsWith(browserExternalId)) {
            return id;
          }
          if (/\?commonjs/.test(id) || id === "commonjsHelpers.js") {
            return;
          }
          const targetWeb = !ssr || ssrTarget === "webworker";
          const isRequire2 = (_c = (_b = (_a2 = resolveOpts === null || resolveOpts === void 0 ? void 0 : resolveOpts.custom) === null || _a2 === void 0 ? void 0 : _a2["node-resolve"]) === null || _b === void 0 ? void 0 : _b.isRequire) !== null && _c !== void 0 ? _c : false;
          const options2 = __spreadProps2(__spreadValues2({
            isRequire: isRequire2
          }, baseOptions), {
            isFromTsImporter: isTsRequest(importer !== null && importer !== void 0 ? importer : "")
          });
          let res;
          if (asSrc && id.startsWith(FS_PREFIX)) {
            const fsPath = fsPathFromId(id);
            res = tryFsResolve(fsPath, options2);
            isDebug$5 && debug$d(`[@fs] ${source.cyan(id)} -> ${source.dim(res)}`);
            return res || fsPath;
          }
          if (asSrc && id.startsWith("/")) {
            const fsPath = path__default.resolve(root, id.slice(1));
            if (res = tryFsResolve(fsPath, options2)) {
              isDebug$5 && debug$d(`[url] ${source.cyan(id)} -> ${source.dim(res)}`);
              return res;
            }
          }
          if (id.startsWith(".") || preferRelative && /^\w/.test(id)) {
            const basedir = importer ? path__default.dirname(importer) : process.cwd();
            const fsPath = path__default.resolve(basedir, id);
            const normalizedFsPath = normalizePath$4(fsPath);
            const pathFromBasedir = normalizedFsPath.slice(basedir.length);
            if (pathFromBasedir.startsWith("/node_modules/")) {
              const bareImport = pathFromBasedir.slice("/node_modules/".length);
              if ((res = tryNodeResolve(bareImport, importer, options2, targetWeb, server2, ssr)) && res.id.startsWith(normalizedFsPath)) {
                return res;
              }
            }
            if (targetWeb && (res = tryResolveBrowserMapping(fsPath, importer, options2, true))) {
              return res;
            }
            if (res = tryFsResolve(fsPath, options2)) {
              isDebug$5 && debug$d(`[relative] ${source.cyan(id)} -> ${source.dim(res)}`);
              const pkg = importer != null && idToPkgMap.get(importer);
              if (pkg) {
                idToPkgMap.set(res, pkg);
                return {
                  id: res,
                  moduleSideEffects: pkg.hasSideEffects(res)
                };
              }
              return res;
            }
          }
          if (path__default.isAbsolute(id) && (res = tryFsResolve(id, options2))) {
            isDebug$5 && debug$d(`[fs] ${source.cyan(id)} -> ${source.dim(res)}`);
            return res;
          }
          if (isExternalUrl(id)) {
            return {
              id,
              external: true
            };
          }
          if (isDataUrl(id)) {
            return null;
          }
          if (bareImportRE.test(id)) {
            if (asSrc && server2 && !ssr && (res = tryOptimizedResolve(id, server2, importer))) {
              return res;
            }
            if (targetWeb && (res = tryResolveBrowserMapping(id, importer, options2, false))) {
              return res;
            }
            if (res = tryNodeResolve(id, importer, options2, targetWeb, server2, ssr)) {
              return res;
            }
            if (isBuiltin(id)) {
              if (ssr) {
                if (ssrNoExternal === true) {
                  let message = `Cannot bundle Node.js built-in "${id}"`;
                  if (importer) {
                    message += ` imported from "${path__default.relative(process.cwd(), importer)}"`;
                  }
                  message += `. Consider disabling ssr.noExternal or remove the built-in dependency.`;
                  this.error(message);
                }
                return {
                  id,
                  external: true
                };
              } else {
                if (!asSrc) {
                  debug$d(`externalized node built-in "${id}" to empty module. (imported by: ${source.white.dim(importer)})`);
                }
                return isProduction ? browserExternalId : `${browserExternalId}:${id}`;
              }
            }
          }
          isDebug$5 && debug$d(`[fallthrough] ${source.dim(id)}`);
        },
        load(id) {
          if (id.startsWith(browserExternalId)) {
            return isProduction ? `export default {}` : `export default new Proxy({}, {
  get() {
    throw new Error('Module "${id.slice(browserExternalId.length + 1)}" has been externalized for browser compatibility and cannot be accessed in client code.')
  }
})`;
          }
        }
      };
    }
    function tryFsResolve(fsPath, options2, tryIndex = true, targetWeb = true) {
      let file = fsPath;
      let postfix = "";
      let postfixIndex = fsPath.indexOf("?");
      if (postfixIndex < 0) {
        postfixIndex = fsPath.indexOf("#");
      }
      if (postfixIndex > 0) {
        file = fsPath.slice(0, postfixIndex);
        postfix = fsPath.slice(postfixIndex);
      }
      let res;
      if (postfix && (res = tryResolveFile(fsPath, "", options2, false, targetWeb, options2.tryPrefix, options2.skipPackageJson))) {
        return res;
      }
      if (res = tryResolveFile(file, postfix, options2, false, targetWeb, options2.tryPrefix, options2.skipPackageJson)) {
        return res;
      }
      for (const ext2 of options2.extensions || DEFAULT_EXTENSIONS$1) {
        if (postfix && (res = tryResolveFile(fsPath + ext2, "", options2, false, targetWeb, options2.tryPrefix, options2.skipPackageJson))) {
          return res;
        }
        if (res = tryResolveFile(file + ext2, postfix, options2, false, targetWeb, options2.tryPrefix, options2.skipPackageJson)) {
          return res;
        }
      }
      if (postfix && (res = tryResolveFile(fsPath, "", options2, tryIndex, targetWeb, options2.tryPrefix, options2.skipPackageJson))) {
        return res;
      }
      if (res = tryResolveFile(file, postfix, options2, tryIndex, targetWeb, options2.tryPrefix, options2.skipPackageJson)) {
        return res;
      }
    }
    function tryResolveFile(file, postfix, options2, tryIndex, targetWeb, tryPrefix, skipPackageJson) {
      if (isFileReadable(file)) {
        if (!fs__default.statSync(file).isDirectory()) {
          return getRealPath(file, options2.preserveSymlinks) + postfix;
        } else if (tryIndex) {
          if (!skipPackageJson) {
            const pkgPath = file + "/package.json";
            try {
              const pkg = loadPackageData(pkgPath, options2.preserveSymlinks);
              const resolved = resolvePackageEntry(file, pkg, targetWeb, options2);
              return resolved;
            } catch (e2) {
              if (e2.code !== "ENOENT") {
                throw e2;
              }
            }
          }
          const index2 = tryFsResolve(file + "/index", options2);
          if (index2)
            return index2 + postfix;
        }
      }
      const tryTsExtension = options2.isFromTsImporter && isPossibleTsOutput(file);
      if (tryTsExtension) {
        const tsSrcPath = getTsSrcPath(file);
        return tryResolveFile(tsSrcPath, postfix, options2, tryIndex, targetWeb, tryPrefix, skipPackageJson);
      }
      if (tryPrefix) {
        const prefixed = `${path__default.dirname(file)}/${tryPrefix}${path__default.basename(file)}`;
        return tryResolveFile(prefixed, postfix, options2, tryIndex, targetWeb);
      }
    }
    var idToPkgMap = new Map();
    function tryNodeResolve(id, importer, options2, targetWeb, server2, ssr) {
      var _a2, _b, _c;
      const { root, dedupe, isBuild, preserveSymlinks, packageCache } = options2;
      const lastArrowIndex = id.lastIndexOf(">");
      const nestedRoot = id.substring(0, lastArrowIndex).trim();
      const nestedPath = id.substring(lastArrowIndex + 1).trim();
      const possiblePkgIds = [];
      for (let prevSlashIndex = -1; ; ) {
        let slashIndex = nestedPath.indexOf("/", prevSlashIndex + 1);
        if (slashIndex < 0) {
          slashIndex = nestedPath.length;
        }
        const part = nestedPath.slice(prevSlashIndex + 1, prevSlashIndex = slashIndex);
        if (!part) {
          break;
        }
        if (possiblePkgIds.length ? path__default.extname(part) : part[0] === "@") {
          continue;
        }
        const possiblePkgId = nestedPath.slice(0, slashIndex);
        possiblePkgIds.push(possiblePkgId);
      }
      let basedir;
      if (dedupe === null || dedupe === void 0 ? void 0 : dedupe.some((id2) => possiblePkgIds.includes(id2))) {
        basedir = root;
      } else if (importer && path__default.isAbsolute(importer) && fs__default.existsSync(cleanUrl(importer))) {
        basedir = path__default.dirname(importer);
      } else {
        basedir = root;
      }
      if (nestedRoot) {
        basedir = nestedResolveFrom(nestedRoot, basedir, preserveSymlinks);
      }
      let pkg;
      const pkgId = possiblePkgIds.reverse().find((pkgId2) => {
        pkg = resolvePackageData(pkgId2, basedir, preserveSymlinks, packageCache);
        return pkg;
      });
      if (!pkg) {
        return;
      }
      let resolveId2 = resolvePackageEntry;
      let unresolvedId = pkgId;
      if (unresolvedId !== nestedPath) {
        resolveId2 = resolveDeepImport;
        unresolvedId = "." + nestedPath.slice(pkgId.length);
      }
      let resolved;
      try {
        resolved = resolveId2(unresolvedId, pkg, targetWeb, options2);
      } catch (err) {
        if (!options2.tryEsmOnly) {
          throw err;
        }
      }
      if (!resolved && options2.tryEsmOnly) {
        resolved = resolveId2(unresolvedId, pkg, targetWeb, __spreadProps2(__spreadValues2({}, options2), {
          isRequire: false,
          mainFields: DEFAULT_MAIN_FIELDS,
          extensions: DEFAULT_EXTENSIONS$1
        }));
      }
      if (!resolved) {
        return;
      }
      idToPkgMap.set(resolved, pkg);
      if (isBuild) {
        return {
          id: resolved,
          moduleSideEffects: pkg.hasSideEffects(resolved)
        };
      } else {
        if (!resolved.includes("node_modules") || !server2 || server2._isRunningOptimizer || !server2._optimizeDepsMetadata) {
          return { id: resolved };
        }
        const isJsType = OPTIMIZABLE_ENTRY_RE.test(resolved);
        const exclude = (_a2 = server2.config.optimizeDeps) === null || _a2 === void 0 ? void 0 : _a2.exclude;
        if (!isJsType || (importer === null || importer === void 0 ? void 0 : importer.includes("node_modules")) || (exclude === null || exclude === void 0 ? void 0 : exclude.includes(pkgId)) || (exclude === null || exclude === void 0 ? void 0 : exclude.includes(nestedPath)) || SPECIAL_QUERY_RE.test(resolved) || ssr) {
          const versionHash = (_b = server2._optimizeDepsMetadata) === null || _b === void 0 ? void 0 : _b.browserHash;
          if (versionHash && isJsType) {
            resolved = injectQuery(resolved, `v=${versionHash}`);
          }
        } else {
          (_c = server2._registerMissingImport) === null || _c === void 0 ? void 0 : _c.call(server2, id, resolved, ssr);
        }
        return { id: resolved };
      }
    }
    function tryOptimizedResolve(id, server2, importer) {
      const cacheDir = server2.config.cacheDir;
      const depData = server2._optimizeDepsMetadata;
      if (!cacheDir || !depData)
        return;
      const getOptimizedUrl = (optimizedData) => {
        return optimizedData.file + `?v=${depData.browserHash}${optimizedData.needsInterop ? `&es-interop` : ``}`;
      };
      const isOptimized = depData.optimized[id];
      if (isOptimized) {
        return getOptimizedUrl(isOptimized);
      }
      if (!importer)
        return;
      let resolvedSrc;
      for (const [pkgPath, optimizedData] of Object.entries(depData.optimized)) {
        if (!pkgPath.endsWith(id))
          continue;
        if (resolvedSrc == null) {
          try {
            resolvedSrc = normalizePath$4(resolveFrom$3(id, path__default.dirname(importer)));
          } catch {
            break;
          }
        }
        if (optimizedData.src === resolvedSrc) {
          return getOptimizedUrl(optimizedData);
        }
      }
    }
    function resolvePackageEntry(id, { dir, data: data2, setResolvedCache, getResolvedCache }, targetWeb, options2) {
      var _a2, _b;
      const cached = getResolvedCache(".", targetWeb);
      if (cached) {
        return cached;
      }
      try {
        let entryPoint;
        if (data2.exports) {
          entryPoint = resolveExports(data2, ".", options2, targetWeb);
        }
        if (targetWeb && (!entryPoint || entryPoint.endsWith(".mjs"))) {
          const browserEntry = typeof data2.browser === "string" ? data2.browser : isObject$3(data2.browser) && data2.browser["."];
          if (browserEntry) {
            if (typeof data2.module === "string" && data2.module !== browserEntry) {
              const resolvedBrowserEntry = tryFsResolve(path__default.join(dir, browserEntry), options2);
              if (resolvedBrowserEntry) {
                const content2 = fs__default.readFileSync(resolvedBrowserEntry, "utf-8");
                if (/typeof exports\s*==/.test(content2) && /typeof module\s*==/.test(content2) || /module\.exports\s*=/.test(content2)) {
                  entryPoint = data2.module;
                }
              }
            } else {
              entryPoint = browserEntry;
            }
          }
        }
        if (!entryPoint || entryPoint.endsWith(".mjs")) {
          for (const field of options2.mainFields || DEFAULT_MAIN_FIELDS) {
            if (typeof data2[field] === "string") {
              entryPoint = data2[field];
              break;
            }
          }
        }
        entryPoint = entryPoint || data2.main || "index.js";
        if (((_a2 = options2.mainFields) === null || _a2 === void 0 ? void 0 : _a2[0]) === "sass" && !((_b = options2.extensions) === null || _b === void 0 ? void 0 : _b.includes(path__default.extname(entryPoint)))) {
          entryPoint = "";
          options2.skipPackageJson = true;
        }
        const { browser: browserField } = data2;
        if (targetWeb && isObject$3(browserField)) {
          entryPoint = mapWithBrowserField(entryPoint, browserField) || entryPoint;
        }
        entryPoint = path__default.join(dir, entryPoint);
        const resolvedEntryPoint = tryFsResolve(entryPoint, options2);
        if (resolvedEntryPoint) {
          isDebug$5 && debug$d(`[package entry] ${source.cyan(id)} -> ${source.dim(resolvedEntryPoint)}`);
          setResolvedCache(".", resolvedEntryPoint, targetWeb);
          return resolvedEntryPoint;
        } else {
          packageEntryFailure(id);
        }
      } catch (e2) {
        packageEntryFailure(id, e2.message);
      }
    }
    function packageEntryFailure(id, details) {
      throw new Error(`Failed to resolve entry for package "${id}". The package may have incorrect main/module/exports specified in its package.json` + (details ? ": " + details : "."));
    }
    function resolveExports(pkg, key, options2, targetWeb) {
      const conditions = [options2.isProduction ? "production" : "development"];
      if (!options2.isRequire) {
        conditions.push("module");
      }
      if (options2.conditions) {
        conditions.push(...options2.conditions);
      }
      return resolve(pkg, key, {
        browser: targetWeb,
        require: options2.isRequire,
        conditions
      });
    }
    function resolveDeepImport(id, { webResolvedImports, setResolvedCache, getResolvedCache, dir, data: data2 }, targetWeb, options2) {
      const cache2 = getResolvedCache(id, targetWeb);
      if (cache2) {
        return cache2;
      }
      let relativeId = id;
      const { exports: exportsField, browser: browserField } = data2;
      if (exportsField) {
        if (isObject$3(exportsField) && !Array.isArray(exportsField)) {
          relativeId = resolveExports(data2, relativeId, options2, targetWeb);
        } else {
          relativeId = void 0;
        }
        if (!relativeId) {
          throw new Error(`Package subpath '${relativeId}' is not defined by "exports" in ${path__default.join(dir, "package.json")}.`);
        }
      } else if (targetWeb && isObject$3(browserField)) {
        const mapped = mapWithBrowserField(relativeId, browserField);
        if (mapped) {
          relativeId = mapped;
        } else if (mapped === false) {
          return webResolvedImports[id] = browserExternalId;
        }
      }
      if (relativeId) {
        const resolved = tryFsResolve(path__default.join(dir, relativeId), options2, !exportsField, targetWeb);
        if (resolved) {
          isDebug$5 && debug$d(`[node/deep-import] ${source.cyan(id)} -> ${source.dim(resolved)}`);
          setResolvedCache(id, resolved, targetWeb);
          return resolved;
        }
      }
    }
    function tryResolveBrowserMapping(id, importer, options2, isFilePath) {
      let res;
      const pkg = importer && idToPkgMap.get(importer);
      if (pkg && isObject$3(pkg.data.browser)) {
        const mapId = isFilePath ? "./" + slash$3(path__default.relative(pkg.dir, id)) : id;
        const browserMappedPath = mapWithBrowserField(mapId, pkg.data.browser);
        if (browserMappedPath) {
          const fsPath = path__default.join(pkg.dir, browserMappedPath);
          if (res = tryFsResolve(fsPath, options2)) {
            isDebug$5 && debug$d(`[browser mapped] ${source.cyan(id)} -> ${source.dim(res)}`);
            idToPkgMap.set(res, pkg);
            return {
              id: res,
              moduleSideEffects: pkg.hasSideEffects(res)
            };
          }
        } else if (browserMappedPath === false) {
          return browserExternalId;
        }
      }
    }
    function mapWithBrowserField(relativePathInPkgDir, map2) {
      const normalizedPath = path__default.posix.normalize(relativePathInPkgDir);
      for (const key in map2) {
        const normalizedKey = path__default.posix.normalize(key);
        if (normalizedPath === normalizedKey || equalWithoutSuffix(normalizedPath, normalizedKey, ".js") || equalWithoutSuffix(normalizedPath, normalizedKey, "/index.js")) {
          return map2[key];
        }
      }
    }
    function equalWithoutSuffix(path2, key, suffix) {
      return key.endsWith(suffix) && key.slice(0, -suffix.length) === path2;
    }
    function getRealPath(resolved, preserveSymlinks) {
      resolved = ensureVolumeInPath(resolved);
      if (!preserveSymlinks && browserExternalId !== resolved) {
        resolved = fs__default.realpathSync(resolved);
      }
      return normalizePath$4(resolved);
    }
    var debug$c = createDebugger("vite:ssr-external");
    function resolveSSRExternal(config2, knownImports) {
      var _a2;
      const ssrConfig = config2.ssr;
      if ((ssrConfig === null || ssrConfig === void 0 ? void 0 : ssrConfig.noExternal) === true) {
        return [];
      }
      const ssrExternals = new Set();
      const seen2 = new Set();
      (_a2 = ssrConfig === null || ssrConfig === void 0 ? void 0 : ssrConfig.external) === null || _a2 === void 0 ? void 0 : _a2.forEach((id) => {
        ssrExternals.add(id);
        seen2.add(id);
      });
      collectExternals(config2.root, config2.resolve.preserveSymlinks, ssrExternals, seen2, config2.logger);
      const importedDeps = knownImports.map(getNpmPackageName).filter(isDefined);
      for (const dep of importedDeps) {
        if (!seen2.has(dep)) {
          ssrExternals.add(dep);
        }
      }
      ssrExternals.delete("vite");
      let externals = [...ssrExternals];
      if (ssrConfig === null || ssrConfig === void 0 ? void 0 : ssrConfig.noExternal) {
        externals = externals.filter(createFilter$1(void 0, ssrConfig.noExternal, { resolve: false }));
      }
      return externals;
    }
    var CJS_CONTENT_RE = /\bmodule\.exports\b|\bexports[.\[]|\brequire\s*\(|\bObject\.(defineProperty|defineProperties|assign)\s*\(\s*exports\b/;
    function collectExternals(root, preserveSymlinks, ssrExternals, seen2, logger) {
      var _a2;
      const rootPkgContent = lookupFile(root, ["package.json"]);
      if (!rootPkgContent) {
        return;
      }
      const rootPkg = JSON.parse(rootPkgContent);
      const deps = __spreadValues2(__spreadValues2({}, rootPkg.devDependencies), rootPkg.dependencies);
      const resolveOptions = {
        root,
        preserveSymlinks,
        isProduction: false,
        isBuild: true
      };
      const depsToTrace = new Set();
      for (const id in deps) {
        if (seen2.has(id))
          continue;
        seen2.add(id);
        let esmEntry;
        let requireEntry;
        try {
          esmEntry = (_a2 = tryNodeResolve(id, void 0, resolveOptions, true, void 0, true)) === null || _a2 === void 0 ? void 0 : _a2.id;
          requireEntry = normalizePath$4(__require.resolve(id, { paths: [root] }));
        } catch (e2) {
          try {
            const pkgPath = resolveFrom$3(`${id}/package.json`, root);
            if (pkgPath.includes("node_modules")) {
              ssrExternals.add(id);
            } else {
              depsToTrace.add(path__default.dirname(pkgPath));
            }
            continue;
          } catch {
          }
          debug$c(`Failed to resolve entries for package "${id}"
`, e2);
          continue;
        }
        if (!esmEntry) {
          ssrExternals.add(id);
        } else if (!esmEntry.includes("node_modules")) {
          const pkgPath = resolveFrom$3(`${id}/package.json`, root);
          depsToTrace.add(path__default.dirname(pkgPath));
        } else if (esmEntry !== requireEntry) {
          ssrExternals.add(id);
        } else if (/\.m?js$/.test(esmEntry)) {
          const pkgPath = resolveFrom$3(`${id}/package.json`, root);
          const pkgContent = fs__default.readFileSync(pkgPath, "utf-8");
          if (!pkgContent) {
            continue;
          }
          const pkg = JSON.parse(pkgContent);
          if (pkg.type === "module" || esmEntry.endsWith(".mjs")) {
            ssrExternals.add(id);
            continue;
          }
          const content2 = fs__default.readFileSync(esmEntry, "utf-8");
          if (CJS_CONTENT_RE.test(content2)) {
            ssrExternals.add(id);
            continue;
          }
          logger.warn(`${id} doesn't appear to be written in CJS, but also doesn't appear to be a valid ES module (i.e. it doesn't have "type": "module" or an .mjs extension for the entry point). Please contact the package author to fix.`);
        }
      }
      for (const depRoot of depsToTrace) {
        collectExternals(depRoot, preserveSymlinks, ssrExternals, seen2, logger);
      }
    }
    function shouldExternalizeForSSR(id, externals) {
      const should = externals.some((e2) => {
        if (id === e2) {
          return true;
        }
        if (id.startsWith(e2 + "/") && (!path__default.extname(id) || id.endsWith(".js"))) {
          return true;
        }
      });
      return should;
    }
    function getNpmPackageName(importPath) {
      const parts = importPath.split("/");
      if (parts[0].startsWith("@")) {
        if (!parts[1])
          return null;
        return `${parts[0]}/${parts[1]}`;
      } else {
        return parts[0];
      }
    }
    function ssrManifestPlugin(config2) {
      const ssrManifest = {};
      const base2 = config2.base;
      return {
        name: "vite:ssr-manifest",
        generateBundle(_options, bundle) {
          for (const file in bundle) {
            const chunk = bundle[file];
            if (chunk.type === "chunk") {
              const cssFiles = chunk.isEntry ? null : chunkToEmittedCssFileMap.get(chunk);
              const assetFiles = chunkToEmittedAssetsMap.get(chunk);
              for (const id in chunk.modules) {
                const normalizedId = normalizePath$3(path$t.relative(config2.root, id));
                const mappedChunks = ssrManifest[normalizedId] || (ssrManifest[normalizedId] = []);
                if (!chunk.isEntry) {
                  mappedChunks.push(base2 + chunk.fileName);
                }
                if (cssFiles) {
                  cssFiles.forEach((file2) => {
                    mappedChunks.push(base2 + file2);
                  });
                }
                if (assetFiles) {
                  assetFiles.forEach((file2) => {
                    mappedChunks.push(base2 + file2);
                  });
                }
              }
            }
          }
          this.emitFile({
            fileName: "ssr-manifest.json",
            type: "asset",
            source: JSON.stringify(ssrManifest, null, 2)
          });
        }
      };
    }
    var reservedWords = {
      3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
      5: "class enum extends super const export import",
      6: "enum",
      strict: "implements interface let package private protected public static yield",
      strictBind: "eval arguments"
    };
    var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
    var keywords$1 = {
      5: ecma5AndLessKeywords,
      "5module": ecma5AndLessKeywords + " export import",
      6: ecma5AndLessKeywords + " const class extends export import super"
    };
    var keywordRelationalOperator = /^in(stanceof)?$/;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set2) {
      var pos = 65536;
      for (var i2 = 0; i2 < set2.length; i2 += 2) {
        pos += set2[i2];
        if (pos > code) {
          return false;
        }
        pos += set2[i2 + 1];
        if (pos >= code) {
          return true;
        }
      }
    }
    function isIdentifierStart(code, astral) {
      if (code < 65) {
        return code === 36;
      }
      if (code < 91) {
        return true;
      }
      if (code < 97) {
        return code === 95;
      }
      if (code < 123) {
        return true;
      }
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      if (astral === false) {
        return false;
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code, astral) {
      if (code < 48) {
        return code === 36;
      }
      if (code < 58) {
        return true;
      }
      if (code < 65) {
        return false;
      }
      if (code < 91) {
        return true;
      }
      if (code < 97) {
        return code === 95;
      }
      if (code < 123) {
        return true;
      }
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      if (astral === false) {
        return false;
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    var TokenType = function TokenType2(label, conf) {
      if (conf === void 0)
        conf = {};
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop || null;
      this.updateContext = null;
    };
    function binop(name, prec) {
      return new TokenType(name, { beforeExpr: true, binop: prec });
    }
    var beforeExpr = { beforeExpr: true };
    var startsExpr = { startsExpr: true };
    var keywords = {};
    function kw(name, options2) {
      if (options2 === void 0)
        options2 = {};
      options2.keyword = name;
      return keywords[name] = new TokenType(name, options2);
    }
    var types$1 = {
      num: new TokenType("num", startsExpr),
      regexp: new TokenType("regexp", startsExpr),
      string: new TokenType("string", startsExpr),
      name: new TokenType("name", startsExpr),
      privateId: new TokenType("privateId", startsExpr),
      eof: new TokenType("eof"),
      bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
      bracketR: new TokenType("]"),
      braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
      braceR: new TokenType("}"),
      parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
      parenR: new TokenType(")"),
      comma: new TokenType(",", beforeExpr),
      semi: new TokenType(";", beforeExpr),
      colon: new TokenType(":", beforeExpr),
      dot: new TokenType("."),
      question: new TokenType("?", beforeExpr),
      questionDot: new TokenType("?."),
      arrow: new TokenType("=>", beforeExpr),
      template: new TokenType("template"),
      invalidTemplate: new TokenType("invalidTemplate"),
      ellipsis: new TokenType("...", beforeExpr),
      backQuote: new TokenType("`", startsExpr),
      dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
      eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
      assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
      incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
      prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
      logicalOR: binop("||", 1),
      logicalAND: binop("&&", 2),
      bitwiseOR: binop("|", 3),
      bitwiseXOR: binop("^", 4),
      bitwiseAND: binop("&", 5),
      equality: binop("==/!=/===/!==", 6),
      relational: binop("</>/<=/>=", 7),
      bitShift: binop("<</>>/>>>", 8),
      plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
      modulo: binop("%", 10),
      star: binop("*", 10),
      slash: binop("/", 10),
      starstar: new TokenType("**", { beforeExpr: true }),
      coalesce: binop("??", 1),
      _break: kw("break"),
      _case: kw("case", beforeExpr),
      _catch: kw("catch"),
      _continue: kw("continue"),
      _debugger: kw("debugger"),
      _default: kw("default", beforeExpr),
      _do: kw("do", { isLoop: true, beforeExpr: true }),
      _else: kw("else", beforeExpr),
      _finally: kw("finally"),
      _for: kw("for", { isLoop: true }),
      _function: kw("function", startsExpr),
      _if: kw("if"),
      _return: kw("return", beforeExpr),
      _switch: kw("switch"),
      _throw: kw("throw", beforeExpr),
      _try: kw("try"),
      _var: kw("var"),
      _const: kw("const"),
      _while: kw("while", { isLoop: true }),
      _with: kw("with"),
      _new: kw("new", { beforeExpr: true, startsExpr: true }),
      _this: kw("this", startsExpr),
      _super: kw("super", startsExpr),
      _class: kw("class", startsExpr),
      _extends: kw("extends", beforeExpr),
      _export: kw("export"),
      _import: kw("import", startsExpr),
      _null: kw("null", startsExpr),
      _true: kw("true", startsExpr),
      _false: kw("false", startsExpr),
      _in: kw("in", { beforeExpr: true, binop: 7 }),
      _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
      _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
      _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
      _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
    };
    var lineBreak = /\r\n?|\n|\u2028|\u2029/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code) {
      return code === 10 || code === 13 || code === 8232 || code === 8233;
    }
    function nextLineBreak(code, from, end) {
      if (end === void 0)
        end = code.length;
      for (var i2 = from; i2 < end; i2++) {
        var next = code.charCodeAt(i2);
        if (isNewLine(next)) {
          return i2 < end - 1 && next === 13 && code.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
        }
      }
      return -1;
    }
    var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var ref = Object.prototype;
    var hasOwnProperty$1 = ref.hasOwnProperty;
    var toString$1 = ref.toString;
    var hasOwn = Object.hasOwn || function(obj, propName) {
      return hasOwnProperty$1.call(obj, propName);
    };
    var isArray = Array.isArray || function(obj) {
      return toString$1.call(obj) === "[object Array]";
    };
    function wordsRegexp(words) {
      return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
    }
    var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
    var Position = function Position2(line, col) {
      this.line = line;
      this.column = col;
    };
    Position.prototype.offset = function offset2(n3) {
      return new Position(this.line, this.column + n3);
    };
    var SourceLocation = function SourceLocation2(p2, start, end) {
      this.start = start;
      this.end = end;
      if (p2.sourceFile !== null) {
        this.source = p2.sourceFile;
      }
    };
    function getLineInfo(input, offset2) {
      for (var line = 1, cur = 0; ; ) {
        var nextBreak = nextLineBreak(input, cur, offset2);
        if (nextBreak < 0) {
          return new Position(line, offset2 - cur);
        }
        ++line;
        cur = nextBreak;
      }
    }
    var defaultOptions = {
      ecmaVersion: null,
      sourceType: "script",
      onInsertedSemicolon: null,
      onTrailingComma: null,
      allowReserved: null,
      allowReturnOutsideFunction: false,
      allowImportExportEverywhere: false,
      allowAwaitOutsideFunction: null,
      allowSuperOutsideMethod: null,
      allowHashBang: false,
      locations: false,
      onToken: null,
      onComment: null,
      ranges: false,
      program: null,
      sourceFile: null,
      directSourceFile: null,
      preserveParens: false
    };
    var warnedAboutEcmaVersion = false;
    function getOptions(opts) {
      var options2 = {};
      for (var opt in defaultOptions) {
        options2[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
      }
      if (options2.ecmaVersion === "latest") {
        options2.ecmaVersion = 1e8;
      } else if (options2.ecmaVersion == null) {
        if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
          warnedAboutEcmaVersion = true;
          console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
        }
        options2.ecmaVersion = 11;
      } else if (options2.ecmaVersion >= 2015) {
        options2.ecmaVersion -= 2009;
      }
      if (options2.allowReserved == null) {
        options2.allowReserved = options2.ecmaVersion < 5;
      }
      if (isArray(options2.onToken)) {
        var tokens = options2.onToken;
        options2.onToken = function(token) {
          return tokens.push(token);
        };
      }
      if (isArray(options2.onComment)) {
        options2.onComment = pushComment(options2, options2.onComment);
      }
      return options2;
    }
    function pushComment(options2, array2) {
      return function(block, text, start, end, startLoc, endLoc) {
        var comment = {
          type: block ? "Block" : "Line",
          value: text,
          start,
          end
        };
        if (options2.locations) {
          comment.loc = new SourceLocation(this, startLoc, endLoc);
        }
        if (options2.ranges) {
          comment.range = [start, end];
        }
        array2.push(comment);
      };
    }
    var SCOPE_TOP = 1;
    var SCOPE_FUNCTION = 2;
    var SCOPE_ASYNC = 4;
    var SCOPE_GENERATOR = 8;
    var SCOPE_ARROW = 16;
    var SCOPE_SIMPLE_CATCH = 32;
    var SCOPE_SUPER = 64;
    var SCOPE_DIRECT_SUPER = 128;
    var SCOPE_CLASS_STATIC_BLOCK = 256;
    var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
    function functionFlags(async2, generator) {
      return SCOPE_FUNCTION | (async2 ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
    }
    var BIND_NONE = 0;
    var BIND_VAR = 1;
    var BIND_LEXICAL = 2;
    var BIND_FUNCTION = 3;
    var BIND_SIMPLE_CATCH = 4;
    var BIND_OUTSIDE = 5;
    var Parser = function Parser2(options2, input, startPos) {
      this.options = options2 = getOptions(options2);
      this.sourceFile = options2.sourceFile;
      this.keywords = wordsRegexp(keywords$1[options2.ecmaVersion >= 6 ? 6 : options2.sourceType === "module" ? "5module" : 5]);
      var reserved = "";
      if (options2.allowReserved !== true) {
        reserved = reservedWords[options2.ecmaVersion >= 6 ? 6 : options2.ecmaVersion === 5 ? 5 : 3];
        if (options2.sourceType === "module") {
          reserved += " await";
        }
      }
      this.reservedWords = wordsRegexp(reserved);
      var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
      this.reservedWordsStrict = wordsRegexp(reservedStrict);
      this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
      this.input = String(input);
      this.containsEsc = false;
      if (startPos) {
        this.pos = startPos;
        this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
      } else {
        this.pos = this.lineStart = 0;
        this.curLine = 1;
      }
      this.type = types$1.eof;
      this.value = null;
      this.start = this.end = this.pos;
      this.startLoc = this.endLoc = this.curPosition();
      this.lastTokEndLoc = this.lastTokStartLoc = null;
      this.lastTokStart = this.lastTokEnd = this.pos;
      this.context = this.initialContext();
      this.exprAllowed = true;
      this.inModule = options2.sourceType === "module";
      this.strict = this.inModule || this.strictDirective(this.pos);
      this.potentialArrowAt = -1;
      this.potentialArrowInForAwait = false;
      this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
      this.labels = [];
      this.undefinedExports = Object.create(null);
      if (this.pos === 0 && options2.allowHashBang && this.input.slice(0, 2) === "#!") {
        this.skipLineComment(2);
      }
      this.scopeStack = [];
      this.enterScope(SCOPE_TOP);
      this.regexpState = null;
      this.privateNameStack = [];
    };
    var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
    Parser.prototype.parse = function parse2() {
      var node2 = this.options.program || this.startNode();
      this.nextToken();
      return this.parseTopLevel(node2);
    };
    prototypeAccessors.inFunction.get = function() {
      return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
    };
    prototypeAccessors.inGenerator.get = function() {
      return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
    };
    prototypeAccessors.inAsync.get = function() {
      return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
    };
    prototypeAccessors.canAwait.get = function() {
      for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
        var scope = this.scopeStack[i2];
        if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
          return false;
        }
        if (scope.flags & SCOPE_FUNCTION) {
          return (scope.flags & SCOPE_ASYNC) > 0;
        }
      }
      return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
    };
    prototypeAccessors.allowSuper.get = function() {
      var ref2 = this.currentThisScope();
      var flags = ref2.flags;
      var inClassFieldInit = ref2.inClassFieldInit;
      return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
    };
    prototypeAccessors.allowDirectSuper.get = function() {
      return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
    };
    prototypeAccessors.treatFunctionsAsVar.get = function() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    };
    prototypeAccessors.allowNewDotTarget.get = function() {
      var ref2 = this.currentThisScope();
      var flags = ref2.flags;
      var inClassFieldInit = ref2.inClassFieldInit;
      return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
    };
    prototypeAccessors.inClassStaticBlock.get = function() {
      return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
    };
    Parser.extend = function extend2() {
      var plugins2 = [], len = arguments.length;
      while (len--)
        plugins2[len] = arguments[len];
      var cls = this;
      for (var i2 = 0; i2 < plugins2.length; i2++) {
        cls = plugins2[i2](cls);
      }
      return cls;
    };
    Parser.parse = function parse2(input, options2) {
      return new this(options2, input).parse();
    };
    Parser.parseExpressionAt = function parseExpressionAt2(input, pos, options2) {
      var parser2 = new this(options2, input, pos);
      parser2.nextToken();
      return parser2.parseExpression();
    };
    Parser.tokenizer = function tokenizer2(input, options2) {
      return new this(options2, input);
    };
    Object.defineProperties(Parser.prototype, prototypeAccessors);
    var pp$9 = Parser.prototype;
    var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
    pp$9.strictDirective = function(start) {
      for (; ; ) {
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        var match2 = literal.exec(this.input.slice(start));
        if (!match2) {
          return false;
        }
        if ((match2[1] || match2[2]) === "use strict") {
          skipWhiteSpace.lastIndex = start + match2[0].length;
          var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
          var next = this.input.charAt(end);
          return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
        }
        start += match2[0].length;
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        if (this.input[start] === ";") {
          start++;
        }
      }
    };
    pp$9.eat = function(type) {
      if (this.type === type) {
        this.next();
        return true;
      } else {
        return false;
      }
    };
    pp$9.isContextual = function(name) {
      return this.type === types$1.name && this.value === name && !this.containsEsc;
    };
    pp$9.eatContextual = function(name) {
      if (!this.isContextual(name)) {
        return false;
      }
      this.next();
      return true;
    };
    pp$9.expectContextual = function(name) {
      if (!this.eatContextual(name)) {
        this.unexpected();
      }
    };
    pp$9.canInsertSemicolon = function() {
      return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$9.insertSemicolon = function() {
      if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon) {
          this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
        }
        return true;
      }
    };
    pp$9.semicolon = function() {
      if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
        this.unexpected();
      }
    };
    pp$9.afterTrailingComma = function(tokType, notNext) {
      if (this.type === tokType) {
        if (this.options.onTrailingComma) {
          this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
        }
        if (!notNext) {
          this.next();
        }
        return true;
      }
    };
    pp$9.expect = function(type) {
      this.eat(type) || this.unexpected();
    };
    pp$9.unexpected = function(pos) {
      this.raise(pos != null ? pos : this.start, "Unexpected token");
    };
    function DestructuringErrors() {
      this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
    }
    pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
      if (!refDestructuringErrors) {
        return;
      }
      if (refDestructuringErrors.trailingComma > -1) {
        this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
      }
      var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
      if (parens > -1) {
        this.raiseRecoverable(parens, "Parenthesized pattern");
      }
    };
    pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
      if (!refDestructuringErrors) {
        return false;
      }
      var shorthandAssign = refDestructuringErrors.shorthandAssign;
      var doubleProto = refDestructuringErrors.doubleProto;
      if (!andThrow) {
        return shorthandAssign >= 0 || doubleProto >= 0;
      }
      if (shorthandAssign >= 0) {
        this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
      }
      if (doubleProto >= 0) {
        this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
      }
    };
    pp$9.checkYieldAwaitInDefaultParams = function() {
      if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
        this.raise(this.yieldPos, "Yield expression cannot be a default value");
      }
      if (this.awaitPos) {
        this.raise(this.awaitPos, "Await expression cannot be a default value");
      }
    };
    pp$9.isSimpleAssignTarget = function(expr) {
      if (expr.type === "ParenthesizedExpression") {
        return this.isSimpleAssignTarget(expr.expression);
      }
      return expr.type === "Identifier" || expr.type === "MemberExpression";
    };
    var pp$8 = Parser.prototype;
    pp$8.parseTopLevel = function(node2) {
      var exports2 = Object.create(null);
      if (!node2.body) {
        node2.body = [];
      }
      while (this.type !== types$1.eof) {
        var stmt = this.parseStatement(null, true, exports2);
        node2.body.push(stmt);
      }
      if (this.inModule) {
        for (var i2 = 0, list2 = Object.keys(this.undefinedExports); i2 < list2.length; i2 += 1) {
          var name = list2[i2];
          this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
        }
      }
      this.adaptDirectivePrologue(node2.body);
      this.next();
      node2.sourceType = this.options.sourceType;
      return this.finishNode(node2, "Program");
    };
    var loopLabel = { kind: "loop" };
    var switchLabel = { kind: "switch" };
    pp$8.isLet = function(context2) {
      if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
        return false;
      }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 91 || nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
        return true;
      }
      if (context2) {
        return false;
      }
      if (nextCh === 123) {
        return true;
      }
      if (isIdentifierStart(nextCh, true)) {
        var pos = next + 1;
        while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
          ++pos;
        }
        if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        var ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) {
          return true;
        }
      }
      return false;
    };
    pp$8.isAsyncFunction = function() {
      if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
        return false;
      }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, after;
      return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
    };
    pp$8.parseStatement = function(context2, topLevel, exports2) {
      var starttype = this.type, node2 = this.startNode(), kind;
      if (this.isLet(context2)) {
        starttype = types$1._var;
        kind = "let";
      }
      switch (starttype) {
        case types$1._break:
        case types$1._continue:
          return this.parseBreakContinueStatement(node2, starttype.keyword);
        case types$1._debugger:
          return this.parseDebuggerStatement(node2);
        case types$1._do:
          return this.parseDoStatement(node2);
        case types$1._for:
          return this.parseForStatement(node2);
        case types$1._function:
          if (context2 && (this.strict || context2 !== "if" && context2 !== "label") && this.options.ecmaVersion >= 6) {
            this.unexpected();
          }
          return this.parseFunctionStatement(node2, false, !context2);
        case types$1._class:
          if (context2) {
            this.unexpected();
          }
          return this.parseClass(node2, true);
        case types$1._if:
          return this.parseIfStatement(node2);
        case types$1._return:
          return this.parseReturnStatement(node2);
        case types$1._switch:
          return this.parseSwitchStatement(node2);
        case types$1._throw:
          return this.parseThrowStatement(node2);
        case types$1._try:
          return this.parseTryStatement(node2);
        case types$1._const:
        case types$1._var:
          kind = kind || this.value;
          if (context2 && kind !== "var") {
            this.unexpected();
          }
          return this.parseVarStatement(node2, kind);
        case types$1._while:
          return this.parseWhileStatement(node2);
        case types$1._with:
          return this.parseWithStatement(node2);
        case types$1.braceL:
          return this.parseBlock(true, node2);
        case types$1.semi:
          return this.parseEmptyStatement(node2);
        case types$1._export:
        case types$1._import:
          if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
            skipWhiteSpace.lastIndex = this.pos;
            var skip = skipWhiteSpace.exec(this.input);
            var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
            if (nextCh === 40 || nextCh === 46) {
              return this.parseExpressionStatement(node2, this.parseExpression());
            }
          }
          if (!this.options.allowImportExportEverywhere) {
            if (!topLevel) {
              this.raise(this.start, "'import' and 'export' may only appear at the top level");
            }
            if (!this.inModule) {
              this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
            }
          }
          return starttype === types$1._import ? this.parseImport(node2) : this.parseExport(node2, exports2);
        default:
          if (this.isAsyncFunction()) {
            if (context2) {
              this.unexpected();
            }
            this.next();
            return this.parseFunctionStatement(node2, true, !context2);
          }
          var maybeName = this.value, expr = this.parseExpression();
          if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
            return this.parseLabeledStatement(node2, maybeName, expr, context2);
          } else {
            return this.parseExpressionStatement(node2, expr);
          }
      }
    };
    pp$8.parseBreakContinueStatement = function(node2, keyword) {
      var isBreak = keyword === "break";
      this.next();
      if (this.eat(types$1.semi) || this.insertSemicolon()) {
        node2.label = null;
      } else if (this.type !== types$1.name) {
        this.unexpected();
      } else {
        node2.label = this.parseIdent();
        this.semicolon();
      }
      var i2 = 0;
      for (; i2 < this.labels.length; ++i2) {
        var lab = this.labels[i2];
        if (node2.label == null || lab.name === node2.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) {
            break;
          }
          if (node2.label && isBreak) {
            break;
          }
        }
      }
      if (i2 === this.labels.length) {
        this.raise(node2.start, "Unsyntactic " + keyword);
      }
      return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
    };
    pp$8.parseDebuggerStatement = function(node2) {
      this.next();
      this.semicolon();
      return this.finishNode(node2, "DebuggerStatement");
    };
    pp$8.parseDoStatement = function(node2) {
      this.next();
      this.labels.push(loopLabel);
      node2.body = this.parseStatement("do");
      this.labels.pop();
      this.expect(types$1._while);
      node2.test = this.parseParenExpression();
      if (this.options.ecmaVersion >= 6) {
        this.eat(types$1.semi);
      } else {
        this.semicolon();
      }
      return this.finishNode(node2, "DoWhileStatement");
    };
    pp$8.parseForStatement = function(node2) {
      this.next();
      var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
      this.labels.push(loopLabel);
      this.enterScope(0);
      this.expect(types$1.parenL);
      if (this.type === types$1.semi) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node2, null);
      }
      var isLet = this.isLet();
      if (this.type === types$1._var || this.type === types$1._const || isLet) {
        var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
        this.next();
        this.parseVar(init$1, true, kind);
        this.finishNode(init$1, "VariableDeclaration");
        if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$1._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node2.await = awaitAt > -1;
            }
          }
          return this.parseForIn(node2, init$1);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node2, init$1);
      }
      var startsWithLet = this.isContextual("let"), isForOf = false;
      var refDestructuringErrors = new DestructuringErrors();
      var init2 = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
      if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types$1._in) {
            if (awaitAt > -1) {
              this.unexpected(awaitAt);
            }
          } else {
            node2.await = awaitAt > -1;
          }
        }
        if (startsWithLet && isForOf) {
          this.raise(init2.start, "The left-hand side of a for-of loop may not start with 'let'.");
        }
        this.toAssignable(init2, false, refDestructuringErrors);
        this.checkLValPattern(init2);
        return this.parseForIn(node2, init2);
      } else {
        this.checkExpressionErrors(refDestructuringErrors, true);
      }
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node2, init2);
    };
    pp$8.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
    };
    pp$8.parseIfStatement = function(node2) {
      this.next();
      node2.test = this.parseParenExpression();
      node2.consequent = this.parseStatement("if");
      node2.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
      return this.finishNode(node2, "IfStatement");
    };
    pp$8.parseReturnStatement = function(node2) {
      if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
        this.raise(this.start, "'return' outside of function");
      }
      this.next();
      if (this.eat(types$1.semi) || this.insertSemicolon()) {
        node2.argument = null;
      } else {
        node2.argument = this.parseExpression();
        this.semicolon();
      }
      return this.finishNode(node2, "ReturnStatement");
    };
    pp$8.parseSwitchStatement = function(node2) {
      this.next();
      node2.discriminant = this.parseParenExpression();
      node2.cases = [];
      this.expect(types$1.braceL);
      this.labels.push(switchLabel);
      this.enterScope(0);
      var cur;
      for (var sawDefault = false; this.type !== types$1.braceR; ) {
        if (this.type === types$1._case || this.type === types$1._default) {
          var isCase = this.type === types$1._case;
          if (cur) {
            this.finishNode(cur, "SwitchCase");
          }
          node2.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
            }
            sawDefault = true;
            cur.test = null;
          }
          this.expect(types$1.colon);
        } else {
          if (!cur) {
            this.unexpected();
          }
          cur.consequent.push(this.parseStatement(null));
        }
      }
      this.exitScope();
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      this.next();
      this.labels.pop();
      return this.finishNode(node2, "SwitchStatement");
    };
    pp$8.parseThrowStatement = function(node2) {
      this.next();
      if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
        this.raise(this.lastTokEnd, "Illegal newline after throw");
      }
      node2.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node2, "ThrowStatement");
    };
    var empty$1 = [];
    pp$8.parseTryStatement = function(node2) {
      this.next();
      node2.block = this.parseBlock();
      node2.handler = null;
      if (this.type === types$1._catch) {
        var clause = this.startNode();
        this.next();
        if (this.eat(types$1.parenL)) {
          clause.param = this.parseBindingAtom();
          var simple = clause.param.type === "Identifier";
          this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
          this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
          this.expect(types$1.parenR);
        } else {
          if (this.options.ecmaVersion < 10) {
            this.unexpected();
          }
          clause.param = null;
          this.enterScope(0);
        }
        clause.body = this.parseBlock(false);
        this.exitScope();
        node2.handler = this.finishNode(clause, "CatchClause");
      }
      node2.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
      if (!node2.handler && !node2.finalizer) {
        this.raise(node2.start, "Missing catch or finally clause");
      }
      return this.finishNode(node2, "TryStatement");
    };
    pp$8.parseVarStatement = function(node2, kind) {
      this.next();
      this.parseVar(node2, false, kind);
      this.semicolon();
      return this.finishNode(node2, "VariableDeclaration");
    };
    pp$8.parseWhileStatement = function(node2) {
      this.next();
      node2.test = this.parseParenExpression();
      this.labels.push(loopLabel);
      node2.body = this.parseStatement("while");
      this.labels.pop();
      return this.finishNode(node2, "WhileStatement");
    };
    pp$8.parseWithStatement = function(node2) {
      if (this.strict) {
        this.raise(this.start, "'with' in strict mode");
      }
      this.next();
      node2.object = this.parseParenExpression();
      node2.body = this.parseStatement("with");
      return this.finishNode(node2, "WithStatement");
    };
    pp$8.parseEmptyStatement = function(node2) {
      this.next();
      return this.finishNode(node2, "EmptyStatement");
    };
    pp$8.parseLabeledStatement = function(node2, maybeName, expr, context2) {
      for (var i$12 = 0, list2 = this.labels; i$12 < list2.length; i$12 += 1) {
        var label = list2[i$12];
        if (label.name === maybeName) {
          this.raise(expr.start, "Label '" + maybeName + "' is already declared");
        }
      }
      var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
      for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
        var label$1 = this.labels[i2];
        if (label$1.statementStart === node2.start) {
          label$1.statementStart = this.start;
          label$1.kind = kind;
        } else {
          break;
        }
      }
      this.labels.push({ name: maybeName, kind, statementStart: this.start });
      node2.body = this.parseStatement(context2 ? context2.indexOf("label") === -1 ? context2 + "label" : context2 : "label");
      this.labels.pop();
      node2.label = expr;
      return this.finishNode(node2, "LabeledStatement");
    };
    pp$8.parseExpressionStatement = function(node2, expr) {
      node2.expression = expr;
      this.semicolon();
      return this.finishNode(node2, "ExpressionStatement");
    };
    pp$8.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
      if (createNewLexicalScope === void 0)
        createNewLexicalScope = true;
      if (node2 === void 0)
        node2 = this.startNode();
      node2.body = [];
      this.expect(types$1.braceL);
      if (createNewLexicalScope) {
        this.enterScope(0);
      }
      while (this.type !== types$1.braceR) {
        var stmt = this.parseStatement(null);
        node2.body.push(stmt);
      }
      if (exitStrict) {
        this.strict = false;
      }
      this.next();
      if (createNewLexicalScope) {
        this.exitScope();
      }
      return this.finishNode(node2, "BlockStatement");
    };
    pp$8.parseFor = function(node2, init2) {
      node2.init = init2;
      this.expect(types$1.semi);
      node2.test = this.type === types$1.semi ? null : this.parseExpression();
      this.expect(types$1.semi);
      node2.update = this.type === types$1.parenR ? null : this.parseExpression();
      this.expect(types$1.parenR);
      node2.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node2, "ForStatement");
    };
    pp$8.parseForIn = function(node2, init2) {
      var isForIn = this.type === types$1._in;
      this.next();
      if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
        this.raise(init2.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
      }
      node2.left = init2;
      node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
      this.expect(types$1.parenR);
      node2.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
    };
    pp$8.parseVar = function(node2, isFor, kind) {
      node2.declarations = [];
      node2.kind = kind;
      for (; ; ) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);
        if (this.eat(types$1.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else if (kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          this.unexpected();
        } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
          this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
        } else {
          decl.init = null;
        }
        node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types$1.comma)) {
          break;
        }
      }
      return node2;
    };
    pp$8.parseVarId = function(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
    };
    var FUNC_STATEMENT = 1;
    var FUNC_HANGING_STATEMENT = 2;
    var FUNC_NULLABLE_ID = 4;
    pp$8.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
      this.initFunction(node2);
      if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
        if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
          this.unexpected();
        }
        node2.generator = this.eat(types$1.star);
      }
      if (this.options.ecmaVersion >= 8) {
        node2.async = !!isAsync;
      }
      if (statement & FUNC_STATEMENT) {
        node2.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
        if (node2.id && !(statement & FUNC_HANGING_STATEMENT)) {
          this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
        }
      }
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(node2.async, node2.generator));
      if (!(statement & FUNC_STATEMENT)) {
        node2.id = this.type === types$1.name ? this.parseIdent() : null;
      }
      this.parseFunctionParams(node2);
      this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node2, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
    };
    pp$8.parseFunctionParams = function(node2) {
      this.expect(types$1.parenL);
      node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
    };
    pp$8.parseClass = function(node2, isStatement) {
      this.next();
      var oldStrict = this.strict;
      this.strict = true;
      this.parseClassId(node2, isStatement);
      this.parseClassSuper(node2);
      var privateNameMap = this.enterClassBody();
      var classBody = this.startNode();
      var hadConstructor = false;
      classBody.body = [];
      this.expect(types$1.braceL);
      while (this.type !== types$1.braceR) {
        var element = this.parseClassElement(node2.superClass !== null);
        if (element) {
          classBody.body.push(element);
          if (element.type === "MethodDefinition" && element.kind === "constructor") {
            if (hadConstructor) {
              this.raise(element.start, "Duplicate constructor in the same class");
            }
            hadConstructor = true;
          } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
            this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
          }
        }
      }
      this.strict = oldStrict;
      this.next();
      node2.body = this.finishNode(classBody, "ClassBody");
      this.exitClassBody();
      return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
    };
    pp$8.parseClassElement = function(constructorAllowsSuper) {
      if (this.eat(types$1.semi)) {
        return null;
      }
      var ecmaVersion2 = this.options.ecmaVersion;
      var node2 = this.startNode();
      var keyName = "";
      var isGenerator = false;
      var isAsync = false;
      var kind = "method";
      var isStatic = false;
      if (this.eatContextual("static")) {
        if (ecmaVersion2 >= 13 && this.eat(types$1.braceL)) {
          this.parseClassStaticBlock(node2);
          return node2;
        }
        if (this.isClassElementNameStart() || this.type === types$1.star) {
          isStatic = true;
        } else {
          keyName = "static";
        }
      }
      node2.static = isStatic;
      if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
        if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
          isAsync = true;
        } else {
          keyName = "async";
        }
      }
      if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$1.star)) {
        isGenerator = true;
      }
      if (!keyName && !isAsync && !isGenerator) {
        var lastValue = this.value;
        if (this.eatContextual("get") || this.eatContextual("set")) {
          if (this.isClassElementNameStart()) {
            kind = lastValue;
          } else {
            keyName = lastValue;
          }
        }
      }
      if (keyName) {
        node2.computed = false;
        node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
        node2.key.name = keyName;
        this.finishNode(node2.key, "Identifier");
      } else {
        this.parseClassElementName(node2);
      }
      if (ecmaVersion2 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
        var isConstructor = !node2.static && checkKeyName(node2, "constructor");
        var allowsDirectSuper = isConstructor && constructorAllowsSuper;
        if (isConstructor && kind !== "method") {
          this.raise(node2.key.start, "Constructor can't have get/set modifier");
        }
        node2.kind = isConstructor ? "constructor" : kind;
        this.parseClassMethod(node2, isGenerator, isAsync, allowsDirectSuper);
      } else {
        this.parseClassField(node2);
      }
      return node2;
    };
    pp$8.isClassElementNameStart = function() {
      return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
    };
    pp$8.parseClassElementName = function(element) {
      if (this.type === types$1.privateId) {
        if (this.value === "constructor") {
          this.raise(this.start, "Classes can't have an element named '#constructor'");
        }
        element.computed = false;
        element.key = this.parsePrivateIdent();
      } else {
        this.parsePropertyName(element);
      }
    };
    pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
      var key = method.key;
      if (method.kind === "constructor") {
        if (isGenerator) {
          this.raise(key.start, "Constructor can't be a generator");
        }
        if (isAsync) {
          this.raise(key.start, "Constructor can't be an async method");
        }
      } else if (method.static && checkKeyName(method, "prototype")) {
        this.raise(key.start, "Classes may not have a static property named prototype");
      }
      var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
      if (method.kind === "get" && value.params.length !== 0) {
        this.raiseRecoverable(value.start, "getter should have no params");
      }
      if (method.kind === "set" && value.params.length !== 1) {
        this.raiseRecoverable(value.start, "setter should have exactly one param");
      }
      if (method.kind === "set" && value.params[0].type === "RestElement") {
        this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
      }
      return this.finishNode(method, "MethodDefinition");
    };
    pp$8.parseClassField = function(field) {
      if (checkKeyName(field, "constructor")) {
        this.raise(field.key.start, "Classes can't have a field named 'constructor'");
      } else if (field.static && checkKeyName(field, "prototype")) {
        this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
      }
      if (this.eat(types$1.eq)) {
        var scope = this.currentThisScope();
        var inClassFieldInit = scope.inClassFieldInit;
        scope.inClassFieldInit = true;
        field.value = this.parseMaybeAssign();
        scope.inClassFieldInit = inClassFieldInit;
      } else {
        field.value = null;
      }
      this.semicolon();
      return this.finishNode(field, "PropertyDefinition");
    };
    pp$8.parseClassStaticBlock = function(node2) {
      node2.body = [];
      var oldLabels = this.labels;
      this.labels = [];
      this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
      while (this.type !== types$1.braceR) {
        var stmt = this.parseStatement(null);
        node2.body.push(stmt);
      }
      this.next();
      this.exitScope();
      this.labels = oldLabels;
      return this.finishNode(node2, "StaticBlock");
    };
    pp$8.parseClassId = function(node2, isStatement) {
      if (this.type === types$1.name) {
        node2.id = this.parseIdent();
        if (isStatement) {
          this.checkLValSimple(node2.id, BIND_LEXICAL, false);
        }
      } else {
        if (isStatement === true) {
          this.unexpected();
        }
        node2.id = null;
      }
    };
    pp$8.parseClassSuper = function(node2) {
      node2.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(false) : null;
    };
    pp$8.enterClassBody = function() {
      var element = { declared: Object.create(null), used: [] };
      this.privateNameStack.push(element);
      return element.declared;
    };
    pp$8.exitClassBody = function() {
      var ref2 = this.privateNameStack.pop();
      var declared = ref2.declared;
      var used = ref2.used;
      var len = this.privateNameStack.length;
      var parent = len === 0 ? null : this.privateNameStack[len - 1];
      for (var i2 = 0; i2 < used.length; ++i2) {
        var id = used[i2];
        if (!hasOwn(declared, id.name)) {
          if (parent) {
            parent.used.push(id);
          } else {
            this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
          }
        }
      }
    };
    function isPrivateNameConflicted(privateNameMap, element) {
      var name = element.key.name;
      var curr = privateNameMap[name];
      var next = "true";
      if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
        next = (element.static ? "s" : "i") + element.kind;
      }
      if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
        privateNameMap[name] = "true";
        return false;
      } else if (!curr) {
        privateNameMap[name] = next;
        return false;
      } else {
        return true;
      }
    }
    function checkKeyName(node2, name) {
      var computed = node2.computed;
      var key = node2.key;
      return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
    }
    pp$8.parseExport = function(node2, exports2) {
      this.next();
      if (this.eat(types$1.star)) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node2.exported = this.parseModuleExportName();
            this.checkExport(exports2, node2.exported.name, this.lastTokStart);
          } else {
            node2.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node2.source = this.parseExprAtom();
        this.semicolon();
        return this.finishNode(node2, "ExportAllDeclaration");
      }
      if (this.eat(types$1._default)) {
        this.checkExport(exports2, "default", this.lastTokStart);
        var isAsync;
        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          node2.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types$1._class) {
          var cNode = this.startNode();
          node2.declaration = this.parseClass(cNode, "nullableID");
        } else {
          node2.declaration = this.parseMaybeAssign();
          this.semicolon();
        }
        return this.finishNode(node2, "ExportDefaultDeclaration");
      }
      if (this.shouldParseExportStatement()) {
        node2.declaration = this.parseStatement(null);
        if (node2.declaration.type === "VariableDeclaration") {
          this.checkVariableExport(exports2, node2.declaration.declarations);
        } else {
          this.checkExport(exports2, node2.declaration.id.name, node2.declaration.id.start);
        }
        node2.specifiers = [];
        node2.source = null;
      } else {
        node2.declaration = null;
        node2.specifiers = this.parseExportSpecifiers(exports2);
        if (this.eatContextual("from")) {
          if (this.type !== types$1.string) {
            this.unexpected();
          }
          node2.source = this.parseExprAtom();
        } else {
          for (var i2 = 0, list2 = node2.specifiers; i2 < list2.length; i2 += 1) {
            var spec = list2[i2];
            this.checkUnreserved(spec.local);
            this.checkLocalExport(spec.local);
            if (spec.local.type === "Literal") {
              this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
            }
          }
          node2.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(node2, "ExportNamedDeclaration");
    };
    pp$8.checkExport = function(exports2, name, pos) {
      if (!exports2) {
        return;
      }
      if (hasOwn(exports2, name)) {
        this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
      }
      exports2[name] = true;
    };
    pp$8.checkPatternExport = function(exports2, pat) {
      var type = pat.type;
      if (type === "Identifier") {
        this.checkExport(exports2, pat.name, pat.start);
      } else if (type === "ObjectPattern") {
        for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
          var prop = list2[i2];
          this.checkPatternExport(exports2, prop);
        }
      } else if (type === "ArrayPattern") {
        for (var i$12 = 0, list$12 = pat.elements; i$12 < list$12.length; i$12 += 1) {
          var elt = list$12[i$12];
          if (elt) {
            this.checkPatternExport(exports2, elt);
          }
        }
      } else if (type === "Property") {
        this.checkPatternExport(exports2, pat.value);
      } else if (type === "AssignmentPattern") {
        this.checkPatternExport(exports2, pat.left);
      } else if (type === "RestElement") {
        this.checkPatternExport(exports2, pat.argument);
      } else if (type === "ParenthesizedExpression") {
        this.checkPatternExport(exports2, pat.expression);
      }
    };
    pp$8.checkVariableExport = function(exports2, decls) {
      if (!exports2) {
        return;
      }
      for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
        var decl = list2[i2];
        this.checkPatternExport(exports2, decl.id);
      }
    };
    pp$8.shouldParseExportStatement = function() {
      return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
    };
    pp$8.parseExportSpecifiers = function(exports2) {
      var nodes = [], first2 = true;
      this.expect(types$1.braceL);
      while (!this.eat(types$1.braceR)) {
        if (!first2) {
          this.expect(types$1.comma);
          if (this.afterTrailingComma(types$1.braceR)) {
            break;
          }
        } else {
          first2 = false;
        }
        var node2 = this.startNode();
        node2.local = this.parseModuleExportName();
        node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
        this.checkExport(exports2, node2.exported[node2.exported.type === "Identifier" ? "name" : "value"], node2.exported.start);
        nodes.push(this.finishNode(node2, "ExportSpecifier"));
      }
      return nodes;
    };
    pp$8.parseImport = function(node2) {
      this.next();
      if (this.type === types$1.string) {
        node2.specifiers = empty$1;
        node2.source = this.parseExprAtom();
      } else {
        node2.specifiers = this.parseImportSpecifiers();
        this.expectContextual("from");
        node2.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
      }
      this.semicolon();
      return this.finishNode(node2, "ImportDeclaration");
    };
    pp$8.parseImportSpecifiers = function() {
      var nodes = [], first2 = true;
      if (this.type === types$1.name) {
        var node2 = this.startNode();
        node2.local = this.parseIdent();
        this.checkLValSimple(node2.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node2, "ImportDefaultSpecifier"));
        if (!this.eat(types$1.comma)) {
          return nodes;
        }
      }
      if (this.type === types$1.star) {
        var node$12 = this.startNode();
        this.next();
        this.expectContextual("as");
        node$12.local = this.parseIdent();
        this.checkLValSimple(node$12.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$12, "ImportNamespaceSpecifier"));
        return nodes;
      }
      this.expect(types$1.braceL);
      while (!this.eat(types$1.braceR)) {
        if (!first2) {
          this.expect(types$1.comma);
          if (this.afterTrailingComma(types$1.braceR)) {
            break;
          }
        } else {
          first2 = false;
        }
        var node$2 = this.startNode();
        node$2.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          node$2.local = this.parseIdent();
        } else {
          this.checkUnreserved(node$2.imported);
          node$2.local = node$2.imported;
        }
        this.checkLValSimple(node$2.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$2, "ImportSpecifier"));
      }
      return nodes;
    };
    pp$8.parseModuleExportName = function() {
      if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
        var stringLiteral = this.parseLiteral(this.value);
        if (loneSurrogate.test(stringLiteral.value)) {
          this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
        }
        return stringLiteral;
      }
      return this.parseIdent(true);
    };
    pp$8.adaptDirectivePrologue = function(statements) {
      for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
        statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
      }
    };
    pp$8.isDirectiveCandidate = function(statement) {
      return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
    };
    var pp$7 = Parser.prototype;
    pp$7.toAssignable = function(node2, isBinding, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 6 && node2) {
        switch (node2.type) {
          case "Identifier":
            if (this.inAsync && node2.name === "await") {
              this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
            }
            break;
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node2.type = "ObjectPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            for (var i2 = 0, list2 = node2.properties; i2 < list2.length; i2 += 1) {
              var prop = list2[i2];
              this.toAssignable(prop, isBinding);
              if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                this.raise(prop.argument.start, "Unexpected token");
              }
            }
            break;
          case "Property":
            if (node2.kind !== "init") {
              this.raise(node2.key.start, "Object pattern can't contain getter or setter");
            }
            this.toAssignable(node2.value, isBinding);
            break;
          case "ArrayExpression":
            node2.type = "ArrayPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            this.toAssignableList(node2.elements, isBinding);
            break;
          case "SpreadElement":
            node2.type = "RestElement";
            this.toAssignable(node2.argument, isBinding);
            if (node2.argument.type === "AssignmentPattern") {
              this.raise(node2.argument.start, "Rest elements cannot have a default value");
            }
            break;
          case "AssignmentExpression":
            if (node2.operator !== "=") {
              this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
            }
            node2.type = "AssignmentPattern";
            delete node2.operator;
            this.toAssignable(node2.left, isBinding);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
            break;
          case "ChainExpression":
            this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (!isBinding) {
              break;
            }
          default:
            this.raise(node2.start, "Assigning to rvalue");
        }
      } else if (refDestructuringErrors) {
        this.checkPatternErrors(refDestructuringErrors, true);
      }
      return node2;
    };
    pp$7.toAssignableList = function(exprList, isBinding) {
      var end = exprList.length;
      for (var i2 = 0; i2 < end; i2++) {
        var elt = exprList[i2];
        if (elt) {
          this.toAssignable(elt, isBinding);
        }
      }
      if (end) {
        var last = exprList[end - 1];
        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
          this.unexpected(last.argument.start);
        }
      }
      return exprList;
    };
    pp$7.parseSpread = function(refDestructuringErrors) {
      var node2 = this.startNode();
      this.next();
      node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      return this.finishNode(node2, "SpreadElement");
    };
    pp$7.parseRestBinding = function() {
      var node2 = this.startNode();
      this.next();
      if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
        this.unexpected();
      }
      node2.argument = this.parseBindingAtom();
      return this.finishNode(node2, "RestElement");
    };
    pp$7.parseBindingAtom = function() {
      if (this.options.ecmaVersion >= 6) {
        switch (this.type) {
          case types$1.bracketL:
            var node2 = this.startNode();
            this.next();
            node2.elements = this.parseBindingList(types$1.bracketR, true, true);
            return this.finishNode(node2, "ArrayPattern");
          case types$1.braceL:
            return this.parseObj(true);
        }
      }
      return this.parseIdent();
    };
    pp$7.parseBindingList = function(close2, allowEmpty, allowTrailingComma) {
      var elts = [], first2 = true;
      while (!this.eat(close2)) {
        if (first2) {
          first2 = false;
        } else {
          this.expect(types$1.comma);
        }
        if (allowEmpty && this.type === types$1.comma) {
          elts.push(null);
        } else if (allowTrailingComma && this.afterTrailingComma(close2)) {
          break;
        } else if (this.type === types$1.ellipsis) {
          var rest = this.parseRestBinding();
          this.parseBindingListItem(rest);
          elts.push(rest);
          if (this.type === types$1.comma) {
            this.raise(this.start, "Comma is not permitted after the rest element");
          }
          this.expect(close2);
          break;
        } else {
          var elem = this.parseMaybeDefault(this.start, this.startLoc);
          this.parseBindingListItem(elem);
          elts.push(elem);
        }
      }
      return elts;
    };
    pp$7.parseBindingListItem = function(param) {
      return param;
    };
    pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
      left = left || this.parseBindingAtom();
      if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
        return left;
      }
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.left = left;
      node2.right = this.parseMaybeAssign();
      return this.finishNode(node2, "AssignmentPattern");
    };
    pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE;
      var isBind = bindingType !== BIND_NONE;
      switch (expr.type) {
        case "Identifier":
          if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
            this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
          }
          if (isBind) {
            if (bindingType === BIND_LEXICAL && expr.name === "let") {
              this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
            }
            if (checkClashes) {
              if (hasOwn(checkClashes, expr.name)) {
                this.raiseRecoverable(expr.start, "Argument name clash");
              }
              checkClashes[expr.name] = true;
            }
            if (bindingType !== BIND_OUTSIDE) {
              this.declareName(expr.name, bindingType, expr.start);
            }
          }
          break;
        case "ChainExpression":
          this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding member expression");
          }
          break;
        case "ParenthesizedExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding parenthesized expression");
          }
          return this.checkLValSimple(expr.expression, bindingType, checkClashes);
        default:
          this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
      }
    };
    pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE;
      switch (expr.type) {
        case "ObjectPattern":
          for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
            var prop = list2[i2];
            this.checkLValInnerPattern(prop, bindingType, checkClashes);
          }
          break;
        case "ArrayPattern":
          for (var i$12 = 0, list$12 = expr.elements; i$12 < list$12.length; i$12 += 1) {
            var elem = list$12[i$12];
            if (elem) {
              this.checkLValInnerPattern(elem, bindingType, checkClashes);
            }
          }
          break;
        default:
          this.checkLValSimple(expr, bindingType, checkClashes);
      }
    };
    pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0)
        bindingType = BIND_NONE;
      switch (expr.type) {
        case "Property":
          this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
          break;
        case "AssignmentPattern":
          this.checkLValPattern(expr.left, bindingType, checkClashes);
          break;
        case "RestElement":
          this.checkLValPattern(expr.argument, bindingType, checkClashes);
          break;
        default:
          this.checkLValPattern(expr, bindingType, checkClashes);
      }
    };
    var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
      this.generator = !!generator;
    };
    var types = {
      b_stat: new TokContext("{", false),
      b_expr: new TokContext("{", true),
      b_tmpl: new TokContext("${", false),
      p_stat: new TokContext("(", false),
      p_expr: new TokContext("(", true),
      q_tmpl: new TokContext("`", true, true, function(p2) {
        return p2.tryReadTemplateToken();
      }),
      f_stat: new TokContext("function", false),
      f_expr: new TokContext("function", true),
      f_expr_gen: new TokContext("function", true, false, null, true),
      f_gen: new TokContext("function", false, false, null, true)
    };
    var pp$6 = Parser.prototype;
    pp$6.initialContext = function() {
      return [types.b_stat];
    };
    pp$6.curContext = function() {
      return this.context[this.context.length - 1];
    };
    pp$6.braceIsBlock = function(prevType) {
      var parent = this.curContext();
      if (parent === types.f_expr || parent === types.f_stat) {
        return true;
      }
      if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
        return !parent.isExpr;
      }
      if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
        return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      }
      if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
        return true;
      }
      if (prevType === types$1.braceL) {
        return parent === types.b_stat;
      }
      if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
        return false;
      }
      return !this.exprAllowed;
    };
    pp$6.inGeneratorContext = function() {
      for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
        var context2 = this.context[i2];
        if (context2.token === "function") {
          return context2.generator;
        }
      }
      return false;
    };
    pp$6.updateContext = function(prevType) {
      var update, type = this.type;
      if (type.keyword && prevType === types$1.dot) {
        this.exprAllowed = false;
      } else if (update = type.updateContext) {
        update.call(this, prevType);
      } else {
        this.exprAllowed = type.beforeExpr;
      }
    };
    pp$6.overrideContext = function(tokenCtx) {
      if (this.curContext() !== tokenCtx) {
        this.context[this.context.length - 1] = tokenCtx;
      }
    };
    types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
      if (this.context.length === 1) {
        this.exprAllowed = true;
        return;
      }
      var out2 = this.context.pop();
      if (out2 === types.b_stat && this.curContext().token === "function") {
        out2 = this.context.pop();
      }
      this.exprAllowed = !out2.isExpr;
    };
    types$1.braceL.updateContext = function(prevType) {
      this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
      this.exprAllowed = true;
    };
    types$1.dollarBraceL.updateContext = function() {
      this.context.push(types.b_tmpl);
      this.exprAllowed = true;
    };
    types$1.parenL.updateContext = function(prevType) {
      var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
      this.context.push(statementParens ? types.p_stat : types.p_expr);
      this.exprAllowed = true;
    };
    types$1.incDec.updateContext = function() {
    };
    types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
      if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
        this.context.push(types.f_expr);
      } else {
        this.context.push(types.f_stat);
      }
      this.exprAllowed = false;
    };
    types$1.backQuote.updateContext = function() {
      if (this.curContext() === types.q_tmpl) {
        this.context.pop();
      } else {
        this.context.push(types.q_tmpl);
      }
      this.exprAllowed = false;
    };
    types$1.star.updateContext = function(prevType) {
      if (prevType === types$1._function) {
        var index2 = this.context.length - 1;
        if (this.context[index2] === types.f_expr) {
          this.context[index2] = types.f_expr_gen;
        } else {
          this.context[index2] = types.f_gen;
        }
      }
      this.exprAllowed = true;
    };
    types$1.name.updateContext = function(prevType) {
      var allowed = false;
      if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
        if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
          allowed = true;
        }
      }
      this.exprAllowed = allowed;
    };
    var pp$5 = Parser.prototype;
    pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
        return;
      }
      if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
        return;
      }
      var key = prop.key;
      var name;
      switch (key.type) {
        case "Identifier":
          name = key.name;
          break;
        case "Literal":
          name = String(key.value);
          break;
        default:
          return;
      }
      var kind = prop.kind;
      if (this.options.ecmaVersion >= 6) {
        if (name === "__proto__" && kind === "init") {
          if (propHash.proto) {
            if (refDestructuringErrors) {
              if (refDestructuringErrors.doubleProto < 0) {
                refDestructuringErrors.doubleProto = key.start;
              }
            } else {
              this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
            }
          }
          propHash.proto = true;
        }
        return;
      }
      name = "$" + name;
      var other = propHash[name];
      if (other) {
        var redefinition;
        if (kind === "init") {
          redefinition = this.strict && other.init || other.get || other.set;
        } else {
          redefinition = other.init || other[kind];
        }
        if (redefinition) {
          this.raiseRecoverable(key.start, "Redefinition of property");
        }
      } else {
        other = propHash[name] = {
          init: false,
          get: false,
          set: false
        };
      }
      other[kind] = true;
    };
    pp$5.parseExpression = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
      if (this.type === types$1.comma) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.expressions = [expr];
        while (this.eat(types$1.comma)) {
          node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
        }
        return this.finishNode(node2, "SequenceExpression");
      }
      return expr;
    };
    pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
      if (this.isContextual("yield")) {
        if (this.inGenerator) {
          return this.parseYield(forInit);
        } else {
          this.exprAllowed = false;
        }
      }
      var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
      if (refDestructuringErrors) {
        oldParenAssign = refDestructuringErrors.parenthesizedAssign;
        oldTrailingComma = refDestructuringErrors.trailingComma;
        oldDoubleProto = refDestructuringErrors.doubleProto;
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
      } else {
        refDestructuringErrors = new DestructuringErrors();
        ownDestructuringErrors = true;
      }
      var startPos = this.start, startLoc = this.startLoc;
      if (this.type === types$1.parenL || this.type === types$1.name) {
        this.potentialArrowAt = this.start;
        this.potentialArrowInForAwait = forInit === "await";
      }
      var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }
      if (this.type.isAssign) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.operator = this.value;
        if (this.type === types$1.eq) {
          left = this.toAssignable(left, false, refDestructuringErrors);
        }
        if (!ownDestructuringErrors) {
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
        }
        if (refDestructuringErrors.shorthandAssign >= left.start) {
          refDestructuringErrors.shorthandAssign = -1;
        }
        if (this.type === types$1.eq) {
          this.checkLValPattern(left);
        } else {
          this.checkLValSimple(left);
        }
        node2.left = left;
        this.next();
        node2.right = this.parseMaybeAssign(forInit);
        if (oldDoubleProto > -1) {
          refDestructuringErrors.doubleProto = oldDoubleProto;
        }
        return this.finishNode(node2, "AssignmentExpression");
      } else {
        if (ownDestructuringErrors) {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
      }
      if (oldParenAssign > -1) {
        refDestructuringErrors.parenthesizedAssign = oldParenAssign;
      }
      if (oldTrailingComma > -1) {
        refDestructuringErrors.trailingComma = oldTrailingComma;
      }
      return left;
    };
    pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprOps(forInit, refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      if (this.eat(types$1.question)) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.test = expr;
        node2.consequent = this.parseMaybeAssign();
        this.expect(types$1.colon);
        node2.alternate = this.parseMaybeAssign(forInit);
        return this.finishNode(node2, "ConditionalExpression");
      }
      return expr;
    };
    pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
    };
    pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
      var prec = this.type.binop;
      if (prec != null && (!forInit || this.type !== types$1._in)) {
        if (prec > minPrec) {
          var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
          var coalesce = this.type === types$1.coalesce;
          if (coalesce) {
            prec = types$1.logicalAND.binop;
          }
          var op = this.value;
          this.next();
          var startPos = this.start, startLoc = this.startLoc;
          var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
          var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
          if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
            this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
          }
          return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
        }
      }
      return left;
    };
    pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
      if (right.type === "PrivateIdentifier") {
        this.raise(right.start, "Private identifier can only be left side of binary expression");
      }
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.left = left;
      node2.operator = op;
      node2.right = right;
      return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
    };
    pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
      var startPos = this.start, startLoc = this.startLoc, expr;
      if (this.isContextual("await") && this.canAwait) {
        expr = this.parseAwait(forInit);
        sawUnary = true;
      } else if (this.type.prefix) {
        var node2 = this.startNode(), update = this.type === types$1.incDec;
        node2.operator = this.value;
        node2.prefix = true;
        this.next();
        node2.argument = this.parseMaybeUnary(null, true, update, forInit);
        this.checkExpressionErrors(refDestructuringErrors, true);
        if (update) {
          this.checkLValSimple(node2.argument);
        } else if (this.strict && node2.operator === "delete" && node2.argument.type === "Identifier") {
          this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
        } else if (node2.operator === "delete" && isPrivateFieldAccess(node2.argument)) {
          this.raiseRecoverable(node2.start, "Private fields can not be deleted");
        } else {
          sawUnary = true;
        }
        expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
      } else if (!sawUnary && this.type === types$1.privateId) {
        if (forInit || this.privateNameStack.length === 0) {
          this.unexpected();
        }
        expr = this.parsePrivateIdent();
        if (this.type !== types$1._in) {
          this.unexpected();
        }
      } else {
        expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        while (this.type.postfix && !this.canInsertSemicolon()) {
          var node$12 = this.startNodeAt(startPos, startLoc);
          node$12.operator = this.value;
          node$12.prefix = false;
          node$12.argument = expr;
          this.checkLValSimple(expr);
          this.next();
          expr = this.finishNode(node$12, "UpdateExpression");
        }
      }
      if (!incDec && this.eat(types$1.starstar)) {
        if (sawUnary) {
          this.unexpected(this.lastTokStart);
        } else {
          return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
        }
      } else {
        return expr;
      }
    };
    function isPrivateFieldAccess(node2) {
      return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess(node2.expression);
    }
    pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprAtom(refDestructuringErrors, forInit);
      if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
        return expr;
      }
      var result2 = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
      if (refDestructuringErrors && result2.type === "MemberExpression") {
        if (refDestructuringErrors.parenthesizedAssign >= result2.start) {
          refDestructuringErrors.parenthesizedAssign = -1;
        }
        if (refDestructuringErrors.parenthesizedBind >= result2.start) {
          refDestructuringErrors.parenthesizedBind = -1;
        }
        if (refDestructuringErrors.trailingComma >= result2.start) {
          refDestructuringErrors.trailingComma = -1;
        }
      }
      return result2;
    };
    pp$5.parseSubscripts = function(base2, startPos, startLoc, noCalls, forInit) {
      var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base2.type === "Identifier" && base2.name === "async" && this.lastTokEnd === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.potentialArrowAt === base2.start;
      var optionalChained = false;
      while (true) {
        var element = this.parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
        if (element.optional) {
          optionalChained = true;
        }
        if (element === base2 || element.type === "ArrowFunctionExpression") {
          if (optionalChained) {
            var chainNode = this.startNodeAt(startPos, startLoc);
            chainNode.expression = element;
            element = this.finishNode(chainNode, "ChainExpression");
          }
          return element;
        }
        base2 = element;
      }
    };
    pp$5.parseSubscript = function(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
      var optionalSupported = this.options.ecmaVersion >= 11;
      var optional = optionalSupported && this.eat(types$1.questionDot);
      if (noCalls && optional) {
        this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
      }
      var computed = this.eat(types$1.bracketL);
      if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.object = base2;
        if (computed) {
          node2.property = this.parseExpression();
          this.expect(types$1.bracketR);
        } else if (this.type === types$1.privateId && base2.type !== "Super") {
          node2.property = this.parsePrivateIdent();
        } else {
          node2.property = this.parseIdent(this.options.allowReserved !== "never");
        }
        node2.computed = !!computed;
        if (optionalSupported) {
          node2.optional = optional;
        }
        base2 = this.finishNode(node2, "MemberExpression");
      } else if (!noCalls && this.eat(types$1.parenL)) {
        var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
        if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          if (this.awaitIdentPos > 0) {
            this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
          }
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
        var node$12 = this.startNodeAt(startPos, startLoc);
        node$12.callee = base2;
        node$12.arguments = exprList;
        if (optionalSupported) {
          node$12.optional = optional;
        }
        base2 = this.finishNode(node$12, "CallExpression");
      } else if (this.type === types$1.backQuote) {
        if (optional || optionalChained) {
          this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
        }
        var node$2 = this.startNodeAt(startPos, startLoc);
        node$2.tag = base2;
        node$2.quasi = this.parseTemplate({ isTagged: true });
        base2 = this.finishNode(node$2, "TaggedTemplateExpression");
      }
      return base2;
    };
    pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
      if (this.type === types$1.slash) {
        this.readRegexp();
      }
      var node2, canBeArrow = this.potentialArrowAt === this.start;
      switch (this.type) {
        case types$1._super:
          if (!this.allowSuper) {
            this.raise(this.start, "'super' keyword outside a method");
          }
          node2 = this.startNode();
          this.next();
          if (this.type === types$1.parenL && !this.allowDirectSuper) {
            this.raise(node2.start, "super() call outside constructor of a subclass");
          }
          if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
            this.unexpected();
          }
          return this.finishNode(node2, "Super");
        case types$1._this:
          node2 = this.startNode();
          this.next();
          return this.finishNode(node2, "ThisExpression");
        case types$1.name:
          var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
          var id = this.parseIdent(false);
          if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
            this.overrideContext(types.f_expr);
            return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
          }
          if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(types$1.arrow)) {
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
            }
            if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
              id = this.parseIdent(false);
              if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
                this.unexpected();
              }
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
            }
          }
          return id;
        case types$1.regexp:
          var value = this.value;
          node2 = this.parseLiteral(value.value);
          node2.regex = { pattern: value.pattern, flags: value.flags };
          return node2;
        case types$1.num:
        case types$1.string:
          return this.parseLiteral(this.value);
        case types$1._null:
        case types$1._true:
        case types$1._false:
          node2 = this.startNode();
          node2.value = this.type === types$1._null ? null : this.type === types$1._true;
          node2.raw = this.type.keyword;
          this.next();
          return this.finishNode(node2, "Literal");
        case types$1.parenL:
          var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
          if (refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
              refDestructuringErrors.parenthesizedAssign = start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = start;
            }
          }
          return expr;
        case types$1.bracketL:
          node2 = this.startNode();
          this.next();
          node2.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
          return this.finishNode(node2, "ArrayExpression");
        case types$1.braceL:
          this.overrideContext(types.b_expr);
          return this.parseObj(false, refDestructuringErrors);
        case types$1._function:
          node2 = this.startNode();
          this.next();
          return this.parseFunction(node2, 0);
        case types$1._class:
          return this.parseClass(this.startNode(), false);
        case types$1._new:
          return this.parseNew();
        case types$1.backQuote:
          return this.parseTemplate();
        case types$1._import:
          if (this.options.ecmaVersion >= 11) {
            return this.parseExprImport();
          } else {
            return this.unexpected();
          }
        default:
          this.unexpected();
      }
    };
    pp$5.parseExprImport = function() {
      var node2 = this.startNode();
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword import");
      }
      var meta = this.parseIdent(true);
      switch (this.type) {
        case types$1.parenL:
          return this.parseDynamicImport(node2);
        case types$1.dot:
          node2.meta = meta;
          return this.parseImportMeta(node2);
        default:
          this.unexpected();
      }
    };
    pp$5.parseDynamicImport = function(node2) {
      this.next();
      node2.source = this.parseMaybeAssign();
      if (!this.eat(types$1.parenR)) {
        var errorPos = this.start;
        if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
          this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
        } else {
          this.unexpected(errorPos);
        }
      }
      return this.finishNode(node2, "ImportExpression");
    };
    pp$5.parseImportMeta = function(node2) {
      this.next();
      var containsEsc = this.containsEsc;
      node2.property = this.parseIdent(true);
      if (node2.property.name !== "meta") {
        this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
      }
      if (containsEsc) {
        this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
      }
      if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
        this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
      }
      return this.finishNode(node2, "MetaProperty");
    };
    pp$5.parseLiteral = function(value) {
      var node2 = this.startNode();
      node2.value = value;
      node2.raw = this.input.slice(this.start, this.end);
      if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
        node2.bigint = node2.raw.slice(0, -1).replace(/_/g, "");
      }
      this.next();
      return this.finishNode(node2, "Literal");
    };
    pp$5.parseParenExpression = function() {
      this.expect(types$1.parenL);
      var val = this.parseExpression();
      this.expect(types$1.parenR);
      return val;
    };
    pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
      var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
      if (this.options.ecmaVersion >= 6) {
        this.next();
        var innerStartPos = this.start, innerStartLoc = this.startLoc;
        var exprList = [], first2 = true, lastIsComma = false;
        var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
        this.yieldPos = 0;
        this.awaitPos = 0;
        while (this.type !== types$1.parenR) {
          first2 ? first2 = false : this.expect(types$1.comma);
          if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
            lastIsComma = true;
            break;
          } else if (this.type === types$1.ellipsis) {
            spreadStart = this.start;
            exprList.push(this.parseParenItem(this.parseRestBinding()));
            if (this.type === types$1.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            break;
          } else {
            exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
          }
        }
        var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
        this.expect(types$1.parenR);
        if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
        }
        if (!exprList.length || lastIsComma) {
          this.unexpected(this.lastTokStart);
        }
        if (spreadStart) {
          this.unexpected(spreadStart);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else {
          val = exprList[0];
        }
      } else {
        val = this.parseParenExpression();
      }
      if (this.options.preserveParens) {
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        return this.finishNode(par, "ParenthesizedExpression");
      } else {
        return val;
      }
    };
    pp$5.parseParenItem = function(item) {
      return item;
    };
    pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
    };
    var empty = [];
    pp$5.parseNew = function() {
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword new");
      }
      var node2 = this.startNode();
      var meta = this.parseIdent(true);
      if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
        node2.meta = meta;
        var containsEsc = this.containsEsc;
        node2.property = this.parseIdent(true);
        if (node2.property.name !== "target") {
          this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
        }
        if (!this.allowNewDotTarget) {
          this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
        }
        return this.finishNode(node2, "MetaProperty");
      }
      var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
      node2.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
      if (isImport && node2.callee.type === "ImportExpression") {
        this.raise(startPos, "Cannot use new with import()");
      }
      if (this.eat(types$1.parenL)) {
        node2.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
      } else {
        node2.arguments = empty;
      }
      return this.finishNode(node2, "NewExpression");
    };
    pp$5.parseTemplateElement = function(ref2) {
      var isTagged = ref2.isTagged;
      var elem = this.startNode();
      if (this.type === types$1.invalidTemplate) {
        if (!isTagged) {
          this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
        }
        elem.value = {
          raw: this.value,
          cooked: null
        };
      } else {
        elem.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
          cooked: this.value
        };
      }
      this.next();
      elem.tail = this.type === types$1.backQuote;
      return this.finishNode(elem, "TemplateElement");
    };
    pp$5.parseTemplate = function(ref2) {
      if (ref2 === void 0)
        ref2 = {};
      var isTagged = ref2.isTagged;
      if (isTagged === void 0)
        isTagged = false;
      var node2 = this.startNode();
      this.next();
      node2.expressions = [];
      var curElt = this.parseTemplateElement({ isTagged });
      node2.quasis = [curElt];
      while (!curElt.tail) {
        if (this.type === types$1.eof) {
          this.raise(this.pos, "Unterminated template literal");
        }
        this.expect(types$1.dollarBraceL);
        node2.expressions.push(this.parseExpression());
        this.expect(types$1.braceR);
        node2.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
      }
      this.next();
      return this.finishNode(node2, "TemplateLiteral");
    };
    pp$5.isAsyncProp = function(prop) {
      return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$5.parseObj = function(isPattern, refDestructuringErrors) {
      var node2 = this.startNode(), first2 = true, propHash = {};
      node2.properties = [];
      this.next();
      while (!this.eat(types$1.braceR)) {
        if (!first2) {
          this.expect(types$1.comma);
          if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
            break;
          }
        } else {
          first2 = false;
        }
        var prop = this.parseProperty(isPattern, refDestructuringErrors);
        if (!isPattern) {
          this.checkPropClash(prop, propHash, refDestructuringErrors);
        }
        node2.properties.push(prop);
      }
      return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
    };
    pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
      var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
      if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
        if (isPattern) {
          prop.argument = this.parseIdent(false);
          if (this.type === types$1.comma) {
            this.raise(this.start, "Comma is not permitted after the rest element");
          }
          return this.finishNode(prop, "RestElement");
        }
        if (this.type === types$1.parenL && refDestructuringErrors) {
          if (refDestructuringErrors.parenthesizedAssign < 0) {
            refDestructuringErrors.parenthesizedAssign = this.start;
          }
          if (refDestructuringErrors.parenthesizedBind < 0) {
            refDestructuringErrors.parenthesizedBind = this.start;
          }
        }
        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
          refDestructuringErrors.trailingComma = this.start;
        }
        return this.finishNode(prop, "SpreadElement");
      }
      if (this.options.ecmaVersion >= 6) {
        prop.method = false;
        prop.shorthand = false;
        if (isPattern || refDestructuringErrors) {
          startPos = this.start;
          startLoc = this.startLoc;
        }
        if (!isPattern) {
          isGenerator = this.eat(types$1.star);
        }
      }
      var containsEsc = this.containsEsc;
      this.parsePropertyName(prop);
      if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
        this.parsePropertyName(prop, refDestructuringErrors);
      } else {
        isAsync = false;
      }
      this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
      return this.finishNode(prop, "Property");
    };
    pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
      if ((isGenerator || isAsync) && this.type === types$1.colon) {
        this.unexpected();
      }
      if (this.eat(types$1.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
        prop.kind = "init";
      } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
        if (isPattern) {
          this.unexpected();
        }
        prop.kind = "init";
        prop.method = true;
        prop.value = this.parseMethod(isGenerator, isAsync);
      } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
        if (isGenerator || isAsync) {
          this.unexpected();
        }
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get") {
            this.raiseRecoverable(start, "getter should have no params");
          } else {
            this.raiseRecoverable(start, "setter should have exactly one param");
          }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          }
        }
      } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        if (isGenerator || isAsync) {
          this.unexpected();
        }
        this.checkUnreserved(prop.key);
        if (prop.key.name === "await" && !this.awaitIdentPos) {
          this.awaitIdentPos = startPos;
        }
        prop.kind = "init";
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
        } else if (this.type === types$1.eq && refDestructuringErrors) {
          if (refDestructuringErrors.shorthandAssign < 0) {
            refDestructuringErrors.shorthandAssign = this.start;
          }
          prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
        } else {
          prop.value = this.copyNode(prop.key);
        }
        prop.shorthand = true;
      } else {
        this.unexpected();
      }
    };
    pp$5.parsePropertyName = function(prop) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(types$1.bracketL)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssign();
          this.expect(types$1.bracketR);
          return prop.key;
        } else {
          prop.computed = false;
        }
      }
      return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    };
    pp$5.initFunction = function(node2) {
      node2.id = null;
      if (this.options.ecmaVersion >= 6) {
        node2.generator = node2.expression = false;
      }
      if (this.options.ecmaVersion >= 8) {
        node2.async = false;
      }
    };
    pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
      var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.initFunction(node2);
      if (this.options.ecmaVersion >= 6) {
        node2.generator = isGenerator;
      }
      if (this.options.ecmaVersion >= 8) {
        node2.async = !!isAsync;
      }
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(isAsync, node2.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      this.expect(types$1.parenL);
      node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
      this.parseFunctionBody(node2, false, true, false);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node2, "FunctionExpression");
    };
    pp$5.parseArrowExpression = function(node2, params, isAsync, forInit) {
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
      this.initFunction(node2);
      if (this.options.ecmaVersion >= 8) {
        node2.async = !!isAsync;
      }
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      node2.params = this.toAssignableList(params, true);
      this.parseFunctionBody(node2, true, false, forInit);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node2, "ArrowFunctionExpression");
    };
    pp$5.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
      var isExpression = isArrowFunction && this.type !== types$1.braceL;
      var oldStrict = this.strict, useStrict = false;
      if (isExpression) {
        node2.body = this.parseMaybeAssign(forInit);
        node2.expression = true;
        this.checkParams(node2, false);
      } else {
        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
        if (!oldStrict || nonSimple) {
          useStrict = this.strictDirective(this.end);
          if (useStrict && nonSimple) {
            this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
          }
        }
        var oldLabels = this.labels;
        this.labels = [];
        if (useStrict) {
          this.strict = true;
        }
        this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
        if (this.strict && node2.id) {
          this.checkLValSimple(node2.id, BIND_OUTSIDE);
        }
        node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
        node2.expression = false;
        this.adaptDirectivePrologue(node2.body.body);
        this.labels = oldLabels;
      }
      this.exitScope();
    };
    pp$5.isSimpleParamList = function(params) {
      for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
        var param = list2[i2];
        if (param.type !== "Identifier") {
          return false;
        }
      }
      return true;
    };
    pp$5.checkParams = function(node2, allowDuplicates) {
      var nameHash = Object.create(null);
      for (var i2 = 0, list2 = node2.params; i2 < list2.length; i2 += 1) {
        var param = list2[i2];
        this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
      }
    };
    pp$5.parseExprList = function(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
      var elts = [], first2 = true;
      while (!this.eat(close2)) {
        if (!first2) {
          this.expect(types$1.comma);
          if (allowTrailingComma && this.afterTrailingComma(close2)) {
            break;
          }
        } else {
          first2 = false;
        }
        var elt = void 0;
        if (allowEmpty && this.type === types$1.comma) {
          elt = null;
        } else if (this.type === types$1.ellipsis) {
          elt = this.parseSpread(refDestructuringErrors);
          if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
        } else {
          elt = this.parseMaybeAssign(false, refDestructuringErrors);
        }
        elts.push(elt);
      }
      return elts;
    };
    pp$5.checkUnreserved = function(ref2) {
      var start = ref2.start;
      var end = ref2.end;
      var name = ref2.name;
      if (this.inGenerator && name === "yield") {
        this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
      }
      if (this.inAsync && name === "await") {
        this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
      }
      if (this.currentThisScope().inClassFieldInit && name === "arguments") {
        this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
      }
      if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
        this.raise(start, "Cannot use " + name + " in class static initialization block");
      }
      if (this.keywords.test(name)) {
        this.raise(start, "Unexpected keyword '" + name + "'");
      }
      if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
        return;
      }
      var re2 = this.strict ? this.reservedWordsStrict : this.reservedWords;
      if (re2.test(name)) {
        if (!this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
        }
        this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
      }
    };
    pp$5.parseIdent = function(liberal, isBinding) {
      var node2 = this.startNode();
      if (this.type === types$1.name) {
        node2.name = this.value;
      } else if (this.type.keyword) {
        node2.name = this.type.keyword;
        if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
          this.context.pop();
        }
      } else {
        this.unexpected();
      }
      this.next(!!liberal);
      this.finishNode(node2, "Identifier");
      if (!liberal) {
        this.checkUnreserved(node2);
        if (node2.name === "await" && !this.awaitIdentPos) {
          this.awaitIdentPos = node2.start;
        }
      }
      return node2;
    };
    pp$5.parsePrivateIdent = function() {
      var node2 = this.startNode();
      if (this.type === types$1.privateId) {
        node2.name = this.value;
      } else {
        this.unexpected();
      }
      this.next();
      this.finishNode(node2, "PrivateIdentifier");
      if (this.privateNameStack.length === 0) {
        this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
      } else {
        this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
      }
      return node2;
    };
    pp$5.parseYield = function(forInit) {
      if (!this.yieldPos) {
        this.yieldPos = this.start;
      }
      var node2 = this.startNode();
      this.next();
      if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
        node2.delegate = false;
        node2.argument = null;
      } else {
        node2.delegate = this.eat(types$1.star);
        node2.argument = this.parseMaybeAssign(forInit);
      }
      return this.finishNode(node2, "YieldExpression");
    };
    pp$5.parseAwait = function(forInit) {
      if (!this.awaitPos) {
        this.awaitPos = this.start;
      }
      var node2 = this.startNode();
      this.next();
      node2.argument = this.parseMaybeUnary(null, true, false, forInit);
      return this.finishNode(node2, "AwaitExpression");
    };
    var pp$4 = Parser.prototype;
    pp$4.raise = function(pos, message) {
      var loc = getLineInfo(this.input, pos);
      message += " (" + loc.line + ":" + loc.column + ")";
      var err = new SyntaxError(message);
      err.pos = pos;
      err.loc = loc;
      err.raisedAt = this.pos;
      throw err;
    };
    pp$4.raiseRecoverable = pp$4.raise;
    pp$4.curPosition = function() {
      if (this.options.locations) {
        return new Position(this.curLine, this.pos - this.lineStart);
      }
    };
    var pp$3 = Parser.prototype;
    var Scope = function Scope2(flags) {
      this.flags = flags;
      this.var = [];
      this.lexical = [];
      this.functions = [];
      this.inClassFieldInit = false;
    };
    pp$3.enterScope = function(flags) {
      this.scopeStack.push(new Scope(flags));
    };
    pp$3.exitScope = function() {
      this.scopeStack.pop();
    };
    pp$3.treatFunctionsAsVarInScope = function(scope) {
      return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
    };
    pp$3.declareName = function(name, bindingType, pos) {
      var redeclared = false;
      if (bindingType === BIND_LEXICAL) {
        var scope = this.currentScope();
        redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
        scope.lexical.push(name);
        if (this.inModule && scope.flags & SCOPE_TOP) {
          delete this.undefinedExports[name];
        }
      } else if (bindingType === BIND_SIMPLE_CATCH) {
        var scope$1 = this.currentScope();
        scope$1.lexical.push(name);
      } else if (bindingType === BIND_FUNCTION) {
        var scope$2 = this.currentScope();
        if (this.treatFunctionsAsVar) {
          redeclared = scope$2.lexical.indexOf(name) > -1;
        } else {
          redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
        }
        scope$2.functions.push(name);
      } else {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
          var scope$3 = this.scopeStack[i2];
          if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
            redeclared = true;
            break;
          }
          scope$3.var.push(name);
          if (this.inModule && scope$3.flags & SCOPE_TOP) {
            delete this.undefinedExports[name];
          }
          if (scope$3.flags & SCOPE_VAR) {
            break;
          }
        }
      }
      if (redeclared) {
        this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
      }
    };
    pp$3.checkLocalExport = function(id) {
      if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
        this.undefinedExports[id.name] = id;
      }
    };
    pp$3.currentScope = function() {
      return this.scopeStack[this.scopeStack.length - 1];
    };
    pp$3.currentVarScope = function() {
      for (var i2 = this.scopeStack.length - 1; ; i2--) {
        var scope = this.scopeStack[i2];
        if (scope.flags & SCOPE_VAR) {
          return scope;
        }
      }
    };
    pp$3.currentThisScope = function() {
      for (var i2 = this.scopeStack.length - 1; ; i2--) {
        var scope = this.scopeStack[i2];
        if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
          return scope;
        }
      }
    };
    var Node = function Node2(parser2, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      if (parser2.options.locations) {
        this.loc = new SourceLocation(parser2, loc);
      }
      if (parser2.options.directSourceFile) {
        this.sourceFile = parser2.options.directSourceFile;
      }
      if (parser2.options.ranges) {
        this.range = [pos, 0];
      }
    };
    var pp$2 = Parser.prototype;
    pp$2.startNode = function() {
      return new Node(this, this.start, this.startLoc);
    };
    pp$2.startNodeAt = function(pos, loc) {
      return new Node(this, pos, loc);
    };
    function finishNodeAt(node2, type, pos, loc) {
      node2.type = type;
      node2.end = pos;
      if (this.options.locations) {
        node2.loc.end = loc;
      }
      if (this.options.ranges) {
        node2.range[1] = pos;
      }
      return node2;
    }
    pp$2.finishNode = function(node2, type) {
      return finishNodeAt.call(this, node2, type, this.lastTokEnd, this.lastTokEndLoc);
    };
    pp$2.finishNodeAt = function(node2, type, pos, loc) {
      return finishNodeAt.call(this, node2, type, pos, loc);
    };
    pp$2.copyNode = function(node2) {
      var newNode = new Node(this, node2.start, this.startLoc);
      for (var prop in node2) {
        newNode[prop] = node2[prop];
      }
      return newNode;
    };
    var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
    var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
    var ecma11BinaryProperties = ecma10BinaryProperties;
    var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
    var ecma13BinaryProperties = ecma12BinaryProperties;
    var unicodeBinaryProperties = {
      9: ecma9BinaryProperties,
      10: ecma10BinaryProperties,
      11: ecma11BinaryProperties,
      12: ecma12BinaryProperties,
      13: ecma13BinaryProperties
    };
    var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
    var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
    var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
    var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
    var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
    var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
    var unicodeScriptValues = {
      9: ecma9ScriptValues,
      10: ecma10ScriptValues,
      11: ecma11ScriptValues,
      12: ecma12ScriptValues,
      13: ecma13ScriptValues
    };
    var data = {};
    function buildUnicodeData(ecmaVersion2) {
      var d3 = data[ecmaVersion2] = {
        binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion2] + " " + unicodeGeneralCategoryValues),
        nonBinary: {
          General_Category: wordsRegexp(unicodeGeneralCategoryValues),
          Script: wordsRegexp(unicodeScriptValues[ecmaVersion2])
        }
      };
      d3.nonBinary.Script_Extensions = d3.nonBinary.Script;
      d3.nonBinary.gc = d3.nonBinary.General_Category;
      d3.nonBinary.sc = d3.nonBinary.Script;
      d3.nonBinary.scx = d3.nonBinary.Script_Extensions;
    }
    for (i$1 = 0, list$1 = [9, 10, 11, 12, 13]; i$1 < list$1.length; i$1 += 1) {
      ecmaVersion = list$1[i$1];
      buildUnicodeData(ecmaVersion);
    }
    var ecmaVersion;
    var i$1;
    var list$1;
    var pp$1 = Parser.prototype;
    var RegExpValidationState = function RegExpValidationState2(parser2) {
      this.parser = parser2;
      this.validFlags = "gim" + (parser2.options.ecmaVersion >= 6 ? "uy" : "") + (parser2.options.ecmaVersion >= 9 ? "s" : "") + (parser2.options.ecmaVersion >= 13 ? "d" : "");
      this.unicodeProperties = data[parser2.options.ecmaVersion >= 13 ? 13 : parser2.options.ecmaVersion];
      this.source = "";
      this.flags = "";
      this.start = 0;
      this.switchU = false;
      this.switchN = false;
      this.pos = 0;
      this.lastIntValue = 0;
      this.lastStringValue = "";
      this.lastAssertionIsQuantifiable = false;
      this.numCapturingParens = 0;
      this.maxBackReference = 0;
      this.groupNames = [];
      this.backReferenceNames = [];
    };
    RegExpValidationState.prototype.reset = function reset(start, pattern2, flags) {
      var unicode = flags.indexOf("u") !== -1;
      this.start = start | 0;
      this.source = pattern2 + "";
      this.flags = flags;
      this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
      this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
    };
    RegExpValidationState.prototype.raise = function raise(message) {
      this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
    };
    RegExpValidationState.prototype.at = function at2(i2, forceU) {
      if (forceU === void 0)
        forceU = false;
      var s2 = this.source;
      var l2 = s2.length;
      if (i2 >= l2) {
        return -1;
      }
      var c2 = s2.charCodeAt(i2);
      if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i2 + 1 >= l2) {
        return c2;
      }
      var next = s2.charCodeAt(i2 + 1);
      return next >= 56320 && next <= 57343 ? (c2 << 10) + next - 56613888 : c2;
    };
    RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
      if (forceU === void 0)
        forceU = false;
      var s2 = this.source;
      var l2 = s2.length;
      if (i2 >= l2) {
        return l2;
      }
      var c2 = s2.charCodeAt(i2), next;
      if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i2 + 1 >= l2 || (next = s2.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
        return i2 + 1;
      }
      return i2 + 2;
    };
    RegExpValidationState.prototype.current = function current(forceU) {
      if (forceU === void 0)
        forceU = false;
      return this.at(this.pos, forceU);
    };
    RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
      if (forceU === void 0)
        forceU = false;
      return this.at(this.nextIndex(this.pos, forceU), forceU);
    };
    RegExpValidationState.prototype.advance = function advance(forceU) {
      if (forceU === void 0)
        forceU = false;
      this.pos = this.nextIndex(this.pos, forceU);
    };
    RegExpValidationState.prototype.eat = function eat(ch2, forceU) {
      if (forceU === void 0)
        forceU = false;
      if (this.current(forceU) === ch2) {
        this.advance(forceU);
        return true;
      }
      return false;
    };
    function codePointToString$1(ch2) {
      if (ch2 <= 65535) {
        return String.fromCharCode(ch2);
      }
      ch2 -= 65536;
      return String.fromCharCode((ch2 >> 10) + 55296, (ch2 & 1023) + 56320);
    }
    pp$1.validateRegExpFlags = function(state) {
      var validFlags = state.validFlags;
      var flags = state.flags;
      for (var i2 = 0; i2 < flags.length; i2++) {
        var flag = flags.charAt(i2);
        if (validFlags.indexOf(flag) === -1) {
          this.raise(state.start, "Invalid regular expression flag");
        }
        if (flags.indexOf(flag, i2 + 1) > -1) {
          this.raise(state.start, "Duplicate regular expression flag");
        }
      }
    };
    pp$1.validateRegExpPattern = function(state) {
      this.regexp_pattern(state);
      if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
        state.switchN = true;
        this.regexp_pattern(state);
      }
    };
    pp$1.regexp_pattern = function(state) {
      state.pos = 0;
      state.lastIntValue = 0;
      state.lastStringValue = "";
      state.lastAssertionIsQuantifiable = false;
      state.numCapturingParens = 0;
      state.maxBackReference = 0;
      state.groupNames.length = 0;
      state.backReferenceNames.length = 0;
      this.regexp_disjunction(state);
      if (state.pos !== state.source.length) {
        if (state.eat(41)) {
          state.raise("Unmatched ')'");
        }
        if (state.eat(93) || state.eat(125)) {
          state.raise("Lone quantifier brackets");
        }
      }
      if (state.maxBackReference > state.numCapturingParens) {
        state.raise("Invalid escape");
      }
      for (var i2 = 0, list2 = state.backReferenceNames; i2 < list2.length; i2 += 1) {
        var name = list2[i2];
        if (state.groupNames.indexOf(name) === -1) {
          state.raise("Invalid named capture referenced");
        }
      }
    };
    pp$1.regexp_disjunction = function(state) {
      this.regexp_alternative(state);
      while (state.eat(124)) {
        this.regexp_alternative(state);
      }
      if (this.regexp_eatQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      if (state.eat(123)) {
        state.raise("Lone quantifier brackets");
      }
    };
    pp$1.regexp_alternative = function(state) {
      while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
      }
    };
    pp$1.regexp_eatTerm = function(state) {
      if (this.regexp_eatAssertion(state)) {
        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
          if (state.switchU) {
            state.raise("Invalid quantifier");
          }
        }
        return true;
      }
      if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
        this.regexp_eatQuantifier(state);
        return true;
      }
      return false;
    };
    pp$1.regexp_eatAssertion = function(state) {
      var start = state.pos;
      state.lastAssertionIsQuantifiable = false;
      if (state.eat(94) || state.eat(36)) {
        return true;
      }
      if (state.eat(92)) {
        if (state.eat(66) || state.eat(98)) {
          return true;
        }
        state.pos = start;
      }
      if (state.eat(40) && state.eat(63)) {
        var lookbehind = false;
        if (this.options.ecmaVersion >= 9) {
          lookbehind = state.eat(60);
        }
        if (state.eat(61) || state.eat(33)) {
          this.regexp_disjunction(state);
          if (!state.eat(41)) {
            state.raise("Unterminated group");
          }
          state.lastAssertionIsQuantifiable = !lookbehind;
          return true;
        }
      }
      state.pos = start;
      return false;
    };
    pp$1.regexp_eatQuantifier = function(state, noError) {
      if (noError === void 0)
        noError = false;
      if (this.regexp_eatQuantifierPrefix(state, noError)) {
        state.eat(63);
        return true;
      }
      return false;
    };
    pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
      return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
    };
    pp$1.regexp_eatBracedQuantifier = function(state, noError) {
      var start = state.pos;
      if (state.eat(123)) {
        var min2 = 0, max = -1;
        if (this.regexp_eatDecimalDigits(state)) {
          min2 = state.lastIntValue;
          if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
            max = state.lastIntValue;
          }
          if (state.eat(125)) {
            if (max !== -1 && max < min2 && !noError) {
              state.raise("numbers out of order in {} quantifier");
            }
            return true;
          }
        }
        if (state.switchU && !noError) {
          state.raise("Incomplete quantifier");
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatAtom = function(state) {
      return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
    };
    pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
      var start = state.pos;
      if (state.eat(92)) {
        if (this.regexp_eatAtomEscape(state)) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatUncapturingGroup = function(state) {
      var start = state.pos;
      if (state.eat(40)) {
        if (state.eat(63) && state.eat(58)) {
          this.regexp_disjunction(state);
          if (state.eat(41)) {
            return true;
          }
          state.raise("Unterminated group");
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatCapturingGroup = function(state) {
      if (state.eat(40)) {
        if (this.options.ecmaVersion >= 9) {
          this.regexp_groupSpecifier(state);
        } else if (state.current() === 63) {
          state.raise("Invalid group");
        }
        this.regexp_disjunction(state);
        if (state.eat(41)) {
          state.numCapturingParens += 1;
          return true;
        }
        state.raise("Unterminated group");
      }
      return false;
    };
    pp$1.regexp_eatExtendedAtom = function(state) {
      return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
    };
    pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
      if (this.regexp_eatBracedQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      return false;
    };
    pp$1.regexp_eatSyntaxCharacter = function(state) {
      var ch2 = state.current();
      if (isSyntaxCharacter(ch2)) {
        state.lastIntValue = ch2;
        state.advance();
        return true;
      }
      return false;
    };
    function isSyntaxCharacter(ch2) {
      return ch2 === 36 || ch2 >= 40 && ch2 <= 43 || ch2 === 46 || ch2 === 63 || ch2 >= 91 && ch2 <= 94 || ch2 >= 123 && ch2 <= 125;
    }
    pp$1.regexp_eatPatternCharacters = function(state) {
      var start = state.pos;
      var ch2 = 0;
      while ((ch2 = state.current()) !== -1 && !isSyntaxCharacter(ch2)) {
        state.advance();
      }
      return state.pos !== start;
    };
    pp$1.regexp_eatExtendedPatternCharacter = function(state) {
      var ch2 = state.current();
      if (ch2 !== -1 && ch2 !== 36 && !(ch2 >= 40 && ch2 <= 43) && ch2 !== 46 && ch2 !== 63 && ch2 !== 91 && ch2 !== 94 && ch2 !== 124) {
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_groupSpecifier = function(state) {
      if (state.eat(63)) {
        if (this.regexp_eatGroupName(state)) {
          if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
            state.raise("Duplicate capture group name");
          }
          state.groupNames.push(state.lastStringValue);
          return;
        }
        state.raise("Invalid group");
      }
    };
    pp$1.regexp_eatGroupName = function(state) {
      state.lastStringValue = "";
      if (state.eat(60)) {
        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
          return true;
        }
        state.raise("Invalid capture group name");
      }
      return false;
    };
    pp$1.regexp_eatRegExpIdentifierName = function(state) {
      state.lastStringValue = "";
      if (this.regexp_eatRegExpIdentifierStart(state)) {
        state.lastStringValue += codePointToString$1(state.lastIntValue);
        while (this.regexp_eatRegExpIdentifierPart(state)) {
          state.lastStringValue += codePointToString$1(state.lastIntValue);
        }
        return true;
      }
      return false;
    };
    pp$1.regexp_eatRegExpIdentifierStart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch2 = state.current(forceU);
      state.advance(forceU);
      if (ch2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch2 = state.lastIntValue;
      }
      if (isRegExpIdentifierStart(ch2)) {
        state.lastIntValue = ch2;
        return true;
      }
      state.pos = start;
      return false;
    };
    function isRegExpIdentifierStart(ch2) {
      return isIdentifierStart(ch2, true) || ch2 === 36 || ch2 === 95;
    }
    pp$1.regexp_eatRegExpIdentifierPart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch2 = state.current(forceU);
      state.advance(forceU);
      if (ch2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch2 = state.lastIntValue;
      }
      if (isRegExpIdentifierPart(ch2)) {
        state.lastIntValue = ch2;
        return true;
      }
      state.pos = start;
      return false;
    };
    function isRegExpIdentifierPart(ch2) {
      return isIdentifierChar(ch2, true) || ch2 === 36 || ch2 === 95 || ch2 === 8204 || ch2 === 8205;
    }
    pp$1.regexp_eatAtomEscape = function(state) {
      if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
        return true;
      }
      if (state.switchU) {
        if (state.current() === 99) {
          state.raise("Invalid unicode escape");
        }
        state.raise("Invalid escape");
      }
      return false;
    };
    pp$1.regexp_eatBackReference = function(state) {
      var start = state.pos;
      if (this.regexp_eatDecimalEscape(state)) {
        var n3 = state.lastIntValue;
        if (state.switchU) {
          if (n3 > state.maxBackReference) {
            state.maxBackReference = n3;
          }
          return true;
        }
        if (n3 <= state.numCapturingParens) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatKGroupName = function(state) {
      if (state.eat(107)) {
        if (this.regexp_eatGroupName(state)) {
          state.backReferenceNames.push(state.lastStringValue);
          return true;
        }
        state.raise("Invalid named reference");
      }
      return false;
    };
    pp$1.regexp_eatCharacterEscape = function(state) {
      return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
    };
    pp$1.regexp_eatCControlLetter = function(state) {
      var start = state.pos;
      if (state.eat(99)) {
        if (this.regexp_eatControlLetter(state)) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatZero = function(state) {
      if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
        state.lastIntValue = 0;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatControlEscape = function(state) {
      var ch2 = state.current();
      if (ch2 === 116) {
        state.lastIntValue = 9;
        state.advance();
        return true;
      }
      if (ch2 === 110) {
        state.lastIntValue = 10;
        state.advance();
        return true;
      }
      if (ch2 === 118) {
        state.lastIntValue = 11;
        state.advance();
        return true;
      }
      if (ch2 === 102) {
        state.lastIntValue = 12;
        state.advance();
        return true;
      }
      if (ch2 === 114) {
        state.lastIntValue = 13;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatControlLetter = function(state) {
      var ch2 = state.current();
      if (isControlLetter(ch2)) {
        state.lastIntValue = ch2 % 32;
        state.advance();
        return true;
      }
      return false;
    };
    function isControlLetter(ch2) {
      return ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122;
    }
    pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
      if (forceU === void 0)
        forceU = false;
      var start = state.pos;
      var switchU = forceU || state.switchU;
      if (state.eat(117)) {
        if (this.regexp_eatFixedHexDigits(state, 4)) {
          var lead = state.lastIntValue;
          if (switchU && lead >= 55296 && lead <= 56319) {
            var leadSurrogateEnd = state.pos;
            if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
              var trail = state.lastIntValue;
              if (trail >= 56320 && trail <= 57343) {
                state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                return true;
              }
            }
            state.pos = leadSurrogateEnd;
            state.lastIntValue = lead;
          }
          return true;
        }
        if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
          return true;
        }
        if (switchU) {
          state.raise("Invalid unicode escape");
        }
        state.pos = start;
      }
      return false;
    };
    function isValidUnicode(ch2) {
      return ch2 >= 0 && ch2 <= 1114111;
    }
    pp$1.regexp_eatIdentityEscape = function(state) {
      if (state.switchU) {
        if (this.regexp_eatSyntaxCharacter(state)) {
          return true;
        }
        if (state.eat(47)) {
          state.lastIntValue = 47;
          return true;
        }
        return false;
      }
      var ch2 = state.current();
      if (ch2 !== 99 && (!state.switchN || ch2 !== 107)) {
        state.lastIntValue = ch2;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatDecimalEscape = function(state) {
      state.lastIntValue = 0;
      var ch2 = state.current();
      if (ch2 >= 49 && ch2 <= 57) {
        do {
          state.lastIntValue = 10 * state.lastIntValue + (ch2 - 48);
          state.advance();
        } while ((ch2 = state.current()) >= 48 && ch2 <= 57);
        return true;
      }
      return false;
    };
    pp$1.regexp_eatCharacterClassEscape = function(state) {
      var ch2 = state.current();
      if (isCharacterClassEscape(ch2)) {
        state.lastIntValue = -1;
        state.advance();
        return true;
      }
      if (state.switchU && this.options.ecmaVersion >= 9 && (ch2 === 80 || ch2 === 112)) {
        state.lastIntValue = -1;
        state.advance();
        if (state.eat(123) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(125)) {
          return true;
        }
        state.raise("Invalid property name");
      }
      return false;
    };
    function isCharacterClassEscape(ch2) {
      return ch2 === 100 || ch2 === 68 || ch2 === 115 || ch2 === 83 || ch2 === 119 || ch2 === 87;
    }
    pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
      var start = state.pos;
      if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
        var name = state.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(state)) {
          var value = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
          return true;
        }
      }
      state.pos = start;
      if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
        var nameOrValue = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        return true;
      }
      return false;
    };
    pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
      if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
        state.raise("Invalid property name");
      }
      if (!state.unicodeProperties.nonBinary[name].test(value)) {
        state.raise("Invalid property value");
      }
    };
    pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
      if (!state.unicodeProperties.binary.test(nameOrValue)) {
        state.raise("Invalid property name");
      }
    };
    pp$1.regexp_eatUnicodePropertyName = function(state) {
      var ch2 = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyNameCharacter(ch2 = state.current())) {
        state.lastStringValue += codePointToString$1(ch2);
        state.advance();
      }
      return state.lastStringValue !== "";
    };
    function isUnicodePropertyNameCharacter(ch2) {
      return isControlLetter(ch2) || ch2 === 95;
    }
    pp$1.regexp_eatUnicodePropertyValue = function(state) {
      var ch2 = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyValueCharacter(ch2 = state.current())) {
        state.lastStringValue += codePointToString$1(ch2);
        state.advance();
      }
      return state.lastStringValue !== "";
    };
    function isUnicodePropertyValueCharacter(ch2) {
      return isUnicodePropertyNameCharacter(ch2) || isDecimalDigit(ch2);
    }
    pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
      return this.regexp_eatUnicodePropertyValue(state);
    };
    pp$1.regexp_eatCharacterClass = function(state) {
      if (state.eat(91)) {
        state.eat(94);
        this.regexp_classRanges(state);
        if (state.eat(93)) {
          return true;
        }
        state.raise("Unterminated character class");
      }
      return false;
    };
    pp$1.regexp_classRanges = function(state) {
      while (this.regexp_eatClassAtom(state)) {
        var left = state.lastIntValue;
        if (state.eat(45) && this.regexp_eatClassAtom(state)) {
          var right = state.lastIntValue;
          if (state.switchU && (left === -1 || right === -1)) {
            state.raise("Invalid character class");
          }
          if (left !== -1 && right !== -1 && left > right) {
            state.raise("Range out of order in character class");
          }
        }
      }
    };
    pp$1.regexp_eatClassAtom = function(state) {
      var start = state.pos;
      if (state.eat(92)) {
        if (this.regexp_eatClassEscape(state)) {
          return true;
        }
        if (state.switchU) {
          var ch$1 = state.current();
          if (ch$1 === 99 || isOctalDigit(ch$1)) {
            state.raise("Invalid class escape");
          }
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      var ch2 = state.current();
      if (ch2 !== 93) {
        state.lastIntValue = ch2;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatClassEscape = function(state) {
      var start = state.pos;
      if (state.eat(98)) {
        state.lastIntValue = 8;
        return true;
      }
      if (state.switchU && state.eat(45)) {
        state.lastIntValue = 45;
        return true;
      }
      if (!state.switchU && state.eat(99)) {
        if (this.regexp_eatClassControlLetter(state)) {
          return true;
        }
        state.pos = start;
      }
      return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
    };
    pp$1.regexp_eatClassControlLetter = function(state) {
      var ch2 = state.current();
      if (isDecimalDigit(ch2) || ch2 === 95) {
        state.lastIntValue = ch2 % 32;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatHexEscapeSequence = function(state) {
      var start = state.pos;
      if (state.eat(120)) {
        if (this.regexp_eatFixedHexDigits(state, 2)) {
          return true;
        }
        if (state.switchU) {
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatDecimalDigits = function(state) {
      var start = state.pos;
      var ch2 = 0;
      state.lastIntValue = 0;
      while (isDecimalDigit(ch2 = state.current())) {
        state.lastIntValue = 10 * state.lastIntValue + (ch2 - 48);
        state.advance();
      }
      return state.pos !== start;
    };
    function isDecimalDigit(ch2) {
      return ch2 >= 48 && ch2 <= 57;
    }
    pp$1.regexp_eatHexDigits = function(state) {
      var start = state.pos;
      var ch2 = 0;
      state.lastIntValue = 0;
      while (isHexDigit(ch2 = state.current())) {
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch2);
        state.advance();
      }
      return state.pos !== start;
    };
    function isHexDigit(ch2) {
      return ch2 >= 48 && ch2 <= 57 || ch2 >= 65 && ch2 <= 70 || ch2 >= 97 && ch2 <= 102;
    }
    function hexToInt(ch2) {
      if (ch2 >= 65 && ch2 <= 70) {
        return 10 + (ch2 - 65);
      }
      if (ch2 >= 97 && ch2 <= 102) {
        return 10 + (ch2 - 97);
      }
      return ch2 - 48;
    }
    pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
      if (this.regexp_eatOctalDigit(state)) {
        var n1 = state.lastIntValue;
        if (this.regexp_eatOctalDigit(state)) {
          var n22 = state.lastIntValue;
          if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
            state.lastIntValue = n1 * 64 + n22 * 8 + state.lastIntValue;
          } else {
            state.lastIntValue = n1 * 8 + n22;
          }
        } else {
          state.lastIntValue = n1;
        }
        return true;
      }
      return false;
    };
    pp$1.regexp_eatOctalDigit = function(state) {
      var ch2 = state.current();
      if (isOctalDigit(ch2)) {
        state.lastIntValue = ch2 - 48;
        state.advance();
        return true;
      }
      state.lastIntValue = 0;
      return false;
    };
    function isOctalDigit(ch2) {
      return ch2 >= 48 && ch2 <= 55;
    }
    pp$1.regexp_eatFixedHexDigits = function(state, length) {
      var start = state.pos;
      state.lastIntValue = 0;
      for (var i2 = 0; i2 < length; ++i2) {
        var ch2 = state.current();
        if (!isHexDigit(ch2)) {
          state.pos = start;
          return false;
        }
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch2);
        state.advance();
      }
      return true;
    };
    var Token = function Token2(p2) {
      this.type = p2.type;
      this.value = p2.value;
      this.start = p2.start;
      this.end = p2.end;
      if (p2.options.locations) {
        this.loc = new SourceLocation(p2, p2.startLoc, p2.endLoc);
      }
      if (p2.options.ranges) {
        this.range = [p2.start, p2.end];
      }
    };
    var pp = Parser.prototype;
    pp.next = function(ignoreEscapeSequenceInKeyword) {
      if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
      }
      if (this.options.onToken) {
        this.options.onToken(new Token(this));
      }
      this.lastTokEnd = this.end;
      this.lastTokStart = this.start;
      this.lastTokEndLoc = this.endLoc;
      this.lastTokStartLoc = this.startLoc;
      this.nextToken();
    };
    pp.getToken = function() {
      this.next();
      return new Token(this);
    };
    if (typeof Symbol !== "undefined") {
      pp[Symbol.iterator] = function() {
        var this$1$1 = this;
        return {
          next: function() {
            var token = this$1$1.getToken();
            return {
              done: token.type === types$1.eof,
              value: token
            };
          }
        };
      };
    }
    pp.nextToken = function() {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) {
        this.skipSpace();
      }
      this.start = this.pos;
      if (this.options.locations) {
        this.startLoc = this.curPosition();
      }
      if (this.pos >= this.input.length) {
        return this.finishToken(types$1.eof);
      }
      if (curContext.override) {
        return curContext.override(this);
      } else {
        this.readToken(this.fullCharCodeAtPos());
      }
    };
    pp.readToken = function(code) {
      if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
        return this.readWord();
      }
      return this.getTokenFromCode(code);
    };
    pp.fullCharCodeAtPos = function() {
      var code = this.input.charCodeAt(this.pos);
      if (code <= 55295 || code >= 56320) {
        return code;
      }
      var next = this.input.charCodeAt(this.pos + 1);
      return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
    };
    pp.skipBlockComment = function() {
      var startLoc = this.options.onComment && this.curPosition();
      var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
      if (end === -1) {
        this.raise(this.pos - 2, "Unterminated comment");
      }
      this.pos = end + 2;
      if (this.options.locations) {
        for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
          ++this.curLine;
          pos = this.lineStart = nextBreak;
        }
      }
      if (this.options.onComment) {
        this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
      }
    };
    pp.skipLineComment = function(startSkip) {
      var start = this.pos;
      var startLoc = this.options.onComment && this.curPosition();
      var ch2 = this.input.charCodeAt(this.pos += startSkip);
      while (this.pos < this.input.length && !isNewLine(ch2)) {
        ch2 = this.input.charCodeAt(++this.pos);
      }
      if (this.options.onComment) {
        this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
      }
    };
    pp.skipSpace = function() {
      loop:
        while (this.pos < this.input.length) {
          var ch2 = this.input.charCodeAt(this.pos);
          switch (ch2) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break loop;
              }
              break;
            default:
              if (ch2 > 8 && ch2 < 14 || ch2 >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch2))) {
                ++this.pos;
              } else {
                break loop;
              }
          }
        }
    };
    pp.finishToken = function(type, val) {
      this.end = this.pos;
      if (this.options.locations) {
        this.endLoc = this.curPosition();
      }
      var prevType = this.type;
      this.type = type;
      this.value = val;
      this.updateContext(prevType);
    };
    pp.readToken_dot = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next >= 48 && next <= 57) {
        return this.readNumber(true);
      }
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
        this.pos += 3;
        return this.finishToken(types$1.ellipsis);
      } else {
        ++this.pos;
        return this.finishToken(types$1.dot);
      }
    };
    pp.readToken_slash = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (this.exprAllowed) {
        ++this.pos;
        return this.readRegexp();
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(types$1.slash, 1);
    };
    pp.readToken_mult_modulo_exp = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      var tokentype = code === 42 ? types$1.star : types$1.modulo;
      if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
        ++size;
        tokentype = types$1.starstar;
        next = this.input.charCodeAt(this.pos + 2);
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, size + 1);
      }
      return this.finishOp(tokentype, size);
    };
    pp.readToken_pipe_amp = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (this.options.ecmaVersion >= 12) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 === 61) {
            return this.finishOp(types$1.assign, 3);
          }
        }
        return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
    };
    pp.readToken_caret = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(types$1.bitwiseXOR, 1);
    };
    pp.readToken_plus_min = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
          this.skipLineComment(3);
          this.skipSpace();
          return this.nextToken();
        }
        return this.finishOp(types$1.incDec, 2);
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(types$1.plusMin, 1);
    };
    pp.readToken_lt_gt = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.pos + size) === 61) {
          return this.finishOp(types$1.assign, size + 1);
        }
        return this.finishOp(types$1.bitShift, size);
      }
      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken();
      }
      if (next === 61) {
        size = 2;
      }
      return this.finishOp(types$1.relational, size);
    };
    pp.readToken_eq_excl = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) {
        return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
      }
      if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
        this.pos += 2;
        return this.finishToken(types$1.arrow);
      }
      return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
    };
    pp.readToken_question = function() {
      var ecmaVersion2 = this.options.ecmaVersion;
      if (ecmaVersion2 >= 11) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 46) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 < 48 || next2 > 57) {
            return this.finishOp(types$1.questionDot, 2);
          }
        }
        if (next === 63) {
          if (ecmaVersion2 >= 12) {
            var next2$1 = this.input.charCodeAt(this.pos + 2);
            if (next2$1 === 61) {
              return this.finishOp(types$1.assign, 3);
            }
          }
          return this.finishOp(types$1.coalesce, 2);
        }
      }
      return this.finishOp(types$1.question, 1);
    };
    pp.readToken_numberSign = function() {
      var ecmaVersion2 = this.options.ecmaVersion;
      var code = 35;
      if (ecmaVersion2 >= 13) {
        ++this.pos;
        code = this.fullCharCodeAtPos();
        if (isIdentifierStart(code, true) || code === 92) {
          return this.finishToken(types$1.privateId, this.readWord1());
        }
      }
      this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    pp.getTokenFromCode = function(code) {
      switch (code) {
        case 46:
          return this.readToken_dot();
        case 40:
          ++this.pos;
          return this.finishToken(types$1.parenL);
        case 41:
          ++this.pos;
          return this.finishToken(types$1.parenR);
        case 59:
          ++this.pos;
          return this.finishToken(types$1.semi);
        case 44:
          ++this.pos;
          return this.finishToken(types$1.comma);
        case 91:
          ++this.pos;
          return this.finishToken(types$1.bracketL);
        case 93:
          ++this.pos;
          return this.finishToken(types$1.bracketR);
        case 123:
          ++this.pos;
          return this.finishToken(types$1.braceL);
        case 125:
          ++this.pos;
          return this.finishToken(types$1.braceR);
        case 58:
          ++this.pos;
          return this.finishToken(types$1.colon);
        case 96:
          if (this.options.ecmaVersion < 6) {
            break;
          }
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        case 48:
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 120 || next === 88) {
            return this.readRadixNumber(16);
          }
          if (this.options.ecmaVersion >= 6) {
            if (next === 111 || next === 79) {
              return this.readRadixNumber(8);
            }
            if (next === 98 || next === 66) {
              return this.readRadixNumber(2);
            }
          }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return this.readNumber(false);
        case 34:
        case 39:
          return this.readString(code);
        case 47:
          return this.readToken_slash();
        case 37:
        case 42:
          return this.readToken_mult_modulo_exp(code);
        case 124:
        case 38:
          return this.readToken_pipe_amp(code);
        case 94:
          return this.readToken_caret();
        case 43:
        case 45:
          return this.readToken_plus_min(code);
        case 60:
        case 62:
          return this.readToken_lt_gt(code);
        case 61:
        case 33:
          return this.readToken_eq_excl(code);
        case 63:
          return this.readToken_question();
        case 126:
          return this.finishOp(types$1.prefix, 1);
        case 35:
          return this.readToken_numberSign();
      }
      this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    pp.finishOp = function(type, size) {
      var str = this.input.slice(this.pos, this.pos + size);
      this.pos += size;
      return this.finishToken(type, str);
    };
    pp.readRegexp = function() {
      var escaped2, inClass, start = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(start, "Unterminated regular expression");
        }
        var ch2 = this.input.charAt(this.pos);
        if (lineBreak.test(ch2)) {
          this.raise(start, "Unterminated regular expression");
        }
        if (!escaped2) {
          if (ch2 === "[") {
            inClass = true;
          } else if (ch2 === "]" && inClass) {
            inClass = false;
          } else if (ch2 === "/" && !inClass) {
            break;
          }
          escaped2 = ch2 === "\\";
        } else {
          escaped2 = false;
        }
        ++this.pos;
      }
      var pattern2 = this.input.slice(start, this.pos);
      ++this.pos;
      var flagsStart = this.pos;
      var flags = this.readWord1();
      if (this.containsEsc) {
        this.unexpected(flagsStart);
      }
      var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
      state.reset(start, pattern2, flags);
      this.validateRegExpFlags(state);
      this.validateRegExpPattern(state);
      var value = null;
      try {
        value = new RegExp(pattern2, flags);
      } catch (e2) {
      }
      return this.finishToken(types$1.regexp, { pattern: pattern2, flags, value });
    };
    pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
      var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
      var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
      var start = this.pos, total = 0, lastCode = 0;
      for (var i2 = 0, e2 = len == null ? Infinity : len; i2 < e2; ++i2, ++this.pos) {
        var code = this.input.charCodeAt(this.pos), val = void 0;
        if (allowSeparators && code === 95) {
          if (isLegacyOctalNumericLiteral) {
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
          }
          if (lastCode === 95) {
            this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
          }
          if (i2 === 0) {
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
          }
          lastCode = code;
          continue;
        }
        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (code >= 48 && code <= 57) {
          val = code - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          break;
        }
        lastCode = code;
        total = total * radix + val;
      }
      if (allowSeparators && lastCode === 95) {
        this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
      }
      if (this.pos === start || len != null && this.pos - start !== len) {
        return null;
      }
      return total;
    };
    function stringToNumber(str, isLegacyOctalNumericLiteral) {
      if (isLegacyOctalNumericLiteral) {
        return parseInt(str, 8);
      }
      return parseFloat(str.replace(/_/g, ""));
    }
    function stringToBigInt(str) {
      if (typeof BigInt !== "function") {
        return null;
      }
      return BigInt(str.replace(/_/g, ""));
    }
    pp.readRadixNumber = function(radix) {
      var start = this.pos;
      this.pos += 2;
      var val = this.readInt(radix);
      if (val == null) {
        this.raise(this.start + 2, "Expected number in radix " + radix);
      }
      if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
        val = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
      } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      return this.finishToken(types$1.num, val);
    };
    pp.readNumber = function(startsWithDot) {
      var start = this.pos;
      if (!startsWithDot && this.readInt(10, void 0, true) === null) {
        this.raise(start, "Invalid number");
      }
      var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (octal && this.strict) {
        this.raise(start, "Invalid number");
      }
      var next = this.input.charCodeAt(this.pos);
      if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
        var val$1 = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$1.num, val$1);
      }
      if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
        octal = false;
      }
      if (next === 46 && !octal) {
        ++this.pos;
        this.readInt(10);
        next = this.input.charCodeAt(this.pos);
      }
      if ((next === 69 || next === 101) && !octal) {
        next = this.input.charCodeAt(++this.pos);
        if (next === 43 || next === 45) {
          ++this.pos;
        }
        if (this.readInt(10) === null) {
          this.raise(start, "Invalid number");
        }
      }
      if (isIdentifierStart(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      var val = stringToNumber(this.input.slice(start, this.pos), octal);
      return this.finishToken(types$1.num, val);
    };
    pp.readCodePoint = function() {
      var ch2 = this.input.charCodeAt(this.pos), code;
      if (ch2 === 123) {
        if (this.options.ecmaVersion < 6) {
          this.unexpected();
        }
        var codePos = ++this.pos;
        code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
        ++this.pos;
        if (code > 1114111) {
          this.invalidStringToken(codePos, "Code point out of bounds");
        }
      } else {
        code = this.readHexChar(4);
      }
      return code;
    };
    function codePointToString(code) {
      if (code <= 65535) {
        return String.fromCharCode(code);
      }
      code -= 65536;
      return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
    }
    pp.readString = function(quote) {
      var out2 = "", chunkStart = ++this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(this.start, "Unterminated string constant");
        }
        var ch2 = this.input.charCodeAt(this.pos);
        if (ch2 === quote) {
          break;
        }
        if (ch2 === 92) {
          out2 += this.input.slice(chunkStart, this.pos);
          out2 += this.readEscapedChar(false);
          chunkStart = this.pos;
        } else if (ch2 === 8232 || ch2 === 8233) {
          if (this.options.ecmaVersion < 10) {
            this.raise(this.start, "Unterminated string constant");
          }
          ++this.pos;
          if (this.options.locations) {
            this.curLine++;
            this.lineStart = this.pos;
          }
        } else {
          if (isNewLine(ch2)) {
            this.raise(this.start, "Unterminated string constant");
          }
          ++this.pos;
        }
      }
      out2 += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(types$1.string, out2);
    };
    var INVALID_TEMPLATE_ESCAPE_ERROR = {};
    pp.tryReadTemplateToken = function() {
      this.inTemplateElement = true;
      try {
        this.readTmplToken();
      } catch (err) {
        if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
          this.readInvalidTemplateToken();
        } else {
          throw err;
        }
      }
      this.inTemplateElement = false;
    };
    pp.invalidStringToken = function(position, message) {
      if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
        throw INVALID_TEMPLATE_ESCAPE_ERROR;
      } else {
        this.raise(position, message);
      }
    };
    pp.readTmplToken = function() {
      var out2 = "", chunkStart = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(this.start, "Unterminated template");
        }
        var ch2 = this.input.charCodeAt(this.pos);
        if (ch2 === 96 || ch2 === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
          if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
            if (ch2 === 36) {
              this.pos += 2;
              return this.finishToken(types$1.dollarBraceL);
            } else {
              ++this.pos;
              return this.finishToken(types$1.backQuote);
            }
          }
          out2 += this.input.slice(chunkStart, this.pos);
          return this.finishToken(types$1.template, out2);
        }
        if (ch2 === 92) {
          out2 += this.input.slice(chunkStart, this.pos);
          out2 += this.readEscapedChar(true);
          chunkStart = this.pos;
        } else if (isNewLine(ch2)) {
          out2 += this.input.slice(chunkStart, this.pos);
          ++this.pos;
          switch (ch2) {
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) {
                ++this.pos;
              }
            case 10:
              out2 += "\n";
              break;
            default:
              out2 += String.fromCharCode(ch2);
              break;
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
    };
    pp.readInvalidTemplateToken = function() {
      for (; this.pos < this.input.length; this.pos++) {
        switch (this.input[this.pos]) {
          case "\\":
            ++this.pos;
            break;
          case "$":
            if (this.input[this.pos + 1] !== "{") {
              break;
            }
          case "`":
            return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
        }
      }
      this.raise(this.start, "Unterminated template");
    };
    pp.readEscapedChar = function(inTemplate) {
      var ch2 = this.input.charCodeAt(++this.pos);
      ++this.pos;
      switch (ch2) {
        case 110:
          return "\n";
        case 114:
          return "\r";
        case 120:
          return String.fromCharCode(this.readHexChar(2));
        case 117:
          return codePointToString(this.readCodePoint());
        case 116:
          return "	";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          if (this.options.locations) {
            this.lineStart = this.pos;
            ++this.curLine;
          }
          return "";
        case 56:
        case 57:
          if (this.strict) {
            this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
          }
          if (inTemplate) {
            var codePos = this.pos - 1;
            this.invalidStringToken(codePos, "Invalid escape sequence in template string");
            return null;
          }
        default:
          if (ch2 >= 48 && ch2 <= 55) {
            var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
            var octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            this.pos += octalStr.length - 1;
            ch2 = this.input.charCodeAt(this.pos);
            if ((octalStr !== "0" || ch2 === 56 || ch2 === 57) && (this.strict || inTemplate)) {
              this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
            }
            return String.fromCharCode(octal);
          }
          if (isNewLine(ch2)) {
            return "";
          }
          return String.fromCharCode(ch2);
      }
    };
    pp.readHexChar = function(len) {
      var codePos = this.pos;
      var n3 = this.readInt(16, len);
      if (n3 === null) {
        this.invalidStringToken(codePos, "Bad character escape sequence");
      }
      return n3;
    };
    pp.readWord1 = function() {
      this.containsEsc = false;
      var word = "", first2 = true, chunkStart = this.pos;
      var astral = this.options.ecmaVersion >= 6;
      while (this.pos < this.input.length) {
        var ch2 = this.fullCharCodeAtPos();
        if (isIdentifierChar(ch2, astral)) {
          this.pos += ch2 <= 65535 ? 1 : 2;
        } else if (ch2 === 92) {
          this.containsEsc = true;
          word += this.input.slice(chunkStart, this.pos);
          var escStart = this.pos;
          if (this.input.charCodeAt(++this.pos) !== 117) {
            this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
          }
          ++this.pos;
          var esc = this.readCodePoint();
          if (!(first2 ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
            this.invalidStringToken(escStart, "Invalid Unicode escape");
          }
          word += codePointToString(esc);
          chunkStart = this.pos;
        } else {
          break;
        }
        first2 = false;
      }
      return word + this.input.slice(chunkStart, this.pos);
    };
    pp.readWord = function() {
      var word = this.readWord1();
      var type = types$1.name;
      if (this.keywords.test(word)) {
        type = keywords[word];
      }
      return this.finishToken(type, word);
    };
    var version = "8.7.0";
    Parser.acorn = {
      Parser,
      version,
      defaultOptions,
      Position,
      SourceLocation,
      getLineInfo,
      Node,
      TokenType,
      tokTypes: types$1,
      keywordTypes: keywords,
      TokContext,
      tokContexts: types,
      isIdentifierChar,
      isIdentifierStart,
      Token,
      isNewLine,
      lineBreak,
      lineBreakG,
      nonASCIIwhitespace
    };
    function parse$c(input, options2) {
      return Parser.parse(input, options2);
    }
    function parseExpressionAt(input, pos, options2) {
      return Parser.parseExpressionAt(input, pos, options2);
    }
    function tokenizer(input, options2) {
      return Parser.tokenizer(input, options2);
    }
    var acorn = {
      __proto__: null,
      Node,
      Parser,
      Position,
      SourceLocation,
      TokContext,
      Token,
      TokenType,
      defaultOptions,
      getLineInfo,
      isIdentifierChar,
      isIdentifierStart,
      isNewLine,
      keywordTypes: keywords,
      lineBreak,
      lineBreakG,
      nonASCIIwhitespace,
      parse: parse$c,
      parseExpressionAt,
      tokContexts: types,
      tokTypes: types$1,
      tokenizer,
      version
    };
    var ansiRegex$1 = ({ onlyFirst = false } = {}) => {
      const pattern2 = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern2, onlyFirst ? void 0 : "g");
    };
    var ansiRegex = ansiRegex$1;
    var stripAnsi = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
    function prepareError(err) {
      return {
        message: stripAnsi(err.message),
        stack: stripAnsi(cleanStack(err.stack || "")),
        id: err.id,
        frame: stripAnsi(err.frame || ""),
        plugin: err.plugin,
        pluginCode: err.pluginCode,
        loc: err.loc
      };
    }
    function buildErrorMessage(err, args = [], includeStack = true) {
      if (err.plugin)
        args.push(`  Plugin: ${source.magenta(err.plugin)}`);
      if (err.id)
        args.push(`  File: ${source.cyan(err.id)}`);
      if (err.frame)
        args.push(source.yellow(pad$1(err.frame)));
      if (includeStack && err.stack)
        args.push(pad$1(cleanStack(err.stack)));
      return args.join("\n");
    }
    function cleanStack(stack) {
      return stack.split(/\n/g).filter((l2) => /^\s*at/.test(l2)).join("\n");
    }
    function logError(server2, err) {
      const msg = buildErrorMessage(err, [
        source.red(`Internal server error: ${err.message}`)
      ]);
      server2.config.logger.error(msg, {
        clear: true,
        timestamp: true,
        error: err
      });
      server2.ws.send({
        type: "error",
        err: prepareError(err)
      });
    }
    function errorMiddleware(server2, allowNext = false) {
      return function viteErrorMiddleware(err, _req, res, next) {
        logError(server2, err);
        if (allowNext) {
          next();
        } else {
          res.statusCode = 500;
          res.end(`
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <title>Error</title>
            <script type="module">
              import { ErrorOverlay } from '/@vite/client'
              document.body.appendChild(new ErrorOverlay(${JSON.stringify(prepareError(err)).replace(/</g, "\\u003c")}))
            <\/script>
          </head>
          <body>
          </body>
        </html>
      `);
        }
      };
    }
    var parser = Parser;
    async function createPluginContainer({ plugins: plugins2, logger, root, build: { rollupOptions } }, moduleGraph, watcher) {
      const isDebug2 = process.env.DEBUG;
      const seenResolves = {};
      const debugResolve = createDebugger("vite:resolve");
      const debugPluginResolve = createDebugger("vite:plugin-resolve", {
        onlyWhenFocused: "vite:plugin"
      });
      const debugPluginTransform = createDebugger("vite:plugin-transform", {
        onlyWhenFocused: "vite:plugin"
      });
      const watchFiles = new Set();
      const rollupPkgPath = path$t.resolve(__require.resolve("rollup"), "../../package.json");
      const minimalContext = {
        meta: {
          rollupVersion: JSON.parse(fs__default.readFileSync(rollupPkgPath, "utf-8")).version,
          watchMode: true
        }
      };
      function warnIncompatibleMethod(method, plugin) {
        logger.warn(source.cyan(`[plugin:${plugin}] `) + source.yellow(`context method ${source.bold(`${method}()`)} is not supported in serve mode. This plugin is likely not vite-compatible.`));
      }
      const ModuleInfoProxy = {
        get(info, key) {
          if (key in info) {
            return info[key];
          }
          throw Error(`[vite] The "${key}" property of ModuleInfo is not supported.`);
        }
      };
      const EMPTY_OBJECT = Object.freeze({});
      function getModuleInfo(id) {
        const module2 = moduleGraph === null || moduleGraph === void 0 ? void 0 : moduleGraph.getModuleById(id);
        if (!module2) {
          return null;
        }
        if (!module2.info) {
          module2.info = new Proxy({ id, meta: module2.meta || EMPTY_OBJECT }, ModuleInfoProxy);
        }
        return module2.info;
      }
      function updateModuleInfo(id, { meta }) {
        if (meta) {
          const moduleInfo = getModuleInfo(id);
          if (moduleInfo) {
            moduleInfo.meta = __spreadValues2(__spreadValues2({}, moduleInfo.meta), meta);
          }
        }
      }
      class Context {
        constructor(initialPlugin) {
          this.meta = minimalContext.meta;
          this.ssr = false;
          this._activeId = null;
          this._activeCode = null;
          this._addedImports = null;
          this._activePlugin = initialPlugin || null;
        }
        parse(code, opts = {}) {
          return parser.parse(code, __spreadValues2({
            sourceType: "module",
            ecmaVersion: "latest",
            locations: true
          }, opts));
        }
        async resolve(id, importer, options2) {
          let skip;
          if ((options2 === null || options2 === void 0 ? void 0 : options2.skipSelf) && this._activePlugin) {
            skip = new Set(this._resolveSkips);
            skip.add(this._activePlugin);
          }
          let out2 = await container.resolveId(id, importer, { skip, ssr: this.ssr });
          if (typeof out2 === "string")
            out2 = { id: out2 };
          return out2;
        }
        getModuleInfo(id) {
          return getModuleInfo(id);
        }
        getModuleIds() {
          return moduleGraph ? moduleGraph.idToModuleMap.keys() : Array.prototype[Symbol.iterator]();
        }
        addWatchFile(id) {
          watchFiles.add(id);
          (this._addedImports || (this._addedImports = new Set())).add(id);
          if (watcher)
            ensureWatchedFile(watcher, id, root);
        }
        getWatchFiles() {
          return [...watchFiles];
        }
        emitFile(assetOrFile) {
          warnIncompatibleMethod(`emitFile`, this._activePlugin.name);
          return "";
        }
        setAssetSource() {
          warnIncompatibleMethod(`setAssetSource`, this._activePlugin.name);
        }
        getFileName() {
          warnIncompatibleMethod(`getFileName`, this._activePlugin.name);
          return "";
        }
        warn(e2, position) {
          const err = formatError(e2, position, this);
          const msg = buildErrorMessage(err, [source.yellow(`warning: ${err.message}`)], false);
          logger.warn(msg, {
            clear: true,
            timestamp: true
          });
        }
        error(e2, position) {
          throw formatError(e2, position, this);
        }
      }
      function formatError(e2, position, ctx) {
        const err = typeof e2 === "string" ? new Error(e2) : e2;
        if (ctx._activePlugin)
          err.plugin = ctx._activePlugin.name;
        if (ctx._activeId && !err.id)
          err.id = ctx._activeId;
        if (ctx._activeCode) {
          err.pluginCode = ctx._activeCode;
          const pos = position != null ? position : err.pos != null ? err.pos : err.position;
          if (pos != null) {
            let errLocation;
            try {
              errLocation = numberToPos(ctx._activeCode, pos);
            } catch (err2) {
              logger.error(source.red(`Error in error handler:
${err2.stack || err2.message}
`), { error: err2 });
              throw err;
            }
            err.loc = err.loc || __spreadValues2({
              file: err.id
            }, errLocation);
            err.frame = err.frame || generateCodeFrame(ctx._activeCode, pos);
          } else if (err.loc) {
            if (!err.frame) {
              let code = ctx._activeCode;
              if (err.loc.file) {
                err.id = normalizePath$4(err.loc.file);
                try {
                  code = fs__default.readFileSync(err.loc.file, "utf-8");
                } catch {
                }
              }
              err.frame = generateCodeFrame(code, err.loc);
            }
          } else if (err.line && err.column) {
            err.loc = {
              file: err.id,
              line: err.line,
              column: err.column
            };
            err.frame = err.frame || generateCodeFrame(ctx._activeCode, err.loc);
          }
        }
        return err;
      }
      class TransformContext extends Context {
        constructor(filename2, code, inMap) {
          super();
          this.originalSourcemap = null;
          this.sourcemapChain = [];
          this.combinedMap = null;
          this.filename = filename2;
          this.originalCode = code;
          if (inMap) {
            this.sourcemapChain.push(inMap);
          }
        }
        _getCombinedSourcemap(createIfNull = false) {
          let combinedMap = this.combinedMap;
          for (let m3 of this.sourcemapChain) {
            if (typeof m3 === "string")
              m3 = JSON.parse(m3);
            if (!("version" in m3)) {
              combinedMap = this.combinedMap = null;
              this.sourcemapChain.length = 0;
              break;
            }
            if (!combinedMap) {
              combinedMap = m3;
            } else {
              combinedMap = combineSourcemaps(this.filename, [
                __spreadProps2(__spreadValues2({}, m3), {
                  sourcesContent: combinedMap.sourcesContent
                }),
                combinedMap
              ]);
            }
          }
          if (!combinedMap) {
            return createIfNull ? new MagicString(this.originalCode).generateMap({
              includeContent: true,
              hires: true,
              source: this.filename
            }) : null;
          }
          if (combinedMap !== this.combinedMap) {
            this.combinedMap = combinedMap;
            this.sourcemapChain.length = 0;
          }
          return this.combinedMap;
        }
        getCombinedSourcemap() {
          return this._getCombinedSourcemap(true);
        }
      }
      let closed = false;
      const container = {
        options: await (async () => {
          let options2 = rollupOptions;
          for (const plugin of plugins2) {
            if (!plugin.options)
              continue;
            options2 = await plugin.options.call(minimalContext, options2) || options2;
          }
          if (options2.acornInjectPlugins) {
            parser = Parser.extend(options2.acornInjectPlugins);
          }
          return __spreadValues2({
            acorn,
            acornInjectPlugins: []
          }, options2);
        })(),
        getModuleInfo,
        async buildStart() {
          await Promise.all(plugins2.map((plugin) => {
            if (plugin.buildStart) {
              return plugin.buildStart.call(new Context(plugin), container.options);
            }
          }));
        },
        async resolveId(rawId, importer = path$t.join(root, "index.html"), options2) {
          const skip = options2 === null || options2 === void 0 ? void 0 : options2.skip;
          const ssr = options2 === null || options2 === void 0 ? void 0 : options2.ssr;
          const ctx = new Context();
          ctx.ssr = !!ssr;
          ctx._resolveSkips = skip;
          const resolveStart = isDebug2 ? perf_hooks.performance.now() : 0;
          let id = null;
          const partial2 = {};
          for (const plugin of plugins2) {
            if (!plugin.resolveId)
              continue;
            if (skip === null || skip === void 0 ? void 0 : skip.has(plugin))
              continue;
            ctx._activePlugin = plugin;
            const pluginResolveStart = isDebug2 ? perf_hooks.performance.now() : 0;
            const result2 = await plugin.resolveId.call(ctx, rawId, importer, { ssr });
            if (!result2)
              continue;
            if (typeof result2 === "string") {
              id = result2;
            } else {
              id = result2.id;
              Object.assign(partial2, result2);
            }
            isDebug2 && debugPluginResolve(timeFrom(pluginResolveStart), plugin.name, prettifyUrl(id, root));
            break;
          }
          if (isDebug2 && rawId !== id && !rawId.startsWith(FS_PREFIX)) {
            const key = rawId + id;
            if (!seenResolves[key]) {
              seenResolves[key] = true;
              debugResolve(`${timeFrom(resolveStart)} ${source.cyan(rawId)} -> ${source.dim(id)}`);
            }
          }
          if (id) {
            partial2.id = isExternalUrl(id) ? id : normalizePath$4(id);
            return partial2;
          } else {
            return null;
          }
        },
        async load(id, options2) {
          const ssr = options2 === null || options2 === void 0 ? void 0 : options2.ssr;
          const ctx = new Context();
          ctx.ssr = !!ssr;
          for (const plugin of plugins2) {
            if (!plugin.load)
              continue;
            ctx._activePlugin = plugin;
            const result2 = await plugin.load.call(ctx, id, { ssr });
            if (result2 != null) {
              if (isObject$3(result2)) {
                updateModuleInfo(id, result2);
              }
              return result2;
            }
          }
          return null;
        },
        async transform(code, id, options2) {
          const inMap = options2 === null || options2 === void 0 ? void 0 : options2.inMap;
          const ssr = options2 === null || options2 === void 0 ? void 0 : options2.ssr;
          const ctx = new TransformContext(id, code, inMap);
          ctx.ssr = !!ssr;
          for (const plugin of plugins2) {
            if (!plugin.transform)
              continue;
            ctx._activePlugin = plugin;
            ctx._activeId = id;
            ctx._activeCode = code;
            const start = isDebug2 ? perf_hooks.performance.now() : 0;
            let result2;
            try {
              result2 = await plugin.transform.call(ctx, code, id, { ssr });
            } catch (e2) {
              ctx.error(e2);
            }
            if (!result2)
              continue;
            isDebug2 && debugPluginTransform(timeFrom(start), plugin.name, prettifyUrl(id, root));
            if (isObject$3(result2)) {
              if (result2.code !== void 0) {
                code = result2.code;
                if (result2.map) {
                  ctx.sourcemapChain.push(result2.map);
                }
              }
              updateModuleInfo(id, result2);
            } else {
              code = result2;
            }
          }
          return {
            code,
            map: ctx._getCombinedSourcemap()
          };
        },
        async close() {
          if (closed)
            return;
          const ctx = new Context();
          await Promise.all(plugins2.map((p2) => p2.buildEnd && p2.buildEnd.call(ctx)));
          await Promise.all(plugins2.map((p2) => p2.closeBundle && p2.closeBundle.call(ctx)));
          closed = true;
        }
      };
      return container;
    }
    var debug$b = createDebugger("vite:deps");
    var htmlTypesRE = /\.(html|vue|svelte|astro)$/;
    var setupRE = /<script\s+setup/;
    var importsRE = /(?<!\/\/.*)(?<=^|;|\*\/)\s*import(?!\s+type)(?:[\w*{}\n\r\t, ]+from\s*)?\s*("[^"]+"|'[^']+')\s*(?=$|;|\/\/|\/\*)/gm;
    async function scanImports(config2) {
      var _a2, _b, _c;
      const start = perf_hooks.performance.now();
      let entries = [];
      const explicitEntryPatterns = config2.optimizeDeps.entries;
      const buildInput = (_a2 = config2.build.rollupOptions) === null || _a2 === void 0 ? void 0 : _a2.input;
      if (explicitEntryPatterns) {
        entries = await globEntries(explicitEntryPatterns, config2);
      } else if (buildInput) {
        const resolvePath = (p2) => path__default.resolve(config2.root, p2);
        if (typeof buildInput === "string") {
          entries = [resolvePath(buildInput)];
        } else if (Array.isArray(buildInput)) {
          entries = buildInput.map(resolvePath);
        } else if (isObject$3(buildInput)) {
          entries = Object.values(buildInput).map(resolvePath);
        } else {
          throw new Error("invalid rollupOptions.input value.");
        }
      } else {
        entries = await globEntries("**/*.html", config2);
      }
      entries = entries.filter((entry2) => (JS_TYPES_RE.test(entry2) || htmlTypesRE.test(entry2)) && fs__default.existsSync(entry2));
      if (!entries.length) {
        if (!explicitEntryPatterns && !config2.optimizeDeps.include) {
          config2.logger.warn(source.yellow("(!) Could not auto-determine entry point from rollupOptions or html files and there are no explicit optimizeDeps.include patterns. Skipping dependency pre-bundling."));
        }
        return { deps: {}, missing: {} };
      } else {
        debug$b(`Crawling dependencies using entries:
  ${entries.join("\n  ")}`);
      }
      const deps = {};
      const missing = {};
      const container = await createPluginContainer(config2);
      const plugin = esbuildScanPlugin(config2, container, deps, missing, entries);
      const _a3 = (_c = (_b = config2.optimizeDeps) === null || _b === void 0 ? void 0 : _b.esbuildOptions) !== null && _c !== void 0 ? _c : {}, { plugins: plugins2 = [] } = _a3, esbuildOptions = __objRest(_a3, ["plugins"]);
      await Promise.all(entries.map((entry2) => esbuild.build(__spreadValues2({
        absWorkingDir: process.cwd(),
        write: false,
        entryPoints: [entry2],
        bundle: true,
        format: "esm",
        logLevel: "error",
        plugins: [...plugins2, plugin]
      }, esbuildOptions))));
      debug$b(`Scan completed in ${(perf_hooks.performance.now() - start).toFixed(2)}ms:`, deps);
      return {
        deps,
        missing
      };
    }
    function globEntries(pattern2, config2) {
      return out(pattern2, {
        cwd: config2.root,
        ignore: [
          "**/node_modules/**",
          `**/${config2.build.outDir}/**`,
          `**/__tests__/**`
        ],
        absolute: true
      });
    }
    var scriptModuleRE = /(<script\b[^>]*type\s*=\s*(?:"module"|'module')[^>]*>)(.*?)<\/script>/gims;
    var scriptRE = /(<script\b(?:\s[^>]*>|>))(.*?)<\/script>/gims;
    var commentRE = /<!--(.|[\r\n])*?-->/;
    var srcRE = /\bsrc\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
    var typeRE = /\btype\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
    var langRE = /\blang\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
    var contextRE = /\bcontext\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/im;
    function esbuildScanPlugin(config2, container, depImports, missing, entries) {
      var _a2, _b;
      const seen2 = new Map();
      const resolve2 = async (id, importer) => {
        const key = id + (importer && path__default.dirname(importer));
        if (seen2.has(key)) {
          return seen2.get(key);
        }
        const resolved = await container.resolveId(id, importer && normalizePath$4(importer));
        const res = resolved === null || resolved === void 0 ? void 0 : resolved.id;
        seen2.set(key, res);
        return res;
      };
      const include = (_a2 = config2.optimizeDeps) === null || _a2 === void 0 ? void 0 : _a2.include;
      const exclude = [
        ...((_b = config2.optimizeDeps) === null || _b === void 0 ? void 0 : _b.exclude) || [],
        "@vite/client",
        "@vite/env"
      ];
      const externalUnlessEntry = ({ path: path2 }) => ({
        path: path2,
        external: !entries.includes(path2)
      });
      return {
        name: "vite:dep-scan",
        setup(build2) {
          const localScripts = {};
          build2.onResolve({ filter: externalRE }, ({ path: path2 }) => ({
            path: path2,
            external: true
          }));
          build2.onResolve({ filter: dataUrlRE }, ({ path: path2 }) => ({
            path: path2,
            external: true
          }));
          build2.onResolve({ filter: virtualModuleRE }, ({ path: path2 }) => {
            return {
              path: path2.replace(virtualModulePrefix, ""),
              namespace: "local-script"
            };
          });
          build2.onLoad({ filter: /.*/, namespace: "local-script" }, ({ path: path2 }) => {
            return localScripts[path2];
          });
          build2.onResolve({ filter: htmlTypesRE }, async ({ path: path2, importer }) => {
            return {
              path: await resolve2(path2, importer),
              namespace: "html"
            };
          });
          build2.onLoad({ filter: htmlTypesRE, namespace: "html" }, async ({ path: path2 }) => {
            let raw = fs__default.readFileSync(path2, "utf-8");
            raw = raw.replace(commentRE, "<!---->");
            const isHtml = path2.endsWith(".html");
            const regex = isHtml ? scriptModuleRE : scriptRE;
            regex.lastIndex = 0;
            let js2 = "";
            let loader = "js";
            let match2;
            while (match2 = regex.exec(raw)) {
              const [, openTag, content2] = match2;
              const typeMatch = openTag.match(typeRE);
              const type = typeMatch && (typeMatch[1] || typeMatch[2] || typeMatch[3]);
              const langMatch = openTag.match(langRE);
              const lang = langMatch && (langMatch[1] || langMatch[2] || langMatch[3]);
              if (type && !(type.includes("javascript") || type.includes("ecmascript") || type === "module")) {
                continue;
              }
              if (lang === "ts" || lang === "tsx" || lang === "jsx") {
                loader = lang;
              }
              const srcMatch = openTag.match(srcRE);
              if (srcMatch) {
                const src2 = srcMatch[1] || srcMatch[2] || srcMatch[3];
                js2 += `import ${JSON.stringify(src2)}
`;
              } else if (content2.trim()) {
                const contextMatch = openTag.match(contextRE);
                const context2 = contextMatch && (contextMatch[1] || contextMatch[2] || contextMatch[3]);
                if (path2.endsWith(".vue") && setupRE.test(openTag) || path2.endsWith(".svelte") && context2 !== "module") {
                  const localContent = content2 + (loader.startsWith("ts") ? extractImportPaths(content2) : "");
                  localScripts[path2] = {
                    loader,
                    contents: localContent
                  };
                  js2 += `import '${virtualModulePrefix}${path2}';
`;
                } else {
                  js2 += content2 + "\n";
                }
              }
            }
            if (loader.startsWith("ts") && path2.endsWith(".svelte")) {
              js2 += extractImportPaths(js2);
            }
            if (!path2.endsWith(".vue") || !js2.includes("export default")) {
              js2 += "\nexport default {}";
            }
            if (js2.includes("import.meta.glob")) {
              return {
                loader: "js",
                contents: await transformGlob(js2, path2, config2.root, loader)
              };
            }
            return {
              loader,
              contents: js2
            };
          });
          build2.onResolve({
            filter: /^[\w@][^:]/
          }, async ({ path: id, importer }) => {
            if (moduleListContains(exclude, id)) {
              return externalUnlessEntry({ path: id });
            }
            if (depImports[id]) {
              return externalUnlessEntry({ path: id });
            }
            const resolved = await resolve2(id, importer);
            if (resolved) {
              if (shouldExternalizeDep(resolved, id)) {
                return externalUnlessEntry({ path: id });
              }
              if (resolved.includes("node_modules") || (include === null || include === void 0 ? void 0 : include.includes(id))) {
                if (OPTIMIZABLE_ENTRY_RE.test(resolved)) {
                  depImports[id] = resolved;
                }
                return externalUnlessEntry({ path: id });
              } else {
                const namespace = htmlTypesRE.test(resolved) ? "html" : void 0;
                return {
                  path: path__default.resolve(resolved),
                  namespace
                };
              }
            } else {
              missing[id] = normalizePath$4(importer);
            }
          });
          build2.onResolve({
            filter: /\.(css|less|sass|scss|styl|stylus|pcss|postcss|json)$/
          }, externalUnlessEntry);
          build2.onResolve({
            filter: new RegExp(`\\.(${KNOWN_ASSET_TYPES.join("|")})$`)
          }, externalUnlessEntry);
          build2.onResolve({ filter: SPECIAL_QUERY_RE }, ({ path: path2 }) => ({
            path: path2,
            external: true
          }));
          build2.onResolve({
            filter: /.*/
          }, async ({ path: id, importer }) => {
            const resolved = await resolve2(id, importer);
            if (resolved) {
              if (shouldExternalizeDep(resolved, id)) {
                return externalUnlessEntry({ path: id });
              }
              const namespace = htmlTypesRE.test(resolved) ? "html" : void 0;
              return {
                path: path__default.resolve(cleanUrl(resolved)),
                namespace
              };
            } else {
              return externalUnlessEntry({ path: id });
            }
          });
          build2.onLoad({ filter: JS_TYPES_RE }, ({ path: id }) => {
            let ext2 = path__default.extname(id).slice(1);
            if (ext2 === "mjs")
              ext2 = "js";
            let contents = fs__default.readFileSync(id, "utf-8");
            if (ext2.endsWith("x") && config2.esbuild && config2.esbuild.jsxInject) {
              contents = config2.esbuild.jsxInject + `
` + contents;
            }
            if (contents.includes("import.meta.glob")) {
              return transformGlob(contents, id, config2.root, ext2).then((contents2) => ({
                loader: ext2,
                contents: contents2
              }));
            }
            return {
              loader: ext2,
              contents
            };
          });
        }
      };
    }
    async function transformGlob(source2, importer, root, loader) {
      if (loader !== "js") {
        source2 = (await esbuild.transform(source2, { loader })).code;
      }
      await init;
      const imports = parse$f(source2)[0];
      const s2 = new MagicString(source2);
      for (let index2 = 0; index2 < imports.length; index2++) {
        const { s: start, e: end, ss: expStart } = imports[index2];
        const url2 = source2.slice(start, end);
        if (url2 !== "import.meta")
          continue;
        if (source2.slice(end, end + 5) !== ".glob")
          continue;
        const { importsString, exp, endIndex } = await transformImportGlob(source2, start, normalizePath$4(importer), index2, root);
        s2.prepend(importsString);
        s2.overwrite(expStart, endIndex, exp);
      }
      return s2.toString();
    }
    function extractImportPaths(code) {
      code = code.replace(multilineCommentsRE$1, "/* */").replace(singlelineCommentsRE$1, "");
      let js2 = "";
      let m3;
      while ((m3 = importsRE.exec(code)) != null) {
        if (m3.index === importsRE.lastIndex) {
          importsRE.lastIndex++;
        }
        js2 += `
import ${m3[1]}`;
      }
      return js2;
    }
    function shouldExternalizeDep(resolvedId, rawId) {
      if (!path__default.isAbsolute(resolvedId)) {
        return true;
      }
      if (resolvedId === rawId || resolvedId.includes("\0")) {
        return true;
      }
      if (!JS_TYPES_RE.test(resolvedId) && !htmlTypesRE.test(resolvedId)) {
        return true;
      }
      return false;
    }
    function assetImportMetaUrlPlugin(config2) {
      return {
        name: "vite:asset-import-meta-url",
        async transform(code, id, options2) {
          if (code.includes("new URL") && code.includes(`import.meta.url`)) {
            const importMetaUrlRE = /\bnew\s+URL\s*\(\s*('[^']+'|"[^"]+"|`[^`]+`)\s*,\s*import\.meta\.url\s*\)/g;
            const noCommentsCode = code.replace(multilineCommentsRE$1, (m3) => " ".repeat(m3.length)).replace(singlelineCommentsRE$1, (m3) => " ".repeat(m3.length));
            let s2 = null;
            let match2;
            while (match2 = importMetaUrlRE.exec(noCommentsCode)) {
              const { 0: exp, 1: rawUrl, index: index2 } = match2;
              if (options2 === null || options2 === void 0 ? void 0 : options2.ssr) {
                this.error(`\`new URL(url, import.meta.url)\` is not supported in SSR.`, index2);
              }
              if (!s2)
                s2 = new MagicString(code);
              if (rawUrl[0] === "`" && /\$\{/.test(rawUrl)) {
                const ast = this.parse(rawUrl);
                const templateLiteral = ast.body[0].expression;
                if (templateLiteral.expressions.length) {
                  const pattern2 = buildGlobPattern(templateLiteral);
                  s2.overwrite(index2, index2 + exp.length, `new URL(import.meta.globEagerDefault(${JSON.stringify(pattern2)})[${rawUrl}], self.location)`);
                  continue;
                }
              }
              const url2 = rawUrl.slice(1, -1);
              const file = path__default.resolve(path__default.dirname(id), url2);
              const builtUrl = await fileToUrl(file, config2, this);
              s2.overwrite(index2, index2 + exp.length, `new URL(${JSON.stringify(builtUrl)}, self.location)`);
            }
            if (s2) {
              return {
                code: s2.toString(),
                map: config2.build.sourcemap ? s2.generateMap({ hires: true }) : null
              };
            }
          }
          return null;
        }
      };
    }
    function buildGlobPattern(ast) {
      let pattern2 = "";
      let lastElementIndex = -1;
      for (const exp of ast.expressions) {
        for (let i2 = lastElementIndex + 1; i2 < ast.quasis.length; i2++) {
          const el = ast.quasis[i2];
          if (el.end < exp.start) {
            pattern2 += el.value.raw;
            lastElementIndex = i2;
          }
        }
        pattern2 += "**";
      }
      for (let i2 = lastElementIndex + 1; i2 < ast.quasis.length; i2++) {
        pattern2 += ast.quasis[i2].value.raw;
      }
      return pattern2;
    }
    function loadFallbackPlugin() {
      return {
        name: "vite:load-fallback",
        async load(id) {
          try {
            return await fs$r.promises.readFile(cleanUrl(id), "utf-8");
          } catch (e2) {
            return fs$r.promises.readFile(id, "utf-8");
          }
        }
      };
    }
    function resolveBuildOptions(root, raw, isBuild) {
      var _a2;
      const resolved = __spreadProps2(__spreadValues2({
        target: "modules",
        polyfillModulePreload: true,
        outDir: "dist",
        assetsDir: "assets",
        assetsInlineLimit: 4096,
        cssCodeSplit: !(raw === null || raw === void 0 ? void 0 : raw.lib),
        cssTarget: false,
        sourcemap: false,
        rollupOptions: {},
        minify: (raw === null || raw === void 0 ? void 0 : raw.ssr) ? false : "esbuild",
        terserOptions: {},
        write: true,
        emptyOutDir: null,
        manifest: false,
        lib: false,
        ssr: false,
        ssrManifest: false,
        reportCompressedSize: true,
        chunkSizeWarningLimit: 500,
        watch: null
      }, raw), {
        commonjsOptions: __spreadValues2({
          include: [/node_modules/],
          extensions: [".js", ".cjs"]
        }, raw === null || raw === void 0 ? void 0 : raw.commonjsOptions),
        dynamicImportVarsOptions: __spreadValues2({
          warnOnError: true,
          exclude: [/node_modules/]
        }, raw === null || raw === void 0 ? void 0 : raw.dynamicImportVarsOptions)
      });
      const resolve2 = (p2) => p2.startsWith("\0") ? p2 : path__default.resolve(root, p2);
      resolved.outDir = resolve2(resolved.outDir);
      let input;
      if ((_a2 = raw === null || raw === void 0 ? void 0 : raw.rollupOptions) === null || _a2 === void 0 ? void 0 : _a2.input) {
        input = Array.isArray(raw.rollupOptions.input) ? raw.rollupOptions.input.map((input2) => resolve2(input2)) : typeof raw.rollupOptions.input === "object" ? Object.fromEntries(Object.entries(raw.rollupOptions.input).map(([key, value]) => [
          key,
          resolve2(value)
        ])) : resolve2(raw.rollupOptions.input);
      } else if ((raw === null || raw === void 0 ? void 0 : raw.lib) && isBuild) {
        input = resolve2(raw.lib.entry);
      } else if (typeof (raw === null || raw === void 0 ? void 0 : raw.ssr) === "string") {
        input = resolve2(raw.ssr);
      } else if (isBuild) {
        input = resolve2("index.html");
      }
      if (!!(raw === null || raw === void 0 ? void 0 : raw.ssr) && typeof input === "string" && input.endsWith(".html")) {
        throw new Error(`rollupOptions.input should not be an html file when building for SSR. Please specify a dedicated SSR entry.`);
      }
      if (input) {
        resolved.rollupOptions.input = input;
      }
      if (resolved.target === "modules") {
        resolved.target = [
          "es2019",
          "edge88",
          "firefox78",
          "chrome87",
          "safari13.1"
        ];
      } else if (resolved.target === "esnext" && resolved.minify === "terser") {
        resolved.target = "es2019";
      }
      if (!resolved.cssTarget) {
        resolved.cssTarget = resolved.target;
      }
      if (resolved.minify === "false") {
        resolved.minify = false;
      }
      if (resolved.minify === true) {
        resolved.minify = "esbuild";
      }
      return resolved;
    }
    function resolveBuildPlugins(config2) {
      const options2 = config2.build;
      return {
        pre: [
          watchPackageDataPlugin(config2),
          buildHtmlPlugin(config2),
          commonjs(options2.commonjsOptions),
          dataURIPlugin(),
          dynamicImportVariables(options2.dynamicImportVarsOptions),
          assetImportMetaUrlPlugin(config2),
          ...options2.rollupOptions.plugins ? options2.rollupOptions.plugins.filter(Boolean) : []
        ],
        post: [
          buildImportAnalysisPlugin(config2),
          buildEsbuildPlugin(config2),
          ...options2.minify === "terser" ? [terserPlugin(config2)] : [],
          ...options2.manifest ? [manifestPlugin(config2)] : [],
          ...options2.ssrManifest ? [ssrManifestPlugin(config2)] : [],
          buildReporterPlugin(config2),
          loadFallbackPlugin()
        ]
      };
    }
    var parallelCallCounts = 0;
    var parallelBuilds = [];
    async function build(inlineConfig = {}) {
      parallelCallCounts++;
      try {
        return await doBuild(inlineConfig);
      } finally {
        parallelCallCounts--;
        if (parallelCallCounts <= 0) {
          await Promise.all(parallelBuilds.map((bundle) => bundle.close()));
          parallelBuilds.length = 0;
        }
      }
    }
    async function doBuild(inlineConfig = {}) {
      var _a2, _b, _c;
      const config2 = await resolveConfig(inlineConfig, "build", "production");
      const options2 = config2.build;
      const input = options2.rollupOptions.input;
      const outDir = options2.outDir;
      const ssr = !!options2.ssr;
      const libOptions = options2.lib;
      config2.logger.info(source.cyan(`vite v${require_package().version} ${source.green(`building ${ssr ? `SSR bundle ` : ``}for ${config2.mode}...`)}`));
      const plugins2 = ssr ? config2.plugins.map((p2) => injectSsrFlagToHooks(p2)) : config2.plugins;
      const userExternal = (_a2 = options2.rollupOptions) === null || _a2 === void 0 ? void 0 : _a2.external;
      let external = userExternal;
      if (ssr) {
        let knownImports;
        if (config2.cacheDir) {
          const dataPath = path__default.join(config2.cacheDir, "_metadata.json");
          try {
            const data2 = JSON.parse(fs__default.readFileSync(dataPath, "utf-8"));
            knownImports = Object.keys(data2.optimized);
          } catch (e2) {
          }
        }
        if (!knownImports) {
          knownImports = Object.keys((await scanImports(config2)).deps);
        }
        external = resolveExternal(resolveSSRExternal(config2, knownImports), userExternal);
      }
      const rollup = (init_rollup_browser(), rollup_browser_exports);
      const rollupOptions = __spreadProps2(__spreadValues2({
        context: "globalThis",
        preserveEntrySignatures: ssr ? "allow-extension" : libOptions ? "strict" : false
      }, options2.rollupOptions), {
        plugins: plugins2,
        external,
        onwarn(warning, warn2) {
          onRollupWarning(warning, warn2, config2);
        }
      });
      const outputBuildError = (e2) => {
        let msg = source.red((e2.plugin ? `[${e2.plugin}] ` : "") + e2.message);
        if (e2.id) {
          msg += `
file: ${source.cyan(e2.id + (e2.loc ? `:${e2.loc.line}:${e2.loc.column}` : ""))}`;
        }
        if (e2.frame) {
          msg += `
` + source.yellow(e2.frame);
        }
        config2.logger.error(msg, { error: e2 });
      };
      try {
        const buildOutputOptions = (output = {}) => {
          if (output.output) {
            config2.logger.warn(`You've set "rollupOptions.output.output" in your config. This is deprecated and will override all Vite.js default output options. Please use "rollupOptions.output" instead.`);
          }
          return __spreadValues2({
            dir: outDir,
            format: ssr ? "cjs" : "es",
            exports: ssr ? "named" : "auto",
            sourcemap: options2.sourcemap,
            name: libOptions ? libOptions.name : void 0,
            entryFileNames: ssr ? `[name].js` : libOptions ? resolveLibFilename(libOptions, output.format || "es", config2.root) : path__default.posix.join(options2.assetsDir, `[name].[hash].js`),
            chunkFileNames: libOptions ? `[name].js` : path__default.posix.join(options2.assetsDir, `[name].[hash].js`),
            assetFileNames: libOptions ? `[name].[ext]` : path__default.posix.join(options2.assetsDir, `[name].[hash].[ext]`),
            namespaceToStringTag: true,
            inlineDynamicImports: ssr && typeof input === "string",
            manualChunks: !ssr && !libOptions && (output === null || output === void 0 ? void 0 : output.format) !== "umd" && (output === null || output === void 0 ? void 0 : output.format) !== "iife" ? createMoveToVendorChunkFn() : void 0
          }, output);
        };
        const outputs = resolveBuildOutputs((_b = options2.rollupOptions) === null || _b === void 0 ? void 0 : _b.output, libOptions, config2.logger);
        if (config2.build.watch) {
          config2.logger.info(source.cyanBright(`
watching for file changes...`));
          const output = [];
          if (Array.isArray(outputs)) {
            for (const resolvedOutput of outputs) {
              output.push(buildOutputOptions(resolvedOutput));
            }
          } else {
            output.push(buildOutputOptions(outputs));
          }
          const watcherOptions = config2.build.watch;
          const watcher = rollup.watch(__spreadProps2(__spreadValues2({}, rollupOptions), {
            output,
            watch: __spreadProps2(__spreadValues2({}, watcherOptions), {
              chokidar: __spreadValues2({
                ignored: [
                  "**/node_modules/**",
                  "**/.git/**",
                  ...((_c = watcherOptions === null || watcherOptions === void 0 ? void 0 : watcherOptions.chokidar) === null || _c === void 0 ? void 0 : _c.ignored) || []
                ],
                ignoreInitial: true,
                ignorePermissionErrors: true
              }, watcherOptions.chokidar)
            })
          }));
          watcher.on("event", (event) => {
            if (event.code === "BUNDLE_START") {
              config2.logger.info(source.cyanBright(`
build started...`));
              if (options2.write) {
                prepareOutDir(outDir, options2.emptyOutDir, config2);
              }
            } else if (event.code === "BUNDLE_END") {
              event.result.close();
              config2.logger.info(source.cyanBright(`built in ${event.duration}ms.`));
            } else if (event.code === "ERROR") {
              outputBuildError(event.error);
            }
          });
          watcher.close();
          return watcher;
        }
        const bundle = await rollup.rollup(rollupOptions);
        parallelBuilds.push(bundle);
        const generate2 = (output = {}) => {
          return bundle[options2.write ? "write" : "generate"](buildOutputOptions(output));
        };
        if (options2.write) {
          prepareOutDir(outDir, options2.emptyOutDir, config2);
        }
        if (Array.isArray(outputs)) {
          const res = [];
          for (const output of outputs) {
            res.push(await generate2(output));
          }
          return res;
        } else {
          return await generate2(outputs);
        }
      } catch (e2) {
        outputBuildError(e2);
        throw e2;
      }
    }
    function prepareOutDir(outDir, emptyOutDir, config2) {
      if (fs__default.existsSync(outDir)) {
        if (emptyOutDir == null && !normalizePath$4(outDir).startsWith(config2.root + "/")) {
          config2.logger.warn(source.yellow(`
${source.bold(`(!)`)} outDir ${source.white.dim(outDir)} is not inside project root and will not be emptied.
Use --emptyOutDir to override.
`));
        } else if (emptyOutDir !== false) {
          emptyDir(outDir, [".git"]);
        }
      }
      if (config2.publicDir && fs__default.existsSync(config2.publicDir)) {
        copyDir(config2.publicDir, outDir);
      }
    }
    function getPkgName(root) {
      const { name } = JSON.parse(lookupFile(root, ["package.json"]) || `{}`);
      return (name === null || name === void 0 ? void 0 : name.startsWith("@")) ? name.split("/")[1] : name;
    }
    function createMoveToVendorChunkFn(config2) {
      const cache2 = new Map();
      return (id, { getModuleInfo }) => {
        if (id.includes("node_modules") && !isCSSRequest(id) && staticImportedByEntry(id, getModuleInfo, cache2)) {
          return "vendor";
        }
      };
    }
    function staticImportedByEntry(id, getModuleInfo, cache2, importStack = []) {
      if (cache2.has(id)) {
        return cache2.get(id);
      }
      if (importStack.includes(id)) {
        cache2.set(id, false);
        return false;
      }
      const mod = getModuleInfo(id);
      if (!mod) {
        cache2.set(id, false);
        return false;
      }
      if (mod.isEntry) {
        cache2.set(id, true);
        return true;
      }
      const someImporterIs = mod.importers.some((importer) => staticImportedByEntry(importer, getModuleInfo, cache2, importStack.concat(id)));
      cache2.set(id, someImporterIs);
      return someImporterIs;
    }
    function resolveLibFilename(libOptions, format2, root) {
      if (typeof libOptions.fileName === "function") {
        return libOptions.fileName(format2);
      }
      const name = libOptions.fileName || getPkgName(root);
      if (!name)
        throw new Error('Name in package.json is required if option "build.lib.fileName" is not provided.');
      return `${name}.${format2}.js`;
    }
    function resolveBuildOutputs(outputs, libOptions, logger) {
      if (libOptions) {
        const formats = libOptions.formats || ["es", "umd"];
        if ((formats.includes("umd") || formats.includes("iife")) && !libOptions.name) {
          throw new Error(`Option "build.lib.name" is required when output formats include "umd" or "iife".`);
        }
        if (!outputs) {
          return formats.map((format2) => ({ format: format2 }));
        } else if (!Array.isArray(outputs)) {
          return formats.map((format2) => __spreadProps2(__spreadValues2({}, outputs), { format: format2 }));
        } else if (libOptions.formats) {
          logger.warn(source.yellow(`"build.lib.formats" will be ignored because "build.rollupOptions.output" is already an array format`));
        }
      }
      return outputs;
    }
    var warningIgnoreList = [`CIRCULAR_DEPENDENCY`, `THIS_IS_UNDEFINED`];
    var dynamicImportWarningIgnoreList = [
      `Unsupported expression`,
      `statically analyzed`
    ];
    function onRollupWarning(warning, warn2, config2) {
      var _a2;
      if (warning.code === "UNRESOLVED_IMPORT") {
        const id = warning.source;
        const importer = warning.importer;
        if (!importer || !/\?commonjs-external$/.test(importer)) {
          throw new Error(`[vite]: Rollup failed to resolve import "${id}" from "${importer}".
This is most likely unintended because it can break your application at runtime.
If you do want to externalize this module explicitly add it to
\`build.rollupOptions.external\``);
        }
      }
      if (warning.plugin === "rollup-plugin-dynamic-import-variables" && dynamicImportWarningIgnoreList.some((msg) => warning.message.includes(msg))) {
        return;
      }
      if (!warningIgnoreList.includes(warning.code)) {
        const userOnWarn = (_a2 = config2.build.rollupOptions) === null || _a2 === void 0 ? void 0 : _a2.onwarn;
        if (userOnWarn) {
          userOnWarn(warning, warn2);
        } else if (warning.code === "PLUGIN_WARNING") {
          config2.logger.warn(`${source.bold.yellow(`[plugin:${warning.plugin}]`)} ${source.yellow(warning.message)}`);
        } else {
          warn2(warning);
        }
      }
    }
    function resolveExternal(ssrExternals, user) {
      return (id, parentId, isResolved) => {
        if (shouldExternalizeForSSR(id, ssrExternals)) {
          return true;
        }
        if (user) {
          if (typeof user === "function") {
            return user(id, parentId, isResolved);
          } else if (Array.isArray(user)) {
            return user.some((test) => isExternal(id, test));
          } else {
            return isExternal(id, user);
          }
        }
      };
    }
    function isExternal(id, test) {
      if (typeof test === "string") {
        return id === test;
      } else {
        return test.test(id);
      }
    }
    function injectSsrFlagToHooks(p2) {
      const { resolveId: resolveId2, load: load2, transform: transform2 } = p2;
      return __spreadProps2(__spreadValues2({}, p2), {
        resolveId: wrapSsrResolveId(resolveId2),
        load: wrapSsrLoad(load2),
        transform: wrapSsrTransform(transform2)
      });
    }
    function wrapSsrResolveId(fn2) {
      if (!fn2)
        return;
      return function(id, importer, options2) {
        return fn2.call(this, id, importer, injectSsrFlag(options2));
      };
    }
    function wrapSsrLoad(fn2) {
      if (!fn2)
        return;
      return function(id, ...args) {
        return fn2.call(this, id, injectSsrFlag(args[0]));
      };
    }
    function wrapSsrTransform(fn2) {
      if (!fn2)
        return;
      return function(code, importer, ...args) {
        return fn2.call(this, code, importer, injectSsrFlag(args[0]));
      };
    }
    function injectSsrFlag(options2 = {}) {
      return __spreadProps2(__spreadValues2({}, options2), { ssr: true });
    }
    var build$1 = {
      __proto__: null,
      resolveBuildOptions,
      resolveBuildPlugins,
      build,
      resolveLibFilename,
      onRollupWarning
    };
    var src = { exports: {} };
    var browser = { exports: {} };
    var debug$a = { exports: {} };
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    var ms = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse$b(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options2.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse$b(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match2 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match2) {
        return;
      }
      var n3 = parseFloat(match2[1]);
      var type = (match2[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n3 * y;
        case "days":
        case "day":
        case "d":
          return n3 * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n3 * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n3 * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n3 * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n3;
        default:
          return void 0;
      }
    }
    function fmtShort(ms3) {
      if (ms3 >= d) {
        return Math.round(ms3 / d) + "d";
      }
      if (ms3 >= h) {
        return Math.round(ms3 / h) + "h";
      }
      if (ms3 >= m) {
        return Math.round(ms3 / m) + "m";
      }
      if (ms3 >= s) {
        return Math.round(ms3 / s) + "s";
      }
      return ms3 + "ms";
    }
    function fmtLong(ms3) {
      return plural(ms3, d, "day") || plural(ms3, h, "hour") || plural(ms3, m, "minute") || plural(ms3, s, "second") || ms3 + " ms";
    }
    function plural(ms3, n3, name) {
      if (ms3 < n3) {
        return;
      }
      if (ms3 < n3 * 1.5) {
        return Math.floor(ms3 / n3) + " " + name;
      }
      return Math.ceil(ms3 / n3) + " " + name + "s";
    }
    (function(module2, exports2) {
      exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
      exports2.coerce = coerce;
      exports2.disable = disable;
      exports2.enable = enable;
      exports2.enabled = enabled;
      exports2.humanize = ms;
      exports2.names = [];
      exports2.skips = [];
      exports2.formatters = {};
      var prevTime;
      function selectColor(namespace) {
        var hash = 0, i2;
        for (i2 in namespace) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return exports2.colors[Math.abs(hash) % exports2.colors.length];
      }
      function createDebug(namespace) {
        function debug2() {
          if (!debug2.enabled)
            return;
          var self2 = debug2;
          var curr = +new Date();
          var ms3 = curr - (prevTime || curr);
          self2.diff = ms3;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          var args = new Array(arguments.length);
          for (var i2 = 0; i2 < args.length; i2++) {
            args[i2] = arguments[i2];
          }
          args[0] = exports2.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          var index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format2) {
            if (match2 === "%%")
              return match2;
            index2++;
            var formatter2 = exports2.formatters[format2];
            if (typeof formatter2 === "function") {
              var val = args[index2];
              match2 = formatter2.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match2;
          });
          exports2.formatArgs.call(self2, args);
          var logFn = debug2.log || exports2.log || console.log.bind(console);
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.enabled = exports2.enabled(namespace);
        debug2.useColors = exports2.useColors();
        debug2.color = selectColor(namespace);
        if (typeof exports2.init === "function") {
          exports2.init(debug2);
        }
        return debug2;
      }
      function enable(namespaces) {
        exports2.save(namespaces);
        exports2.names = [];
        exports2.skips = [];
        var split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        var len = split2.length;
        for (var i2 = 0; i2 < len; i2++) {
          if (!split2[i2])
            continue;
          namespaces = split2[i2].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            exports2.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        exports2.enable("");
      }
      function enabled(name) {
        var i2, len;
        for (i2 = 0, len = exports2.skips.length; i2 < len; i2++) {
          if (exports2.skips[i2].test(name)) {
            return false;
          }
        }
        for (i2 = 0, len = exports2.names.length; i2 < len; i2++) {
          if (exports2.names[i2].test(name)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error)
          return val.stack || val.message;
        return val;
      }
    })(debug$a, debug$a.exports);
    (function(module2, exports2) {
      exports2 = module2.exports = debug$a.exports;
      exports2.log = log2;
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load2;
      exports2.useColors = useColors;
      exports2.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
      exports2.colors = [
        "lightseagreen",
        "forestgreen",
        "goldenrod",
        "dodgerblue",
        "darkorchid",
        "crimson"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
          return true;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      exports2.formatters.j = function(v2) {
        try {
          return JSON.stringify(v2);
        } catch (err) {
          return "[UnexpectedJSONParseError]: " + err.message;
        }
      };
      function formatArgs(args) {
        var useColors2 = this.useColors;
        args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
        if (!useColors2)
          return;
        var c2 = "color: " + this.color;
        args.splice(1, 0, c2, "color: inherit");
        var index2 = 0;
        var lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, function(match2) {
          if (match2 === "%%")
            return;
          index2++;
          if (match2 === "%c") {
            lastC = index2;
          }
        });
        args.splice(lastC, 0, c2);
      }
      function log2() {
        return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
      }
      function save(namespaces) {
        try {
          if (namespaces == null) {
            exports2.storage.removeItem("debug");
          } else {
            exports2.storage.debug = namespaces;
          }
        } catch (e2) {
        }
      }
      function load2() {
        var r2;
        try {
          r2 = exports2.storage.debug;
        } catch (e2) {
        }
        if (!r2 && typeof process !== "undefined" && "env" in process) {
          r2 = process.env.DEBUG;
        }
        return r2;
      }
      exports2.enable(load2());
      function localstorage() {
        try {
          return window.localStorage;
        } catch (e2) {
        }
      }
    })(browser, browser.exports);
    var node = { exports: {} };
    (function(module2, exports2) {
      var tty2 = require$$0__default;
      var util2 = require$$0__default$2;
      exports2 = module2.exports = debug$a.exports;
      exports2.init = init2;
      exports2.log = log2;
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load2;
      exports2.useColors = useColors;
      exports2.colors = [6, 2, 3, 4, 5, 1];
      exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
        return /^debug_/i.test(key);
      }).reduce(function(obj, key) {
        var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_2, k2) {
          return k2.toUpperCase();
        });
        var val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val))
          val = true;
        else if (/^(no|off|false|disabled)$/i.test(val))
          val = false;
        else if (val === "null")
          val = null;
        else
          val = Number(val);
        obj[prop] = val;
        return obj;
      }, {});
      var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
      if (fd !== 1 && fd !== 2) {
        util2.deprecate(function() {
        }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
      }
      var stream2 = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
      function useColors() {
        return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty2.isatty(fd);
      }
      exports2.formatters.o = function(v2) {
        this.inspectOpts.colors = this.useColors;
        return util2.inspect(v2, this.inspectOpts).split("\n").map(function(str) {
          return str.trim();
        }).join(" ");
      };
      exports2.formatters.O = function(v2) {
        this.inspectOpts.colors = this.useColors;
        return util2.inspect(v2, this.inspectOpts);
      };
      function formatArgs(args) {
        var name = this.namespace;
        var useColors2 = this.useColors;
        if (useColors2) {
          var c2 = this.color;
          var prefix = "  [3" + c2 + ";1m" + name + " [0m";
          args[0] = prefix + args[0].split("\n").join("\n" + prefix);
          args.push("[3" + c2 + "m+" + exports2.humanize(this.diff) + "[0m");
        } else {
          args[0] = new Date().toUTCString() + " " + name + " " + args[0];
        }
      }
      function log2() {
        return stream2.write(util2.format.apply(util2, arguments) + "\n");
      }
      function save(namespaces) {
        if (namespaces == null) {
          delete process.env.DEBUG;
        } else {
          process.env.DEBUG = namespaces;
        }
      }
      function load2() {
        return process.env.DEBUG;
      }
      function createWritableStdioStream(fd2) {
        var stream3;
        var tty_wrap = process.binding("tty_wrap");
        switch (tty_wrap.guessHandleType(fd2)) {
          case "TTY":
            stream3 = new tty2.WriteStream(fd2);
            stream3._type = "tty";
            if (stream3._handle && stream3._handle.unref) {
              stream3._handle.unref();
            }
            break;
          case "FILE":
            var fs3 = fs__default;
            stream3 = new fs3.SyncWriteStream(fd2, { autoClose: false });
            stream3._type = "fs";
            break;
          case "PIPE":
          case "TCP":
            var net2 = require$$3__default;
            stream3 = new net2.Socket({
              fd: fd2,
              readable: false,
              writable: true
            });
            stream3.readable = false;
            stream3.read = null;
            stream3._type = "pipe";
            if (stream3._handle && stream3._handle.unref) {
              stream3._handle.unref();
            }
            break;
          default:
            throw new Error("Implement me. Unknown stream file type!");
        }
        stream3.fd = fd2;
        stream3._isStdio = true;
        return stream3;
      }
      function init2(debug2) {
        debug2.inspectOpts = {};
        var keys = Object.keys(exports2.inspectOpts);
        for (var i2 = 0; i2 < keys.length; i2++) {
          debug2.inspectOpts[keys[i2]] = exports2.inspectOpts[keys[i2]];
        }
      }
      exports2.enable(load2());
    })(node, node.exports);
    if (typeof process !== "undefined" && process.type === "renderer") {
      src.exports = browser.exports;
    } else {
      src.exports = node.exports;
    }
    var encodeurl = encodeUrl$1;
    var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
    var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
    var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1\uFFFD$2";
    function encodeUrl$1(url2) {
      return String(url2).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
    }
    var matchHtmlRegExp = /["'&<>]/;
    var escapeHtml_1 = escapeHtml$1;
    function escapeHtml$1(string2) {
      var str = "" + string2;
      var match2 = matchHtmlRegExp.exec(str);
      if (!match2) {
        return str;
      }
      var escape2;
      var html = "";
      var index2 = 0;
      var lastIndex = 0;
      for (index2 = match2.index; index2 < str.length; index2++) {
        switch (str.charCodeAt(index2)) {
          case 34:
            escape2 = "&quot;";
            break;
          case 38:
            escape2 = "&amp;";
            break;
          case 39:
            escape2 = "&#39;";
            break;
          case 60:
            escape2 = "&lt;";
            break;
          case 62:
            escape2 = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index2) {
          html += str.substring(lastIndex, index2);
        }
        lastIndex = index2 + 1;
        html += escape2;
      }
      return lastIndex !== index2 ? html + str.substring(lastIndex, index2) : html;
    }
    var onFinished$2 = { exports: {} };
    var eeFirst = first$1;
    function first$1(stuff, done) {
      if (!Array.isArray(stuff))
        throw new TypeError("arg must be an array of [ee, events...] arrays");
      var cleanups = [];
      for (var i2 = 0; i2 < stuff.length; i2++) {
        var arr = stuff[i2];
        if (!Array.isArray(arr) || arr.length < 2)
          throw new TypeError("each array member must be [ee, events...]");
        var ee2 = arr[0];
        for (var j2 = 1; j2 < arr.length; j2++) {
          var event = arr[j2];
          var fn2 = listener(event, callback);
          ee2.on(event, fn2);
          cleanups.push({
            ee: ee2,
            event,
            fn: fn2
          });
        }
      }
      function callback() {
        cleanup();
        done.apply(null, arguments);
      }
      function cleanup() {
        var x2;
        for (var i3 = 0; i3 < cleanups.length; i3++) {
          x2 = cleanups[i3];
          x2.ee.removeListener(x2.event, x2.fn);
        }
      }
      function thunk(fn3) {
        done = fn3;
      }
      thunk.cancel = cleanup;
      return thunk;
    }
    function listener(event, done) {
      return function onevent(arg1) {
        var args = new Array(arguments.length);
        var ee2 = this;
        var err = event === "error" ? arg1 : null;
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        done(err, ee2, event, args);
      };
    }
    onFinished$2.exports = onFinished$1;
    onFinished$2.exports.isFinished = isFinished$1;
    var first = eeFirst;
    var defer$2 = typeof setImmediate === "function" ? setImmediate : function(fn2) {
      process.nextTick(fn2.bind.apply(fn2, arguments));
    };
    function onFinished$1(msg, listener2) {
      if (isFinished$1(msg) !== false) {
        defer$2(listener2, null, msg);
        return msg;
      }
      attachListener(msg, listener2);
      return msg;
    }
    function isFinished$1(msg) {
      var socket = msg.socket;
      if (typeof msg.finished === "boolean") {
        return Boolean(msg.finished || socket && !socket.writable);
      }
      if (typeof msg.complete === "boolean") {
        return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
      }
      return void 0;
    }
    function attachFinishedListener(msg, callback) {
      var eeMsg;
      var eeSocket;
      var finished = false;
      function onFinish(error2) {
        eeMsg.cancel();
        eeSocket.cancel();
        finished = true;
        callback(error2);
      }
      eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
      function onSocket(socket) {
        msg.removeListener("socket", onSocket);
        if (finished)
          return;
        if (eeMsg !== eeSocket)
          return;
        eeSocket = first([[socket, "error", "close"]], onFinish);
      }
      if (msg.socket) {
        onSocket(msg.socket);
        return;
      }
      msg.on("socket", onSocket);
      if (msg.socket === void 0) {
        patchAssignSocket(msg, onSocket);
      }
    }
    function attachListener(msg, listener2) {
      var attached = msg.__onFinished;
      if (!attached || !attached.queue) {
        attached = msg.__onFinished = createListener(msg);
        attachFinishedListener(msg, attached);
      }
      attached.queue.push(listener2);
    }
    function createListener(msg) {
      function listener2(err) {
        if (msg.__onFinished === listener2)
          msg.__onFinished = null;
        if (!listener2.queue)
          return;
        var queue2 = listener2.queue;
        listener2.queue = null;
        for (var i2 = 0; i2 < queue2.length; i2++) {
          queue2[i2](err, msg);
        }
      }
      listener2.queue = [];
      return listener2;
    }
    function patchAssignSocket(res, callback) {
      var assignSocket = res.assignSocket;
      if (typeof assignSocket !== "function")
        return;
      res.assignSocket = function _assignSocket(socket) {
        assignSocket.call(this, socket);
        callback(socket);
      };
    }
    var parseurl$1 = { exports: {} };
    var url$3 = require$$0__default$5;
    var parse$a = url$3.parse;
    var Url = url$3.Url;
    parseurl$1.exports = parseurl;
    parseurl$1.exports.original = originalurl;
    function parseurl(req2) {
      var url2 = req2.url;
      if (url2 === void 0) {
        return void 0;
      }
      var parsed = req2._parsedUrl;
      if (fresh(url2, parsed)) {
        return parsed;
      }
      parsed = fastparse(url2);
      parsed._raw = url2;
      return req2._parsedUrl = parsed;
    }
    function originalurl(req2) {
      var url2 = req2.originalUrl;
      if (typeof url2 !== "string") {
        return parseurl(req2);
      }
      var parsed = req2._parsedOriginalUrl;
      if (fresh(url2, parsed)) {
        return parsed;
      }
      parsed = fastparse(url2);
      parsed._raw = url2;
      return req2._parsedOriginalUrl = parsed;
    }
    function fastparse(str) {
      if (typeof str !== "string" || str.charCodeAt(0) !== 47) {
        return parse$a(str);
      }
      var pathname = str;
      var query = null;
      var search = null;
      for (var i2 = 1; i2 < str.length; i2++) {
        switch (str.charCodeAt(i2)) {
          case 63:
            if (search === null) {
              pathname = str.substring(0, i2);
              query = str.substring(i2 + 1);
              search = str.substring(i2);
            }
            break;
          case 9:
          case 10:
          case 12:
          case 13:
          case 32:
          case 35:
          case 160:
          case 65279:
            return parse$a(str);
        }
      }
      var url2 = Url !== void 0 ? new Url() : {};
      url2.path = str;
      url2.href = str;
      url2.pathname = pathname;
      if (search !== null) {
        url2.query = query;
        url2.search = search;
      }
      return url2;
    }
    function fresh(url2, parsedUrl) {
      return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
    }
    var require$$0$2 = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "306": "(Unused)",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Unordered Collection",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
    var codes = require$$0$2;
    var statuses$1 = status;
    status.STATUS_CODES = codes;
    status.codes = populateStatusesMap(status, codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status.empty = {
      204: true,
      205: true,
      304: true
    };
    status.retry = {
      502: true,
      503: true,
      504: true
    };
    function populateStatusesMap(statuses2, codes2) {
      var arr = [];
      Object.keys(codes2).forEach(function forEachCode(code) {
        var message = codes2[code];
        var status2 = Number(code);
        statuses2[status2] = message;
        statuses2[message] = status2;
        statuses2[message.toLowerCase()] = status2;
        arr.push(status2);
      });
      return arr;
    }
    function status(code) {
      if (typeof code === "number") {
        if (!status[code])
          throw new Error("invalid status code: " + code);
        return code;
      }
      if (typeof code !== "string") {
        throw new TypeError("code must be a number or string");
      }
      var n3 = parseInt(code, 10);
      if (!isNaN(n3)) {
        if (!status[n3])
          throw new Error("invalid status code: " + n3);
        return n3;
      }
      n3 = status[code.toLowerCase()];
      if (!n3)
        throw new Error('invalid status message: "' + code + '"');
      return n3;
    }
    var unpipe_1 = unpipe$1;
    function hasPipeDataListeners(stream2) {
      var listeners = stream2.listeners("data");
      for (var i2 = 0; i2 < listeners.length; i2++) {
        if (listeners[i2].name === "ondata") {
          return true;
        }
      }
      return false;
    }
    function unpipe$1(stream2) {
      if (!stream2) {
        throw new TypeError("argument stream is required");
      }
      if (typeof stream2.unpipe === "function") {
        stream2.unpipe();
        return;
      }
      if (!hasPipeDataListeners(stream2)) {
        return;
      }
      var listener2;
      var listeners = stream2.listeners("close");
      for (var i2 = 0; i2 < listeners.length; i2++) {
        listener2 = listeners[i2];
        if (listener2.name !== "cleanup" && listener2.name !== "onclose") {
          continue;
        }
        listener2.call(stream2);
      }
    }
    var debug$9 = src.exports("finalhandler");
    var encodeUrl = encodeurl;
    var escapeHtml = escapeHtml_1;
    var onFinished = onFinished$2.exports;
    var parseUrl$1 = parseurl$1.exports;
    var statuses = statuses$1;
    var unpipe = unpipe_1;
    var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
    var NEWLINE_REGEXP = /\n/g;
    var defer$1 = typeof setImmediate === "function" ? setImmediate : function(fn2) {
      process.nextTick(fn2.bind.apply(fn2, arguments));
    };
    var isFinished = onFinished.isFinished;
    function createHtmlDocument(message) {
      var body = escapeHtml(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
      return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
    }
    var finalhandler_1 = finalhandler$1;
    function finalhandler$1(req2, res, options2) {
      var opts = options2 || {};
      var env2 = opts.env || "development";
      var onerror = opts.onerror;
      return function(err) {
        var headers;
        var msg;
        var status2;
        if (!err && headersSent(res)) {
          debug$9("cannot 404 after headers sent");
          return;
        }
        if (err) {
          status2 = getErrorStatusCode(err);
          if (status2 === void 0) {
            status2 = getResponseStatusCode(res);
          } else {
            headers = getErrorHeaders(err);
          }
          msg = getErrorMessage(err, status2, env2);
        } else {
          status2 = 404;
          msg = "Cannot " + req2.method + " " + encodeUrl(getResourceName(req2));
        }
        debug$9("default %s", status2);
        if (err && onerror) {
          defer$1(onerror, err, req2, res);
        }
        if (headersSent(res)) {
          debug$9("cannot %d after headers sent", status2);
          req2.socket.destroy();
          return;
        }
        send$2(req2, res, status2, headers, msg);
      };
    }
    function getErrorHeaders(err) {
      if (!err.headers || typeof err.headers !== "object") {
        return void 0;
      }
      var headers = Object.create(null);
      var keys = Object.keys(err.headers);
      for (var i2 = 0; i2 < keys.length; i2++) {
        var key = keys[i2];
        headers[key] = err.headers[key];
      }
      return headers;
    }
    function getErrorMessage(err, status2, env2) {
      var msg;
      if (env2 !== "production") {
        msg = err.stack;
        if (!msg && typeof err.toString === "function") {
          msg = err.toString();
        }
      }
      return msg || statuses[status2];
    }
    function getErrorStatusCode(err) {
      if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
        return err.status;
      }
      if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
        return err.statusCode;
      }
      return void 0;
    }
    function getResourceName(req2) {
      try {
        return parseUrl$1.original(req2).pathname;
      } catch (e2) {
        return "resource";
      }
    }
    function getResponseStatusCode(res) {
      var status2 = res.statusCode;
      if (typeof status2 !== "number" || status2 < 400 || status2 > 599) {
        status2 = 500;
      }
      return status2;
    }
    function headersSent(res) {
      return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
    }
    function send$2(req2, res, status2, headers, message) {
      function write() {
        var body = createHtmlDocument(message);
        res.statusCode = status2;
        res.statusMessage = statuses[status2];
        setHeaders(res, headers);
        res.setHeader("Content-Security-Policy", "default-src 'none'");
        res.setHeader("X-Content-Type-Options", "nosniff");
        res.setHeader("Content-Type", "text/html; charset=utf-8");
        res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
        if (req2.method === "HEAD") {
          res.end();
          return;
        }
        res.end(body, "utf8");
      }
      if (isFinished(req2)) {
        write();
        return;
      }
      unpipe(req2);
      onFinished(req2, write);
      req2.resume();
    }
    function setHeaders(res, headers) {
      if (!headers) {
        return;
      }
      var keys = Object.keys(headers);
      for (var i2 = 0; i2 < keys.length; i2++) {
        var key = keys[i2];
        res.setHeader(key, headers[key]);
      }
    }
    var utilsMerge = { exports: {} };
    (function(module2, exports2) {
      module2.exports = function(a2, b2) {
        if (a2 && b2) {
          for (var key in b2) {
            a2[key] = b2[key];
          }
        }
        return a2;
      };
    })(utilsMerge);
    var debug$8 = src.exports("connect:dispatcher");
    var EventEmitter$3 = require$$0__default$4.EventEmitter;
    var finalhandler = finalhandler_1;
    var http$4 = require$$1__default$2;
    var merge = utilsMerge.exports;
    var parseUrl = parseurl$1.exports;
    var connect = createServer$1;
    var env = "development";
    var proto = {};
    var defer = typeof setImmediate === "function" ? setImmediate : function(fn2) {
      process.nextTick(fn2.bind.apply(fn2, arguments));
    };
    function createServer$1() {
      function app(req2, res, next) {
        app.handle(req2, res, next);
      }
      merge(app, proto);
      merge(app, EventEmitter$3.prototype);
      app.route = "/";
      app.stack = [];
      return app;
    }
    proto.use = function use(route2, fn2) {
      var handle = fn2;
      var path2 = route2;
      if (typeof route2 !== "string") {
        handle = route2;
        path2 = "/";
      }
      if (typeof handle.handle === "function") {
        var server2 = handle;
        server2.route = path2;
        handle = function(req2, res, next) {
          server2.handle(req2, res, next);
        };
      }
      if (handle instanceof http$4.Server) {
        handle = handle.listeners("request")[0];
      }
      if (path2[path2.length - 1] === "/") {
        path2 = path2.slice(0, -1);
      }
      debug$8("use %s %s", path2 || "/", handle.name || "anonymous");
      this.stack.push({ route: path2, handle });
      return this;
    };
    proto.handle = function handle(req2, res, out2) {
      var index2 = 0;
      var protohost = getProtohost(req2.url) || "";
      var removed = "";
      var slashAdded = false;
      var stack = this.stack;
      var done = out2 || finalhandler(req2, res, {
        env,
        onerror: logerror
      });
      req2.originalUrl = req2.originalUrl || req2.url;
      function next(err) {
        if (slashAdded) {
          req2.url = req2.url.substr(1);
          slashAdded = false;
        }
        if (removed.length !== 0) {
          req2.url = protohost + removed + req2.url.substr(protohost.length);
          removed = "";
        }
        var layer = stack[index2++];
        if (!layer) {
          defer(done, err);
          return;
        }
        var path2 = parseUrl(req2).pathname || "/";
        var route2 = layer.route;
        if (path2.toLowerCase().substr(0, route2.length) !== route2.toLowerCase()) {
          return next(err);
        }
        var c2 = path2.length > route2.length && path2[route2.length];
        if (c2 && c2 !== "/" && c2 !== ".") {
          return next(err);
        }
        if (route2.length !== 0 && route2 !== "/") {
          removed = route2;
          req2.url = protohost + req2.url.substr(protohost.length + removed.length);
          if (!protohost && req2.url[0] !== "/") {
            req2.url = "/" + req2.url;
            slashAdded = true;
          }
        }
        call(layer.handle, route2, err, req2, res, next);
      }
      next();
    };
    proto.listen = function listen() {
      var server2 = http$4.createServer(this);
      return server2.listen.apply(server2, arguments);
    };
    function call(handle, route2, err, req2, res, next) {
      var arity = handle.length;
      var error2 = err;
      var hasError = Boolean(err);
      debug$8("%s %s : %s", handle.name || "<anonymous>", route2, req2.originalUrl);
      try {
        if (hasError && arity === 4) {
          handle(err, req2, res, next);
          return;
        } else if (!hasError && arity < 4) {
          handle(req2, res, next);
          return;
        }
      } catch (e2) {
        error2 = e2;
      }
      next(error2);
    }
    function logerror(err) {
      if (env !== "test")
        console.error(err.stack || err.toString());
    }
    function getProtohost(url2) {
      if (url2.length === 0 || url2[0] === "/") {
        return void 0;
      }
      var fqdnIndex = url2.indexOf("://");
      return fqdnIndex !== -1 && url2.lastIndexOf("?", fqdnIndex) === -1 ? url2.substr(0, url2.indexOf("/", 3 + fqdnIndex)) : void 0;
    }
    var lib$1 = { exports: {} };
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i2 = 0; i2 < 10; i2++) {
          test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n3) {
          return test2[n3];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    var objectAssign = shouldUseNative() ? Object.assign : function(target, source2) {
      var from;
      var to2 = toObject(target);
      var symbols;
      for (var s2 = 1; s2 < arguments.length; s2++) {
        from = Object(arguments[s2]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to2[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            if (propIsEnumerable.call(from, symbols[i2])) {
              to2[symbols[i2]] = from[symbols[i2]];
            }
          }
        }
      }
      return to2;
    };
    var vary$2 = { exports: {} };
    vary$2.exports = vary$1;
    vary$2.exports.append = append;
    var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
    function append(header, field) {
      if (typeof header !== "string") {
        throw new TypeError("header argument is required");
      }
      if (!field) {
        throw new TypeError("field argument is required");
      }
      var fields = !Array.isArray(field) ? parse$9(String(field)) : field;
      for (var j2 = 0; j2 < fields.length; j2++) {
        if (!FIELD_NAME_REGEXP.test(fields[j2])) {
          throw new TypeError("field argument contains an invalid header name");
        }
      }
      if (header === "*") {
        return header;
      }
      var val = header;
      var vals = parse$9(header.toLowerCase());
      if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
        return "*";
      }
      for (var i2 = 0; i2 < fields.length; i2++) {
        var fld = fields[i2].toLowerCase();
        if (vals.indexOf(fld) === -1) {
          vals.push(fld);
          val = val ? val + ", " + fields[i2] : fields[i2];
        }
      }
      return val;
    }
    function parse$9(header) {
      var end = 0;
      var list2 = [];
      var start = 0;
      for (var i2 = 0, len = header.length; i2 < len; i2++) {
        switch (header.charCodeAt(i2)) {
          case 32:
            if (start === end) {
              start = end = i2 + 1;
            }
            break;
          case 44:
            list2.push(header.substring(start, end));
            start = end = i2 + 1;
            break;
          default:
            end = i2 + 1;
            break;
        }
      }
      list2.push(header.substring(start, end));
      return list2;
    }
    function vary$1(res, field) {
      if (!res || !res.getHeader || !res.setHeader) {
        throw new TypeError("res argument is required");
      }
      var val = res.getHeader("Vary") || "";
      var header = Array.isArray(val) ? val.join(", ") : String(val);
      if (val = append(header, field)) {
        res.setHeader("Vary", val);
      }
    }
    (function() {
      var assign = objectAssign;
      var vary2 = vary$2.exports;
      var defaults2 = {
        origin: "*",
        methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
        preflightContinue: false,
        optionsSuccessStatus: 204
      };
      function isString2(s2) {
        return typeof s2 === "string" || s2 instanceof String;
      }
      function isOriginAllowed(origin, allowedOrigin) {
        if (Array.isArray(allowedOrigin)) {
          for (var i2 = 0; i2 < allowedOrigin.length; ++i2) {
            if (isOriginAllowed(origin, allowedOrigin[i2])) {
              return true;
            }
          }
          return false;
        } else if (isString2(allowedOrigin)) {
          return origin === allowedOrigin;
        } else if (allowedOrigin instanceof RegExp) {
          return allowedOrigin.test(origin);
        } else {
          return !!allowedOrigin;
        }
      }
      function configureOrigin(options2, req2) {
        var requestOrigin = req2.headers.origin, headers = [], isAllowed;
        if (!options2.origin || options2.origin === "*") {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: "*"
          }]);
        } else if (isString2(options2.origin)) {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: options2.origin
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        } else {
          isAllowed = isOriginAllowed(requestOrigin, options2.origin);
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: isAllowed ? requestOrigin : false
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        }
        return headers;
      }
      function configureMethods(options2) {
        var methods = options2.methods;
        if (methods.join) {
          methods = options2.methods.join(",");
        }
        return {
          key: "Access-Control-Allow-Methods",
          value: methods
        };
      }
      function configureCredentials(options2) {
        if (options2.credentials === true) {
          return {
            key: "Access-Control-Allow-Credentials",
            value: "true"
          };
        }
        return null;
      }
      function configureAllowedHeaders(options2, req2) {
        var allowedHeaders = options2.allowedHeaders || options2.headers;
        var headers = [];
        if (!allowedHeaders) {
          allowedHeaders = req2.headers["access-control-request-headers"];
          headers.push([{
            key: "Vary",
            value: "Access-Control-Request-Headers"
          }]);
        } else if (allowedHeaders.join) {
          allowedHeaders = allowedHeaders.join(",");
        }
        if (allowedHeaders && allowedHeaders.length) {
          headers.push([{
            key: "Access-Control-Allow-Headers",
            value: allowedHeaders
          }]);
        }
        return headers;
      }
      function configureExposedHeaders(options2) {
        var headers = options2.exposedHeaders;
        if (!headers) {
          return null;
        } else if (headers.join) {
          headers = headers.join(",");
        }
        if (headers && headers.length) {
          return {
            key: "Access-Control-Expose-Headers",
            value: headers
          };
        }
        return null;
      }
      function configureMaxAge(options2) {
        var maxAge = (typeof options2.maxAge === "number" || options2.maxAge) && options2.maxAge.toString();
        if (maxAge && maxAge.length) {
          return {
            key: "Access-Control-Max-Age",
            value: maxAge
          };
        }
        return null;
      }
      function applyHeaders(headers, res) {
        for (var i2 = 0, n3 = headers.length; i2 < n3; i2++) {
          var header = headers[i2];
          if (header) {
            if (Array.isArray(header)) {
              applyHeaders(header, res);
            } else if (header.key === "Vary" && header.value) {
              vary2(res, header.value);
            } else if (header.value) {
              res.setHeader(header.key, header.value);
            }
          }
        }
      }
      function cors(options2, req2, res, next) {
        var headers = [], method = req2.method && req2.method.toUpperCase && req2.method.toUpperCase();
        if (method === "OPTIONS") {
          headers.push(configureOrigin(options2, req2));
          headers.push(configureCredentials(options2));
          headers.push(configureMethods(options2));
          headers.push(configureAllowedHeaders(options2, req2));
          headers.push(configureMaxAge(options2));
          headers.push(configureExposedHeaders(options2));
          applyHeaders(headers, res);
          if (options2.preflightContinue) {
            next();
          } else {
            res.statusCode = options2.optionsSuccessStatus;
            res.setHeader("Content-Length", "0");
            res.end();
          }
        } else {
          headers.push(configureOrigin(options2, req2));
          headers.push(configureCredentials(options2));
          headers.push(configureExposedHeaders(options2));
          applyHeaders(headers, res);
          next();
        }
      }
      function middlewareWrapper(o2) {
        var optionsCallback = null;
        if (typeof o2 === "function") {
          optionsCallback = o2;
        } else {
          optionsCallback = function(req2, cb) {
            cb(null, o2);
          };
        }
        return function corsMiddleware2(req2, res, next) {
          optionsCallback(req2, function(err, options2) {
            if (err) {
              next(err);
            } else {
              var corsOptions = assign({}, defaults2, options2);
              var originCallback = null;
              if (corsOptions.origin && typeof corsOptions.origin === "function") {
                originCallback = corsOptions.origin;
              } else if (corsOptions.origin) {
                originCallback = function(origin, cb) {
                  cb(null, corsOptions.origin);
                };
              }
              if (originCallback) {
                originCallback(req2.headers.origin, function(err2, origin) {
                  if (err2 || !origin) {
                    next(err2);
                  } else {
                    corsOptions.origin = origin;
                    cors(corsOptions, req2, res, next);
                  }
                });
              } else {
                next();
              }
            }
          });
        };
      }
      lib$1.exports = middlewareWrapper;
    })();
    var corsMiddleware = lib$1.exports;
    var chokidar = {};
    var fs$b = fs__default;
    var { Readable } = require$$0__default$3;
    var sysPath$3 = path__default;
    var { promisify: promisify$4 } = require$$0__default$2;
    var picomatch$1 = picomatch$3;
    var readdir$1 = promisify$4(fs$b.readdir);
    var stat$3 = promisify$4(fs$b.stat);
    var lstat$2 = promisify$4(fs$b.lstat);
    var realpath$1 = promisify$4(fs$b.realpath);
    var BANG$2 = "!";
    var RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
    var NORMAL_FLOW_ERRORS = new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
    var FILE_TYPE = "files";
    var DIR_TYPE = "directories";
    var FILE_DIR_TYPE = "files_directories";
    var EVERYTHING_TYPE = "all";
    var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
    var isNormalFlowError = (error2) => NORMAL_FLOW_ERRORS.has(error2.code);
    var [maj, min] = process.versions.node.split(".").slice(0, 2).map((n3) => Number.parseInt(n3, 10));
    var wantBigintFsStats = process.platform === "win32" && (maj > 10 || maj === 10 && min >= 5);
    var normalizeFilter = (filter2) => {
      if (filter2 === void 0)
        return;
      if (typeof filter2 === "function")
        return filter2;
      if (typeof filter2 === "string") {
        const glob2 = picomatch$1(filter2.trim());
        return (entry2) => glob2(entry2.basename);
      }
      if (Array.isArray(filter2)) {
        const positive = [];
        const negative = [];
        for (const item of filter2) {
          const trimmed = item.trim();
          if (trimmed.charAt(0) === BANG$2) {
            negative.push(picomatch$1(trimmed.slice(1)));
          } else {
            positive.push(picomatch$1(trimmed));
          }
        }
        if (negative.length > 0) {
          if (positive.length > 0) {
            return (entry2) => positive.some((f2) => f2(entry2.basename)) && !negative.some((f2) => f2(entry2.basename));
          }
          return (entry2) => !negative.some((f2) => f2(entry2.basename));
        }
        return (entry2) => positive.some((f2) => f2(entry2.basename));
      }
    };
    var ReaddirpStream = class extends Readable {
      static get defaultOptions() {
        return {
          root: ".",
          fileFilter: (path2) => true,
          directoryFilter: (path2) => true,
          type: FILE_TYPE,
          lstat: false,
          depth: 2147483648,
          alwaysStat: false
        };
      }
      constructor(options2 = {}) {
        super({
          objectMode: true,
          autoDestroy: true,
          highWaterMark: options2.highWaterMark || 4096
        });
        const opts = __spreadValues2(__spreadValues2({}, ReaddirpStream.defaultOptions), options2);
        const { root, type } = opts;
        this._fileFilter = normalizeFilter(opts.fileFilter);
        this._directoryFilter = normalizeFilter(opts.directoryFilter);
        const statMethod = opts.lstat ? lstat$2 : stat$3;
        if (wantBigintFsStats) {
          this._stat = (path2) => statMethod(path2, { bigint: true });
        } else {
          this._stat = statMethod;
        }
        this._maxDepth = opts.depth;
        this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsEverything = type === EVERYTHING_TYPE;
        this._root = sysPath$3.resolve(root);
        this._isDirent = "Dirent" in fs$b && !opts.alwaysStat;
        this._statsProp = this._isDirent ? "dirent" : "stats";
        this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
        this.parents = [this._exploreDir(root, 1)];
        this.reading = false;
        this.parent = void 0;
      }
      async _read(batch) {
        if (this.reading)
          return;
        this.reading = true;
        try {
          while (!this.destroyed && batch > 0) {
            const { path: path2, depth: depth2, files = [] } = this.parent || {};
            if (files.length > 0) {
              const slice2 = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path2));
              for (const entry2 of await Promise.all(slice2)) {
                if (this.destroyed)
                  return;
                const entryType = await this._getEntryType(entry2);
                if (entryType === "directory" && this._directoryFilter(entry2)) {
                  if (depth2 <= this._maxDepth) {
                    this.parents.push(this._exploreDir(entry2.fullPath, depth2 + 1));
                  }
                  if (this._wantsDir) {
                    this.push(entry2);
                    batch--;
                  }
                } else if ((entryType === "file" || this._includeAsFile(entry2)) && this._fileFilter(entry2)) {
                  if (this._wantsFile) {
                    this.push(entry2);
                    batch--;
                  }
                }
              }
            } else {
              const parent = this.parents.pop();
              if (!parent) {
                this.push(null);
                break;
              }
              this.parent = await parent;
              if (this.destroyed)
                return;
            }
          }
        } catch (error2) {
          this.destroy(error2);
        } finally {
          this.reading = false;
        }
      }
      async _exploreDir(path2, depth2) {
        let files;
        try {
          files = await readdir$1(path2, this._rdOptions);
        } catch (error2) {
          this._onError(error2);
        }
        return { files, depth: depth2, path: path2 };
      }
      async _formatEntry(dirent, path2) {
        let entry2;
        try {
          const basename = this._isDirent ? dirent.name : dirent;
          const fullPath = sysPath$3.resolve(sysPath$3.join(path2, basename));
          entry2 = { path: sysPath$3.relative(this._root, fullPath), fullPath, basename };
          entry2[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
        } catch (err) {
          this._onError(err);
        }
        return entry2;
      }
      _onError(err) {
        if (isNormalFlowError(err) && !this.destroyed) {
          this.emit("warn", err);
        } else {
          this.destroy(err);
        }
      }
      async _getEntryType(entry2) {
        const stats = entry2 && entry2[this._statsProp];
        if (!stats) {
          return;
        }
        if (stats.isFile()) {
          return "file";
        }
        if (stats.isDirectory()) {
          return "directory";
        }
        if (stats && stats.isSymbolicLink()) {
          const full = entry2.fullPath;
          try {
            const entryRealPath = await realpath$1(full);
            const entryRealPathStats = await lstat$2(entryRealPath);
            if (entryRealPathStats.isFile()) {
              return "file";
            }
            if (entryRealPathStats.isDirectory()) {
              const len = entryRealPath.length;
              if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {
                const recursiveError = new Error(`Circular symlink detected: "${full}" points to "${entryRealPath}"`);
                recursiveError.code = RECURSIVE_ERROR_CODE;
                return this._onError(recursiveError);
              }
              return "directory";
            }
          } catch (error2) {
            this._onError(error2);
          }
        }
      }
      _includeAsFile(entry2) {
        const stats = entry2 && entry2[this._statsProp];
        return stats && this._wantsEverything && !stats.isDirectory();
      }
    };
    var readdirp$1 = (root, options2 = {}) => {
      let type = options2.entryType || options2.type;
      if (type === "both")
        type = FILE_DIR_TYPE;
      if (type)
        options2.type = type;
      if (!root) {
        throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
      } else if (typeof root !== "string") {
        throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
      } else if (type && !ALL_TYPES.includes(type)) {
        throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
      }
      options2.root = root;
      return new ReaddirpStream(options2);
    };
    var readdirpPromise = (root, options2 = {}) => {
      return new Promise((resolve2, reject) => {
        const files = [];
        readdirp$1(root, options2).on("data", (entry2) => files.push(entry2)).on("end", () => resolve2(files)).on("error", (error2) => reject(error2));
      });
    };
    readdirp$1.promise = readdirpPromise;
    readdirp$1.ReaddirpStream = ReaddirpStream;
    readdirp$1.default = readdirp$1;
    var readdirp_1 = readdirp$1;
    var anymatch$2 = { exports: {} };
    var normalizePath$2 = function(path2, stripTrailing) {
      if (typeof path2 !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path2 === "\\" || path2 === "/")
        return "/";
      var len = path2.length;
      if (len <= 1)
        return path2;
      var prefix = "";
      if (len > 4 && path2[3] === "\\") {
        var ch2 = path2[2];
        if ((ch2 === "?" || ch2 === ".") && path2.slice(0, 2) === "\\\\") {
          path2 = path2.slice(2);
          prefix = "//";
        }
      }
      var segs = path2.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
    Object.defineProperty(anymatch$2.exports, "__esModule", { value: true });
    var picomatch = picomatch$3;
    var normalizePath$1 = normalizePath$2;
    var BANG$1 = "!";
    var DEFAULT_OPTIONS = { returnIndex: false };
    var arrify$1 = (item) => Array.isArray(item) ? item : [item];
    var createPattern = (matcher2, options2) => {
      if (typeof matcher2 === "function") {
        return matcher2;
      }
      if (typeof matcher2 === "string") {
        const glob2 = picomatch(matcher2, options2);
        return (string2) => matcher2 === string2 || glob2(string2);
      }
      if (matcher2 instanceof RegExp) {
        return (string2) => matcher2.test(string2);
      }
      return (string2) => false;
    };
    var matchPatterns = (patterns, negPatterns, args, returnIndex) => {
      const isList = Array.isArray(args);
      const _path = isList ? args[0] : args;
      if (!isList && typeof _path !== "string") {
        throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path));
      }
      const path2 = normalizePath$1(_path);
      for (let index2 = 0; index2 < negPatterns.length; index2++) {
        const nglob = negPatterns[index2];
        if (nglob(path2)) {
          return returnIndex ? -1 : false;
        }
      }
      const applied = isList && [path2].concat(args.slice(1));
      for (let index2 = 0; index2 < patterns.length; index2++) {
        const pattern2 = patterns[index2];
        if (isList ? pattern2(...applied) : pattern2(path2)) {
          return returnIndex ? index2 : true;
        }
      }
      return returnIndex ? -1 : false;
    };
    var anymatch$1 = (matchers, testString, options2 = DEFAULT_OPTIONS) => {
      if (matchers == null) {
        throw new TypeError("anymatch: specify first argument");
      }
      const opts = typeof options2 === "boolean" ? { returnIndex: options2 } : options2;
      const returnIndex = opts.returnIndex || false;
      const mtchers = arrify$1(matchers);
      const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG$1).map((item) => item.slice(1)).map((item) => picomatch(item, opts));
      const patterns = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG$1).map((matcher2) => createPattern(matcher2, opts));
      if (testString == null) {
        return (testString2, ri2 = false) => {
          const returnIndex2 = typeof ri2 === "boolean" ? ri2 : false;
          return matchPatterns(patterns, negatedGlobs, testString2, returnIndex2);
        };
      }
      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
    };
    anymatch$1.default = anymatch$1;
    anymatch$2.exports = anymatch$1;
    var require$$0$1 = [
      "3dm",
      "3ds",
      "3g2",
      "3gp",
      "7z",
      "a",
      "aac",
      "adp",
      "ai",
      "aif",
      "aiff",
      "alz",
      "ape",
      "apk",
      "appimage",
      "ar",
      "arj",
      "asf",
      "au",
      "avi",
      "bak",
      "baml",
      "bh",
      "bin",
      "bk",
      "bmp",
      "btif",
      "bz2",
      "bzip2",
      "cab",
      "caf",
      "cgm",
      "class",
      "cmx",
      "cpio",
      "cr2",
      "cur",
      "dat",
      "dcm",
      "deb",
      "dex",
      "djvu",
      "dll",
      "dmg",
      "dng",
      "doc",
      "docm",
      "docx",
      "dot",
      "dotm",
      "dra",
      "DS_Store",
      "dsk",
      "dts",
      "dtshd",
      "dvb",
      "dwg",
      "dxf",
      "ecelp4800",
      "ecelp7470",
      "ecelp9600",
      "egg",
      "eol",
      "eot",
      "epub",
      "exe",
      "f4v",
      "fbs",
      "fh",
      "fla",
      "flac",
      "flatpak",
      "fli",
      "flv",
      "fpx",
      "fst",
      "fvt",
      "g3",
      "gh",
      "gif",
      "graffle",
      "gz",
      "gzip",
      "h261",
      "h263",
      "h264",
      "icns",
      "ico",
      "ief",
      "img",
      "ipa",
      "iso",
      "jar",
      "jpeg",
      "jpg",
      "jpgv",
      "jpm",
      "jxr",
      "key",
      "ktx",
      "lha",
      "lib",
      "lvp",
      "lz",
      "lzh",
      "lzma",
      "lzo",
      "m3u",
      "m4a",
      "m4v",
      "mar",
      "mdi",
      "mht",
      "mid",
      "midi",
      "mj2",
      "mka",
      "mkv",
      "mmr",
      "mng",
      "mobi",
      "mov",
      "movie",
      "mp3",
      "mp4",
      "mp4a",
      "mpeg",
      "mpg",
      "mpga",
      "mxu",
      "nef",
      "npx",
      "numbers",
      "nupkg",
      "o",
      "odp",
      "ods",
      "odt",
      "oga",
      "ogg",
      "ogv",
      "otf",
      "ott",
      "pages",
      "pbm",
      "pcx",
      "pdb",
      "pdf",
      "pea",
      "pgm",
      "pic",
      "png",
      "pnm",
      "pot",
      "potm",
      "potx",
      "ppa",
      "ppam",
      "ppm",
      "pps",
      "ppsm",
      "ppsx",
      "ppt",
      "pptm",
      "pptx",
      "psd",
      "pya",
      "pyc",
      "pyo",
      "pyv",
      "qt",
      "rar",
      "ras",
      "raw",
      "resources",
      "rgb",
      "rip",
      "rlc",
      "rmf",
      "rmvb",
      "rpm",
      "rtf",
      "rz",
      "s3m",
      "s7z",
      "scpt",
      "sgi",
      "shar",
      "snap",
      "sil",
      "sketch",
      "slk",
      "smv",
      "snk",
      "so",
      "stl",
      "suo",
      "sub",
      "swf",
      "tar",
      "tbz",
      "tbz2",
      "tga",
      "tgz",
      "thmx",
      "tif",
      "tiff",
      "tlz",
      "ttc",
      "ttf",
      "txz",
      "udf",
      "uvh",
      "uvi",
      "uvm",
      "uvp",
      "uvs",
      "uvu",
      "viv",
      "vob",
      "war",
      "wav",
      "wax",
      "wbmp",
      "wdp",
      "weba",
      "webm",
      "webp",
      "whl",
      "wim",
      "wm",
      "wma",
      "wmv",
      "wmx",
      "woff",
      "woff2",
      "wrm",
      "wvx",
      "xbm",
      "xif",
      "xla",
      "xlam",
      "xls",
      "xlsb",
      "xlsm",
      "xlsx",
      "xlt",
      "xltm",
      "xltx",
      "xm",
      "xmind",
      "xpi",
      "xpm",
      "xwd",
      "xz",
      "z",
      "zip",
      "zipx"
    ];
    var binaryExtensions$1 = require$$0$1;
    var path$a = path__default;
    var binaryExtensions = binaryExtensions$1;
    var extensions = new Set(binaryExtensions);
    var isBinaryPath$1 = (filePath) => extensions.has(path$a.extname(filePath).slice(1).toLowerCase());
    var constants$1 = {};
    (function(exports2) {
      const { sep } = path__default;
      const { platform: platform2 } = process;
      const os3 = require$$0__default$1;
      exports2.EV_ALL = "all";
      exports2.EV_READY = "ready";
      exports2.EV_ADD = "add";
      exports2.EV_CHANGE = "change";
      exports2.EV_ADD_DIR = "addDir";
      exports2.EV_UNLINK = "unlink";
      exports2.EV_UNLINK_DIR = "unlinkDir";
      exports2.EV_RAW = "raw";
      exports2.EV_ERROR = "error";
      exports2.STR_DATA = "data";
      exports2.STR_END = "end";
      exports2.STR_CLOSE = "close";
      exports2.FSEVENT_CREATED = "created";
      exports2.FSEVENT_MODIFIED = "modified";
      exports2.FSEVENT_DELETED = "deleted";
      exports2.FSEVENT_MOVED = "moved";
      exports2.FSEVENT_CLONED = "cloned";
      exports2.FSEVENT_UNKNOWN = "unknown";
      exports2.FSEVENT_TYPE_FILE = "file";
      exports2.FSEVENT_TYPE_DIRECTORY = "directory";
      exports2.FSEVENT_TYPE_SYMLINK = "symlink";
      exports2.KEY_LISTENERS = "listeners";
      exports2.KEY_ERR = "errHandlers";
      exports2.KEY_RAW = "rawEmitters";
      exports2.HANDLER_KEYS = [exports2.KEY_LISTENERS, exports2.KEY_ERR, exports2.KEY_RAW];
      exports2.DOT_SLASH = `.${sep}`;
      exports2.BACK_SLASH_RE = /\\/g;
      exports2.DOUBLE_SLASH_RE = /\/\//;
      exports2.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
      exports2.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
      exports2.REPLACER_RE = /^\.[/\\]/;
      exports2.SLASH = "/";
      exports2.SLASH_SLASH = "//";
      exports2.BRACE_START = "{";
      exports2.BANG = "!";
      exports2.ONE_DOT = ".";
      exports2.TWO_DOTS = "..";
      exports2.STAR = "*";
      exports2.GLOBSTAR = "**";
      exports2.ROOT_GLOBSTAR = "/**/*";
      exports2.SLASH_GLOBSTAR = "/**";
      exports2.DIR_SUFFIX = "Dir";
      exports2.ANYMATCH_OPTS = { dot: true };
      exports2.STRING_TYPE = "string";
      exports2.FUNCTION_TYPE = "function";
      exports2.EMPTY_STR = "";
      exports2.EMPTY_FN = () => {
      };
      exports2.IDENTITY_FN = (val) => val;
      exports2.isWindows = platform2 === "win32";
      exports2.isMacos = platform2 === "darwin";
      exports2.isLinux = platform2 === "linux";
      exports2.isIBMi = os3.type() === "OS400";
    })(constants$1);
    var fs$a = fs__default;
    var sysPath$2 = path__default;
    var { promisify: promisify$3 } = require$$0__default$2;
    var isBinaryPath = isBinaryPath$1;
    var {
      isWindows: isWindows$2,
      isLinux,
      EMPTY_FN: EMPTY_FN$2,
      EMPTY_STR: EMPTY_STR$1,
      KEY_LISTENERS,
      KEY_ERR,
      KEY_RAW,
      HANDLER_KEYS,
      EV_CHANGE: EV_CHANGE$2,
      EV_ADD: EV_ADD$2,
      EV_ADD_DIR: EV_ADD_DIR$2,
      EV_ERROR: EV_ERROR$2,
      STR_DATA: STR_DATA$1,
      STR_END: STR_END$2,
      BRACE_START: BRACE_START$1,
      STAR
    } = constants$1;
    var THROTTLE_MODE_WATCH = "watch";
    var open$1 = promisify$3(fs$a.open);
    var stat$2 = promisify$3(fs$a.stat);
    var lstat$1 = promisify$3(fs$a.lstat);
    var close = promisify$3(fs$a.close);
    var fsrealpath = promisify$3(fs$a.realpath);
    var statMethods$1 = { lstat: lstat$1, stat: stat$2 };
    var foreach = (val, fn2) => {
      if (val instanceof Set) {
        val.forEach(fn2);
      } else {
        fn2(val);
      }
    };
    var addAndConvert = (main2, prop, item) => {
      let container = main2[prop];
      if (!(container instanceof Set)) {
        main2[prop] = container = new Set([container]);
      }
      container.add(item);
    };
    var clearItem = (cont) => (key) => {
      const set2 = cont[key];
      if (set2 instanceof Set) {
        set2.clear();
      } else {
        delete cont[key];
      }
    };
    var delFromSet = (main2, prop, item) => {
      const container = main2[prop];
      if (container instanceof Set) {
        container.delete(item);
      } else if (container === item) {
        delete main2[prop];
      }
    };
    var isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
    var FsWatchInstances = new Map();
    function createFsWatchInstance(path2, options2, listener2, errHandler, emitRaw) {
      const handleEvent = (rawEvent, evPath) => {
        listener2(path2);
        emitRaw(rawEvent, evPath, { watchedPath: path2 });
        if (evPath && path2 !== evPath) {
          fsWatchBroadcast(sysPath$2.resolve(path2, evPath), KEY_LISTENERS, sysPath$2.join(path2, evPath));
        }
      };
      try {
        return fs$a.watch(path2, options2, handleEvent);
      } catch (error2) {
        errHandler(error2);
      }
    }
    var fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
      const cont = FsWatchInstances.get(fullPath);
      if (!cont)
        return;
      foreach(cont[type], (listener2) => {
        listener2(val1, val2, val3);
      });
    };
    var setFsWatchListener = (path2, fullPath, options2, handlers) => {
      const { listener: listener2, errHandler, rawEmitter } = handlers;
      let cont = FsWatchInstances.get(fullPath);
      let watcher;
      if (!options2.persistent) {
        watcher = createFsWatchInstance(path2, options2, listener2, errHandler, rawEmitter);
        return watcher.close.bind(watcher);
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener2);
        addAndConvert(cont, KEY_ERR, errHandler);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        watcher = createFsWatchInstance(path2, options2, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, fsWatchBroadcast.bind(null, fullPath, KEY_RAW));
        if (!watcher)
          return;
        watcher.on(EV_ERROR$2, async (error2) => {
          const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
          cont.watcherUnusable = true;
          if (isWindows$2 && error2.code === "EPERM") {
            try {
              const fd = await open$1(path2, "r");
              await close(fd);
              broadcastErr(error2);
            } catch (err) {
            }
          } else {
            broadcastErr(error2);
          }
        });
        cont = {
          listeners: listener2,
          errHandlers: errHandler,
          rawEmitters: rawEmitter,
          watcher
        };
        FsWatchInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener2);
        delFromSet(cont, KEY_ERR, errHandler);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          cont.watcher.close();
          FsWatchInstances.delete(fullPath);
          HANDLER_KEYS.forEach(clearItem(cont));
          cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var FsWatchFileInstances = new Map();
    var setFsWatchFileListener = (path2, fullPath, options2, handlers) => {
      const { listener: listener2, rawEmitter } = handlers;
      let cont = FsWatchFileInstances.get(fullPath);
      const copts = cont && cont.options;
      if (copts && (copts.persistent < options2.persistent || copts.interval > options2.interval)) {
        fs$a.unwatchFile(fullPath);
        cont = void 0;
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener2);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        cont = {
          listeners: listener2,
          rawEmitters: rawEmitter,
          options: options2,
          watcher: fs$a.watchFile(fullPath, options2, (curr, prev) => {
            foreach(cont.rawEmitters, (rawEmitter2) => {
              rawEmitter2(EV_CHANGE$2, fullPath, { curr, prev });
            });
            const currmtime = curr.mtimeMs;
            if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
              foreach(cont.listeners, (listener3) => listener3(path2, curr));
            }
          })
        };
        FsWatchFileInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener2);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          FsWatchFileInstances.delete(fullPath);
          fs$a.unwatchFile(fullPath);
          cont.options = cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var NodeFsHandler$1 = class {
      constructor(fsW) {
        this.fsw = fsW;
        this._boundHandleError = (error2) => fsW._handleError(error2);
      }
      _watchWithNodeFs(path2, listener2) {
        const opts = this.fsw.options;
        const directory = sysPath$2.dirname(path2);
        const basename = sysPath$2.basename(path2);
        const parent = this.fsw._getWatchedDir(directory);
        parent.add(basename);
        const absolutePath = sysPath$2.resolve(path2);
        const options2 = { persistent: opts.persistent };
        if (!listener2)
          listener2 = EMPTY_FN$2;
        let closer;
        if (opts.usePolling) {
          options2.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;
          closer = setFsWatchFileListener(path2, absolutePath, options2, {
            listener: listener2,
            rawEmitter: this.fsw._emitRaw
          });
        } else {
          closer = setFsWatchListener(path2, absolutePath, options2, {
            listener: listener2,
            errHandler: this._boundHandleError,
            rawEmitter: this.fsw._emitRaw
          });
        }
        return closer;
      }
      _handleFile(file, stats, initialAdd) {
        if (this.fsw.closed) {
          return;
        }
        const dirname = sysPath$2.dirname(file);
        const basename = sysPath$2.basename(file);
        const parent = this.fsw._getWatchedDir(dirname);
        let prevStats = stats;
        if (parent.has(basename))
          return;
        const listener2 = async (path2, newStats) => {
          if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))
            return;
          if (!newStats || newStats.mtimeMs === 0) {
            try {
              const newStats2 = await stat$2(file);
              if (this.fsw.closed)
                return;
              const at2 = newStats2.atimeMs;
              const mt2 = newStats2.mtimeMs;
              if (!at2 || at2 <= mt2 || mt2 !== prevStats.mtimeMs) {
                this.fsw._emit(EV_CHANGE$2, file, newStats2);
              }
              if (isLinux && prevStats.ino !== newStats2.ino) {
                this.fsw._closeFile(path2);
                prevStats = newStats2;
                this.fsw._addPathCloser(path2, this._watchWithNodeFs(file, listener2));
              } else {
                prevStats = newStats2;
              }
            } catch (error2) {
              this.fsw._remove(dirname, basename);
            }
          } else if (parent.has(basename)) {
            const at2 = newStats.atimeMs;
            const mt2 = newStats.mtimeMs;
            if (!at2 || at2 <= mt2 || mt2 !== prevStats.mtimeMs) {
              this.fsw._emit(EV_CHANGE$2, file, newStats);
            }
            prevStats = newStats;
          }
        };
        const closer = this._watchWithNodeFs(file, listener2);
        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
          if (!this.fsw._throttle(EV_ADD$2, file, 0))
            return;
          this.fsw._emit(EV_ADD$2, file, stats);
        }
        return closer;
      }
      async _handleSymlink(entry2, directory, path2, item) {
        if (this.fsw.closed) {
          return;
        }
        const full = entry2.fullPath;
        const dir = this.fsw._getWatchedDir(directory);
        if (!this.fsw.options.followSymlinks) {
          this.fsw._incrReadyCount();
          const linkPath = await fsrealpath(path2);
          if (this.fsw.closed)
            return;
          if (dir.has(item)) {
            if (this.fsw._symlinkPaths.get(full) !== linkPath) {
              this.fsw._symlinkPaths.set(full, linkPath);
              this.fsw._emit(EV_CHANGE$2, path2, entry2.stats);
            }
          } else {
            dir.add(item);
            this.fsw._symlinkPaths.set(full, linkPath);
            this.fsw._emit(EV_ADD$2, path2, entry2.stats);
          }
          this.fsw._emitReady();
          return true;
        }
        if (this.fsw._symlinkPaths.has(full)) {
          return true;
        }
        this.fsw._symlinkPaths.set(full, true);
      }
      _handleRead(directory, initialAdd, wh2, target, dir, depth2, throttler) {
        directory = sysPath$2.join(directory, EMPTY_STR$1);
        if (!wh2.hasGlob) {
          throttler = this.fsw._throttle("readdir", directory, 1e3);
          if (!throttler)
            return;
        }
        const previous = this.fsw._getWatchedDir(wh2.path);
        const current = new Set();
        let stream2 = this.fsw._readdirp(directory, {
          fileFilter: (entry2) => wh2.filterPath(entry2),
          directoryFilter: (entry2) => wh2.filterDir(entry2),
          depth: 0
        }).on(STR_DATA$1, async (entry2) => {
          if (this.fsw.closed) {
            stream2 = void 0;
            return;
          }
          const item = entry2.path;
          let path2 = sysPath$2.join(directory, item);
          current.add(item);
          if (entry2.stats.isSymbolicLink() && await this._handleSymlink(entry2, directory, path2, item)) {
            return;
          }
          if (this.fsw.closed) {
            stream2 = void 0;
            return;
          }
          if (item === target || !target && !previous.has(item)) {
            this.fsw._incrReadyCount();
            path2 = sysPath$2.join(dir, sysPath$2.relative(dir, path2));
            this._addToNodeFs(path2, initialAdd, wh2, depth2 + 1);
          }
        }).on(EV_ERROR$2, this._boundHandleError);
        return new Promise((resolve2) => stream2.once(STR_END$2, () => {
          if (this.fsw.closed) {
            stream2 = void 0;
            return;
          }
          const wasThrottled = throttler ? throttler.clear() : false;
          resolve2();
          previous.getChildren().filter((item) => {
            return item !== directory && !current.has(item) && (!wh2.hasGlob || wh2.filterPath({
              fullPath: sysPath$2.resolve(directory, item)
            }));
          }).forEach((item) => {
            this.fsw._remove(directory, item);
          });
          stream2 = void 0;
          if (wasThrottled)
            this._handleRead(directory, false, wh2, target, dir, depth2, throttler);
        }));
      }
      async _handleDir(dir, stats, initialAdd, depth2, target, wh2, realpath2) {
        const parentDir = this.fsw._getWatchedDir(sysPath$2.dirname(dir));
        const tracked = parentDir.has(sysPath$2.basename(dir));
        if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
          if (!wh2.hasGlob || wh2.globFilter(dir))
            this.fsw._emit(EV_ADD_DIR$2, dir, stats);
        }
        parentDir.add(sysPath$2.basename(dir));
        this.fsw._getWatchedDir(dir);
        let throttler;
        let closer;
        const oDepth = this.fsw.options.depth;
        if ((oDepth == null || depth2 <= oDepth) && !this.fsw._symlinkPaths.has(realpath2)) {
          if (!target) {
            await this._handleRead(dir, initialAdd, wh2, target, dir, depth2, throttler);
            if (this.fsw.closed)
              return;
          }
          closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
            if (stats2 && stats2.mtimeMs === 0)
              return;
            this._handleRead(dirPath, false, wh2, target, dir, depth2, throttler);
          });
        }
        return closer;
      }
      async _addToNodeFs(path2, initialAdd, priorWh, depth2, target) {
        const ready = this.fsw._emitReady;
        if (this.fsw._isIgnored(path2) || this.fsw.closed) {
          ready();
          return false;
        }
        const wh2 = this.fsw._getWatchHelpers(path2, depth2);
        if (!wh2.hasGlob && priorWh) {
          wh2.hasGlob = priorWh.hasGlob;
          wh2.globFilter = priorWh.globFilter;
          wh2.filterPath = (entry2) => priorWh.filterPath(entry2);
          wh2.filterDir = (entry2) => priorWh.filterDir(entry2);
        }
        try {
          const stats = await statMethods$1[wh2.statMethod](wh2.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh2.watchPath, stats)) {
            ready();
            return false;
          }
          const follow = this.fsw.options.followSymlinks && !path2.includes(STAR) && !path2.includes(BRACE_START$1);
          let closer;
          if (stats.isDirectory()) {
            const absPath = sysPath$2.resolve(path2);
            const targetPath = follow ? await fsrealpath(path2) : path2;
            if (this.fsw.closed)
              return;
            closer = await this._handleDir(wh2.watchPath, stats, initialAdd, depth2, target, wh2, targetPath);
            if (this.fsw.closed)
              return;
            if (absPath !== targetPath && targetPath !== void 0) {
              this.fsw._symlinkPaths.set(absPath, targetPath);
            }
          } else if (stats.isSymbolicLink()) {
            const targetPath = follow ? await fsrealpath(path2) : path2;
            if (this.fsw.closed)
              return;
            const parent = sysPath$2.dirname(wh2.watchPath);
            this.fsw._getWatchedDir(parent).add(wh2.watchPath);
            this.fsw._emit(EV_ADD$2, wh2.watchPath, stats);
            closer = await this._handleDir(parent, stats, initialAdd, depth2, path2, wh2, targetPath);
            if (this.fsw.closed)
              return;
            if (targetPath !== void 0) {
              this.fsw._symlinkPaths.set(sysPath$2.resolve(path2), targetPath);
            }
          } else {
            closer = this._handleFile(wh2.watchPath, stats, initialAdd);
          }
          ready();
          this.fsw._addPathCloser(path2, closer);
          return false;
        } catch (error2) {
          if (this.fsw._handleError(error2)) {
            ready();
            return path2;
          }
        }
      }
    };
    var nodefsHandler = NodeFsHandler$1;
    var fseventsHandler = { exports: {} };
    var fs$9 = fs__default;
    var sysPath$1 = path__default;
    var { promisify: promisify$2 } = require$$0__default$2;
    var fsevents;
    try {
      fsevents = eval("require")("fsevents");
    } catch (error2) {
      if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR)
        console.error(error2);
    }
    if (fsevents) {
      const mtch = process.version.match(/v(\d+)\.(\d+)/);
      if (mtch && mtch[1] && mtch[2]) {
        const maj2 = Number.parseInt(mtch[1], 10);
        const min2 = Number.parseInt(mtch[2], 10);
        if (maj2 === 8 && min2 < 16) {
          fsevents = void 0;
        }
      }
    }
    var {
      EV_ADD: EV_ADD$1,
      EV_CHANGE: EV_CHANGE$1,
      EV_ADD_DIR: EV_ADD_DIR$1,
      EV_UNLINK: EV_UNLINK$1,
      EV_ERROR: EV_ERROR$1,
      STR_DATA,
      STR_END: STR_END$1,
      FSEVENT_CREATED,
      FSEVENT_MODIFIED,
      FSEVENT_DELETED,
      FSEVENT_MOVED,
      FSEVENT_UNKNOWN,
      FSEVENT_TYPE_FILE,
      FSEVENT_TYPE_DIRECTORY,
      FSEVENT_TYPE_SYMLINK,
      ROOT_GLOBSTAR,
      DIR_SUFFIX,
      DOT_SLASH,
      FUNCTION_TYPE: FUNCTION_TYPE$1,
      EMPTY_FN: EMPTY_FN$1,
      IDENTITY_FN
    } = constants$1;
    var Depth = (value) => isNaN(value) ? {} : { depth: value };
    var stat$1 = promisify$2(fs$9.stat);
    var lstat = promisify$2(fs$9.lstat);
    var realpath = promisify$2(fs$9.realpath);
    var statMethods = { stat: stat$1, lstat };
    var FSEventsWatchers = new Map();
    var consolidateThreshhold = 10;
    var wrongEventFlags = new Set([
      69888,
      70400,
      71424,
      72704,
      73472,
      131328,
      131840,
      262912
    ]);
    var createFSEventsInstance = (path2, callback) => {
      const stop = fsevents.watch(path2, callback);
      return { stop };
    };
    function setFSEventsListener(path2, realPath, listener2, rawEmitter) {
      let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;
      const parentPath = sysPath$1.dirname(watchPath);
      let cont = FSEventsWatchers.get(watchPath);
      if (couldConsolidate(parentPath)) {
        watchPath = parentPath;
      }
      const resolvedPath = sysPath$1.resolve(path2);
      const hasSymlink = resolvedPath !== realPath;
      const filteredListener = (fullPath, flags, info) => {
        if (hasSymlink)
          fullPath = fullPath.replace(realPath, resolvedPath);
        if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath$1.sep))
          listener2(fullPath, flags, info);
      };
      let watchedParent = false;
      for (const watchedPath of FSEventsWatchers.keys()) {
        if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {
          watchPath = watchedPath;
          cont = FSEventsWatchers.get(watchPath);
          watchedParent = true;
          break;
        }
      }
      if (cont || watchedParent) {
        cont.listeners.add(filteredListener);
      } else {
        cont = {
          listeners: new Set([filteredListener]),
          rawEmitter,
          watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
            if (!cont.listeners.size)
              return;
            const info = fsevents.getInfo(fullPath, flags);
            cont.listeners.forEach((list2) => {
              list2(fullPath, flags, info);
            });
            cont.rawEmitter(info.event, fullPath, info);
          })
        };
        FSEventsWatchers.set(watchPath, cont);
      }
      return () => {
        const lst = cont.listeners;
        lst.delete(filteredListener);
        if (!lst.size) {
          FSEventsWatchers.delete(watchPath);
          if (cont.watcher)
            return cont.watcher.stop().then(() => {
              cont.rawEmitter = cont.watcher = void 0;
              Object.freeze(cont);
            });
        }
      };
    }
    var couldConsolidate = (path2) => {
      let count = 0;
      for (const watchPath of FSEventsWatchers.keys()) {
        if (watchPath.indexOf(path2) === 0) {
          count++;
          if (count >= consolidateThreshhold) {
            return true;
          }
        }
      }
      return false;
    };
    var canUse = () => fsevents && FSEventsWatchers.size < 128;
    var calcDepth = (path2, root) => {
      let i2 = 0;
      while (!path2.indexOf(root) && (path2 = sysPath$1.dirname(path2)) !== root)
        i2++;
      return i2;
    };
    var sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
    var FsEventsHandler$1 = class {
      constructor(fsw) {
        this.fsw = fsw;
      }
      checkIgnored(path2, stats) {
        const ipaths = this.fsw._ignoredPaths;
        if (this.fsw._isIgnored(path2, stats)) {
          ipaths.add(path2);
          if (stats && stats.isDirectory()) {
            ipaths.add(path2 + ROOT_GLOBSTAR);
          }
          return true;
        }
        ipaths.delete(path2);
        ipaths.delete(path2 + ROOT_GLOBSTAR);
      }
      addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts) {
        const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;
        this.handleEvent(event, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
      async checkExists(path2, fullPath, realPath, parent, watchedDir, item, info, opts) {
        try {
          const stats = await stat$1(path2);
          if (this.fsw.closed)
            return;
          if (sameTypes(info, stats)) {
            this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK$1, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        } catch (error2) {
          if (error2.code === "EACCES") {
            this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK$1, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        }
      }
      handleEvent(event, path2, fullPath, realPath, parent, watchedDir, item, info, opts) {
        if (this.fsw.closed || this.checkIgnored(path2))
          return;
        if (event === EV_UNLINK$1) {
          const isDirectory2 = info.type === FSEVENT_TYPE_DIRECTORY;
          if (isDirectory2 || watchedDir.has(item)) {
            this.fsw._remove(parent, item, isDirectory2);
          }
        } else {
          if (event === EV_ADD$1) {
            if (info.type === FSEVENT_TYPE_DIRECTORY)
              this.fsw._getWatchedDir(path2);
            if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
              const curDepth = opts.depth === void 0 ? void 0 : calcDepth(fullPath, realPath) + 1;
              return this._addToFsEvents(path2, false, true, curDepth);
            }
            this.fsw._getWatchedDir(parent).add(item);
          }
          const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
          this.fsw._emit(eventName, path2);
          if (eventName === EV_ADD_DIR$1)
            this._addToFsEvents(path2, false, true);
        }
      }
      _watchWithFsEvents(watchPath, realPath, transform2, globFilter) {
        if (this.fsw.closed || this.fsw._isIgnored(watchPath))
          return;
        const opts = this.fsw.options;
        const watchCallback = async (fullPath, flags, info) => {
          if (this.fsw.closed)
            return;
          if (opts.depth !== void 0 && calcDepth(fullPath, realPath) > opts.depth)
            return;
          const path2 = transform2(sysPath$1.join(watchPath, sysPath$1.relative(watchPath, fullPath)));
          if (globFilter && !globFilter(path2))
            return;
          const parent = sysPath$1.dirname(path2);
          const item = sysPath$1.basename(path2);
          const watchedDir = this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path2 : parent);
          if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
            if (typeof opts.ignored === FUNCTION_TYPE$1) {
              let stats;
              try {
                stats = await stat$1(path2);
              } catch (error2) {
              }
              if (this.fsw.closed)
                return;
              if (this.checkIgnored(path2, stats))
                return;
              if (sameTypes(info, stats)) {
                this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
              } else {
                this.handleEvent(EV_UNLINK$1, path2, fullPath, realPath, parent, watchedDir, item, info, opts);
              }
            } else {
              this.checkExists(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          } else {
            switch (info.event) {
              case FSEVENT_CREATED:
              case FSEVENT_MODIFIED:
                return this.addOrChange(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
              case FSEVENT_DELETED:
              case FSEVENT_MOVED:
                return this.checkExists(path2, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          }
        };
        const closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);
        this.fsw._emitReady();
        return closer;
      }
      async _handleFsEventsSymlink(linkPath, fullPath, transform2, curDepth) {
        if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))
          return;
        this.fsw._symlinkPaths.set(fullPath, true);
        this.fsw._incrReadyCount();
        try {
          const linkTarget = await realpath(linkPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(linkTarget)) {
            return this.fsw._emitReady();
          }
          this.fsw._incrReadyCount();
          this._addToFsEvents(linkTarget || linkPath, (path2) => {
            let aliasedPath = linkPath;
            if (linkTarget && linkTarget !== DOT_SLASH) {
              aliasedPath = path2.replace(linkTarget, linkPath);
            } else if (path2 !== DOT_SLASH) {
              aliasedPath = sysPath$1.join(linkPath, path2);
            }
            return transform2(aliasedPath);
          }, false, curDepth);
        } catch (error2) {
          if (this.fsw._handleError(error2)) {
            return this.fsw._emitReady();
          }
        }
      }
      emitAdd(newPath, stats, processPath, opts, forceAdd) {
        const pp2 = processPath(newPath);
        const isDir = stats.isDirectory();
        const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp2));
        const base2 = sysPath$1.basename(pp2);
        if (isDir)
          this.fsw._getWatchedDir(pp2);
        if (dirObj.has(base2))
          return;
        dirObj.add(base2);
        if (!opts.ignoreInitial || forceAdd === true) {
          this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp2, stats);
        }
      }
      initWatch(realPath, path2, wh2, processPath) {
        if (this.fsw.closed)
          return;
        const closer = this._watchWithFsEvents(wh2.watchPath, sysPath$1.resolve(realPath || wh2.watchPath), processPath, wh2.globFilter);
        this.fsw._addPathCloser(path2, closer);
      }
      async _addToFsEvents(path2, transform2, forceAdd, priorDepth) {
        if (this.fsw.closed) {
          return;
        }
        const opts = this.fsw.options;
        const processPath = typeof transform2 === FUNCTION_TYPE$1 ? transform2 : IDENTITY_FN;
        const wh2 = this.fsw._getWatchHelpers(path2);
        try {
          const stats = await statMethods[wh2.statMethod](wh2.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh2.watchPath, stats)) {
            throw null;
          }
          if (stats.isDirectory()) {
            if (!wh2.globFilter)
              this.emitAdd(processPath(path2), stats, processPath, opts, forceAdd);
            if (priorDepth && priorDepth > opts.depth)
              return;
            this.fsw._readdirp(wh2.watchPath, __spreadValues2({
              fileFilter: (entry2) => wh2.filterPath(entry2),
              directoryFilter: (entry2) => wh2.filterDir(entry2)
            }, Depth(opts.depth - (priorDepth || 0)))).on(STR_DATA, (entry2) => {
              if (this.fsw.closed) {
                return;
              }
              if (entry2.stats.isDirectory() && !wh2.filterPath(entry2))
                return;
              const joinedPath = sysPath$1.join(wh2.watchPath, entry2.path);
              const { fullPath } = entry2;
              if (wh2.followSymlinks && entry2.stats.isSymbolicLink()) {
                const curDepth = opts.depth === void 0 ? void 0 : calcDepth(joinedPath, sysPath$1.resolve(wh2.watchPath)) + 1;
                this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
              } else {
                this.emitAdd(joinedPath, entry2.stats, processPath, opts, forceAdd);
              }
            }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {
              this.fsw._emitReady();
            });
          } else {
            this.emitAdd(wh2.watchPath, stats, processPath, opts, forceAdd);
            this.fsw._emitReady();
          }
        } catch (error2) {
          if (!error2 || this.fsw._handleError(error2)) {
            this.fsw._emitReady();
            this.fsw._emitReady();
          }
        }
        if (opts.persistent && forceAdd !== true) {
          if (typeof transform2 === FUNCTION_TYPE$1) {
            this.initWatch(void 0, path2, wh2, processPath);
          } else {
            let realPath;
            try {
              realPath = await realpath(wh2.watchPath);
            } catch (e2) {
            }
            this.initWatch(realPath, path2, wh2, processPath);
          }
        }
      }
    };
    fseventsHandler.exports = FsEventsHandler$1;
    fseventsHandler.exports.canUse = canUse;
    var { EventEmitter: EventEmitter$2 } = require$$0__default$4;
    var fs$8 = fs__default;
    var sysPath = path__default;
    var { promisify: promisify$1 } = require$$0__default$2;
    var readdirp = readdirp_1;
    var anymatch = anymatch$2.exports.default;
    var globParent = globParent$2;
    var isGlob = isGlob$2;
    var braces = braces_1;
    var normalizePath = normalizePath$2;
    var NodeFsHandler = nodefsHandler;
    var FsEventsHandler = fseventsHandler.exports;
    var {
      EV_ALL,
      EV_READY,
      EV_ADD,
      EV_CHANGE,
      EV_UNLINK,
      EV_ADD_DIR,
      EV_UNLINK_DIR,
      EV_RAW,
      EV_ERROR,
      STR_CLOSE,
      STR_END,
      BACK_SLASH_RE,
      DOUBLE_SLASH_RE,
      SLASH_OR_BACK_SLASH_RE,
      DOT_RE,
      REPLACER_RE,
      SLASH,
      SLASH_SLASH,
      BRACE_START,
      BANG,
      ONE_DOT,
      TWO_DOTS,
      GLOBSTAR,
      SLASH_GLOBSTAR,
      ANYMATCH_OPTS,
      STRING_TYPE,
      FUNCTION_TYPE,
      EMPTY_STR,
      EMPTY_FN,
      isWindows: isWindows$1,
      isMacos,
      isIBMi
    } = constants$1;
    var stat = promisify$1(fs$8.stat);
    var readdir = promisify$1(fs$8.readdir);
    var arrify = (value = []) => Array.isArray(value) ? value : [value];
    var flatten = (list2, result2 = []) => {
      list2.forEach((item) => {
        if (Array.isArray(item)) {
          flatten(item, result2);
        } else {
          result2.push(item);
        }
      });
      return result2;
    };
    var unifyPaths = (paths_) => {
      const paths = flatten(arrify(paths_));
      if (!paths.every((p2) => typeof p2 === STRING_TYPE)) {
        throw new TypeError(`Non-string provided as watch path: ${paths}`);
      }
      return paths.map(normalizePathToUnix);
    };
    var toUnix = (string2) => {
      let str = string2.replace(BACK_SLASH_RE, SLASH);
      let prepend = false;
      if (str.startsWith(SLASH_SLASH)) {
        prepend = true;
      }
      while (str.match(DOUBLE_SLASH_RE)) {
        str = str.replace(DOUBLE_SLASH_RE, SLASH);
      }
      if (prepend) {
        str = SLASH + str;
      }
      return str;
    };
    var normalizePathToUnix = (path2) => toUnix(sysPath.normalize(toUnix(path2)));
    var normalizeIgnored = (cwd = EMPTY_STR) => (path2) => {
      if (typeof path2 !== STRING_TYPE)
        return path2;
      return normalizePathToUnix(sysPath.isAbsolute(path2) ? path2 : sysPath.join(cwd, path2));
    };
    var getAbsolutePath = (path2, cwd) => {
      if (sysPath.isAbsolute(path2)) {
        return path2;
      }
      if (path2.startsWith(BANG)) {
        return BANG + sysPath.join(cwd, path2.slice(1));
      }
      return sysPath.join(cwd, path2);
    };
    var undef = (opts, key) => opts[key] === void 0;
    var DirEntry = class {
      constructor(dir, removeWatcher) {
        this.path = dir;
        this._removeWatcher = removeWatcher;
        this.items = new Set();
      }
      add(item) {
        const { items } = this;
        if (!items)
          return;
        if (item !== ONE_DOT && item !== TWO_DOTS)
          items.add(item);
      }
      async remove(item) {
        const { items } = this;
        if (!items)
          return;
        items.delete(item);
        if (items.size > 0)
          return;
        const dir = this.path;
        try {
          await readdir(dir);
        } catch (err) {
          if (this._removeWatcher) {
            this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
          }
        }
      }
      has(item) {
        const { items } = this;
        if (!items)
          return;
        return items.has(item);
      }
      getChildren() {
        const { items } = this;
        if (!items)
          return;
        return [...items.values()];
      }
      dispose() {
        this.items.clear();
        delete this.path;
        delete this._removeWatcher;
        delete this.items;
        Object.freeze(this);
      }
    };
    var STAT_METHOD_F = "stat";
    var STAT_METHOD_L = "lstat";
    var WatchHelper = class {
      constructor(path2, watchPath, follow, fsw) {
        this.fsw = fsw;
        this.path = path2 = path2.replace(REPLACER_RE, EMPTY_STR);
        this.watchPath = watchPath;
        this.fullWatchPath = sysPath.resolve(watchPath);
        this.hasGlob = watchPath !== path2;
        if (path2 === EMPTY_STR)
          this.hasGlob = false;
        this.globSymlink = this.hasGlob && follow ? void 0 : false;
        this.globFilter = this.hasGlob ? anymatch(path2, void 0, ANYMATCH_OPTS) : false;
        this.dirParts = this.getDirParts(path2);
        this.dirParts.forEach((parts) => {
          if (parts.length > 1)
            parts.pop();
        });
        this.followSymlinks = follow;
        this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
      }
      checkGlobSymlink(entry2) {
        if (this.globSymlink === void 0) {
          this.globSymlink = entry2.fullParentDir === this.fullWatchPath ? false : { realPath: entry2.fullParentDir, linkPath: this.fullWatchPath };
        }
        if (this.globSymlink) {
          return entry2.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
        }
        return entry2.fullPath;
      }
      entryPath(entry2) {
        return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry2)));
      }
      filterPath(entry2) {
        const { stats } = entry2;
        if (stats && stats.isSymbolicLink())
          return this.filterDir(entry2);
        const resolvedPath = this.entryPath(entry2);
        const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
        return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
      }
      getDirParts(path2) {
        if (!this.hasGlob)
          return [];
        const parts = [];
        const expandedPath = path2.includes(BRACE_START) ? braces.expand(path2) : [path2];
        expandedPath.forEach((path3) => {
          parts.push(sysPath.relative(this.watchPath, path3).split(SLASH_OR_BACK_SLASH_RE));
        });
        return parts;
      }
      filterDir(entry2) {
        if (this.hasGlob) {
          const entryParts = this.getDirParts(this.checkGlobSymlink(entry2));
          let globstar = false;
          this.unmatchedGlob = !this.dirParts.some((parts) => {
            return parts.every((part, i2) => {
              if (part === GLOBSTAR)
                globstar = true;
              return globstar || !entryParts[0][i2] || anymatch(part, entryParts[0][i2], ANYMATCH_OPTS);
            });
          });
        }
        return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry2), entry2.stats);
      }
    };
    var FSWatcher = class extends EventEmitter$2 {
      constructor(_opts) {
        super();
        const opts = {};
        if (_opts)
          Object.assign(opts, _opts);
        this._watched = new Map();
        this._closers = new Map();
        this._ignoredPaths = new Set();
        this._throttled = new Map();
        this._symlinkPaths = new Map();
        this._streams = new Set();
        this.closed = false;
        if (undef(opts, "persistent"))
          opts.persistent = true;
        if (undef(opts, "ignoreInitial"))
          opts.ignoreInitial = false;
        if (undef(opts, "ignorePermissionErrors"))
          opts.ignorePermissionErrors = false;
        if (undef(opts, "interval"))
          opts.interval = 100;
        if (undef(opts, "binaryInterval"))
          opts.binaryInterval = 300;
        if (undef(opts, "disableGlobbing"))
          opts.disableGlobbing = false;
        opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
        if (undef(opts, "useFsEvents"))
          opts.useFsEvents = !opts.usePolling;
        const canUseFsEvents = FsEventsHandler.canUse();
        if (!canUseFsEvents)
          opts.useFsEvents = false;
        if (undef(opts, "usePolling") && !opts.useFsEvents) {
          opts.usePolling = isMacos;
        }
        if (isIBMi) {
          opts.usePolling = true;
        }
        const envPoll = process.env.CHOKIDAR_USEPOLLING;
        if (envPoll !== void 0) {
          const envLower = envPoll.toLowerCase();
          if (envLower === "false" || envLower === "0") {
            opts.usePolling = false;
          } else if (envLower === "true" || envLower === "1") {
            opts.usePolling = true;
          } else {
            opts.usePolling = !!envLower;
          }
        }
        const envInterval = process.env.CHOKIDAR_INTERVAL;
        if (envInterval) {
          opts.interval = Number.parseInt(envInterval, 10);
        }
        if (undef(opts, "atomic"))
          opts.atomic = !opts.usePolling && !opts.useFsEvents;
        if (opts.atomic)
          this._pendingUnlinks = new Map();
        if (undef(opts, "followSymlinks"))
          opts.followSymlinks = true;
        if (undef(opts, "awaitWriteFinish"))
          opts.awaitWriteFinish = false;
        if (opts.awaitWriteFinish === true)
          opts.awaitWriteFinish = {};
        const awf = opts.awaitWriteFinish;
        if (awf) {
          if (!awf.stabilityThreshold)
            awf.stabilityThreshold = 2e3;
          if (!awf.pollInterval)
            awf.pollInterval = 100;
          this._pendingWrites = new Map();
        }
        if (opts.ignored)
          opts.ignored = arrify(opts.ignored);
        let readyCalls = 0;
        this._emitReady = () => {
          readyCalls++;
          if (readyCalls >= this._readyCount) {
            this._emitReady = EMPTY_FN;
            this._readyEmitted = true;
            process.nextTick(() => this.emit(EV_READY));
          }
        };
        this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
        this._readyEmitted = false;
        this.options = opts;
        if (opts.useFsEvents) {
          this._fsEventsHandler = new FsEventsHandler(this);
        } else {
          this._nodeFsHandler = new NodeFsHandler(this);
        }
        Object.freeze(opts);
      }
      add(paths_, _origAdd, _internal) {
        const { cwd, disableGlobbing } = this.options;
        this.closed = false;
        let paths = unifyPaths(paths_);
        if (cwd) {
          paths = paths.map((path2) => {
            const absPath = getAbsolutePath(path2, cwd);
            if (disableGlobbing || !isGlob(path2)) {
              return absPath;
            }
            return normalizePath(absPath);
          });
        }
        paths = paths.filter((path2) => {
          if (path2.startsWith(BANG)) {
            this._ignoredPaths.add(path2.slice(1));
            return false;
          }
          this._ignoredPaths.delete(path2);
          this._ignoredPaths.delete(path2 + SLASH_GLOBSTAR);
          this._userIgnored = void 0;
          return true;
        });
        if (this.options.useFsEvents && this._fsEventsHandler) {
          if (!this._readyCount)
            this._readyCount = paths.length;
          if (this.options.persistent)
            this._readyCount *= 2;
          paths.forEach((path2) => this._fsEventsHandler._addToFsEvents(path2));
        } else {
          if (!this._readyCount)
            this._readyCount = 0;
          this._readyCount += paths.length;
          Promise.all(paths.map(async (path2) => {
            const res = await this._nodeFsHandler._addToNodeFs(path2, !_internal, 0, 0, _origAdd);
            if (res)
              this._emitReady();
            return res;
          })).then((results) => {
            if (this.closed)
              return;
            results.filter((item) => item).forEach((item) => {
              this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
            });
          });
        }
        return this;
      }
      unwatch(paths_) {
        if (this.closed)
          return this;
        const paths = unifyPaths(paths_);
        const { cwd } = this.options;
        paths.forEach((path2) => {
          if (!sysPath.isAbsolute(path2) && !this._closers.has(path2)) {
            if (cwd)
              path2 = sysPath.join(cwd, path2);
            path2 = sysPath.resolve(path2);
          }
          this._closePath(path2);
          this._ignoredPaths.add(path2);
          if (this._watched.has(path2)) {
            this._ignoredPaths.add(path2 + SLASH_GLOBSTAR);
          }
          this._userIgnored = void 0;
        });
        return this;
      }
      close() {
        if (this.closed)
          return this._closePromise;
        this.closed = true;
        this.removeAllListeners();
        const closers = [];
        this._closers.forEach((closerList) => closerList.forEach((closer) => {
          const promise2 = closer();
          if (promise2 instanceof Promise)
            closers.push(promise2);
        }));
        this._streams.forEach((stream2) => stream2.destroy());
        this._userIgnored = void 0;
        this._readyCount = 0;
        this._readyEmitted = false;
        this._watched.forEach((dirent) => dirent.dispose());
        ["closers", "watched", "streams", "symlinkPaths", "throttled"].forEach((key) => {
          this[`_${key}`].clear();
        });
        this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
        return this._closePromise;
      }
      getWatched() {
        const watchList = {};
        this._watched.forEach((entry2, dir) => {
          const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
          watchList[key || ONE_DOT] = entry2.getChildren().sort();
        });
        return watchList;
      }
      emitWithAll(event, args) {
        this.emit(...args);
        if (event !== EV_ERROR)
          this.emit(EV_ALL, ...args);
      }
      async _emit(event, path2, val1, val2, val3) {
        if (this.closed)
          return;
        const opts = this.options;
        if (isWindows$1)
          path2 = sysPath.normalize(path2);
        if (opts.cwd)
          path2 = sysPath.relative(opts.cwd, path2);
        const args = [event, path2];
        if (val3 !== void 0)
          args.push(val1, val2, val3);
        else if (val2 !== void 0)
          args.push(val1, val2);
        else if (val1 !== void 0)
          args.push(val1);
        const awf = opts.awaitWriteFinish;
        let pw;
        if (awf && (pw = this._pendingWrites.get(path2))) {
          pw.lastChange = new Date();
          return this;
        }
        if (opts.atomic) {
          if (event === EV_UNLINK) {
            this._pendingUnlinks.set(path2, args);
            setTimeout(() => {
              this._pendingUnlinks.forEach((entry2, path3) => {
                this.emit(...entry2);
                this.emit(EV_ALL, ...entry2);
                this._pendingUnlinks.delete(path3);
              });
            }, typeof opts.atomic === "number" ? opts.atomic : 100);
            return this;
          }
          if (event === EV_ADD && this._pendingUnlinks.has(path2)) {
            event = args[0] = EV_CHANGE;
            this._pendingUnlinks.delete(path2);
          }
        }
        if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
          const awfEmit = (err, stats) => {
            if (err) {
              event = args[0] = EV_ERROR;
              args[1] = err;
              this.emitWithAll(event, args);
            } else if (stats) {
              if (args.length > 2) {
                args[2] = stats;
              } else {
                args.push(stats);
              }
              this.emitWithAll(event, args);
            }
          };
          this._awaitWriteFinish(path2, awf.stabilityThreshold, event, awfEmit);
          return this;
        }
        if (event === EV_CHANGE) {
          const isThrottled = !this._throttle(EV_CHANGE, path2, 50);
          if (isThrottled)
            return this;
        }
        if (opts.alwaysStat && val1 === void 0 && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
          const fullPath = opts.cwd ? sysPath.join(opts.cwd, path2) : path2;
          let stats;
          try {
            stats = await stat(fullPath);
          } catch (err) {
          }
          if (!stats || this.closed)
            return;
          args.push(stats);
        }
        this.emitWithAll(event, args);
        return this;
      }
      _handleError(error2) {
        const code = error2 && error2.code;
        if (error2 && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
          this.emit(EV_ERROR, error2);
        }
        return error2 || this.closed;
      }
      _throttle(actionType, path2, timeout) {
        if (!this._throttled.has(actionType)) {
          this._throttled.set(actionType, new Map());
        }
        const action = this._throttled.get(actionType);
        const actionPath = action.get(path2);
        if (actionPath) {
          actionPath.count++;
          return false;
        }
        let timeoutObject;
        const clear = () => {
          const item = action.get(path2);
          const count = item ? item.count : 0;
          action.delete(path2);
          clearTimeout(timeoutObject);
          if (item)
            clearTimeout(item.timeoutObject);
          return count;
        };
        timeoutObject = setTimeout(clear, timeout);
        const thr = { timeoutObject, clear, count: 0 };
        action.set(path2, thr);
        return thr;
      }
      _incrReadyCount() {
        return this._readyCount++;
      }
      _awaitWriteFinish(path2, threshold, event, awfEmit) {
        let timeoutHandler;
        let fullPath = path2;
        if (this.options.cwd && !sysPath.isAbsolute(path2)) {
          fullPath = sysPath.join(this.options.cwd, path2);
        }
        const now = new Date();
        const awaitWriteFinish = (prevStat) => {
          fs$8.stat(fullPath, (err, curStat) => {
            if (err || !this._pendingWrites.has(path2)) {
              if (err && err.code !== "ENOENT")
                awfEmit(err);
              return;
            }
            const now2 = Number(new Date());
            if (prevStat && curStat.size !== prevStat.size) {
              this._pendingWrites.get(path2).lastChange = now2;
            }
            const pw = this._pendingWrites.get(path2);
            const df = now2 - pw.lastChange;
            if (df >= threshold) {
              this._pendingWrites.delete(path2);
              awfEmit(void 0, curStat);
            } else {
              timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval, curStat);
            }
          });
        };
        if (!this._pendingWrites.has(path2)) {
          this._pendingWrites.set(path2, {
            lastChange: now,
            cancelWait: () => {
              this._pendingWrites.delete(path2);
              clearTimeout(timeoutHandler);
              return event;
            }
          });
          timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);
        }
      }
      _getGlobIgnored() {
        return [...this._ignoredPaths.values()];
      }
      _isIgnored(path2, stats) {
        if (this.options.atomic && DOT_RE.test(path2))
          return true;
        if (!this._userIgnored) {
          const { cwd } = this.options;
          const ign = this.options.ignored;
          const ignored = ign && ign.map(normalizeIgnored(cwd));
          const paths = arrify(ignored).filter((path3) => typeof path3 === STRING_TYPE && !isGlob(path3)).map((path3) => path3 + SLASH_GLOBSTAR);
          const list2 = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
          this._userIgnored = anymatch(list2, void 0, ANYMATCH_OPTS);
        }
        return this._userIgnored([path2, stats]);
      }
      _isntIgnored(path2, stat2) {
        return !this._isIgnored(path2, stat2);
      }
      _getWatchHelpers(path2, depth2) {
        const watchPath = depth2 || this.options.disableGlobbing || !isGlob(path2) ? path2 : globParent(path2);
        const follow = this.options.followSymlinks;
        return new WatchHelper(path2, watchPath, follow, this);
      }
      _getWatchedDir(directory) {
        if (!this._boundRemove)
          this._boundRemove = this._remove.bind(this);
        const dir = sysPath.resolve(directory);
        if (!this._watched.has(dir))
          this._watched.set(dir, new DirEntry(dir, this._boundRemove));
        return this._watched.get(dir);
      }
      _hasReadPermissions(stats) {
        if (this.options.ignorePermissionErrors)
          return true;
        const md = stats && Number.parseInt(stats.mode, 10);
        const st2 = md & 511;
        const it2 = Number.parseInt(st2.toString(8)[0], 10);
        return Boolean(4 & it2);
      }
      _remove(directory, item, isDirectory2) {
        const path2 = sysPath.join(directory, item);
        const fullPath = sysPath.resolve(path2);
        isDirectory2 = isDirectory2 != null ? isDirectory2 : this._watched.has(path2) || this._watched.has(fullPath);
        if (!this._throttle("remove", path2, 100))
          return;
        if (!isDirectory2 && !this.options.useFsEvents && this._watched.size === 1) {
          this.add(directory, item, true);
        }
        const wp = this._getWatchedDir(path2);
        const nestedDirectoryChildren = wp.getChildren();
        nestedDirectoryChildren.forEach((nested) => this._remove(path2, nested));
        const parent = this._getWatchedDir(directory);
        const wasTracked = parent.has(item);
        parent.remove(item);
        if (this._symlinkPaths.has(fullPath)) {
          this._symlinkPaths.delete(fullPath);
        }
        let relPath = path2;
        if (this.options.cwd)
          relPath = sysPath.relative(this.options.cwd, path2);
        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
          const event = this._pendingWrites.get(relPath).cancelWait();
          if (event === EV_ADD)
            return;
        }
        this._watched.delete(path2);
        this._watched.delete(fullPath);
        const eventName = isDirectory2 ? EV_UNLINK_DIR : EV_UNLINK;
        if (wasTracked && !this._isIgnored(path2))
          this._emit(eventName, path2);
        if (!this.options.useFsEvents) {
          this._closePath(path2);
        }
      }
      _closePath(path2) {
        this._closeFile(path2);
        const dir = sysPath.dirname(path2);
        this._getWatchedDir(dir).remove(sysPath.basename(path2));
      }
      _closeFile(path2) {
        const closers = this._closers.get(path2);
        if (!closers)
          return;
        closers.forEach((closer) => closer());
        this._closers.delete(path2);
      }
      _addPathCloser(path2, closer) {
        if (!closer)
          return;
        let list2 = this._closers.get(path2);
        if (!list2) {
          list2 = [];
          this._closers.set(path2, list2);
        }
        list2.push(closer);
      }
      _readdirp(root, opts) {
        if (this.closed)
          return;
        const options2 = __spreadValues2({ type: EV_ALL, alwaysStat: true, lstat: true }, opts);
        let stream2 = readdirp(root, options2);
        this._streams.add(stream2);
        stream2.once(STR_CLOSE, () => {
          stream2 = void 0;
        });
        stream2.once(STR_END, () => {
          if (stream2) {
            this._streams.delete(stream2);
            stream2 = void 0;
          }
        });
        return stream2;
      }
    };
    chokidar.FSWatcher = FSWatcher;
    var watch = (paths, options2) => {
      const watcher = new FSWatcher(options2);
      watcher.add(paths);
      return watcher;
    };
    chokidar.watch = watch;
    async function resolveHttpServer({ proxy }, app, httpsOptions) {
      if (!httpsOptions) {
        return (init_http(), http_exports).createServer(app);
      }
      if (proxy) {
        return (init_https(), https_exports).createServer(httpsOptions, app);
      } else {
        return (init_http2(), http2_exports).createSecureServer(__spreadProps2(__spreadValues2({}, httpsOptions), {
          allowHTTP1: true
        }), app);
      }
    }
    async function resolveHttpsConfig(https2, cacheDir) {
      if (!https2)
        return void 0;
      const httpsOption = isObject$3(https2) ? https2 : {};
      const { ca: ca2, cert, key, pfx } = httpsOption;
      Object.assign(httpsOption, {
        ca: readFileIfExists(ca2),
        cert: readFileIfExists(cert),
        key: readFileIfExists(key),
        pfx: readFileIfExists(pfx)
      });
      if (!httpsOption.key || !httpsOption.cert) {
        httpsOption.cert = httpsOption.key = await getCertificate(cacheDir);
      }
      return httpsOption;
    }
    function readFileIfExists(value) {
      if (typeof value === "string") {
        try {
          return fs__default.readFileSync(path__default.resolve(value));
        } catch (e2) {
          return value;
        }
      }
      return value;
    }
    async function createCertificate() {
      const { generate: generate2 } = await Promise.resolve().then(function() {
        return require_dep_5a0fbe99();
      }).then(function(n3) {
        return n3.index;
      });
      const pems = generate2(null, {
        algorithm: "sha256",
        days: 30,
        keySize: 2048,
        extensions: [
          {
            name: "keyUsage",
            keyCertSign: true,
            digitalSignature: true,
            nonRepudiation: true,
            keyEncipherment: true,
            dataEncipherment: true
          },
          {
            name: "extKeyUsage",
            serverAuth: true,
            clientAuth: true,
            codeSigning: true,
            timeStamping: true
          },
          {
            name: "subjectAltName",
            altNames: [
              {
                type: 2,
                value: "localhost"
              },
              {
                type: 2,
                value: "localhost.localdomain"
              },
              {
                type: 2,
                value: "lvh.me"
              },
              {
                type: 2,
                value: "*.lvh.me"
              },
              {
                type: 2,
                value: "[::1]"
              },
              {
                type: 7,
                ip: "127.0.0.1"
              },
              {
                type: 7,
                ip: "fe80::1"
              }
            ]
          }
        ]
      });
      return pems.private + pems.cert;
    }
    async function getCertificate(cacheDir) {
      if (!cacheDir)
        return await createCertificate();
      const cachePath = path__default.join(cacheDir, "_cert.pem");
      try {
        const [stat2, content2] = await Promise.all([
          fs$r.promises.stat(cachePath),
          fs$r.promises.readFile(cachePath, "utf8")
        ]);
        if (Date.now() - stat2.ctime.valueOf() > 30 * 24 * 60 * 60 * 1e3) {
          throw new Error("cache is outdated.");
        }
        return content2;
      } catch {
        const content2 = await createCertificate();
        fs$r.promises.mkdir(cacheDir, { recursive: true }).then(() => fs$r.promises.writeFile(cachePath, content2)).catch(() => {
        });
        return content2;
      }
    }
    async function httpServerStart(httpServer, serverOptions) {
      return new Promise((resolve2, reject) => {
        let { port, strictPort, host, logger } = serverOptions;
        const onError = (e2) => {
          if (e2.code === "EADDRINUSE") {
            if (strictPort) {
              httpServer.removeListener("error", onError);
              reject(new Error(`Port ${port} is already in use`));
            } else {
              logger.info(`Port ${port} is in use, trying another one...`);
              httpServer.listen(++port, host);
            }
          } else {
            httpServer.removeListener("error", onError);
            reject(e2);
          }
        };
        httpServer.on("error", onError);
        httpServer.listen(port, host, () => {
          httpServer.removeListener("error", onError);
          resolve2(port);
        });
      });
    }
    var bufferUtil$1 = { exports: {} };
    var constants = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
    var { EMPTY_BUFFER: EMPTY_BUFFER$3 } = constants;
    function concat$1(list2, totalLength) {
      if (list2.length === 0)
        return EMPTY_BUFFER$3;
      if (list2.length === 1)
        return list2[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset2 = 0;
      for (let i2 = 0; i2 < list2.length; i2++) {
        const buf = list2[i2];
        target.set(buf, offset2);
        offset2 += buf.length;
      }
      if (offset2 < totalLength)
        return target.slice(0, offset2);
      return target;
    }
    function _mask(source2, mask2, output, offset2, length) {
      for (let i2 = 0; i2 < length; i2++) {
        output[offset2 + i2] = source2[i2] ^ mask2[i2 & 3];
      }
    }
    function _unmask(buffer, mask2) {
      for (let i2 = 0; i2 < buffer.length; i2++) {
        buffer[i2] ^= mask2[i2 & 3];
      }
    }
    function toArrayBuffer$1(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer$3(data2) {
      toBuffer$3.readOnly = true;
      if (Buffer.isBuffer(data2))
        return data2;
      let buf;
      if (data2 instanceof ArrayBuffer) {
        buf = Buffer.from(data2);
      } else if (ArrayBuffer.isView(data2)) {
        buf = Buffer.from(data2.buffer, data2.byteOffset, data2.byteLength);
      } else {
        buf = Buffer.from(data2);
        toBuffer$3.readOnly = false;
      }
      return buf;
    }
    try {
      const bufferUtil2 = __require("bufferutil");
      bufferUtil$1.exports = {
        concat: concat$1,
        mask(source2, mask2, output, offset2, length) {
          if (length < 48)
            _mask(source2, mask2, output, offset2, length);
          else
            bufferUtil2.mask(source2, mask2, output, offset2, length);
        },
        toArrayBuffer: toArrayBuffer$1,
        toBuffer: toBuffer$3,
        unmask(buffer, mask2) {
          if (buffer.length < 32)
            _unmask(buffer, mask2);
          else
            bufferUtil2.unmask(buffer, mask2);
        }
      };
    } catch (e2) {
      bufferUtil$1.exports = {
        concat: concat$1,
        mask: _mask,
        toArrayBuffer: toArrayBuffer$1,
        toBuffer: toBuffer$3,
        unmask: _unmask
      };
    }
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter$1 = class {
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    var limiter = Limiter$1;
    var zlib$1 = require$$0__default$6;
    var bufferUtil = bufferUtil$1.exports;
    var Limiter = limiter;
    var { kStatusCode: kStatusCode$2 } = constants;
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError$1 = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate$4 = class {
      constructor(options2, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options2 || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(new Error("The deflate stream was closed while data was being processed"));
          }
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      decompress(data2, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data2, fin, (err, result2) => {
            done();
            callback(err, result2);
          });
        });
      }
      compress(data2, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data2, fin, (err, result2) => {
            done();
            callback(err, result2);
          });
        });
      }
      _decompress(data2, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib$1.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib$1.createInflateRaw(__spreadProps2(__spreadValues2({}, this._options.zlibInflateOptions), {
            windowBits
          }));
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data2);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError$1];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data3 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data3);
        });
      }
      _compress(data2, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib$1.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib$1.createDeflateRaw(__spreadProps2(__spreadValues2({}, this._options.zlibDeflateOptions), {
            windowBits
          }));
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data2);
        this._deflate.flush(zlib$1.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data3 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
          if (fin)
            data3 = data3.slice(0, data3.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data3);
        });
      }
    };
    var permessageDeflate = PerMessageDeflate$4;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError$1] = new RangeError("Max payload size exceeded");
      this[kError$1].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError$1][kStatusCode$2] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode$2] = 1007;
      this[kCallback](err);
    }
    var validation = { exports: {} };
    var tokenChars$2 = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function isValidStatusCode$2(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i2 = 0;
      while (i2 < len) {
        if ((buf[i2] & 128) === 0) {
          i2++;
        } else if ((buf[i2] & 224) === 192) {
          if (i2 + 1 === len || (buf[i2 + 1] & 192) !== 128 || (buf[i2] & 254) === 192) {
            return false;
          }
          i2 += 2;
        } else if ((buf[i2] & 240) === 224) {
          if (i2 + 2 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || buf[i2] === 224 && (buf[i2 + 1] & 224) === 128 || buf[i2] === 237 && (buf[i2 + 1] & 224) === 160) {
            return false;
          }
          i2 += 3;
        } else if ((buf[i2] & 248) === 240) {
          if (i2 + 3 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || (buf[i2 + 3] & 192) !== 128 || buf[i2] === 240 && (buf[i2 + 1] & 240) === 128 || buf[i2] === 244 && buf[i2 + 1] > 143 || buf[i2] > 244) {
            return false;
          }
          i2 += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      const isValidUTF82 = __require("utf-8-validate");
      validation.exports = {
        isValidStatusCode: isValidStatusCode$2,
        isValidUTF8(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF82(buf);
        },
        tokenChars: tokenChars$2
      };
    } catch (e2) {
      validation.exports = {
        isValidStatusCode: isValidStatusCode$2,
        isValidUTF8: _isValidUTF8,
        tokenChars: tokenChars$2
      };
    }
    var { Writable: Writable$1 } = require$$0__default$3;
    var PerMessageDeflate$3 = permessageDeflate;
    var {
      BINARY_TYPES: BINARY_TYPES$1,
      EMPTY_BUFFER: EMPTY_BUFFER$2,
      kStatusCode: kStatusCode$1,
      kWebSocket: kWebSocket$2
    } = constants;
    var { concat, toArrayBuffer, unmask } = bufferUtil$1.exports;
    var { isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = validation.exports;
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver$1 = class extends Writable$1 {
      constructor(options2 = {}) {
        super();
        this._binaryType = options2.binaryType || BINARY_TYPES$1[0];
        this._extensions = options2.extensions || {};
        this._isServer = !!options2.isServer;
        this._maxPayload = options2.maxPayload | 0;
        this._skipUTF8Validation = !!options2.skipUTF8Validation;
        this[kWebSocket$2] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      _write(chunk, encoding2, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n3) {
        this._bufferedBytes -= n3;
        if (n3 === this._buffers[0].length)
          return this._buffers.shift();
        if (n3 < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n3);
          return buf.slice(0, n3);
        }
        const dst = Buffer.allocUnsafe(n3);
        do {
          const buf = this._buffers[0];
          const offset2 = dst.length - n3;
          if (n3 >= buf.length) {
            dst.set(this._buffers.shift(), offset2);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n3), offset2);
            this._buffers[0] = buf.slice(n3);
          }
          n3 -= buf.length;
        } while (n3 > 0);
        return dst;
      }
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error$2(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {
          this._loop = false;
          return error$2(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error$2(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (!this._fragmented) {
            this._loop = false;
            return error$2(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error$2(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error$2(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          }
          if (compressed) {
            this._loop = false;
            return error$2(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error$2(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          }
        } else {
          this._loop = false;
          return error$2(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error$2(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          }
        } else if (this._masked) {
          this._loop = false;
          return error$2(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error$2(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error$2(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        let data2 = EMPTY_BUFFER$2;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data2 = this.consume(this._payloadLength);
          if (this._masked)
            unmask(data2, this._mask);
        }
        if (this._opcode > 7)
          return this.controlMessage(data2);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data2, cb);
          return;
        }
        if (data2.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data2);
        }
        return this.dataMessage();
      }
      decompress(data2, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];
        perMessageDeflate.decompress(data2, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(error$2(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
            }
            this._fragments.push(buf);
          }
          const er2 = this.dataMessage();
          if (er2)
            return cb(er2);
          this.startLoop(cb);
        });
      }
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data2;
            if (this._binaryType === "nodebuffer") {
              data2 = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data2 = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data2 = fragments;
            }
            this.emit("message", data2, true);
          } else {
            const buf = concat(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              this._loop = false;
              return error$2(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("message", buf, false);
          }
        }
        this._state = GET_INFO;
      }
      controlMessage(data2) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data2.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER$2);
            this.end();
          } else if (data2.length === 1) {
            return error$2(RangeError, "invalid payload length 1", true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          } else {
            const code = data2.readUInt16BE(0);
            if (!isValidStatusCode$1(code)) {
              return error$2(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            }
            const buf = data2.slice(2);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              return error$2(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("conclude", code, buf);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data2);
        } else {
          this.emit("pong", data2);
        }
        this._state = GET_INFO;
      }
    };
    var receiver = Receiver$1;
    function error$2(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, error$2);
      err.code = errorCode;
      err[kStatusCode$1] = statusCode;
      return err;
    }
    var { randomFillSync } = require$$1__default$3;
    var PerMessageDeflate$2 = permessageDeflate;
    var { EMPTY_BUFFER: EMPTY_BUFFER$1 } = constants;
    var { isValidStatusCode } = validation.exports;
    var { mask: applyMask, toBuffer: toBuffer$2 } = bufferUtil$1.exports;
    var mask = Buffer.alloc(4);
    var Sender$1 = class {
      constructor(socket, extensions2) {
        this._extensions = extensions2 || {};
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      static frame(data2, options2) {
        const merge3 = options2.mask && options2.readOnly;
        let offset2 = options2.mask ? 6 : 2;
        let payloadLength = data2.length;
        if (data2.length >= 65536) {
          offset2 += 8;
          payloadLength = 127;
        } else if (data2.length > 125) {
          offset2 += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge3 ? data2.length + offset2 : offset2);
        target[0] = options2.fin ? options2.opcode | 128 : options2.opcode;
        if (options2.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(data2.length, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(data2.length, 4, 6);
        }
        if (!options2.mask)
          return [target, data2];
        randomFillSync(mask, 0, 4);
        target[1] |= 128;
        target[offset2 - 4] = mask[0];
        target[offset2 - 3] = mask[1];
        target[offset2 - 2] = mask[2];
        target[offset2 - 1] = mask[3];
        if (merge3) {
          applyMask(data2, mask, target, offset2, data2.length);
          return [target];
        }
        applyMask(data2, mask, data2, 0, data2.length);
        return [target, data2];
      }
      close(code, data2, mask2, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER$1;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data2 === void 0 || !data2.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data2);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data2 === "string") {
            buf.write(data2, 2);
          } else {
            buf.set(data2, 2);
          }
        }
        if (this._deflating) {
          this.enqueue([this.doClose, buf, mask2, cb]);
        } else {
          this.doClose(buf, mask2, cb);
        }
      }
      doClose(data2, mask2, cb) {
        this.sendFrame(Sender$1.frame(data2, {
          fin: true,
          rsv1: false,
          opcode: 8,
          mask: mask2,
          readOnly: false
        }), cb);
      }
      ping(data2, mask2, cb) {
        const buf = toBuffer$2(data2);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPing, buf, mask2, toBuffer$2.readOnly, cb]);
        } else {
          this.doPing(buf, mask2, toBuffer$2.readOnly, cb);
        }
      }
      doPing(data2, mask2, readOnly, cb) {
        this.sendFrame(Sender$1.frame(data2, {
          fin: true,
          rsv1: false,
          opcode: 9,
          mask: mask2,
          readOnly
        }), cb);
      }
      pong(data2, mask2, cb) {
        const buf = toBuffer$2(data2);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPong, buf, mask2, toBuffer$2.readOnly, cb]);
        } else {
          this.doPong(buf, mask2, toBuffer$2.readOnly, cb);
        }
      }
      doPong(data2, mask2, readOnly, cb) {
        this.sendFrame(Sender$1.frame(data2, {
          fin: true,
          rsv1: false,
          opcode: 10,
          mask: mask2,
          readOnly
        }), cb);
      }
      send(data2, options2, cb) {
        const buf = toBuffer$2(data2);
        const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
        let opcode = options2.binary ? 2 : 1;
        let rsv1 = options2.compress;
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = buf.length >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options2.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            fin: options2.fin,
            rsv1,
            opcode,
            mask: options2.mask,
            readOnly: toBuffer$2.readOnly
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
          } else {
            this.dispatch(buf, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(Sender$1.frame(buf, {
            fin: options2.fin,
            rsv1: false,
            opcode,
            mask: options2.mask,
            readOnly: toBuffer$2.readOnly
          }), cb);
        }
      }
      dispatch(data2, compress, options2, cb) {
        if (!compress) {
          this.sendFrame(Sender$1.frame(data2, options2), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
        this._bufferedBytes += data2.length;
        this._deflating = true;
        perMessageDeflate.compress(data2, options2.fin, (_2, buf) => {
          if (this._socket.destroyed) {
            const err = new Error("The socket was closed while data was being compressed");
            if (typeof cb === "function")
              cb(err);
            for (let i2 = 0; i2 < this._queue.length; i2++) {
              const callback = this._queue[i2][4];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= data2.length;
          this._deflating = false;
          options2.readOnly = false;
          this.sendFrame(Sender$1.frame(buf, options2), cb);
          this.dequeue();
        });
      }
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[1].length;
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[1].length;
        this._queue.push(params);
      }
      sendFrame(list2, cb) {
        if (list2.length === 2) {
          this._socket.cork();
          this._socket.write(list2[0]);
          this._socket.write(list2[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list2[0], cb);
        }
      }
    };
    var sender = Sender$1;
    var { kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = constants;
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      get target() {
        return this[kTarget];
      }
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      constructor(type, options2 = {}) {
        super(type);
        this[kCode] = options2.code === void 0 ? 0 : options2.code;
        this[kReason] = options2.reason === void 0 ? "" : options2.reason;
        this[kWasClean] = options2.wasClean === void 0 ? false : options2.wasClean;
      }
      get code() {
        return this[kCode];
      }
      get reason() {
        return this[kReason];
      }
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      constructor(type, options2 = {}) {
        super(type);
        this[kError] = options2.error === void 0 ? null : options2.error;
        this[kMessage] = options2.message === void 0 ? "" : options2.message;
      }
      get error() {
        return this[kError];
      }
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      constructor(type, options2 = {}) {
        super(type);
        this[kData] = options2.data === void 0 ? null : options2.data;
      }
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      addEventListener(type, listener2, options2 = {}) {
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data2, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data2 : data2.toString()
            });
            event[kTarget] = this;
            listener2.call(this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            listener2.call(this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error2) {
            const event = new ErrorEvent("error", {
              error: error2,
              message: error2.message
            });
            event[kTarget] = this;
            listener2.call(this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            listener2.call(this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute$1] = !!options2[kForOnEventAttribute$1];
        wrapper[kListener$1] = listener2;
        if (options2.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      removeEventListener(type, handler) {
        for (const listener2 of this.listeners(type)) {
          if (listener2[kListener$1] === handler && !listener2[kForOnEventAttribute$1]) {
            this.removeListener(type, listener2);
            break;
          }
        }
      }
    };
    var eventTarget = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    var { tokenChars: tokenChars$1 } = validation.exports;
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse$8(header) {
      const offers = Object.create(null);
      let params = Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i2 = 0;
      for (; i2 < header.length; i2++) {
        code = header.charCodeAt(i2);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars$1[code] === 1) {
            if (start === -1)
              start = i2;
          } else if (i2 !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i2;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1)
              end = i2;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars$1[code] === 1) {
            if (start === -1)
              start = i2;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i2;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1)
              end = i2;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i2);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars$1[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (start === -1)
              start = i2;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars$1[code] === 1) {
              if (start === -1)
                start = i2;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i2;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
          } else if (code === 34 && header.charCodeAt(i2 - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars$1[code] === 1) {
            if (start === -1)
              start = i2;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i2;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i2}`);
            }
            if (end === -1)
              end = i2;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i2;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format$2(extensions2) {
      return Object.keys(extensions2).map((extension2) => {
        let configurations = extensions2[extension2];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension2].concat(Object.keys(params).map((k2) => {
            let values = params[k2];
            if (!Array.isArray(values))
              values = [values];
            return values.map((v2) => v2 === true ? k2 : `${k2}=${v2}`).join("; ");
          })).join("; ");
        }).join(", ");
      }).join(", ");
    }
    var extension$1 = { format: format$2, parse: parse$8 };
    var EventEmitter$1 = require$$0__default$4;
    var https$2 = require$$1__default$4;
    var http$3 = require$$1__default$2;
    var net = require$$3__default;
    var tls = require$$4__default;
    var { randomBytes, createHash: createHash$1 } = require$$1__default$3;
    var { URL: URL$2 } = require$$0__default$5;
    var PerMessageDeflate$1 = permessageDeflate;
    var Receiver = receiver;
    var Sender = sender;
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID: GUID$1,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket: kWebSocket$1,
      NOOP
    } = constants;
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = eventTarget;
    var { format: format$1, parse: parse$7 } = extension$1;
    var { toBuffer: toBuffer$1 } = bufferUtil$1.exports;
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket$1 = class extends EventEmitter$1 {
      constructor(address, protocols, options2) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = WebSocket$1.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options2 = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options2);
        } else {
          this._isServer = true;
        }
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      get isPaused() {
        return this._paused;
      }
      get onclose() {
        return null;
      }
      get onerror() {
        return null;
      }
      get onopen() {
        return null;
      }
      get onmessage() {
        return null;
      }
      get protocol() {
        return this._protocol;
      }
      get readyState() {
        return this._readyState;
      }
      get url() {
        return this._url;
      }
      setSocket(socket, head, options2) {
        const receiver2 = new Receiver({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options2.maxPayload,
          skipUTF8Validation: options2.skipUTF8Validation
        });
        this._sender = new Sender(socket, this._extensions);
        this._receiver = receiver2;
        this._socket = socket;
        receiver2[kWebSocket$1] = this;
        socket[kWebSocket$1] = this;
        receiver2.on("conclude", receiverOnConclude);
        receiver2.on("drain", receiverOnDrain);
        receiver2.on("error", receiverOnError);
        receiver2.on("message", receiverOnMessage);
        receiver2.on("ping", receiverOnPing);
        receiver2.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError$1);
        this._readyState = WebSocket$1.OPEN;
        this.emit("open");
      }
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket$1.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate$1.extensionName]) {
          this._extensions[PerMessageDeflate$1.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket$1.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data2) {
        if (this.readyState === WebSocket$1.CLOSED)
          return;
        if (this.readyState === WebSocket$1.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake$1(this, this._req, msg);
        }
        if (this.readyState === WebSocket$1.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket$1.CLOSING;
        this._sender.close(code, data2, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
      }
      pause() {
        if (this.readyState === WebSocket$1.CONNECTING || this.readyState === WebSocket$1.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      ping(data2, mask2, cb) {
        if (this.readyState === WebSocket$1.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data2 === "function") {
          cb = data2;
          data2 = mask2 = void 0;
        } else if (typeof mask2 === "function") {
          cb = mask2;
          mask2 = void 0;
        }
        if (typeof data2 === "number")
          data2 = data2.toString();
        if (this.readyState !== WebSocket$1.OPEN) {
          sendAfterClose(this, data2, cb);
          return;
        }
        if (mask2 === void 0)
          mask2 = !this._isServer;
        this._sender.ping(data2 || EMPTY_BUFFER, mask2, cb);
      }
      pong(data2, mask2, cb) {
        if (this.readyState === WebSocket$1.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data2 === "function") {
          cb = data2;
          data2 = mask2 = void 0;
        } else if (typeof mask2 === "function") {
          cb = mask2;
          mask2 = void 0;
        }
        if (typeof data2 === "number")
          data2 = data2.toString();
        if (this.readyState !== WebSocket$1.OPEN) {
          sendAfterClose(this, data2, cb);
          return;
        }
        if (mask2 === void 0)
          mask2 = !this._isServer;
        this._sender.pong(data2 || EMPTY_BUFFER, mask2, cb);
      }
      resume() {
        if (this.readyState === WebSocket$1.CONNECTING || this.readyState === WebSocket$1.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      send(data2, options2, cb) {
        if (this.readyState === WebSocket$1.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options2 === "function") {
          cb = options2;
          options2 = {};
        }
        if (typeof data2 === "number")
          data2 = data2.toString();
        if (this.readyState !== WebSocket$1.OPEN) {
          sendAfterClose(this, data2, cb);
          return;
        }
        const opts = __spreadValues2({
          binary: typeof data2 !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true
        }, options2);
        if (!this._extensions[PerMessageDeflate$1.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data2 || EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket$1.CLOSED)
          return;
        if (this.readyState === WebSocket$1.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake$1(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = WebSocket$1.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket$1, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket$1.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket$1, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket$1.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket$1, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket$1.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket$1, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket$1.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket$1.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket$1.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener2 of this.listeners(method)) {
            if (listener2[kForOnEventAttribute])
              return listener2[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener2 of this.listeners(method)) {
            if (listener2[kForOnEventAttribute]) {
              this.removeListener(method, listener2);
              break;
            }
          }
          if (typeof handler !== "function")
            return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket$1.prototype.addEventListener = addEventListener;
    WebSocket$1.prototype.removeEventListener = removeEventListener;
    var websocket = WebSocket$1;
    function initAsClient(websocket2, address, protocols, options2) {
      const opts = __spreadProps2(__spreadValues2({
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10
      }, options2), {
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      });
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
      }
      let parsedUrl;
      if (address instanceof URL$2) {
        parsedUrl = address;
        websocket2._url = address.href;
      } else {
        try {
          parsedUrl = new URL$2(address);
        } catch (e2) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
        websocket2._url = address;
      }
      const isSecure = parsedUrl.protocol === "wss:";
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      let invalidURLMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isUnixSocket) {
        invalidURLMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
      } else if (isUnixSocket && !parsedUrl.pathname) {
        invalidURLMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidURLMessage = "The URL contains a fragment identifier";
      }
      if (invalidURLMessage) {
        const err = new SyntaxError(invalidURLMessage);
        if (websocket2._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket2, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const get = isSecure ? https$2.get : http$3.get;
      const protocolSet = new Set();
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = __spreadValues2({
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      }, opts.headers);
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate$1(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
        opts.headers["Sec-WebSocket-Extensions"] = format$1({
          [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError("An invalid or duplicated subprotocol was specified");
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req2 = websocket2._req = get(opts);
      if (opts.timeout) {
        req2.on("timeout", () => {
          abortHandshake$1(websocket2, req2, "Opening handshake has timed out");
        });
      }
      req2.on("error", (err) => {
        if (req2 === null || req2.aborted)
          return;
        req2 = websocket2._req = null;
        emitErrorAndClose(websocket2, err);
      });
      req2.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket2._redirects > opts.maxRedirects) {
            abortHandshake$1(websocket2, req2, "Maximum redirects exceeded");
            return;
          }
          req2.abort();
          let addr;
          try {
            addr = new URL$2(location, address);
          } catch (e2) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket2, err);
            return;
          }
          initAsClient(websocket2, addr, protocols, options2);
        } else if (!websocket2.emit("unexpected-response", req2, res)) {
          abortHandshake$1(websocket2, req2, `Unexpected server response: ${res.statusCode}`);
        }
      });
      req2.on("upgrade", (res, socket, head) => {
        websocket2.emit("upgrade", res);
        if (websocket2.readyState !== WebSocket$1.CONNECTING)
          return;
        req2 = websocket2._req = null;
        const digest = createHash$1("sha1").update(key + GUID$1).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake$1(websocket2, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake$1(websocket2, socket, protError);
          return;
        }
        if (serverProt)
          websocket2._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake$1(websocket2, socket, message);
            return;
          }
          let extensions2;
          try {
            extensions2 = parse$7(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake$1(websocket2, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions2);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake$1(websocket2, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions2[PerMessageDeflate$1.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake$1(websocket2, socket, message);
            return;
          }
          websocket2._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;
        }
        websocket2.setSocket(socket, head, {
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
    }
    function emitErrorAndClose(websocket2, err) {
      websocket2._readyState = WebSocket$1.CLOSING;
      websocket2.emit("error", err);
      websocket2.emitClose();
    }
    function netConnect(options2) {
      options2.path = options2.socketPath;
      return net.connect(options2);
    }
    function tlsConnect(options2) {
      options2.path = void 0;
      if (!options2.servername && options2.servername !== "") {
        options2.servername = net.isIP(options2.host) ? "" : options2.host;
      }
      return tls.connect(options2);
    }
    function abortHandshake$1(websocket2, stream2, message) {
      websocket2._readyState = WebSocket$1.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake$1);
      if (stream2.setHeader) {
        stream2.abort();
        if (stream2.socket && !stream2.socket.destroyed) {
          stream2.socket.destroy();
        }
        stream2.once("abort", websocket2.emitClose.bind(websocket2));
        websocket2.emit("error", err);
      } else {
        stream2.destroy(err);
        stream2.once("error", websocket2.emit.bind(websocket2, "error"));
        stream2.once("close", websocket2.emitClose.bind(websocket2));
      }
    }
    function sendAfterClose(websocket2, data2, cb) {
      if (data2) {
        const length = toBuffer$1(data2).length;
        if (websocket2._socket)
          websocket2._sender._bufferedBytes += length;
        else
          websocket2._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(`WebSocket is not open: readyState ${websocket2.readyState} (${readyStates[websocket2.readyState]})`);
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket2 = this[kWebSocket$1];
      websocket2._closeFrameReceived = true;
      websocket2._closeMessage = reason;
      websocket2._closeCode = code;
      if (websocket2._socket[kWebSocket$1] === void 0)
        return;
      websocket2._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket2._socket);
      if (code === 1005)
        websocket2.close();
      else
        websocket2.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket2 = this[kWebSocket$1];
      if (!websocket2.isPaused)
        websocket2._socket.resume();
    }
    function receiverOnError(err) {
      const websocket2 = this[kWebSocket$1];
      if (websocket2._socket[kWebSocket$1] !== void 0) {
        websocket2._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket2._socket);
        websocket2.close(err[kStatusCode]);
      }
      websocket2.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket$1].emitClose();
    }
    function receiverOnMessage(data2, isBinary) {
      this[kWebSocket$1].emit("message", data2, isBinary);
    }
    function receiverOnPing(data2) {
      const websocket2 = this[kWebSocket$1];
      websocket2.pong(data2, !websocket2._isServer, NOOP);
      websocket2.emit("ping", data2);
    }
    function receiverOnPong(data2) {
      this[kWebSocket$1].emit("pong", data2);
    }
    function resume(stream2) {
      stream2.resume();
    }
    function socketOnClose() {
      const websocket2 = this[kWebSocket$1];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket2._readyState = WebSocket$1.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket2._closeFrameReceived && !websocket2._receiver._writableState.errorEmitted && (chunk = websocket2._socket.read()) !== null) {
        websocket2._receiver.write(chunk);
      }
      websocket2._receiver.end();
      this[kWebSocket$1] = void 0;
      clearTimeout(websocket2._closeTimer);
      if (websocket2._receiver._writableState.finished || websocket2._receiver._writableState.errorEmitted) {
        websocket2.emitClose();
      } else {
        websocket2._receiver.on("error", receiverOnFinish);
        websocket2._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket$1]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket2 = this[kWebSocket$1];
      websocket2._readyState = WebSocket$1.CLOSING;
      websocket2._receiver.end();
      this.end();
    }
    function socketOnError$1() {
      const websocket2 = this[kWebSocket$1];
      this.removeListener("error", socketOnError$1);
      this.on("error", NOOP);
      if (websocket2) {
        websocket2._readyState = WebSocket$1.CLOSING;
        this.destroy();
      }
    }
    var { tokenChars } = validation.exports;
    function parse$6(header) {
      const protocols = new Set();
      let start = -1;
      let end = -1;
      let i2 = 0;
      for (i2; i2 < header.length; i2++) {
        const code = header.charCodeAt(i2);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i2;
        } else if (i2 !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i2;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i2}`);
          }
          if (end === -1)
            end = i2;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i2);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    var subprotocol$1 = { parse: parse$6 };
    var EventEmitter = require$$0__default$4;
    var http$2 = require$$1__default$2;
    var { createHash } = require$$1__default$3;
    var extension = extension$1;
    var PerMessageDeflate = permessageDeflate;
    var subprotocol = subprotocol$1;
    var WebSocket = websocket;
    var { GUID, kWebSocket } = constants;
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      constructor(options2, callback) {
        super();
        options2 = __spreadValues2({
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null
        }, options2);
        if (options2.port == null && !options2.server && !options2.noServer || options2.port != null && (options2.server || options2.noServer) || options2.server && options2.noServer) {
          throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
        }
        if (options2.port != null) {
          this._server = http$2.createServer((req2, res) => {
            const body = http$2.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(options2.port, options2.host, options2.backlog, callback);
        } else if (options2.server) {
          this._server = options2.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners$1(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req2, socket, head) => {
              this.handleUpgrade(req2, socket, head, emitConnection);
            }
          });
        }
        if (options2.perMessageDeflate === true)
          options2.perMessageDeflate = {};
        if (options2.clientTracking) {
          this.clients = new Set();
          this._shouldEmitClose = false;
        }
        this.options = options2;
        this._state = RUNNING;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server2 = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server2.close(() => {
            emitClose(this);
          });
        }
      }
      shouldHandle(req2) {
        if (this.options.path) {
          const index2 = req2.url.indexOf("?");
          const pathname = index2 !== -1 ? req2.url.slice(0, index2) : req2.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      handleUpgrade(req2, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req2.headers["sec-websocket-key"] !== void 0 ? req2.headers["sec-websocket-key"] : false;
        const version2 = +req2.headers["sec-websocket-version"];
        if (req2.method !== "GET" || req2.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version2 !== 8 && version2 !== 13 || !this.shouldHandle(req2)) {
          return abortHandshake(socket, 400);
        }
        const secWebSocketProtocol = req2.headers["sec-websocket-protocol"];
        let protocols = new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        const secWebSocketExtensions = req2.headers["sec-websocket-extensions"];
        const extensions2 = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions2[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req2.headers[`${version2 === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req2.socket.authorized || req2.socket.encrypted),
            req: req2
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(extensions2, key, protocols, req2, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions2, key, protocols, req2, socket, head, cb);
      }
      completeUpgrade(extensions2, key, protocols, req2, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws2 = new WebSocket(null);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req2) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws2._protocol = protocol;
          }
        }
        if (extensions2[PerMessageDeflate.extensionName]) {
          const params = extensions2[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws2._extensions = extensions2;
        }
        this.emit("headers", headers, req2);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws2.setSocket(socket, head, {
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws2);
          ws2.on("close", () => {
            this.clients.delete(ws2);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws2, req2);
      }
    };
    var websocketServer = WebSocketServer;
    function addListeners$1(server2, map2) {
      for (const event of Object.keys(map2))
        server2.on(event, map2[event]);
      return function removeListeners() {
        for (const event of Object.keys(map2)) {
          server2.removeListener(event, map2[event]);
        }
      };
    }
    function emitClose(server2) {
      server2._state = CLOSED;
      server2.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || http$2.STATUS_CODES[code];
        headers = __spreadValues2({
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message)
        }, headers);
        socket.write(`HTTP/1.1 ${code} ${http$2.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h3) => `${h3}: ${headers[h3]}`).join("\r\n") + "\r\n\r\n" + message);
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
    var HMR_HEADER = "vite-hmr";
    function createWebSocketServer(server2, config2, httpsOptions) {
      let wss;
      let httpsServer = void 0;
      const hmr = isObject$3(config2.server.hmr) && config2.server.hmr;
      const wsServer = hmr && hmr.server || server2;
      if (wsServer) {
        wss = new websocketServer({ noServer: true });
        wsServer.on("upgrade", (req2, socket, head) => {
          if (req2.headers["sec-websocket-protocol"] === HMR_HEADER) {
            wss.handleUpgrade(req2, socket, head, (ws2) => {
              wss.emit("connection", ws2, req2);
            });
          }
        });
      } else {
        const websocketServerOptions = {};
        const port = hmr && hmr.port || 24678;
        if (httpsOptions) {
          httpsServer = require$$1$4.createServer(httpsOptions, (req2, res) => {
            const statusCode = 426;
            const body = require$$1$3.STATUS_CODES[statusCode];
            if (!body)
              throw new Error(`No body text found for the ${statusCode} status code`);
            res.writeHead(statusCode, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          httpsServer.listen(port);
          websocketServerOptions.server = httpsServer;
        } else {
          websocketServerOptions.port = port;
        }
        wss = new websocketServer(websocketServerOptions);
      }
      wss.on("connection", (socket) => {
        socket.send(JSON.stringify({ type: "connected" }));
        if (bufferedError) {
          socket.send(JSON.stringify(bufferedError));
          bufferedError = null;
        }
      });
      wss.on("error", (e2) => {
        if (e2.code !== "EADDRINUSE") {
          config2.logger.error(source.red(`WebSocket server error:
${e2.stack || e2.message}`), { error: e2 });
        }
      });
      let bufferedError = null;
      return {
        on: wss.on.bind(wss),
        off: wss.off.bind(wss),
        send(payload) {
          if (payload.type === "error" && !wss.clients.size) {
            bufferedError = payload;
            return;
          }
          const stringified = JSON.stringify(payload);
          wss.clients.forEach((client) => {
            if (client.readyState === 1) {
              client.send(stringified);
            }
          });
        },
        close() {
          return new Promise((resolve2, reject) => {
            wss.clients.forEach((client) => {
              client.terminate();
            });
            wss.close((err) => {
              if (err) {
                reject(err);
              } else {
                if (httpsServer) {
                  httpsServer.close((err2) => {
                    if (err2) {
                      reject(err2);
                    } else {
                      resolve2();
                    }
                  });
                } else {
                  resolve2();
                }
              }
            });
          });
        }
      };
    }
    function baseMiddleware({ config: config2 }) {
      const base2 = config2.base;
      return function viteBaseMiddleware(req2, res, next) {
        var _a2;
        const url2 = req2.url;
        const parsed = require$$0$6.parse(url2);
        const path2 = parsed.pathname || "/";
        if (path2.startsWith(base2)) {
          req2.url = url2.replace(base2, "/");
          return next();
        }
        if (config2.server.middlewareMode) {
          return next();
        }
        if (path2 === "/" || path2 === "/index.html") {
          res.writeHead(302, {
            Location: base2
          });
          res.end();
          return;
        } else if ((_a2 = req2.headers.accept) === null || _a2 === void 0 ? void 0 : _a2.includes("text/html")) {
          const redirectPath = base2 + url2.slice(1);
          res.writeHead(404, {
            "Content-Type": "text/html"
          });
          res.end(`The server is configured with a public base URL of ${base2} - did you mean to visit <a href="${redirectPath}">${redirectPath}</a> instead?`);
          return;
        }
        next();
      };
    }
    var httpProxy$2 = { exports: {} };
    var eventemitter3 = { exports: {} };
    (function(module2) {
      var has2 = Object.prototype.hasOwnProperty, prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE2(fn2, context2, once2) {
        this.fn = fn2;
        this.context = context2;
        this.once = once2 || false;
      }
      function addListener(emitter2, event, fn2, context2, once2) {
        if (typeof fn2 !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener2 = new EE2(fn2, context2 || emitter2, once2), evt = prefix ? prefix + event : event;
        if (!emitter2._events[evt])
          emitter2._events[evt] = listener2, emitter2._eventsCount++;
        else if (!emitter2._events[evt].fn)
          emitter2._events[evt].push(listener2);
        else
          emitter2._events[evt] = [emitter2._events[evt], listener2];
        return emitter2;
      }
      function clearEvent(emitter2, evt) {
        if (--emitter2._eventsCount === 0)
          emitter2._events = new Events();
        else
          delete emitter2._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events2, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events2 = this._events) {
          if (has2.call(events2, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events2));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i2 = 0, l2 = handlers.length, ee2 = new Array(l2); i2 < l2; i2++) {
          ee2[i2] = handlers[i2].fn;
        }
        return ee2;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i2;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
            args[i2 - 1] = arguments[i2];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j2;
          for (i2 = 0; i2 < length; i2++) {
            if (listeners[i2].once)
              this.removeListener(event, listeners[i2].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i2].fn.call(listeners[i2].context);
                break;
              case 2:
                listeners[i2].fn.call(listeners[i2].context, a1);
                break;
              case 3:
                listeners[i2].fn.call(listeners[i2].context, a1, a2);
                break;
              case 4:
                listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
                break;
              default:
                if (!args)
                  for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                    args[j2 - 1] = arguments[j2];
                  }
                listeners[i2].fn.apply(listeners[i2].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on2(event, fn2, context2) {
        return addListener(this, event, fn2, context2, false);
      };
      EventEmitter2.prototype.once = function once2(event, fn2, context2) {
        return addListener(this, event, fn2, context2, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn2, context2, once2) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn2) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn2 && (!once2 || listeners.once) && (!context2 || listeners.context === context2)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i2 = 0, events2 = [], length = listeners.length; i2 < length; i2++) {
            if (listeners[i2].fn !== fn2 || once2 && !listeners[i2].once || context2 && listeners[i2].context !== context2) {
              events2.push(listeners[i2]);
            }
          }
          if (events2.length)
            this._events[evt] = events2.length === 1 ? events2[0] : events2;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      {
        module2.exports = EventEmitter2;
      }
    })(eventemitter3);
    var common$3 = {};
    var requiresPort = function required(port, protocol) {
      protocol = protocol.split(":")[0];
      port = +port;
      if (!port)
        return false;
      switch (protocol) {
        case "http":
        case "ws":
          return port !== 80;
        case "https":
        case "wss":
          return port !== 443;
        case "ftp":
          return port !== 21;
        case "gopher":
          return port !== 70;
        case "file":
          return false;
      }
      return port !== 0;
    };
    (function(exports2) {
      var common2 = exports2, url2 = require$$0__default$5, extend2 = require$$0__default$2._extend, required = requiresPort;
      var upgradeHeader = /(^|,)\s*upgrade\s*($|,)/i, isSSL = /^https|wss/;
      common2.isSSL = isSSL;
      common2.setupOutgoing = function(outgoing, options2, req2, forward) {
        outgoing.port = options2[forward || "target"].port || (isSSL.test(options2[forward || "target"].protocol) ? 443 : 80);
        [
          "host",
          "hostname",
          "socketPath",
          "pfx",
          "key",
          "passphrase",
          "cert",
          "ca",
          "ciphers",
          "secureProtocol"
        ].forEach(function(e2) {
          outgoing[e2] = options2[forward || "target"][e2];
        });
        outgoing.method = options2.method || req2.method;
        outgoing.headers = extend2({}, req2.headers);
        if (options2.headers) {
          extend2(outgoing.headers, options2.headers);
        }
        if (options2.auth) {
          outgoing.auth = options2.auth;
        }
        if (options2.ca) {
          outgoing.ca = options2.ca;
        }
        if (isSSL.test(options2[forward || "target"].protocol)) {
          outgoing.rejectUnauthorized = typeof options2.secure === "undefined" ? true : options2.secure;
        }
        outgoing.agent = options2.agent || false;
        outgoing.localAddress = options2.localAddress;
        if (!outgoing.agent) {
          outgoing.headers = outgoing.headers || {};
          if (typeof outgoing.headers.connection !== "string" || !upgradeHeader.test(outgoing.headers.connection)) {
            outgoing.headers.connection = "close";
          }
        }
        var target = options2[forward || "target"];
        var targetPath = target && options2.prependPath !== false ? target.path || "" : "";
        var outgoingPath = !options2.toProxy ? url2.parse(req2.url).path || "" : req2.url;
        outgoingPath = !options2.ignorePath ? outgoingPath : "";
        outgoing.path = common2.urlJoin(targetPath, outgoingPath);
        if (options2.changeOrigin) {
          outgoing.headers.host = required(outgoing.port, options2[forward || "target"].protocol) && !hasPort(outgoing.host) ? outgoing.host + ":" + outgoing.port : outgoing.host;
        }
        return outgoing;
      };
      common2.setupSocket = function(socket) {
        socket.setTimeout(0);
        socket.setNoDelay(true);
        socket.setKeepAlive(true, 0);
        return socket;
      };
      common2.getPort = function(req2) {
        var res = req2.headers.host ? req2.headers.host.match(/:(\d+)/) : "";
        return res ? res[1] : common2.hasEncryptedConnection(req2) ? "443" : "80";
      };
      common2.hasEncryptedConnection = function(req2) {
        return Boolean(req2.connection.encrypted || req2.connection.pair);
      };
      common2.urlJoin = function() {
        var args = Array.prototype.slice.call(arguments), lastIndex = args.length - 1, last = args[lastIndex], lastSegs = last.split("?"), retSegs;
        args[lastIndex] = lastSegs.shift();
        retSegs = [
          args.filter(Boolean).join("/").replace(/\/+/g, "/").replace("http:/", "http://").replace("https:/", "https://")
        ];
        retSegs.push.apply(retSegs, lastSegs);
        return retSegs.join("?");
      };
      common2.rewriteCookieProperty = function rewriteCookieProperty(header, config2, property) {
        if (Array.isArray(header)) {
          return header.map(function(headerElement) {
            return rewriteCookieProperty(headerElement, config2, property);
          });
        }
        return header.replace(new RegExp("(;\\s*" + property + "=)([^;]+)", "i"), function(match2, prefix, previousValue) {
          var newValue;
          if (previousValue in config2) {
            newValue = config2[previousValue];
          } else if ("*" in config2) {
            newValue = config2["*"];
          } else {
            return match2;
          }
          if (newValue) {
            return prefix + newValue;
          } else {
            return "";
          }
        });
      };
      function hasPort(host) {
        return !!~host.indexOf(":");
      }
    })(common$3);
    var url$2 = require$$0__default$5;
    var common$2 = common$3;
    var redirectRegex = /^201|30(1|2|7|8)$/;
    var webOutgoing = {
      removeChunked: function removeChunked(req2, res, proxyRes) {
        if (req2.httpVersion === "1.0") {
          delete proxyRes.headers["transfer-encoding"];
        }
      },
      setConnection: function setConnection(req2, res, proxyRes) {
        if (req2.httpVersion === "1.0") {
          proxyRes.headers.connection = req2.headers.connection || "close";
        } else if (req2.httpVersion !== "2.0" && !proxyRes.headers.connection) {
          proxyRes.headers.connection = req2.headers.connection || "keep-alive";
        }
      },
      setRedirectHostRewrite: function setRedirectHostRewrite(req2, res, proxyRes, options2) {
        if ((options2.hostRewrite || options2.autoRewrite || options2.protocolRewrite) && proxyRes.headers["location"] && redirectRegex.test(proxyRes.statusCode)) {
          var target = url$2.parse(options2.target);
          var u2 = url$2.parse(proxyRes.headers["location"]);
          if (target.host != u2.host) {
            return;
          }
          if (options2.hostRewrite) {
            u2.host = options2.hostRewrite;
          } else if (options2.autoRewrite) {
            u2.host = req2.headers["host"];
          }
          if (options2.protocolRewrite) {
            u2.protocol = options2.protocolRewrite;
          }
          proxyRes.headers["location"] = u2.format();
        }
      },
      writeHeaders: function writeHeaders(req2, res, proxyRes, options2) {
        var rewriteCookieDomainConfig = options2.cookieDomainRewrite, rewriteCookiePathConfig = options2.cookiePathRewrite, preserveHeaderKeyCase = options2.preserveHeaderKeyCase, rawHeaderKeyMap, setHeader = function(key2, header) {
          if (header == void 0)
            return;
          if (rewriteCookieDomainConfig && key2.toLowerCase() === "set-cookie") {
            header = common$2.rewriteCookieProperty(header, rewriteCookieDomainConfig, "domain");
          }
          if (rewriteCookiePathConfig && key2.toLowerCase() === "set-cookie") {
            header = common$2.rewriteCookieProperty(header, rewriteCookiePathConfig, "path");
          }
          res.setHeader(String(key2).trim(), header);
        };
        if (typeof rewriteCookieDomainConfig === "string") {
          rewriteCookieDomainConfig = { "*": rewriteCookieDomainConfig };
        }
        if (typeof rewriteCookiePathConfig === "string") {
          rewriteCookiePathConfig = { "*": rewriteCookiePathConfig };
        }
        if (preserveHeaderKeyCase && proxyRes.rawHeaders != void 0) {
          rawHeaderKeyMap = {};
          for (var i2 = 0; i2 < proxyRes.rawHeaders.length; i2 += 2) {
            var key = proxyRes.rawHeaders[i2];
            rawHeaderKeyMap[key.toLowerCase()] = key;
          }
        }
        Object.keys(proxyRes.headers).forEach(function(key2) {
          var header = proxyRes.headers[key2];
          if (preserveHeaderKeyCase && rawHeaderKeyMap) {
            key2 = rawHeaderKeyMap[key2] || key2;
          }
          setHeader(key2, header);
        });
      },
      writeStatusCode: function writeStatusCode(req2, res, proxyRes) {
        if (proxyRes.statusMessage) {
          res.statusCode = proxyRes.statusCode;
          res.statusMessage = proxyRes.statusMessage;
        } else {
          res.statusCode = proxyRes.statusCode;
        }
      }
    };
    var followRedirects$1 = { exports: {} };
    var debug$7;
    var debug_1 = function() {
      if (!debug$7) {
        try {
          debug$7 = require_browser2()("follow-redirects");
        } catch (error2) {
        }
        if (typeof debug$7 !== "function") {
          debug$7 = function() {
          };
        }
      }
      debug$7.apply(null, arguments);
    };
    var url$1 = require$$0__default$5;
    var URL$1 = url$1.URL;
    var http$1 = require$$1__default$2;
    var https$1 = require$$1__default$4;
    var Writable = require$$0__default$3.Writable;
    var assert$1 = require$$5__default;
    var debug$6 = debug_1;
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
    var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded");
    var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
    var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    function RedirectableRequest(options2, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options2);
      this._options = options2;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data2, encoding2, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!(typeof data2 === "string" || typeof data2 === "object" && "length" in data2)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (typeof encoding2 === "function") {
        callback = encoding2;
        encoding2 = null;
      }
      if (data2.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data2.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data2.length;
        this._requestBodyBuffers.push({ data: data2, encoding: encoding2 });
        this._currentRequest.write(data2, encoding2, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data2, encoding2, callback) {
      if (typeof data2 === "function") {
        callback = data2;
        data2 = encoding2 = null;
      } else if (typeof encoding2 === "function") {
        callback = encoding2;
        encoding2 = null;
      }
      if (!data2) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data2, encoding2, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a2, b2) {
        return this._currentRequest[method](a2, b2);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options2) {
      if (!options2.headers) {
        options2.headers = {};
      }
      if (options2.host) {
        if (!options2.hostname) {
          options2.hostname = options2.host;
        }
        delete options2.host;
      }
      if (!options2.pathname && options2.path) {
        var searchPos = options2.path.indexOf("?");
        if (searchPos < 0) {
          options2.pathname = options2.path;
        } else {
          options2.pathname = options2.path.substring(0, searchPos);
          options2.search = options2.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.substr(0, protocol.length - 1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      this._currentUrl = url$1.format(this._options);
      request._redirectable = this;
      for (var e2 = 0; e2 < events.length; e2++) {
        request.on(events[e2], eventHandlers[events[e2]]);
      }
      if (this._isRedirect) {
        var i2 = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error2) {
          if (request === self2._currentRequest) {
            if (error2) {
              self2.emit("error", error2);
            } else if (i2 < buffers.length) {
              var buffer = buffers[i2++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (location && this._options.followRedirects !== false && statusCode >= 300 && statusCode < 400) {
        abortRequest(this._currentRequest);
        response.destroy();
        if (++this._redirectCount > this._options.maxRedirects) {
          this.emit("error", new TooManyRedirectsError());
          return;
        }
        if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
          this._options.method = "GET";
          this._requestBodyBuffers = [];
          removeMatchingHeaders(/^content-/i, this._options.headers);
        }
        var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
        var currentUrlParts = url$1.parse(this._currentUrl);
        var currentHost = currentHostHeader || currentUrlParts.host;
        var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url$1.format(Object.assign(currentUrlParts, { host: currentHost }));
        var redirectUrl;
        try {
          redirectUrl = url$1.resolve(currentUrl, location);
        } catch (cause) {
          this.emit("error", new RedirectionError(cause));
          return;
        }
        debug$6("redirecting to", redirectUrl);
        this._isRedirect = true;
        var redirectUrlParts = url$1.parse(redirectUrl);
        Object.assign(this._options, redirectUrlParts);
        if (!(redirectUrlParts.host === currentHost || isSubdomainOf(redirectUrlParts.host, currentHost))) {
          removeMatchingHeaders(/^authorization$/i, this._options.headers);
        }
        if (typeof this._options.beforeRedirect === "function") {
          var responseDetails = { headers: response.headers };
          try {
            this._options.beforeRedirect.call(null, this._options, responseDetails);
          } catch (err) {
            this.emit("error", err);
            return;
          }
          this._sanitizeOptions(this._options);
        }
        try {
          this._performRequest();
        } catch (cause) {
          this.emit("error", new RedirectionError(cause));
        }
      } else {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
      }
    };
    function wrap(protocols) {
      var exports2 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
        function request(input, options2, callback) {
          if (typeof input === "string") {
            var urlStr = input;
            try {
              input = urlToOptions(new URL$1(urlStr));
            } catch (err) {
              input = url$1.parse(urlStr);
            }
          } else if (URL$1 && input instanceof URL$1) {
            input = urlToOptions(input);
          } else {
            callback = options2;
            options2 = input;
            input = { protocol };
          }
          if (typeof options2 === "function") {
            callback = options2;
            options2 = null;
          }
          options2 = Object.assign({
            maxRedirects: exports2.maxRedirects,
            maxBodyLength: exports2.maxBodyLength
          }, input, options2);
          options2.nativeProtocols = nativeProtocols;
          assert$1.equal(options2.protocol, protocol, "protocol mismatch");
          debug$6("options", options2);
          return new RedirectableRequest(options2, callback);
        }
        function get(input, options2, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options2, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports2;
    }
    function noop$2() {
    }
    function urlToOptions(urlObject) {
      var options2 = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options2.port = Number(urlObject.port);
      }
      return options2;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header].toString().trim();
          delete headers[header];
        }
      }
      return lastValue;
    }
    function createErrorType(code, defaultMessage) {
      function CustomError(cause) {
        Error.captureStackTrace(this, this.constructor);
        if (!cause) {
          this.message = defaultMessage;
        } else {
          this.message = defaultMessage + ": " + cause.message;
          this.cause = cause;
        }
      }
      CustomError.prototype = new Error();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      CustomError.prototype.code = code;
      return CustomError;
    }
    function abortRequest(request) {
      for (var e2 = 0; e2 < events.length; e2++) {
        request.removeListener(events[e2], eventHandlers[events[e2]]);
      }
      request.on("error", noop$2);
      request.abort();
    }
    function isSubdomainOf(subdomain, domain) {
      const dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    followRedirects$1.exports = wrap({ http: http$1, https: https$1 });
    followRedirects$1.exports.wrap = wrap;
    var httpNative = require$$1__default$2;
    var httpsNative = require$$1__default$4;
    var web_o = webOutgoing;
    var common$1 = common$3;
    var followRedirects = followRedirects$1.exports;
    web_o = Object.keys(web_o).map(function(pass) {
      return web_o[pass];
    });
    var nativeAgents = { http: httpNative, https: httpsNative };
    var webIncoming = {
      deleteLength: function deleteLength(req2, res, options2) {
        if ((req2.method === "DELETE" || req2.method === "OPTIONS") && !req2.headers["content-length"]) {
          req2.headers["content-length"] = "0";
          delete req2.headers["transfer-encoding"];
        }
      },
      timeout: function timeout(req2, res, options2) {
        if (options2.timeout) {
          req2.socket.setTimeout(options2.timeout);
        }
      },
      XHeaders: function XHeaders(req2, res, options2) {
        if (!options2.xfwd)
          return;
        var encrypted = req2.isSpdy || common$1.hasEncryptedConnection(req2);
        var values = {
          for: req2.connection.remoteAddress || req2.socket.remoteAddress,
          port: common$1.getPort(req2),
          proto: encrypted ? "https" : "http"
        };
        ["for", "port", "proto"].forEach(function(header) {
          req2.headers["x-forwarded-" + header] = (req2.headers["x-forwarded-" + header] || "") + (req2.headers["x-forwarded-" + header] ? "," : "") + values[header];
        });
        req2.headers["x-forwarded-host"] = req2.headers["x-forwarded-host"] || req2.headers["host"] || "";
      },
      stream: function stream2(req2, res, options2, _2, server2, clb) {
        server2.emit("start", req2, res, options2.target || options2.forward);
        var agents = options2.followRedirects ? followRedirects : nativeAgents;
        var http2 = agents.http;
        var https2 = agents.https;
        if (options2.forward) {
          var forwardReq = (options2.forward.protocol === "https:" ? https2 : http2).request(common$1.setupOutgoing(options2.ssl || {}, options2, req2, "forward"));
          var forwardError = createErrorHandler(forwardReq, options2.forward);
          req2.on("error", forwardError);
          forwardReq.on("error", forwardError);
          (options2.buffer || req2).pipe(forwardReq);
          if (!options2.target) {
            return res.end();
          }
        }
        var proxyReq = (options2.target.protocol === "https:" ? https2 : http2).request(common$1.setupOutgoing(options2.ssl || {}, options2, req2));
        proxyReq.on("socket", function(socket) {
          if (server2 && !proxyReq.getHeader("expect")) {
            server2.emit("proxyReq", proxyReq, req2, res, options2);
          }
        });
        if (options2.proxyTimeout) {
          proxyReq.setTimeout(options2.proxyTimeout, function() {
            proxyReq.abort();
          });
        }
        req2.on("aborted", function() {
          proxyReq.abort();
        });
        var proxyError = createErrorHandler(proxyReq, options2.target);
        req2.on("error", proxyError);
        proxyReq.on("error", proxyError);
        function createErrorHandler(proxyReq2, url2) {
          return function proxyError2(err) {
            if (req2.socket.destroyed && err.code === "ECONNRESET") {
              server2.emit("econnreset", err, req2, res, url2);
              return proxyReq2.abort();
            }
            if (clb) {
              clb(err, req2, res, url2);
            } else {
              server2.emit("error", err, req2, res, url2);
            }
          };
        }
        (options2.buffer || req2).pipe(proxyReq);
        proxyReq.on("response", function(proxyRes) {
          if (server2) {
            server2.emit("proxyRes", proxyRes, req2, res);
          }
          if (!res.headersSent && !options2.selfHandleResponse) {
            for (var i2 = 0; i2 < web_o.length; i2++) {
              if (web_o[i2](req2, res, proxyRes, options2)) {
                break;
              }
            }
          }
          if (!res.finished) {
            proxyRes.on("end", function() {
              if (server2)
                server2.emit("end", req2, res, proxyRes);
            });
            if (!options2.selfHandleResponse)
              proxyRes.pipe(res);
          } else {
            if (server2)
              server2.emit("end", req2, res, proxyRes);
          }
        });
      }
    };
    var http = require$$1__default$2;
    var https = require$$1__default$4;
    var common = common$3;
    var wsIncoming = {
      checkMethodAndHeader: function checkMethodAndHeader(req2, socket) {
        if (req2.method !== "GET" || !req2.headers.upgrade) {
          socket.destroy();
          return true;
        }
        if (req2.headers.upgrade.toLowerCase() !== "websocket") {
          socket.destroy();
          return true;
        }
      },
      XHeaders: function XHeaders(req2, socket, options2) {
        if (!options2.xfwd)
          return;
        var values = {
          for: req2.connection.remoteAddress || req2.socket.remoteAddress,
          port: common.getPort(req2),
          proto: common.hasEncryptedConnection(req2) ? "wss" : "ws"
        };
        ["for", "port", "proto"].forEach(function(header) {
          req2.headers["x-forwarded-" + header] = (req2.headers["x-forwarded-" + header] || "") + (req2.headers["x-forwarded-" + header] ? "," : "") + values[header];
        });
      },
      stream: function stream2(req2, socket, options2, head, server2, clb) {
        var createHttpHeader = function(line, headers) {
          return Object.keys(headers).reduce(function(head2, key) {
            var value = headers[key];
            if (!Array.isArray(value)) {
              head2.push(key + ": " + value);
              return head2;
            }
            for (var i2 = 0; i2 < value.length; i2++) {
              head2.push(key + ": " + value[i2]);
            }
            return head2;
          }, [line]).join("\r\n") + "\r\n\r\n";
        };
        common.setupSocket(socket);
        if (head && head.length)
          socket.unshift(head);
        var proxyReq = (common.isSSL.test(options2.target.protocol) ? https : http).request(common.setupOutgoing(options2.ssl || {}, options2, req2));
        if (server2) {
          server2.emit("proxyReqWs", proxyReq, req2, socket, options2, head);
        }
        proxyReq.on("error", onOutgoingError);
        proxyReq.on("response", function(res) {
          if (!res.upgrade) {
            socket.write(createHttpHeader("HTTP/" + res.httpVersion + " " + res.statusCode + " " + res.statusMessage, res.headers));
            res.pipe(socket);
          }
        });
        proxyReq.on("upgrade", function(proxyRes, proxySocket, proxyHead) {
          proxySocket.on("error", onOutgoingError);
          proxySocket.on("end", function() {
            server2.emit("close", proxyRes, proxySocket, proxyHead);
          });
          socket.on("error", function() {
            proxySocket.end();
          });
          common.setupSocket(proxySocket);
          if (proxyHead && proxyHead.length)
            proxySocket.unshift(proxyHead);
          socket.write(createHttpHeader("HTTP/1.1 101 Switching Protocols", proxyRes.headers));
          proxySocket.pipe(socket).pipe(proxySocket);
          server2.emit("open", proxySocket);
          server2.emit("proxySocket", proxySocket);
        });
        return proxyReq.end();
        function onOutgoingError(err) {
          if (clb) {
            clb(err, req2, socket);
          } else {
            server2.emit("error", err, req2, socket);
          }
          socket.end();
        }
      }
    };
    (function(module2) {
      var httpProxy2 = module2.exports, extend2 = require$$0__default$2._extend, parse_url = require$$0__default$5.parse, EE3 = eventemitter3.exports, http2 = require$$1__default$2, https2 = require$$1__default$4, web = webIncoming, ws2 = wsIncoming;
      httpProxy2.Server = ProxyServer2;
      function createRightProxy(type) {
        return function(options2) {
          return function(req2, res) {
            var passes = type === "ws" ? this.wsPasses : this.webPasses, args = [].slice.call(arguments), cntr = args.length - 1, head, cbl;
            if (typeof args[cntr] === "function") {
              cbl = args[cntr];
              cntr--;
            }
            var requestOptions = options2;
            if (!(args[cntr] instanceof Buffer) && args[cntr] !== res) {
              requestOptions = extend2({}, options2);
              extend2(requestOptions, args[cntr]);
              cntr--;
            }
            if (args[cntr] instanceof Buffer) {
              head = args[cntr];
            }
            ["target", "forward"].forEach(function(e2) {
              if (typeof requestOptions[e2] === "string")
                requestOptions[e2] = parse_url(requestOptions[e2]);
            });
            if (!requestOptions.target && !requestOptions.forward) {
              return this.emit("error", new Error("Must provide a proper URL as target"));
            }
            for (var i2 = 0; i2 < passes.length; i2++) {
              if (passes[i2](req2, res, requestOptions, head, this, cbl)) {
                break;
              }
            }
          };
        };
      }
      httpProxy2.createRightProxy = createRightProxy;
      function ProxyServer2(options2) {
        EE3.call(this);
        options2 = options2 || {};
        options2.prependPath = options2.prependPath === false ? false : true;
        this.web = this.proxyRequest = createRightProxy("web")(options2);
        this.ws = this.proxyWebsocketRequest = createRightProxy("ws")(options2);
        this.options = options2;
        this.webPasses = Object.keys(web).map(function(pass) {
          return web[pass];
        });
        this.wsPasses = Object.keys(ws2).map(function(pass) {
          return ws2[pass];
        });
        this.on("error", this.onError, this);
      }
      require$$0__default$2.inherits(ProxyServer2, EE3);
      ProxyServer2.prototype.onError = function(err) {
        if (this.listeners("error").length === 1) {
          throw err;
        }
      };
      ProxyServer2.prototype.listen = function(port, hostname) {
        var self2 = this, closure = function(req2, res) {
          self2.web(req2, res);
        };
        this._server = this.options.ssl ? https2.createServer(this.options.ssl, closure) : http2.createServer(closure);
        if (this.options.ws) {
          this._server.on("upgrade", function(req2, socket, head) {
            self2.ws(req2, socket, head);
          });
        }
        this._server.listen(port, hostname);
        return this;
      };
      ProxyServer2.prototype.close = function(callback) {
        var self2 = this;
        if (this._server) {
          this._server.close(done);
        }
        function done() {
          self2._server = null;
          if (callback) {
            callback.apply(null, arguments);
          }
        }
      };
      ProxyServer2.prototype.before = function(type, passName, callback) {
        if (type !== "ws" && type !== "web") {
          throw new Error("type must be `web` or `ws`");
        }
        var passes = type === "ws" ? this.wsPasses : this.webPasses, i2 = false;
        passes.forEach(function(v2, idx) {
          if (v2.name === passName)
            i2 = idx;
        });
        if (i2 === false)
          throw new Error("No such pass");
        passes.splice(i2, 0, callback);
      };
      ProxyServer2.prototype.after = function(type, passName, callback) {
        if (type !== "ws" && type !== "web") {
          throw new Error("type must be `web` or `ws`");
        }
        var passes = type === "ws" ? this.wsPasses : this.webPasses, i2 = false;
        passes.forEach(function(v2, idx) {
          if (v2.name === passName)
            i2 = idx;
        });
        if (i2 === false)
          throw new Error("No such pass");
        passes.splice(i2++, 0, callback);
      };
    })(httpProxy$2);
    var ProxyServer = httpProxy$2.exports.Server;
    function createProxyServer(options2) {
      return new ProxyServer(options2);
    }
    ProxyServer.createProxyServer = createProxyServer;
    ProxyServer.createServer = createProxyServer;
    ProxyServer.createProxy = createProxyServer;
    var httpProxy$1 = ProxyServer;
    var httpProxy = httpProxy$1;
    var debug$5 = createDebugger("vite:proxy");
    function proxyMiddleware(httpServer, config2) {
      const options2 = config2.server.proxy;
      const proxies = {};
      Object.keys(options2).forEach((context2) => {
        let opts = options2[context2];
        if (typeof opts === "string") {
          opts = { target: opts, changeOrigin: true };
        }
        const proxy = httpProxy.createProxyServer(opts);
        proxy.on("error", (err) => {
          config2.logger.error(`${source.red(`http proxy error:`)}
${err.stack}`, {
            timestamp: true,
            error: err
          });
        });
        if (opts.configure) {
          opts.configure(proxy, opts);
        }
        proxies[context2] = [proxy, __spreadValues2({}, opts)];
      });
      if (httpServer) {
        httpServer.on("upgrade", (req2, socket, head) => {
          var _a2;
          const url2 = req2.url;
          for (const context2 in proxies) {
            if (doesProxyContextMatchUrl(context2, url2)) {
              const [proxy, opts] = proxies[context2];
              if ((opts.ws || ((_a2 = opts.target) === null || _a2 === void 0 ? void 0 : _a2.toString().startsWith("ws:"))) && req2.headers["sec-websocket-protocol"] !== HMR_HEADER) {
                if (opts.rewrite) {
                  req2.url = opts.rewrite(url2);
                }
                debug$5(`${req2.url} -> ws ${opts.target}`);
                proxy.ws(req2, socket, head);
                return;
              }
            }
          }
        });
      }
      return function viteProxyMiddleware(req2, res, next) {
        const url2 = req2.url;
        for (const context2 in proxies) {
          if (doesProxyContextMatchUrl(context2, url2)) {
            const [proxy, opts] = proxies[context2];
            const options3 = {};
            if (opts.bypass) {
              const bypassResult = opts.bypass(req2, res, opts);
              if (typeof bypassResult === "string") {
                req2.url = bypassResult;
                debug$5(`bypass: ${req2.url} -> ${bypassResult}`);
                return next();
              } else if (isObject$3(bypassResult)) {
                Object.assign(options3, bypassResult);
                debug$5(`bypass: ${req2.url} use modified options: %O`, options3);
                return next();
              } else if (bypassResult === false) {
                debug$5(`bypass: ${req2.url} -> 404`);
                return res.end(404);
              }
            }
            debug$5(`${req2.url} -> ${opts.target || opts.forward}`);
            if (opts.rewrite) {
              req2.url = opts.rewrite(req2.url);
            }
            proxy.web(req2, res, options3);
            return;
          }
        }
        next();
      };
    }
    function doesProxyContextMatchUrl(context2, url2) {
      return context2.startsWith("^") && new RegExp(context2).test(url2) || url2.startsWith(context2);
    }
    var lib = { exports: {} };
    (function(module2, exports2) {
      var url2 = require$$0__default$5;
      module2.exports = function historyApiFallback(options2) {
        options2 = options2 || {};
        var logger = getLogger(options2);
        return function(req2, res, next) {
          var headers = req2.headers;
          if (req2.method !== "GET") {
            logger("Not rewriting", req2.method, req2.url, "because the method is not GET.");
            return next();
          } else if (!headers || typeof headers.accept !== "string") {
            logger("Not rewriting", req2.method, req2.url, "because the client did not send an HTTP accept header.");
            return next();
          } else if (headers.accept.indexOf("application/json") === 0) {
            logger("Not rewriting", req2.method, req2.url, "because the client prefers JSON.");
            return next();
          } else if (!acceptsHtml(headers.accept, options2)) {
            logger("Not rewriting", req2.method, req2.url, "because the client does not accept HTML.");
            return next();
          }
          var parsedUrl = url2.parse(req2.url);
          var rewriteTarget;
          options2.rewrites = options2.rewrites || [];
          for (var i2 = 0; i2 < options2.rewrites.length; i2++) {
            var rewrite = options2.rewrites[i2];
            var match2 = parsedUrl.pathname.match(rewrite.from);
            if (match2 !== null) {
              rewriteTarget = evaluateRewriteRule(parsedUrl, match2, rewrite.to, req2);
              if (rewriteTarget.charAt(0) !== "/") {
                logger("We recommend using an absolute path for the rewrite target.", "Received a non-absolute rewrite target", rewriteTarget, "for URL", req2.url);
              }
              logger("Rewriting", req2.method, req2.url, "to", rewriteTarget);
              req2.url = rewriteTarget;
              return next();
            }
          }
          var pathname = parsedUrl.pathname;
          if (pathname.lastIndexOf(".") > pathname.lastIndexOf("/") && options2.disableDotRule !== true) {
            logger("Not rewriting", req2.method, req2.url, "because the path includes a dot (.) character.");
            return next();
          }
          rewriteTarget = options2.index || "/index.html";
          logger("Rewriting", req2.method, req2.url, "to", rewriteTarget);
          req2.url = rewriteTarget;
          next();
        };
      };
      function evaluateRewriteRule(parsedUrl, match2, rule, req2) {
        if (typeof rule === "string") {
          return rule;
        } else if (typeof rule !== "function") {
          throw new Error("Rewrite rule can only be of type string or function.");
        }
        return rule({
          parsedUrl,
          match: match2,
          request: req2
        });
      }
      function acceptsHtml(header, options2) {
        options2.htmlAcceptHeaders = options2.htmlAcceptHeaders || ["text/html", "*/*"];
        for (var i2 = 0; i2 < options2.htmlAcceptHeaders.length; i2++) {
          if (header.indexOf(options2.htmlAcceptHeaders[i2]) !== -1) {
            return true;
          }
        }
        return false;
      }
      function getLogger(options2) {
        if (options2 && options2.logger) {
          return options2.logger;
        } else if (options2 && options2.verbose) {
          return console.log.bind(console);
        }
        return function() {
        };
      }
    })(lib);
    var history = lib.exports;
    function spaFallbackMiddleware(root) {
      const historySpaFallbackMiddleware = history({
        logger: createDebugger("vite:spa-fallback"),
        rewrites: [
          {
            from: /\/$/,
            to({ parsedUrl }) {
              const rewritten = decodeURIComponent(parsedUrl.pathname) + "index.html";
              if (fs__default.existsSync(path__default.join(root, rewritten))) {
                return rewritten;
              } else {
                return `/index.html`;
              }
            }
          }
        ]
      });
      return function viteSpaFallbackMiddleware(req2, res, next) {
        return historySpaFallbackMiddleware(req2, res, next);
      };
    }
    var etag_1 = etag;
    var crypto = require$$1__default$3;
    var Stats = fs__default.Stats;
    var toString = Object.prototype.toString;
    function entitytag(entity) {
      if (entity.length === 0) {
        return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
      }
      var hash = crypto.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
      var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
      return '"' + len.toString(16) + "-" + hash + '"';
    }
    function etag(entity, options2) {
      if (entity == null) {
        throw new TypeError("argument entity is required");
      }
      var isStats = isstats(entity);
      var weak = options2 && typeof options2.weak === "boolean" ? options2.weak : isStats;
      if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
        throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
      }
      var tag = isStats ? stattag(entity) : entitytag(entity);
      return weak ? "W/" + tag : tag;
    }
    function isstats(obj) {
      if (typeof Stats === "function" && obj instanceof Stats) {
        return true;
      }
      return obj && typeof obj === "object" && "ctime" in obj && toString.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
    }
    function stattag(stat2) {
      var mtime = stat2.mtime.getTime().toString(16);
      var size = stat2.size.toString(16);
      return '"' + size + "-" + mtime + '"';
    }
    var isDebug$4 = process.env.DEBUG;
    var alias$1 = {
      js: "application/javascript",
      css: "text/css",
      html: "text/html",
      json: "application/json"
    };
    function send$1(req2, res, content2, type, etag2 = etag_1(content2, { weak: true }), cacheControl = "no-cache", map2) {
      if (res.writableEnded) {
        return;
      }
      if (req2.headers["if-none-match"] === etag2) {
        res.statusCode = 304;
        return res.end();
      }
      res.setHeader("Content-Type", alias$1[type] || type);
      res.setHeader("Cache-Control", cacheControl);
      res.setHeader("Etag", etag2);
      if (map2 && map2.mappings) {
        if (isDebug$4) {
          content2 += `
/*${JSON.stringify(map2, null, 2).replace(/\*\//g, "*\\/")}*/
`;
        }
        content2 += genSourceMapString(map2);
      }
      res.statusCode = 200;
      return res.end(content2);
    }
    function genSourceMapString(map2) {
      if (typeof map2 !== "string") {
        map2 = JSON.stringify(map2);
      }
      return `
//# sourceMappingURL=data:application/json;base64,${Buffer.from(map2).toString("base64")}`;
    }
    var convertSourceMap = {};
    var safeBuffer = { exports: {} };
    (function(module2, exports2) {
      var buffer = require$$0__default$7;
      var Buffer2 = buffer.Buffer;
      function copyProps(src2, dst) {
        for (var key in src2) {
          dst[key] = src2[key];
        }
      }
      if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
        module2.exports = buffer;
      } else {
        copyProps(buffer, exports2);
        exports2.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer2(arg, encodingOrOffset, length);
      }
      copyProps(Buffer2, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer2(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill2, encoding2) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer2(size);
        if (fill2 !== void 0) {
          if (typeof encoding2 === "string") {
            buf.fill(fill2, encoding2);
          } else {
            buf.fill(fill2);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer2(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    })(safeBuffer, safeBuffer.exports);
    (function(exports2) {
      var fs3 = fs__default;
      var path2 = path__default;
      var SafeBuffer = safeBuffer.exports;
      Object.defineProperty(exports2, "commentRegex", {
        get: function getCommentRegex() {
          return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/mg;
        }
      });
      Object.defineProperty(exports2, "mapFileCommentRegex", {
        get: function getMapFileCommentRegex() {
          return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg;
        }
      });
      function decodeBase64(base642) {
        return (SafeBuffer.Buffer.from(base642, "base64") || "").toString();
      }
      function stripComment(sm) {
        return sm.split(",").pop();
      }
      function readFromFileMap(sm, dir) {
        var r2 = exports2.mapFileCommentRegex.exec(sm);
        var filename2 = r2[1] || r2[2];
        var filepath = path2.resolve(dir, filename2);
        try {
          return fs3.readFileSync(filepath, "utf8");
        } catch (e2) {
          throw new Error("An error occurred while trying to read the map file at " + filepath + "\n" + e2);
        }
      }
      function Converter(sm, opts) {
        opts = opts || {};
        if (opts.isFileComment)
          sm = readFromFileMap(sm, opts.commentFileDir);
        if (opts.hasComment)
          sm = stripComment(sm);
        if (opts.isEncoded)
          sm = decodeBase64(sm);
        if (opts.isJSON || opts.isEncoded)
          sm = JSON.parse(sm);
        this.sourcemap = sm;
      }
      Converter.prototype.toJSON = function(space) {
        return JSON.stringify(this.sourcemap, null, space);
      };
      Converter.prototype.toBase64 = function() {
        var json2 = this.toJSON();
        return (SafeBuffer.Buffer.from(json2, "utf8") || "").toString("base64");
      };
      Converter.prototype.toComment = function(options2) {
        var base642 = this.toBase64();
        var data2 = "sourceMappingURL=data:application/json;charset=utf-8;base64," + base642;
        return options2 && options2.multiline ? "/*# " + data2 + " */" : "//# " + data2;
      };
      Converter.prototype.toObject = function() {
        return JSON.parse(this.toJSON());
      };
      Converter.prototype.addProperty = function(key, value) {
        if (this.sourcemap.hasOwnProperty(key))
          throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
        return this.setProperty(key, value);
      };
      Converter.prototype.setProperty = function(key, value) {
        this.sourcemap[key] = value;
        return this;
      };
      Converter.prototype.getProperty = function(key) {
        return this.sourcemap[key];
      };
      exports2.fromObject = function(obj) {
        return new Converter(obj);
      };
      exports2.fromJSON = function(json2) {
        return new Converter(json2, { isJSON: true });
      };
      exports2.fromBase64 = function(base642) {
        return new Converter(base642, { isEncoded: true });
      };
      exports2.fromComment = function(comment) {
        comment = comment.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
        return new Converter(comment, { isEncoded: true, hasComment: true });
      };
      exports2.fromMapFileComment = function(comment, dir) {
        return new Converter(comment, { commentFileDir: dir, isFileComment: true, isJSON: true });
      };
      exports2.fromSource = function(content2) {
        var m3 = content2.match(exports2.commentRegex);
        return m3 ? exports2.fromComment(m3.pop()) : null;
      };
      exports2.fromMapFileSource = function(content2, dir) {
        var m3 = content2.match(exports2.mapFileCommentRegex);
        return m3 ? exports2.fromMapFileComment(m3.pop(), dir) : null;
      };
      exports2.removeComments = function(src2) {
        return src2.replace(exports2.commentRegex, "");
      };
      exports2.removeMapFileComments = function(src2) {
        return src2.replace(exports2.mapFileCommentRegex, "");
      };
      exports2.generateMapFileComment = function(file, options2) {
        var data2 = "sourceMappingURL=" + file;
        return options2 && options2.multiline ? "/*# " + data2 + " */" : "//# " + data2;
      };
    })(convertSourceMap);
    function extract_names(param) {
      return extract_identifiers(param).map((node2) => node2.name);
    }
    function extract_identifiers(param, nodes = []) {
      switch (param.type) {
        case "Identifier":
          nodes.push(param);
          break;
        case "MemberExpression":
          let object = param;
          while (object.type === "MemberExpression") {
            object = object.object;
          }
          nodes.push(object);
          break;
        case "ObjectPattern":
          const handle_prop = (prop) => {
            if (prop.type === "RestElement") {
              extract_identifiers(prop.argument, nodes);
            } else {
              extract_identifiers(prop.value, nodes);
            }
          };
          param.properties.forEach(handle_prop);
          break;
        case "ArrayPattern":
          const handle_element = (element) => {
            if (element)
              extract_identifiers(element, nodes);
          };
          param.elements.forEach(handle_element);
          break;
        case "RestElement":
          extract_identifiers(param.argument, nodes);
          break;
        case "AssignmentPattern":
          extract_identifiers(param.left, nodes);
          break;
      }
      return nodes;
    }
    var ssrModuleExportsKey = `__vite_ssr_exports__`;
    var ssrImportKey = `__vite_ssr_import__`;
    var ssrDynamicImportKey = `__vite_ssr_dynamic_import__`;
    var ssrExportAllKey = `__vite_ssr_exportAll__`;
    var ssrImportMetaKey = `__vite_ssr_import_meta__`;
    async function ssrTransform(code, inMap, url2) {
      const s2 = new MagicString(code);
      let ast;
      try {
        ast = parser.parse(code, {
          sourceType: "module",
          ecmaVersion: "latest",
          locations: true
        });
      } catch (err) {
        if (!err.loc || !err.loc.line)
          throw err;
        const line = err.loc.line;
        throw new Error(`Parse failure: ${err.message}
Contents of line ${line}: ${code.split("\n")[line - 1]}`);
      }
      let uid = 0;
      const deps = new Set();
      const dynamicDeps = new Set();
      const idToImportMap = new Map();
      const declaredConst = new Set();
      function defineImport(node2, source2) {
        deps.add(source2);
        const importId = `__vite_ssr_import_${uid++}__`;
        s2.appendLeft(node2.start, `const ${importId} = await ${ssrImportKey}(${JSON.stringify(source2)});
`);
        return importId;
      }
      function defineExport(position, name, local = name) {
        s2.appendRight(position, `
Object.defineProperty(${ssrModuleExportsKey}, "${name}", { enumerable: true, configurable: true, get(){ return ${local} }});`);
      }
      for (const node2 of ast.body) {
        if (node2.type === "ImportDeclaration") {
          const importId = defineImport(node2, node2.source.value);
          for (const spec of node2.specifiers) {
            if (spec.type === "ImportSpecifier") {
              idToImportMap.set(spec.local.name, `${importId}.${spec.imported.name}`);
            } else if (spec.type === "ImportDefaultSpecifier") {
              idToImportMap.set(spec.local.name, `${importId}.default`);
            } else {
              idToImportMap.set(spec.local.name, importId);
            }
          }
          s2.remove(node2.start, node2.end);
        }
      }
      for (const node2 of ast.body) {
        if (node2.type === "ExportNamedDeclaration") {
          if (node2.declaration) {
            if (node2.declaration.type === "FunctionDeclaration" || node2.declaration.type === "ClassDeclaration") {
              defineExport(node2.end, node2.declaration.id.name);
            } else {
              for (const declaration of node2.declaration.declarations) {
                const names = extract_names(declaration.id);
                for (const name of names) {
                  defineExport(node2.end, name);
                }
              }
            }
            s2.remove(node2.start, node2.declaration.start);
          } else {
            s2.remove(node2.start, node2.end);
            if (node2.source) {
              const importId = defineImport(node2, node2.source.value);
              for (const spec of node2.specifiers) {
                defineExport(node2.end, spec.exported.name, `${importId}.${spec.local.name}`);
              }
            } else {
              for (const spec of node2.specifiers) {
                const local = spec.local.name;
                const binding = idToImportMap.get(local);
                defineExport(node2.end, spec.exported.name, binding || local);
              }
            }
          }
        }
        if (node2.type === "ExportDefaultDeclaration") {
          if ("id" in node2.declaration && node2.declaration.id) {
            const { name } = node2.declaration.id;
            s2.remove(node2.start, node2.start + 15);
            s2.append(`
Object.defineProperty(${ssrModuleExportsKey}, "default", { enumerable: true, value: ${name} });`);
          } else {
            s2.overwrite(node2.start, node2.start + 14, `${ssrModuleExportsKey}.default =`);
          }
        }
        if (node2.type === "ExportAllDeclaration") {
          if (node2.exported) {
            const importId = defineImport(node2, node2.source.value);
            s2.remove(node2.start, node2.end);
            defineExport(node2.end, node2.exported.name, `${importId}`);
          } else {
            const importId = defineImport(node2, node2.source.value);
            s2.remove(node2.start, node2.end);
            s2.appendLeft(node2.end, `${ssrExportAllKey}(${importId});`);
          }
        }
      }
      walk(ast, {
        onIdentifier(id, parent, parentStack) {
          const grandparent = parentStack[1];
          const binding = idToImportMap.get(id.name);
          if (!binding) {
            return;
          }
          if (isStaticProperty(parent) && parent.shorthand) {
            if (!parent.inPattern || isInDestructuringAssignment(parent, parentStack)) {
              s2.appendLeft(id.end, `: ${binding}`);
            }
          } else if (parent.type === "PropertyDefinition" && (grandparent === null || grandparent === void 0 ? void 0 : grandparent.type) === "ClassBody" || parent.type === "ClassDeclaration" && id === parent.superClass) {
            if (!declaredConst.has(id.name)) {
              declaredConst.add(id.name);
              const topNode = parentStack[parentStack.length - 2];
              s2.prependRight(topNode.start, `const ${id.name} = ${binding};
`);
            }
          } else {
            s2.overwrite(id.start, id.end, binding);
          }
        },
        onImportMeta(node2) {
          s2.overwrite(node2.start, node2.end, ssrImportMetaKey);
        },
        onDynamicImport(node2) {
          s2.overwrite(node2.start, node2.start + 6, ssrDynamicImportKey);
          if (node2.type === "ImportExpression" && node2.source.type === "Literal") {
            dynamicDeps.add(node2.source.value);
          }
        }
      });
      let map2 = s2.generateMap({ hires: true });
      if (inMap && inMap.mappings && inMap.sources.length > 0) {
        map2 = combineSourcemaps(url2, [
          __spreadProps2(__spreadValues2({}, map2), {
            sources: inMap.sources,
            sourcesContent: inMap.sourcesContent
          }),
          inMap
        ]);
      } else {
        map2.sources = [url2];
        map2.sourcesContent = [code];
      }
      return {
        code: s2.toString(),
        map: map2,
        deps: [...deps],
        dynamicDeps: [...dynamicDeps]
      };
    }
    function walk(root, { onIdentifier, onImportMeta, onDynamicImport }) {
      const parentStack = [];
      const scopeMap = new WeakMap();
      const identifiers = [];
      const setScope = (node2, name) => {
        let scopeIds = scopeMap.get(node2);
        if (scopeIds && scopeIds.has(name)) {
          return;
        }
        if (!scopeIds) {
          scopeIds = new Set();
          scopeMap.set(node2, scopeIds);
        }
        scopeIds.add(name);
      };
      function isInScope(name, parents) {
        return parents.some((node2) => {
          var _a2;
          return node2 && ((_a2 = scopeMap.get(node2)) === null || _a2 === void 0 ? void 0 : _a2.has(name));
        });
      }
      walk$1(root, {
        enter(node2, parent) {
          if (node2.type === "ImportDeclaration") {
            return this.skip();
          }
          parent && parentStack.unshift(parent);
          if (node2.type === "MetaProperty" && node2.meta.name === "import") {
            onImportMeta(node2);
          } else if (node2.type === "ImportExpression") {
            onDynamicImport(node2);
          }
          if (node2.type === "Identifier") {
            if (!isInScope(node2.name, parentStack) && isRefIdentifier(node2, parent, parentStack)) {
              identifiers.push([node2, parentStack.slice(0)]);
            }
          } else if (isFunction(node2)) {
            if (node2.type === "FunctionDeclaration") {
              const parentFunction = findParentFunction(parentStack);
              if (parentFunction) {
                setScope(parentFunction, node2.id.name);
              }
            }
            node2.params.forEach((p2) => walk$1(p2.type === "AssignmentPattern" ? p2.left : p2, {
              enter(child, parent2) {
                if (child.type !== "Identifier")
                  return;
                if (isStaticPropertyKey(child, parent2))
                  return;
                if ((parent2 === null || parent2 === void 0 ? void 0 : parent2.type) === "AssignmentPattern" && (parent2 === null || parent2 === void 0 ? void 0 : parent2.right) === child || (parent2 === null || parent2 === void 0 ? void 0 : parent2.type) === "TemplateLiteral" && (parent2 === null || parent2 === void 0 ? void 0 : parent2.expressions.includes(child)) || (parent2 === null || parent2 === void 0 ? void 0 : parent2.type) === "CallExpression" && (parent2 === null || parent2 === void 0 ? void 0 : parent2.callee) === child) {
                  return;
                }
                setScope(node2, child.name);
              }
            }));
          } else if (node2.type === "Property" && parent.type === "ObjectPattern") {
            node2.inPattern = true;
          } else if (node2.type === "VariableDeclarator") {
            const parentFunction = findParentFunction(parentStack);
            if (parentFunction) {
              const handlePattern = (p2) => {
                if (p2.type === "Identifier") {
                  setScope(parentFunction, p2.name);
                } else if (p2.type === "RestElement") {
                  handlePattern(p2.argument);
                } else if (p2.type === "ObjectPattern") {
                  p2.properties.forEach((property) => {
                    if (property.type === "RestElement") {
                      setScope(parentFunction, property.argument.name);
                    } else
                      handlePattern(property.value);
                  });
                } else if (p2.type === "ArrayPattern") {
                  p2.elements.forEach((element) => {
                    if (element)
                      handlePattern(element);
                  });
                } else if (p2.type === "AssignmentPattern") {
                  handlePattern(p2.left);
                } else {
                  setScope(parentFunction, p2.name);
                }
              };
              handlePattern(node2.id);
            }
          }
        },
        leave(node2, parent) {
          parent && parentStack.shift();
        }
      });
      identifiers.forEach(([node2, stack]) => {
        if (!isInScope(node2.name, stack))
          onIdentifier(node2, stack[0], stack);
      });
    }
    function isRefIdentifier(id, parent, parentStack) {
      if (parent.type === "CatchClause" || (parent.type === "VariableDeclarator" || parent.type === "ClassDeclaration") && parent.id === id) {
        return false;
      }
      if (isFunction(parent)) {
        if (parent.id === id) {
          return false;
        }
        if (parent.params.includes(id)) {
          return false;
        }
      }
      if (parent.type === "MethodDefinition") {
        return false;
      }
      if (isStaticPropertyKey(id, parent) || parent.inPattern) {
        return false;
      }
      if (parent.type === "ArrayPattern" && !isInDestructuringAssignment(parent, parentStack)) {
        return false;
      }
      if (parent.type === "MemberExpression" && parent.property === id && !parent.computed) {
        return false;
      }
      if (parent.type === "ExportSpecifier") {
        return false;
      }
      if (id.name === "arguments") {
        return false;
      }
      return true;
    }
    var isStaticProperty = (node2) => node2 && node2.type === "Property" && !node2.computed;
    var isStaticPropertyKey = (node2, parent) => isStaticProperty(parent) && parent.key === node2;
    function isFunction(node2) {
      return /Function(?:Expression|Declaration)$|Method$/.test(node2.type);
    }
    function findParentFunction(parentStack) {
      return parentStack.find((i2) => isFunction(i2));
    }
    function isInDestructuringAssignment(parent, parentStack) {
      if (parent && (parent.type === "Property" || parent.type === "ArrayPattern")) {
        return parentStack.some((i2) => i2.type === "AssignmentExpression");
      }
      return false;
    }
    var isDebug$3 = !!process.env.DEBUG;
    var debug$4 = createDebugger("vite:sourcemap", {
      onlyWhenFocused: true
    });
    var virtualSourceRE = /^(\0|dep:|browser-external:)/;
    async function injectSourcesContent(map2, file, logger) {
      let sourceRoot;
      try {
        sourceRoot = await fs$r.promises.realpath(path__default.resolve(path__default.dirname(file), map2.sourceRoot || ""));
      } catch {
      }
      const missingSources = [];
      map2.sourcesContent = await Promise.all(map2.sources.map((sourcePath) => {
        if (sourcePath && !virtualSourceRE.test(sourcePath)) {
          sourcePath = decodeURI(sourcePath);
          if (sourceRoot) {
            sourcePath = path__default.resolve(sourceRoot, sourcePath);
          }
          return fs$r.promises.readFile(sourcePath, "utf-8").catch(() => {
            missingSources.push(sourcePath);
            return null;
          });
        }
        return null;
      }));
      if (missingSources.length) {
        logger.warnOnce(`Sourcemap for "${file}" points to missing source files`);
        isDebug$3 && debug$4(`Missing sources:
  ` + missingSources.join(`
  `));
      }
    }
    function parse$5(req2) {
      let raw = req2.url;
      if (raw == null)
        return;
      let prev = req2._parsedUrl;
      if (prev && prev.raw === raw)
        return prev;
      let pathname = raw, search = "", query;
      if (raw.length > 1) {
        let idx = raw.indexOf("?", 1);
        if (idx !== -1) {
          search = raw.substring(idx);
          pathname = raw.substring(0, idx);
          if (search.length > 1) {
            query = qs__namespace.parse(search.substring(1));
          }
        }
      }
      return req2._parsedUrl = { pathname, search, query, raw };
    }
    function list(dir, callback, pre = "") {
      dir = path$t.resolve(".", dir);
      let arr = fs$r.readdirSync(dir);
      let i2 = 0, abs, stats;
      for (; i2 < arr.length; i2++) {
        abs = path$t.join(dir, arr[i2]);
        stats = fs$r.statSync(abs);
        stats.isDirectory() ? list(abs, callback, path$t.join(pre, arr[i2])) : callback(path$t.join(pre, arr[i2]), abs, stats);
      }
    }
    var mimes = {
      "ez": "application/andrew-inset",
      "aw": "application/applixware",
      "atom": "application/atom+xml",
      "atomcat": "application/atomcat+xml",
      "atomdeleted": "application/atomdeleted+xml",
      "atomsvc": "application/atomsvc+xml",
      "dwd": "application/atsc-dwd+xml",
      "held": "application/atsc-held+xml",
      "rsat": "application/atsc-rsat+xml",
      "bdoc": "application/bdoc",
      "xcs": "application/calendar+xml",
      "ccxml": "application/ccxml+xml",
      "cdfx": "application/cdfx+xml",
      "cdmia": "application/cdmi-capability",
      "cdmic": "application/cdmi-container",
      "cdmid": "application/cdmi-domain",
      "cdmio": "application/cdmi-object",
      "cdmiq": "application/cdmi-queue",
      "cu": "application/cu-seeme",
      "mpd": "application/dash+xml",
      "davmount": "application/davmount+xml",
      "dbk": "application/docbook+xml",
      "dssc": "application/dssc+der",
      "xdssc": "application/dssc+xml",
      "es": "application/ecmascript",
      "ecma": "application/ecmascript",
      "emma": "application/emma+xml",
      "emotionml": "application/emotionml+xml",
      "epub": "application/epub+zip",
      "exi": "application/exi",
      "fdt": "application/fdt+xml",
      "pfr": "application/font-tdpfr",
      "geojson": "application/geo+json",
      "gml": "application/gml+xml",
      "gpx": "application/gpx+xml",
      "gxf": "application/gxf",
      "gz": "application/gzip",
      "hjson": "application/hjson",
      "stk": "application/hyperstudio",
      "ink": "application/inkml+xml",
      "inkml": "application/inkml+xml",
      "ipfix": "application/ipfix",
      "its": "application/its+xml",
      "jar": "application/java-archive",
      "war": "application/java-archive",
      "ear": "application/java-archive",
      "ser": "application/java-serialized-object",
      "class": "application/java-vm",
      "js": "application/javascript",
      "mjs": "application/javascript",
      "json": "application/json",
      "map": "application/json",
      "json5": "application/json5",
      "jsonml": "application/jsonml+json",
      "jsonld": "application/ld+json",
      "lgr": "application/lgr+xml",
      "lostxml": "application/lost+xml",
      "hqx": "application/mac-binhex40",
      "cpt": "application/mac-compactpro",
      "mads": "application/mads+xml",
      "webmanifest": "application/manifest+json",
      "mrc": "application/marc",
      "mrcx": "application/marcxml+xml",
      "ma": "application/mathematica",
      "nb": "application/mathematica",
      "mb": "application/mathematica",
      "mathml": "application/mathml+xml",
      "mbox": "application/mbox",
      "mscml": "application/mediaservercontrol+xml",
      "metalink": "application/metalink+xml",
      "meta4": "application/metalink4+xml",
      "mets": "application/mets+xml",
      "maei": "application/mmt-aei+xml",
      "musd": "application/mmt-usd+xml",
      "mods": "application/mods+xml",
      "m21": "application/mp21",
      "mp21": "application/mp21",
      "mp4s": "application/mp4",
      "m4p": "application/mp4",
      "doc": "application/msword",
      "dot": "application/msword",
      "mxf": "application/mxf",
      "nq": "application/n-quads",
      "nt": "application/n-triples",
      "cjs": "application/node",
      "bin": "application/octet-stream",
      "dms": "application/octet-stream",
      "lrf": "application/octet-stream",
      "mar": "application/octet-stream",
      "so": "application/octet-stream",
      "dist": "application/octet-stream",
      "distz": "application/octet-stream",
      "pkg": "application/octet-stream",
      "bpk": "application/octet-stream",
      "dump": "application/octet-stream",
      "elc": "application/octet-stream",
      "deploy": "application/octet-stream",
      "exe": "application/octet-stream",
      "dll": "application/octet-stream",
      "deb": "application/octet-stream",
      "dmg": "application/octet-stream",
      "iso": "application/octet-stream",
      "img": "application/octet-stream",
      "msi": "application/octet-stream",
      "msp": "application/octet-stream",
      "msm": "application/octet-stream",
      "buffer": "application/octet-stream",
      "oda": "application/oda",
      "opf": "application/oebps-package+xml",
      "ogx": "application/ogg",
      "omdoc": "application/omdoc+xml",
      "onetoc": "application/onenote",
      "onetoc2": "application/onenote",
      "onetmp": "application/onenote",
      "onepkg": "application/onenote",
      "oxps": "application/oxps",
      "relo": "application/p2p-overlay+xml",
      "xer": "application/patch-ops-error+xml",
      "pdf": "application/pdf",
      "pgp": "application/pgp-encrypted",
      "asc": "application/pgp-signature",
      "sig": "application/pgp-signature",
      "prf": "application/pics-rules",
      "p10": "application/pkcs10",
      "p7m": "application/pkcs7-mime",
      "p7c": "application/pkcs7-mime",
      "p7s": "application/pkcs7-signature",
      "p8": "application/pkcs8",
      "ac": "application/pkix-attr-cert",
      "cer": "application/pkix-cert",
      "crl": "application/pkix-crl",
      "pkipath": "application/pkix-pkipath",
      "pki": "application/pkixcmp",
      "pls": "application/pls+xml",
      "ai": "application/postscript",
      "eps": "application/postscript",
      "ps": "application/postscript",
      "provx": "application/provenance+xml",
      "cww": "application/prs.cww",
      "pskcxml": "application/pskc+xml",
      "raml": "application/raml+yaml",
      "rdf": "application/rdf+xml",
      "owl": "application/rdf+xml",
      "rif": "application/reginfo+xml",
      "rnc": "application/relax-ng-compact-syntax",
      "rl": "application/resource-lists+xml",
      "rld": "application/resource-lists-diff+xml",
      "rs": "application/rls-services+xml",
      "rapd": "application/route-apd+xml",
      "sls": "application/route-s-tsid+xml",
      "rusd": "application/route-usd+xml",
      "gbr": "application/rpki-ghostbusters",
      "mft": "application/rpki-manifest",
      "roa": "application/rpki-roa",
      "rsd": "application/rsd+xml",
      "rss": "application/rss+xml",
      "rtf": "application/rtf",
      "sbml": "application/sbml+xml",
      "scq": "application/scvp-cv-request",
      "scs": "application/scvp-cv-response",
      "spq": "application/scvp-vp-request",
      "spp": "application/scvp-vp-response",
      "sdp": "application/sdp",
      "senmlx": "application/senml+xml",
      "sensmlx": "application/sensml+xml",
      "setpay": "application/set-payment-initiation",
      "setreg": "application/set-registration-initiation",
      "shf": "application/shf+xml",
      "siv": "application/sieve",
      "sieve": "application/sieve",
      "smi": "application/smil+xml",
      "smil": "application/smil+xml",
      "rq": "application/sparql-query",
      "srx": "application/sparql-results+xml",
      "gram": "application/srgs",
      "grxml": "application/srgs+xml",
      "sru": "application/sru+xml",
      "ssdl": "application/ssdl+xml",
      "ssml": "application/ssml+xml",
      "swidtag": "application/swid+xml",
      "tei": "application/tei+xml",
      "teicorpus": "application/tei+xml",
      "tfi": "application/thraud+xml",
      "tsd": "application/timestamped-data",
      "toml": "application/toml",
      "trig": "application/trig",
      "ttml": "application/ttml+xml",
      "ubj": "application/ubjson",
      "rsheet": "application/urc-ressheet+xml",
      "td": "application/urc-targetdesc+xml",
      "vxml": "application/voicexml+xml",
      "wasm": "application/wasm",
      "wgt": "application/widget",
      "hlp": "application/winhlp",
      "wsdl": "application/wsdl+xml",
      "wspolicy": "application/wspolicy+xml",
      "xaml": "application/xaml+xml",
      "xav": "application/xcap-att+xml",
      "xca": "application/xcap-caps+xml",
      "xdf": "application/xcap-diff+xml",
      "xel": "application/xcap-el+xml",
      "xns": "application/xcap-ns+xml",
      "xenc": "application/xenc+xml",
      "xhtml": "application/xhtml+xml",
      "xht": "application/xhtml+xml",
      "xlf": "application/xliff+xml",
      "xml": "application/xml",
      "xsl": "application/xml",
      "xsd": "application/xml",
      "rng": "application/xml",
      "dtd": "application/xml-dtd",
      "xop": "application/xop+xml",
      "xpl": "application/xproc+xml",
      "xslt": "application/xml",
      "xspf": "application/xspf+xml",
      "mxml": "application/xv+xml",
      "xhvml": "application/xv+xml",
      "xvml": "application/xv+xml",
      "xvm": "application/xv+xml",
      "yang": "application/yang",
      "yin": "application/yin+xml",
      "zip": "application/zip",
      "3gpp": "video/3gpp",
      "adp": "audio/adpcm",
      "amr": "audio/amr",
      "au": "audio/basic",
      "snd": "audio/basic",
      "mid": "audio/midi",
      "midi": "audio/midi",
      "kar": "audio/midi",
      "rmi": "audio/midi",
      "mxmf": "audio/mobile-xmf",
      "mp3": "audio/mpeg",
      "m4a": "audio/mp4",
      "mp4a": "audio/mp4",
      "mpga": "audio/mpeg",
      "mp2": "audio/mpeg",
      "mp2a": "audio/mpeg",
      "m2a": "audio/mpeg",
      "m3a": "audio/mpeg",
      "oga": "audio/ogg",
      "ogg": "audio/ogg",
      "spx": "audio/ogg",
      "opus": "audio/ogg",
      "s3m": "audio/s3m",
      "sil": "audio/silk",
      "wav": "audio/wav",
      "weba": "audio/webm",
      "xm": "audio/xm",
      "ttc": "font/collection",
      "otf": "font/otf",
      "ttf": "font/ttf",
      "woff": "font/woff",
      "woff2": "font/woff2",
      "exr": "image/aces",
      "apng": "image/apng",
      "avif": "image/avif",
      "bmp": "image/bmp",
      "cgm": "image/cgm",
      "drle": "image/dicom-rle",
      "emf": "image/emf",
      "fits": "image/fits",
      "g3": "image/g3fax",
      "gif": "image/gif",
      "heic": "image/heic",
      "heics": "image/heic-sequence",
      "heif": "image/heif",
      "heifs": "image/heif-sequence",
      "hej2": "image/hej2k",
      "hsj2": "image/hsj2",
      "ief": "image/ief",
      "jls": "image/jls",
      "jp2": "image/jp2",
      "jpg2": "image/jp2",
      "jpeg": "image/jpeg",
      "jpg": "image/jpeg",
      "jpe": "image/jpeg",
      "jph": "image/jph",
      "jhc": "image/jphc",
      "jpm": "image/jpm",
      "jpx": "image/jpx",
      "jpf": "image/jpx",
      "jxr": "image/jxr",
      "jxra": "image/jxra",
      "jxrs": "image/jxrs",
      "jxs": "image/jxs",
      "jxsc": "image/jxsc",
      "jxsi": "image/jxsi",
      "jxss": "image/jxss",
      "ktx": "image/ktx",
      "ktx2": "image/ktx2",
      "png": "image/png",
      "btif": "image/prs.btif",
      "pti": "image/prs.pti",
      "sgi": "image/sgi",
      "svg": "image/svg+xml",
      "svgz": "image/svg+xml",
      "t38": "image/t38",
      "tif": "image/tiff",
      "tiff": "image/tiff",
      "tfx": "image/tiff-fx",
      "webp": "image/webp",
      "wmf": "image/wmf",
      "disposition-notification": "message/disposition-notification",
      "u8msg": "message/global",
      "u8dsn": "message/global-delivery-status",
      "u8mdn": "message/global-disposition-notification",
      "u8hdr": "message/global-headers",
      "eml": "message/rfc822",
      "mime": "message/rfc822",
      "3mf": "model/3mf",
      "gltf": "model/gltf+json",
      "glb": "model/gltf-binary",
      "igs": "model/iges",
      "iges": "model/iges",
      "msh": "model/mesh",
      "mesh": "model/mesh",
      "silo": "model/mesh",
      "mtl": "model/mtl",
      "obj": "model/obj",
      "stpz": "model/step+zip",
      "stpxz": "model/step-xml+zip",
      "stl": "model/stl",
      "wrl": "model/vrml",
      "vrml": "model/vrml",
      "x3db": "model/x3d+fastinfoset",
      "x3dbz": "model/x3d+binary",
      "x3dv": "model/x3d-vrml",
      "x3dvz": "model/x3d+vrml",
      "x3d": "model/x3d+xml",
      "x3dz": "model/x3d+xml",
      "appcache": "text/cache-manifest",
      "manifest": "text/cache-manifest",
      "ics": "text/calendar",
      "ifb": "text/calendar",
      "coffee": "text/coffeescript",
      "litcoffee": "text/coffeescript",
      "css": "text/css",
      "csv": "text/csv",
      "html": "text/html",
      "htm": "text/html",
      "shtml": "text/html",
      "jade": "text/jade",
      "jsx": "text/jsx",
      "less": "text/less",
      "markdown": "text/markdown",
      "md": "text/markdown",
      "mml": "text/mathml",
      "mdx": "text/mdx",
      "n3": "text/n3",
      "txt": "text/plain",
      "text": "text/plain",
      "conf": "text/plain",
      "def": "text/plain",
      "list": "text/plain",
      "log": "text/plain",
      "in": "text/plain",
      "ini": "text/plain",
      "dsc": "text/prs.lines.tag",
      "rtx": "text/richtext",
      "sgml": "text/sgml",
      "sgm": "text/sgml",
      "shex": "text/shex",
      "slim": "text/slim",
      "slm": "text/slim",
      "spdx": "text/spdx",
      "stylus": "text/stylus",
      "styl": "text/stylus",
      "tsv": "text/tab-separated-values",
      "t": "text/troff",
      "tr": "text/troff",
      "roff": "text/troff",
      "man": "text/troff",
      "me": "text/troff",
      "ms": "text/troff",
      "ttl": "text/turtle",
      "uri": "text/uri-list",
      "uris": "text/uri-list",
      "urls": "text/uri-list",
      "vcard": "text/vcard",
      "vtt": "text/vtt",
      "yaml": "text/yaml",
      "yml": "text/yaml",
      "3gp": "video/3gpp",
      "3g2": "video/3gpp2",
      "h261": "video/h261",
      "h263": "video/h263",
      "h264": "video/h264",
      "m4s": "video/iso.segment",
      "jpgv": "video/jpeg",
      "jpgm": "image/jpm",
      "mj2": "video/mj2",
      "mjp2": "video/mj2",
      "ts": "video/mp2t",
      "mp4": "video/mp4",
      "mp4v": "video/mp4",
      "mpg4": "video/mp4",
      "mpeg": "video/mpeg",
      "mpg": "video/mpeg",
      "mpe": "video/mpeg",
      "m1v": "video/mpeg",
      "m2v": "video/mpeg",
      "ogv": "video/ogg",
      "qt": "video/quicktime",
      "mov": "video/quicktime",
      "webm": "video/webm"
    };
    function lookup(extn) {
      let tmp = ("" + extn).trim().toLowerCase();
      let idx = tmp.lastIndexOf(".");
      return mimes[!~idx ? tmp : tmp.substring(++idx)];
    }
    var noop$1 = () => {
    };
    function isMatch(uri, arr) {
      for (let i2 = 0; i2 < arr.length; i2++) {
        if (arr[i2].test(uri))
          return true;
      }
    }
    function toAssume(uri, extns) {
      let i2 = 0, x2, len = uri.length - 1;
      if (uri.charCodeAt(len) === 47) {
        uri = uri.substring(0, len);
      }
      let arr = [], tmp = `${uri}/index`;
      for (; i2 < extns.length; i2++) {
        x2 = extns[i2] ? `.${extns[i2]}` : "";
        if (uri)
          arr.push(uri + x2);
        arr.push(tmp + x2);
      }
      return arr;
    }
    function viaCache(cache2, uri, extns) {
      let i2 = 0, data2, arr = toAssume(uri, extns);
      for (; i2 < arr.length; i2++) {
        if (data2 = cache2[arr[i2]])
          return data2;
      }
    }
    function viaLocal(dir, isEtag, uri, extns) {
      let i2 = 0, arr = toAssume(uri, extns);
      let abs, stats, name, headers;
      for (; i2 < arr.length; i2++) {
        abs = path$t.normalize(path$t.join(dir, name = arr[i2]));
        if (abs.startsWith(dir) && fs__namespace.existsSync(abs)) {
          stats = fs__namespace.statSync(abs);
          if (stats.isDirectory())
            continue;
          headers = toHeaders(name, stats, isEtag);
          headers["Cache-Control"] = isEtag ? "no-cache" : "no-store";
          return { abs, stats, headers };
        }
      }
    }
    function is404(req2, res) {
      return res.statusCode = 404, res.end();
    }
    function send(req2, res, file, stats, headers) {
      let code = 200, tmp, opts = {};
      headers = __spreadValues2({}, headers);
      for (let key in headers) {
        tmp = res.getHeader(key);
        if (tmp)
          headers[key] = tmp;
      }
      if (tmp = res.getHeader("content-type")) {
        headers["Content-Type"] = tmp;
      }
      if (req2.headers.range) {
        code = 206;
        let [x2, y3] = req2.headers.range.replace("bytes=", "").split("-");
        let end = opts.end = parseInt(y3, 10) || stats.size - 1;
        let start = opts.start = parseInt(x2, 10) || 0;
        if (start >= stats.size || end >= stats.size) {
          res.setHeader("Content-Range", `bytes */${stats.size}`);
          res.statusCode = 416;
          return res.end();
        }
        headers["Content-Range"] = `bytes ${start}-${end}/${stats.size}`;
        headers["Content-Length"] = end - start + 1;
        headers["Accept-Ranges"] = "bytes";
      }
      res.writeHead(code, headers);
      fs__namespace.createReadStream(file, opts).pipe(res);
    }
    var ENCODING = {
      ".br": "br",
      ".gz": "gzip"
    };
    function toHeaders(name, stats, isEtag) {
      let enc = ENCODING[name.slice(-3)];
      let ctype = lookup(name.slice(0, enc && -3)) || "";
      if (ctype === "text/html")
        ctype += ";charset=utf-8";
      let headers = {
        "Content-Length": stats.size,
        "Content-Type": ctype,
        "Last-Modified": stats.mtime.toUTCString()
      };
      if (enc)
        headers["Content-Encoding"] = enc;
      if (isEtag)
        headers["ETag"] = `W/"${stats.size}-${stats.mtime.getTime()}"`;
      return headers;
    }
    function sirv(dir, opts = {}) {
      dir = path$t.resolve(dir || ".");
      let isNotFound = opts.onNoMatch || is404;
      let setHeaders2 = opts.setHeaders || noop$1;
      let extensions2 = opts.extensions || ["html", "htm"];
      let gzips = opts.gzip && extensions2.map((x2) => `${x2}.gz`).concat("gz");
      let brots = opts.brotli && extensions2.map((x2) => `${x2}.br`).concat("br");
      const FILES = {};
      let fallback = "/";
      let isEtag = !!opts.etag;
      let isSPA = !!opts.single;
      if (typeof opts.single === "string") {
        let idx = opts.single.lastIndexOf(".");
        fallback += !!~idx ? opts.single.substring(0, idx) : opts.single;
      }
      let ignores = [];
      if (opts.ignores !== false) {
        ignores.push(/[/]([A-Za-z\s\d~$._-]+\.\w+){1,}$/);
        if (opts.dotfiles)
          ignores.push(/\/\.\w/);
        else
          ignores.push(/\/\.well-known/);
        [].concat(opts.ignores || []).forEach((x2) => {
          ignores.push(new RegExp(x2, "i"));
        });
      }
      let cc = opts.maxAge != null && `public,max-age=${opts.maxAge}`;
      if (cc && opts.immutable)
        cc += ",immutable";
      else if (cc && opts.maxAge === 0)
        cc += ",must-revalidate";
      if (!opts.dev) {
        list(dir, (name, abs, stats) => {
          if (/\.well-known[\\+\/]/.test(name))
            ;
          else if (!opts.dotfiles && /(^\.|[\\+|\/+]\.)/.test(name))
            return;
          let headers = toHeaders(name, stats, isEtag);
          if (cc)
            headers["Cache-Control"] = cc;
          FILES["/" + name.normalize().replace(/\\+/g, "/")] = { abs, stats, headers };
        });
      }
      let lookup2 = opts.dev ? viaLocal.bind(0, dir, isEtag) : viaCache.bind(0, FILES);
      return function(req2, res, next) {
        let extns = [""];
        let pathname = parse$5(req2).pathname;
        let val = req2.headers["accept-encoding"] || "";
        if (gzips && val.includes("gzip"))
          extns.unshift(...gzips);
        if (brots && /(br|brotli)/i.test(val))
          extns.unshift(...brots);
        extns.push(...extensions2);
        if (pathname.indexOf("%") !== -1) {
          try {
            pathname = decodeURIComponent(pathname);
          } catch (err) {
          }
        }
        let data2 = lookup2(pathname, extns) || isSPA && !isMatch(pathname, ignores) && lookup2(fallback, extns);
        if (!data2)
          return next ? next() : isNotFound(req2, res);
        if (isEtag && req2.headers["if-none-match"] === data2.headers["ETag"]) {
          res.writeHead(304);
          return res.end();
        }
        if (gzips || brots) {
          res.setHeader("Vary", "Accept-Encoding");
        }
        setHeaders2(res, pathname, data2.stats);
        send(req2, res, data2.abs, data2.stats, data2.headers);
      };
    }
    var sirvOptions = {
      dev: true,
      etag: true,
      extensions: [],
      setHeaders(res, pathname) {
        if (/\.[tj]sx?$/.test(pathname)) {
          res.setHeader("Content-Type", "application/javascript");
        }
      }
    };
    function servePublicMiddleware(dir) {
      const serve = sirv(dir, sirvOptions);
      return function viteServePublicMiddleware(req2, res, next) {
        if (isImportRequest(req2.url) || isInternalRequest(req2.url)) {
          return next();
        }
        serve(req2, res, next);
      };
    }
    function serveStaticMiddleware(dir, server2) {
      const serve = sirv(dir, sirvOptions);
      return function viteServeStaticMiddleware(req2, res, next) {
        const cleanedUrl = cleanUrl(req2.url);
        if (cleanedUrl.endsWith("/") || path__default.extname(cleanedUrl) === ".html" || isInternalRequest(req2.url)) {
          return next();
        }
        const url2 = decodeURI(req2.url);
        let redirected;
        for (const { find: find2, replacement: replacement2 } of server2.config.resolve.alias) {
          const matches2 = typeof find2 === "string" ? url2.startsWith(find2) : find2.test(url2);
          if (matches2) {
            redirected = url2.replace(find2, replacement2);
            break;
          }
        }
        if (redirected) {
          if (redirected.startsWith(dir)) {
            redirected = redirected.slice(dir.length);
          }
        }
        const resolvedUrl = redirected || url2;
        let fileUrl = path__default.resolve(dir, resolvedUrl.replace(/^\//, ""));
        if (resolvedUrl.endsWith("/") && !fileUrl.endsWith("/")) {
          fileUrl = fileUrl + "/";
        }
        if (!ensureServingAccess(fileUrl, server2, res, next)) {
          return;
        }
        if (redirected) {
          req2.url = redirected;
        }
        serve(req2, res, next);
      };
    }
    function serveRawFsMiddleware(server2) {
      const serveFromRoot = sirv("/", sirvOptions);
      return function viteServeRawFsMiddleware(req2, res, next) {
        let url2 = req2.url;
        if (url2.startsWith(FS_PREFIX)) {
          if (!ensureServingAccess(slash$3(path__default.resolve(fsPathFromId(url2))), server2, res, next)) {
            return;
          }
          url2 = url2.slice(FS_PREFIX.length);
          if (isWindows$4)
            url2 = url2.replace(/^[A-Z]:/i, "");
          req2.url = url2;
          serveFromRoot(req2, res, next);
        } else {
          next();
        }
      };
    }
    var _matchOptions = { matchBase: true };
    function isFileServingAllowed(url2, server2) {
      if (!server2.config.server.fs.strict)
        return true;
      const cleanedUrl = cleanUrl(url2);
      const file = ensureLeadingSlash(normalizePath$4(cleanedUrl));
      if (server2.config.server.fs.deny.some((i2) => micromatch_1.isMatch(file, i2, _matchOptions)))
        return false;
      if (server2.moduleGraph.safeModulesPath.has(file))
        return true;
      if (server2.config.server.fs.allow.some((i2) => file.startsWith(i2 + "/")))
        return true;
      return false;
    }
    function ensureServingAccess(url2, server2, res, next) {
      if (isFileServingAllowed(url2, server2)) {
        return true;
      }
      if (isFileReadable(cleanUrl(url2))) {
        const urlMessage = `The request url "${url2}" is outside of Vite serving allow list.`;
        const hintMessage = `
${server2.config.server.fs.allow.map((i2) => `- ${i2}`).join("\n")}

Refer to docs https://vitejs.dev/config/#server-fs-allow for configurations and more details.`;
        server2.config.logger.error(urlMessage);
        server2.config.logger.warnOnce(hintMessage + "\n");
        res.statusCode = 403;
        res.write(renderRestrictedErrorHTML(urlMessage + "\n" + hintMessage));
        res.end();
      } else {
        next();
      }
      return false;
    }
    function renderRestrictedErrorHTML(msg) {
      const html = String.raw;
      return html`
    <body>
      <h1>403 Restricted</h1>
      <p>${msg.replace(/\n/g, "<br/>")}</p>
      <style>
        body {
          padding: 1em 2em;
        }
      </style>
    </body>
  `;
    }
    var debugLoad = createDebugger("vite:load");
    var debugTransform = createDebugger("vite:transform");
    var debugCache$1 = createDebugger("vite:cache");
    var isDebug$2 = !!process.env.DEBUG;
    function transformRequest(url2, server2, options2 = {}) {
      const cacheKey = (options2.ssr ? "ssr:" : options2.html ? "html:" : "") + url2;
      let request = server2._pendingRequests.get(cacheKey);
      if (!request) {
        request = doTransform(url2, server2, options2);
        server2._pendingRequests.set(cacheKey, request);
        const done = () => server2._pendingRequests.delete(cacheKey);
        request.then(done, done);
      }
      return request;
    }
    async function doTransform(url2, server2, options2) {
      var _a2, _b;
      url2 = removeTimestampQuery(url2);
      const { config: config2, pluginContainer, moduleGraph, watcher } = server2;
      const { root, logger } = config2;
      const prettyUrl = isDebug$2 ? prettifyUrl(url2, root) : "";
      const ssr = !!options2.ssr;
      const module2 = await server2.moduleGraph.getModuleByUrl(url2);
      const cached = module2 && (ssr ? module2.ssrTransformResult : module2.transformResult);
      if (cached) {
        isDebug$2 && debugCache$1(`[memory] ${prettyUrl}`);
        return cached;
      }
      const id = ((_a2 = await pluginContainer.resolveId(url2)) === null || _a2 === void 0 ? void 0 : _a2.id) || url2;
      const file = cleanUrl(id);
      let code = null;
      let map2 = null;
      const loadStart = isDebug$2 ? perf_hooks.performance.now() : 0;
      const loadResult = await pluginContainer.load(id, { ssr });
      if (loadResult == null) {
        if (options2.html && !id.endsWith(".html")) {
          return null;
        }
        if (options2.ssr || isFileServingAllowed(file, server2)) {
          try {
            code = await fs$r.promises.readFile(file, "utf-8");
            isDebug$2 && debugLoad(`${timeFrom(loadStart)} [fs] ${prettyUrl}`);
          } catch (e2) {
            if (e2.code !== "ENOENT") {
              throw e2;
            }
          }
        }
        if (code) {
          try {
            map2 = (_b = convertSourceMap.fromSource(code) || convertSourceMap.fromMapFileSource(code, path__default.dirname(file))) === null || _b === void 0 ? void 0 : _b.toObject();
          } catch (e2) {
            logger.warn(`Failed to load source map for ${url2}.`, {
              timestamp: true
            });
          }
        }
      } else {
        isDebug$2 && debugLoad(`${timeFrom(loadStart)} [plugin] ${prettyUrl}`);
        if (isObject$3(loadResult)) {
          code = loadResult.code;
          map2 = loadResult.map;
        } else {
          code = loadResult;
        }
      }
      if (code == null) {
        if (checkPublicFile(url2, config2)) {
          throw new Error(`Failed to load url ${url2} (resolved id: ${id}). This file is in /public and will be copied as-is during build without going through the plugin transforms, and therefore should not be imported from source code. It can only be referenced via HTML tags.`);
        } else {
          return null;
        }
      }
      const mod = await moduleGraph.ensureEntryFromUrl(url2);
      ensureWatchedFile(watcher, mod.file, root);
      const transformStart = isDebug$2 ? perf_hooks.performance.now() : 0;
      const transformResult = await pluginContainer.transform(code, id, {
        inMap: map2,
        ssr
      });
      if (transformResult == null || isObject$3(transformResult) && transformResult.code == null) {
        isDebug$2 && debugTransform(timeFrom(transformStart) + source.dim(` [skipped] ${prettyUrl}`));
      } else {
        isDebug$2 && debugTransform(`${timeFrom(transformStart)} ${prettyUrl}`);
        code = transformResult.code;
        map2 = transformResult.map;
      }
      if (map2 && mod.file) {
        map2 = typeof map2 === "string" ? JSON.parse(map2) : map2;
        if (map2.mappings && !map2.sourcesContent) {
          await injectSourcesContent(map2, mod.file, logger);
        }
      }
      if (ssr) {
        return mod.ssrTransformResult = await ssrTransform(code, map2, url2);
      } else {
        return mod.transformResult = {
          code,
          map: map2,
          etag: etag_1(code, { weak: true })
        };
      }
    }
    var NEW_DEPENDENCY_BUILD_TIMEOUT = 1e3;
    var debugCache = createDebugger("vite:cache");
    var isDebug$1 = !!process.env.DEBUG;
    var knownIgnoreList = new Set(["/", "/favicon.ico"]);
    function transformMiddleware(server2) {
      const { config: { root, logger, cacheDir }, moduleGraph } = server2;
      let cacheDirPrefix;
      if (cacheDir) {
        const cacheDirRelative = normalizePath$4(path__default.relative(root, cacheDir));
        if (cacheDirRelative.startsWith("../")) {
          cacheDirPrefix = `/@fs/${normalizePath$4(cacheDir).replace(/^\//, "")}`;
        } else {
          cacheDirPrefix = `/${cacheDirRelative}`;
        }
      }
      return async function viteTransformMiddleware(req2, res, next) {
        var _a2, _b, _c, _d, _e2, _f, _g, _h2;
        if (req2.method !== "GET" || knownIgnoreList.has(req2.url)) {
          return next();
        }
        if (server2._pendingReload && !((_a2 = req2.url) === null || _a2 === void 0 ? void 0 : _a2.startsWith(CLIENT_PUBLIC_PATH)) && !((_b = req2.url) === null || _b === void 0 ? void 0 : _b.includes("vite/dist/client"))) {
          try {
            await Promise.race([
              server2._pendingReload,
              new Promise((_2, reject) => setTimeout(reject, NEW_DEPENDENCY_BUILD_TIMEOUT))
            ]);
          } catch {
            if (!res.writableEnded) {
              res.statusCode = 408;
              res.end(`<h1>[vite] Something unexpected happened while optimizing "${req2.url}"<h1><p>The current page should have reloaded by now</p>`);
            }
            return;
          }
        }
        let url2 = decodeURI(removeTimestampQuery(req2.url)).replace(NULL_BYTE_PLACEHOLDER, "\0");
        const withoutQuery = cleanUrl(url2);
        try {
          const isSourceMap = withoutQuery.endsWith(".map");
          if (isSourceMap) {
            const originalUrl = url2.replace(/\.map($|\?)/, "$1");
            const map2 = (_d = (_c = await moduleGraph.getModuleByUrl(originalUrl)) === null || _c === void 0 ? void 0 : _c.transformResult) === null || _d === void 0 ? void 0 : _d.map;
            if (map2) {
              return send$1(req2, res, JSON.stringify(map2), "json");
            } else {
              return next();
            }
          }
          const publicDir = normalizePath$4(server2.config.publicDir);
          const rootDir = normalizePath$4(server2.config.root);
          if (publicDir.startsWith(rootDir)) {
            const publicPath = `${publicDir.slice(rootDir.length)}/`;
            if (url2.startsWith(publicPath)) {
              logger.warn(source.yellow(`files in the public directory are served at the root path.
Instead of ${source.cyan(url2)}, use ${source.cyan(url2.replace(publicPath, "/"))}.`));
            }
          }
          if (isJSRequest(url2) || isImportRequest(url2) || isCSSRequest(url2) || isHTMLProxy(url2)) {
            url2 = removeImportQuery(url2);
            url2 = unwrapId$1(url2);
            if (isCSSRequest(url2) && !isDirectRequest(url2) && ((_e2 = req2.headers.accept) === null || _e2 === void 0 ? void 0 : _e2.includes("text/css"))) {
              url2 = injectQuery(url2, "direct");
            }
            const ifNoneMatch = req2.headers["if-none-match"];
            if (ifNoneMatch && ((_g = (_f = await moduleGraph.getModuleByUrl(url2)) === null || _f === void 0 ? void 0 : _f.transformResult) === null || _g === void 0 ? void 0 : _g.etag) === ifNoneMatch) {
              isDebug$1 && debugCache(`[304] ${prettifyUrl(url2, root)}`);
              res.statusCode = 304;
              return res.end();
            }
            const result2 = await transformRequest(url2, server2, {
              html: (_h2 = req2.headers.accept) === null || _h2 === void 0 ? void 0 : _h2.includes("text/html")
            });
            if (result2) {
              const type = isDirectCSSRequest(url2) ? "css" : "js";
              const isDep = DEP_VERSION_RE.test(url2) || cacheDirPrefix && url2.startsWith(cacheDirPrefix);
              return send$1(req2, res, result2.code, type, result2.etag, isDep ? "max-age=31536000,immutable" : "no-cache", result2.map);
            }
          }
        } catch (e2) {
          return next(e2);
        }
        next();
      };
    }
    function createDevHtmlTransformFn(server2) {
      const [preHooks, postHooks] = resolveHtmlTransforms(server2.config.plugins);
      return (url2, html, originalUrl) => {
        return applyHtmlTransforms(html, [...preHooks, devHtmlHook, ...postHooks], {
          path: url2,
          filename: getHtmlFilename(url2, server2),
          server: server2,
          originalUrl
        });
      };
    }
    function getHtmlFilename(url2, server2) {
      if (url2.startsWith(FS_PREFIX)) {
        return decodeURIComponent(fsPathFromId(url2));
      } else {
        return decodeURIComponent(path__default.join(server2.config.root, url2.slice(1)));
      }
    }
    var startsWithSingleSlashRE = /^\/(?!\/)/;
    var processNodeUrl = (node2, s2, config2, htmlPath, originalUrl, moduleGraph) => {
      var _a2;
      let url2 = ((_a2 = node2.value) === null || _a2 === void 0 ? void 0 : _a2.content) || "";
      if (moduleGraph) {
        const mod = moduleGraph.urlToModuleMap.get(url2);
        if (mod && mod.lastHMRTimestamp > 0) {
          url2 = injectQuery(url2, `t=${mod.lastHMRTimestamp}`);
        }
      }
      if (startsWithSingleSlashRE.test(url2)) {
        s2.overwrite(node2.value.loc.start.offset, node2.value.loc.end.offset, `"${config2.base + url2.slice(1)}"`);
      } else if (url2.startsWith(".") && originalUrl && originalUrl !== "/" && htmlPath === "/index.html") {
        s2.overwrite(node2.value.loc.start.offset, node2.value.loc.end.offset, `"${path__default.posix.join(path__default.posix.relative(originalUrl, "/"), url2.slice(1))}"`);
      }
    };
    var devHtmlHook = async (html, { path: htmlPath, server: server2, originalUrl }) => {
      const { config: config2, moduleGraph } = server2;
      const base2 = config2.base || "/";
      const s2 = new MagicString(html);
      let scriptModuleIndex = -1;
      const filePath = cleanUrl(htmlPath);
      await traverseHtml(html, htmlPath, (node2) => {
        if (node2.type !== 1) {
          return;
        }
        if (node2.tag === "script") {
          const { src: src2, isModule } = getScriptInfo(node2);
          if (isModule) {
            scriptModuleIndex++;
          }
          if (src2) {
            processNodeUrl(src2, s2, config2, htmlPath, originalUrl, moduleGraph);
          } else if (isModule) {
            const url2 = filePath.replace(normalizePath$4(config2.root), "");
            const contents = node2.children.map((child) => child.content || "").join("");
            addToHTMLProxyCache(config2, url2, scriptModuleIndex, contents);
            const modulePath = `${config2.base + htmlPath.slice(1)}?html-proxy&index=${scriptModuleIndex}.js`;
            const module2 = server2 === null || server2 === void 0 ? void 0 : server2.moduleGraph.getModuleById(modulePath);
            if (module2) {
              server2 === null || server2 === void 0 ? void 0 : server2.moduleGraph.invalidateModule(module2);
            }
            s2.overwrite(node2.loc.start.offset, node2.loc.end.offset, `<script type="module" src="${modulePath}"><\/script>`);
          }
        }
        const assetAttrs = assetAttrsConfig[node2.tag];
        if (assetAttrs) {
          for (const p2 of node2.props) {
            if (p2.type === 6 && p2.value && assetAttrs.includes(p2.name)) {
              processNodeUrl(p2, s2, config2, htmlPath, originalUrl);
            }
          }
        }
      });
      html = s2.toString();
      return {
        html,
        tags: [
          {
            tag: "script",
            attrs: {
              type: "module",
              src: path__default.posix.join(base2, CLIENT_PUBLIC_PATH)
            },
            injectTo: "head-prepend"
          }
        ]
      };
    };
    function indexHtmlMiddleware(server2) {
      return async function viteIndexHtmlMiddleware(req2, res, next) {
        if (res.writableEnded) {
          return next();
        }
        const url2 = req2.url && cleanUrl(req2.url);
        if ((url2 === null || url2 === void 0 ? void 0 : url2.endsWith(".html")) && req2.headers["sec-fetch-dest"] !== "script") {
          const filename2 = getHtmlFilename(url2, server2);
          if (fs__default.existsSync(filename2)) {
            try {
              let html = fs__default.readFileSync(filename2, "utf-8");
              html = await server2.transformIndexHtml(url2, html, req2.originalUrl);
              return send$1(req2, res, html, "html");
            } catch (e2) {
              return next(e2);
            }
          }
        }
        next();
      };
    }
    var logTime = createDebugger("vite:time");
    function timeMiddleware(root) {
      return function viteTimeMiddleware(req2, res, next) {
        const start = perf_hooks.performance.now();
        const end = res.end;
        res.end = (...args) => {
          logTime(`${timeFrom(start)} ${prettifyUrl(req2.url, root)}`);
          return end.call(res, ...args);
        };
        next();
      };
    }
    var ModuleNode = class {
      constructor(url2) {
        this.id = null;
        this.file = null;
        this.importers = new Set();
        this.importedModules = new Set();
        this.acceptedHmrDeps = new Set();
        this.isSelfAccepting = false;
        this.transformResult = null;
        this.ssrTransformResult = null;
        this.ssrModule = null;
        this.lastHMRTimestamp = 0;
        this.url = url2;
        this.type = isDirectCSSRequest(url2) ? "css" : "js";
      }
    };
    function invalidateSSRModule(mod, seen2) {
      if (seen2.has(mod)) {
        return;
      }
      seen2.add(mod);
      mod.ssrModule = null;
      mod.importers.forEach((importer) => invalidateSSRModule(importer, seen2));
    }
    var ModuleGraph = class {
      constructor(resolveId2) {
        this.resolveId = resolveId2;
        this.urlToModuleMap = new Map();
        this.idToModuleMap = new Map();
        this.fileToModulesMap = new Map();
        this.safeModulesPath = new Set();
      }
      async getModuleByUrl(rawUrl) {
        const [url2] = await this.resolveUrl(rawUrl);
        return this.urlToModuleMap.get(url2);
      }
      getModuleById(id) {
        return this.idToModuleMap.get(removeTimestampQuery(id));
      }
      getModulesByFile(file) {
        return this.fileToModulesMap.get(file);
      }
      onFileChange(file) {
        const mods = this.getModulesByFile(file);
        if (mods) {
          const seen2 = new Set();
          mods.forEach((mod) => {
            this.invalidateModule(mod, seen2);
          });
        }
      }
      invalidateModule(mod, seen2 = new Set()) {
        mod.info = void 0;
        mod.transformResult = null;
        mod.ssrTransformResult = null;
        invalidateSSRModule(mod, seen2);
      }
      invalidateAll() {
        const seen2 = new Set();
        this.idToModuleMap.forEach((mod) => {
          this.invalidateModule(mod, seen2);
        });
      }
      async updateModuleInfo(mod, importedModules, acceptedModules, isSelfAccepting) {
        mod.isSelfAccepting = isSelfAccepting;
        const prevImports = mod.importedModules;
        const nextImports = mod.importedModules = new Set();
        let noLongerImported;
        for (const imported of importedModules) {
          const dep = typeof imported === "string" ? await this.ensureEntryFromUrl(imported) : imported;
          dep.importers.add(mod);
          nextImports.add(dep);
        }
        prevImports.forEach((dep) => {
          if (!nextImports.has(dep)) {
            dep.importers.delete(mod);
            if (!dep.importers.size) {
              (noLongerImported || (noLongerImported = new Set())).add(dep);
            }
          }
        });
        const deps = mod.acceptedHmrDeps = new Set();
        for (const accepted of acceptedModules) {
          const dep = typeof accepted === "string" ? await this.ensureEntryFromUrl(accepted) : accepted;
          deps.add(dep);
        }
        return noLongerImported;
      }
      async ensureEntryFromUrl(rawUrl) {
        const [url2, resolvedId, meta] = await this.resolveUrl(rawUrl);
        let mod = this.urlToModuleMap.get(url2);
        if (!mod) {
          mod = new ModuleNode(url2);
          if (meta)
            mod.meta = meta;
          this.urlToModuleMap.set(url2, mod);
          mod.id = resolvedId;
          this.idToModuleMap.set(resolvedId, mod);
          const file = mod.file = cleanUrl(resolvedId);
          let fileMappedModules = this.fileToModulesMap.get(file);
          if (!fileMappedModules) {
            fileMappedModules = new Set();
            this.fileToModulesMap.set(file, fileMappedModules);
          }
          fileMappedModules.add(mod);
        }
        return mod;
      }
      createFileOnlyEntry(file) {
        file = normalizePath$4(file);
        let fileMappedModules = this.fileToModulesMap.get(file);
        if (!fileMappedModules) {
          fileMappedModules = new Set();
          this.fileToModulesMap.set(file, fileMappedModules);
        }
        const url2 = `${FS_PREFIX}${file}`;
        for (const m3 of fileMappedModules) {
          if (m3.url === url2 || m3.id === file) {
            return m3;
          }
        }
        const mod = new ModuleNode(url2);
        mod.file = file;
        fileMappedModules.add(mod);
        return mod;
      }
      async resolveUrl(url2) {
        url2 = removeImportQuery(removeTimestampQuery(url2));
        const resolved = await this.resolveId(url2);
        const resolvedId = (resolved === null || resolved === void 0 ? void 0 : resolved.id) || url2;
        const ext2 = path$t.extname(cleanUrl(resolvedId));
        const { pathname, search, hash } = require$$0$6.parse(url2);
        if (ext2 && !pathname.endsWith(ext2)) {
          url2 = pathname + ext2 + (search || "") + (hash || "");
        }
        return [url2, resolvedId, resolved === null || resolved === void 0 ? void 0 : resolved.meta];
      }
    };
    var debugHmr = createDebugger("vite:hmr");
    var normalizedClientDir = normalizePath$4(CLIENT_DIR);
    function getShortName(file, root) {
      return file.startsWith(root + "/") ? path__default.posix.relative(root, file) : file;
    }
    async function handleHMRUpdate(file, server2) {
      const { ws: ws2, config: config2, moduleGraph } = server2;
      const shortFile = getShortName(file, config2.root);
      const isConfig = file === config2.configFile;
      const isConfigDependency = config2.configFileDependencies.some((name) => file === path__default.resolve(name));
      const isEnv = config2.inlineConfig.envFile !== false && (file === ".env" || file.startsWith(".env."));
      if (isConfig || isConfigDependency || isEnv) {
        debugHmr(`[config change] ${source.dim(shortFile)}`);
        config2.logger.info(source.green(`${path__default.relative(process.cwd(), file)} changed, restarting server...`), { clear: true, timestamp: true });
        try {
          await server2.restart();
        } catch (e2) {
          config2.logger.error(source.red(e2));
        }
        return;
      }
      debugHmr(`[file change] ${source.dim(shortFile)}`);
      if (file.startsWith(normalizedClientDir)) {
        ws2.send({
          type: "full-reload",
          path: "*"
        });
        return;
      }
      const mods = moduleGraph.getModulesByFile(file);
      const timestamp2 = Date.now();
      const hmrContext = {
        file,
        timestamp: timestamp2,
        modules: mods ? [...mods] : [],
        read: () => readModifiedFile(file),
        server: server2
      };
      for (const plugin of config2.plugins) {
        if (plugin.handleHotUpdate) {
          const filteredModules = await plugin.handleHotUpdate(hmrContext);
          if (filteredModules) {
            hmrContext.modules = filteredModules;
          }
        }
      }
      if (!hmrContext.modules.length) {
        if (file.endsWith(".html")) {
          config2.logger.info(source.green(`page reload `) + source.dim(shortFile), {
            clear: true,
            timestamp: true
          });
          ws2.send({
            type: "full-reload",
            path: config2.server.middlewareMode ? "*" : "/" + normalizePath$4(path__default.relative(config2.root, file))
          });
        } else {
          debugHmr(`[no modules matched] ${source.dim(shortFile)}`);
        }
        return;
      }
      updateModules(shortFile, hmrContext.modules, timestamp2, server2);
    }
    function updateModules(file, modules2, timestamp2, { config: config2, ws: ws2 }) {
      const updates = [];
      const invalidatedModules = new Set();
      let needFullReload = false;
      for (const mod of modules2) {
        invalidate(mod, timestamp2, invalidatedModules);
        if (needFullReload) {
          continue;
        }
        const boundaries = new Set();
        const hasDeadEnd = propagateUpdate(mod, boundaries);
        if (hasDeadEnd) {
          needFullReload = true;
          continue;
        }
        updates.push(...[...boundaries].map(({ boundary, acceptedVia }) => ({
          type: `${boundary.type}-update`,
          timestamp: timestamp2,
          path: boundary.url,
          acceptedPath: acceptedVia.url
        })));
      }
      if (needFullReload) {
        config2.logger.info(source.green(`page reload `) + source.dim(file), {
          clear: true,
          timestamp: true
        });
        ws2.send({
          type: "full-reload"
        });
      } else {
        config2.logger.info(updates.map(({ path: path2 }) => source.green(`hmr update `) + source.dim(path2)).join("\n"), { clear: true, timestamp: true });
        ws2.send({
          type: "update",
          updates
        });
      }
    }
    async function handleFileAddUnlink(file, server2, isUnlink = false) {
      var _a2;
      const modules2 = [...(_a2 = server2.moduleGraph.getModulesByFile(file)) !== null && _a2 !== void 0 ? _a2 : []];
      if (isUnlink && file in server2._globImporters) {
        delete server2._globImporters[file];
      } else {
        for (const i2 in server2._globImporters) {
          const { module: module2, importGlobs } = server2._globImporters[i2];
          for (const { base: base2, pattern: pattern2 } of importGlobs) {
            if (micromatch_1.isMatch(file, pattern2) || micromatch_1.isMatch(path__default.relative(base2, file), pattern2)) {
              modules2.push(module2);
              server2.moduleGraph.onFileChange(module2.file);
              break;
            }
          }
        }
      }
      if (modules2.length > 0) {
        updateModules(getShortName(file, server2.config.root), modules2, Date.now(), server2);
      }
    }
    function propagateUpdate(node2, boundaries, currentChain = [node2]) {
      if (node2.isSelfAccepting) {
        boundaries.add({
          boundary: node2,
          acceptedVia: node2
        });
        for (const importer of node2.importers) {
          if (isCSSRequest(importer.url) && !currentChain.includes(importer)) {
            propagateUpdate(importer, boundaries, currentChain.concat(importer));
          }
        }
        return false;
      }
      if (!node2.importers.size) {
        return true;
      }
      if (!isCSSRequest(node2.url) && [...node2.importers].every((i2) => isCSSRequest(i2.url))) {
        return true;
      }
      for (const importer of node2.importers) {
        const subChain = currentChain.concat(importer);
        if (importer.acceptedHmrDeps.has(node2)) {
          boundaries.add({
            boundary: importer,
            acceptedVia: node2
          });
          continue;
        }
        if (currentChain.includes(importer)) {
          return true;
        }
        if (propagateUpdate(importer, boundaries, subChain)) {
          return true;
        }
      }
      return false;
    }
    function invalidate(mod, timestamp2, seen2) {
      if (seen2.has(mod)) {
        return;
      }
      seen2.add(mod);
      mod.lastHMRTimestamp = timestamp2;
      mod.transformResult = null;
      mod.ssrModule = null;
      mod.ssrTransformResult = null;
      mod.importers.forEach((importer) => {
        if (!importer.acceptedHmrDeps.has(mod)) {
          invalidate(importer, timestamp2, seen2);
        }
      });
    }
    function handlePrunedModules(mods, { ws: ws2 }) {
      const t = Date.now();
      mods.forEach((mod) => {
        mod.lastHMRTimestamp = t;
        debugHmr(`[dispose] ${source.dim(mod.file)}`);
      });
      ws2.send({
        type: "prune",
        paths: [...mods].map((m3) => m3.url)
      });
    }
    function lexAcceptedHmrDeps(code, start, urls) {
      let state = 0;
      let prevState = 0;
      let currentDep = "";
      function addDep(index2) {
        urls.add({
          url: currentDep,
          start: index2 - currentDep.length - 1,
          end: index2 + 1
        });
        currentDep = "";
      }
      for (let i2 = start; i2 < code.length; i2++) {
        const char = code.charAt(i2);
        switch (state) {
          case 0:
          case 4:
            if (char === `'`) {
              prevState = state;
              state = 1;
            } else if (char === `"`) {
              prevState = state;
              state = 2;
            } else if (char === "`") {
              prevState = state;
              state = 3;
            } else if (/\s/.test(char)) {
              continue;
            } else {
              if (state === 0) {
                if (char === `[`) {
                  state = 4;
                } else {
                  return true;
                }
              } else if (state === 4) {
                if (char === `]`) {
                  return false;
                } else if (char === ",") {
                  continue;
                } else {
                  error$1(i2);
                }
              }
            }
            break;
          case 1:
            if (char === `'`) {
              addDep(i2);
              if (prevState === 0) {
                return false;
              } else {
                state = prevState;
              }
            } else {
              currentDep += char;
            }
            break;
          case 2:
            if (char === `"`) {
              addDep(i2);
              if (prevState === 0) {
                return false;
              } else {
                state = prevState;
              }
            } else {
              currentDep += char;
            }
            break;
          case 3:
            if (char === "`") {
              addDep(i2);
              if (prevState === 0) {
                return false;
              } else {
                state = prevState;
              }
            } else if (char === "$" && code.charAt(i2 + 1) === "{") {
              error$1(i2);
            } else {
              currentDep += char;
            }
            break;
          default:
            throw new Error("unknown import.meta.hot lexer state");
        }
      }
      return false;
    }
    function error$1(pos) {
      const err = new Error(`import.meta.accept() can only accept string literals or an Array of string literals.`);
      err.pos = pos;
      throw err;
    }
    async function readModifiedFile(file) {
      const content2 = fs__default.readFileSync(file, "utf-8");
      if (!content2) {
        const mtime = fs__default.statSync(file).mtimeMs;
        await new Promise((r2) => {
          let n3 = 0;
          const poll = async () => {
            n3++;
            const newMtime = fs__default.statSync(file).mtimeMs;
            if (newMtime !== mtime || n3 > 10) {
              r2(0);
            } else {
              setTimeout(poll, 10);
            }
          };
          setTimeout(poll, 10);
        });
        return fs__default.readFileSync(file, "utf-8");
      } else {
        return content2;
      }
    }
    var isWsl$2 = { exports: {} };
    var fs$7 = fs__default;
    var isDocker$2;
    function hasDockerEnv() {
      try {
        fs$7.statSync("/.dockerenv");
        return true;
      } catch (_2) {
        return false;
      }
    }
    function hasDockerCGroup() {
      try {
        return fs$7.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
      } catch (_2) {
        return false;
      }
    }
    var isDocker_1 = () => {
      if (isDocker$2 === void 0) {
        isDocker$2 = hasDockerEnv() || hasDockerCGroup();
      }
      return isDocker$2;
    };
    var os$3 = require$$0__default$1;
    var fs$6 = fs__default;
    var isDocker$1 = isDocker_1;
    var isWsl$1 = () => {
      if (process.platform !== "linux") {
        return false;
      }
      if (os$3.release().toLowerCase().includes("microsoft")) {
        if (isDocker$1()) {
          return false;
        }
        return true;
      }
      try {
        return fs$6.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker$1() : false;
      } catch (_2) {
        return false;
      }
    };
    if (process.env.__IS_WSL_TEST__) {
      isWsl$2.exports = isWsl$1;
    } else {
      isWsl$2.exports = isWsl$1();
    }
    var defineLazyProp = (object, propertyName, fn2) => {
      const define2 = (value) => Object.defineProperty(object, propertyName, { value, enumerable: true, writable: true });
      Object.defineProperty(object, propertyName, {
        configurable: true,
        enumerable: true,
        get() {
          const result2 = fn2();
          define2(result2);
          return result2;
        },
        set(value) {
          define2(value);
        }
      });
      return object;
    };
    var path$9 = path__default;
    var childProcess$3 = require$$1__default$5;
    var { promises: fs$5, constants: fsConstants } = fs__default;
    var isWsl = isWsl$2.exports;
    var isDocker = isDocker_1;
    var defineLazyProperty = defineLazyProp;
    var localXdgOpenPath = path$9.join(__dirname, "xdg-open");
    var { platform, arch } = process;
    var getWslDrivesMountPoint = (() => {
      const defaultMountPoint = "/mnt/";
      let mountPoint;
      return async function() {
        if (mountPoint) {
          return mountPoint;
        }
        const configFilePath = "/etc/wsl.conf";
        let isConfigFileExists = false;
        try {
          await fs$5.access(configFilePath, fsConstants.F_OK);
          isConfigFileExists = true;
        } catch {
        }
        if (!isConfigFileExists) {
          return defaultMountPoint;
        }
        const configContent = await fs$5.readFile(configFilePath, { encoding: "utf8" });
        const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
        if (!configMountPoint) {
          return defaultMountPoint;
        }
        mountPoint = configMountPoint.groups.mountPoint.trim();
        mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
        return mountPoint;
      };
    })();
    var pTryEach = async (array2, mapper) => {
      let latestError;
      for (const item of array2) {
        try {
          return await mapper(item);
        } catch (error2) {
          latestError = error2;
        }
      }
      throw latestError;
    };
    var baseOpen = async (options2) => {
      options2 = __spreadValues2({
        wait: false,
        background: false,
        newInstance: false,
        allowNonzeroExitCode: false
      }, options2);
      if (Array.isArray(options2.app)) {
        return pTryEach(options2.app, (singleApp) => baseOpen(__spreadProps2(__spreadValues2({}, options2), {
          app: singleApp
        })));
      }
      let { name: app, arguments: appArguments = [] } = options2.app || {};
      appArguments = [...appArguments];
      if (Array.isArray(app)) {
        return pTryEach(app, (appName) => baseOpen(__spreadProps2(__spreadValues2({}, options2), {
          app: {
            name: appName,
            arguments: appArguments
          }
        })));
      }
      let command2;
      const cliArguments = [];
      const childProcessOptions = {};
      if (platform === "darwin") {
        command2 = "open";
        if (options2.wait) {
          cliArguments.push("--wait-apps");
        }
        if (options2.background) {
          cliArguments.push("--background");
        }
        if (options2.newInstance) {
          cliArguments.push("--new");
        }
        if (app) {
          cliArguments.push("-a", app);
        }
      } else if (platform === "win32" || isWsl && !isDocker()) {
        const mountPoint = await getWslDrivesMountPoint();
        command2 = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
        cliArguments.push("-NoProfile", "-NonInteractive", "\u2013ExecutionPolicy", "Bypass", "-EncodedCommand");
        if (!isWsl) {
          childProcessOptions.windowsVerbatimArguments = true;
        }
        const encodedArguments = ["Start"];
        if (options2.wait) {
          encodedArguments.push("-Wait");
        }
        if (app) {
          encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList");
          if (options2.target) {
            appArguments.unshift(options2.target);
          }
        } else if (options2.target) {
          encodedArguments.push(`"${options2.target}"`);
        }
        if (appArguments.length > 0) {
          appArguments = appArguments.map((arg) => `"\`"${arg}\`""`);
          encodedArguments.push(appArguments.join(","));
        }
        options2.target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
      } else {
        if (app) {
          command2 = app;
        } else {
          const isBundled = !__dirname || __dirname === "/";
          let exeLocalXdgOpen = false;
          try {
            await fs$5.access(localXdgOpenPath, fsConstants.X_OK);
            exeLocalXdgOpen = true;
          } catch {
          }
          const useSystemXdgOpen = process.versions.electron || platform === "android" || isBundled || !exeLocalXdgOpen;
          command2 = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
        }
        if (appArguments.length > 0) {
          cliArguments.push(...appArguments);
        }
        if (!options2.wait) {
          childProcessOptions.stdio = "ignore";
          childProcessOptions.detached = true;
        }
      }
      if (options2.target) {
        cliArguments.push(options2.target);
      }
      if (platform === "darwin" && appArguments.length > 0) {
        cliArguments.push("--args", ...appArguments);
      }
      const subprocess = childProcess$3.spawn(command2, cliArguments, childProcessOptions);
      if (options2.wait) {
        return new Promise((resolve2, reject) => {
          subprocess.once("error", reject);
          subprocess.once("close", (exitCode) => {
            if (options2.allowNonzeroExitCode && exitCode > 0) {
              reject(new Error(`Exited with code ${exitCode}`));
              return;
            }
            resolve2(subprocess);
          });
        });
      }
      subprocess.unref();
      return subprocess;
    };
    var open = (target, options2) => {
      if (typeof target !== "string") {
        throw new TypeError("Expected a `target`");
      }
      return baseOpen(__spreadProps2(__spreadValues2({}, options2), {
        target
      }));
    };
    var openApp = (name, options2) => {
      if (typeof name !== "string") {
        throw new TypeError("Expected a `name`");
      }
      const { arguments: appArguments = [] } = options2 || {};
      if (appArguments !== void 0 && appArguments !== null && !Array.isArray(appArguments)) {
        throw new TypeError("Expected `appArguments` as Array type");
      }
      return baseOpen(__spreadProps2(__spreadValues2({}, options2), {
        app: {
          name,
          arguments: appArguments
        }
      }));
    };
    function detectArchBinary(binary2) {
      if (typeof binary2 === "string" || Array.isArray(binary2)) {
        return binary2;
      }
      const { [arch]: archBinary } = binary2;
      if (!archBinary) {
        throw new Error(`${arch} is not supported`);
      }
      return archBinary;
    }
    function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
      if (wsl && isWsl) {
        return detectArchBinary(wsl);
      }
      if (!platformBinary) {
        throw new Error(`${platform} is not supported`);
      }
      return detectArchBinary(platformBinary);
    }
    var apps = {};
    defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
      darwin: "google chrome",
      win32: "chrome",
      linux: ["google-chrome", "google-chrome-stable", "chromium"]
    }, {
      wsl: {
        ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
        x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
      }
    }));
    defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
      darwin: "firefox",
      win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
      linux: "firefox"
    }, {
      wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
    }));
    defineLazyProperty(apps, "edge", () => detectPlatformBinary({
      darwin: "microsoft edge",
      win32: "msedge",
      linux: ["microsoft-edge", "microsoft-edge-dev"]
    }, {
      wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
    }));
    open.apps = apps;
    open.openApp = openApp;
    var open_1 = open;
    var execa$2 = { exports: {} };
    var crossSpawn$1 = { exports: {} };
    var windows$1 = isexe$3;
    isexe$3.sync = sync$2;
    var fs$4 = fs__default;
    function checkPathExt(path2, options2) {
      var pathext = options2.pathExt !== void 0 ? options2.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i2 = 0; i2 < pathext.length; i2++) {
        var p2 = pathext[i2].toLowerCase();
        if (p2 && path2.substr(-p2.length).toLowerCase() === p2) {
          return true;
        }
      }
      return false;
    }
    function checkStat$1(stat2, path2, options2) {
      if (!stat2.isSymbolicLink() && !stat2.isFile()) {
        return false;
      }
      return checkPathExt(path2, options2);
    }
    function isexe$3(path2, options2, cb) {
      fs$4.stat(path2, function(er2, stat2) {
        cb(er2, er2 ? false : checkStat$1(stat2, path2, options2));
      });
    }
    function sync$2(path2, options2) {
      return checkStat$1(fs$4.statSync(path2), path2, options2);
    }
    var mode = isexe$2;
    isexe$2.sync = sync$1;
    var fs$3 = fs__default;
    function isexe$2(path2, options2, cb) {
      fs$3.stat(path2, function(er2, stat2) {
        cb(er2, er2 ? false : checkStat(stat2, options2));
      });
    }
    function sync$1(path2, options2) {
      return checkStat(fs$3.statSync(path2), options2);
    }
    function checkStat(stat2, options2) {
      return stat2.isFile() && checkMode(stat2, options2);
    }
    function checkMode(stat2, options2) {
      var mod = stat2.mode;
      var uid = stat2.uid;
      var gid = stat2.gid;
      var myUid = options2.uid !== void 0 ? options2.uid : process.getuid && process.getuid();
      var myGid = options2.gid !== void 0 ? options2.gid : process.getgid && process.getgid();
      var u2 = parseInt("100", 8);
      var g2 = parseInt("010", 8);
      var o2 = parseInt("001", 8);
      var ug = u2 | g2;
      var ret = mod & o2 || mod & g2 && gid === myGid || mod & u2 && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
    var core$1;
    if (process.platform === "win32" || commonjsGlobal.TESTING_WINDOWS) {
      core$1 = windows$1;
    } else {
      core$1 = mode;
    }
    var isexe_1 = isexe$1;
    isexe$1.sync = sync;
    function isexe$1(path2, options2, cb) {
      if (typeof options2 === "function") {
        cb = options2;
        options2 = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve2, reject) {
          isexe$1(path2, options2 || {}, function(er2, is2) {
            if (er2) {
              reject(er2);
            } else {
              resolve2(is2);
            }
          });
        });
      }
      core$1(path2, options2 || {}, function(er2, is2) {
        if (er2) {
          if (er2.code === "EACCES" || options2 && options2.ignoreErrors) {
            er2 = null;
            is2 = false;
          }
        }
        cb(er2, is2);
      });
    }
    function sync(path2, options2) {
      try {
        return core$1.sync(path2, options2 || {});
      } catch (er2) {
        if (options2 && options2.ignoreErrors || er2.code === "EACCES") {
          return false;
        } else {
          throw er2;
        }
      }
    }
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path$8 = path__default;
    var COLON = isWindows ? ";" : ":";
    var isexe = isexe_1;
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || "").split(colon)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which$1 = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i2) => new Promise((resolve2, reject) => {
        if (i2 === pathEnv.length)
          return opt.all && found.length ? resolve2(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i2];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path$8.join(pathPart, cmd);
        const p2 = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve2(subStep(p2, i2, 0));
      });
      const subStep = (p2, i2, ii2) => new Promise((resolve2, reject) => {
        if (ii2 === pathExt.length)
          return resolve2(step(i2 + 1));
        const ext2 = pathExt[ii2];
        isexe(p2 + ext2, { pathExt: pathExtExe }, (er2, is2) => {
          if (!er2 && is2) {
            if (opt.all)
              found.push(p2 + ext2);
            else
              return resolve2(p2 + ext2);
          }
          return resolve2(subStep(p2, i2, ii2 + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i2 = 0; i2 < pathEnv.length; i2++) {
        const ppRaw = pathEnv[i2];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path$8.join(pathPart, cmd);
        const p2 = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j2 = 0; j2 < pathExt.length; j2++) {
          const cur = p2 + pathExt[j2];
          try {
            const is2 = isexe.sync(cur, { pathExt: pathExtExe });
            if (is2) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    var which_1 = which$1;
    which$1.sync = whichSync;
    var pathKey$1 = { exports: {} };
    var pathKey = (options2 = {}) => {
      const environment = options2.env || process.env;
      const platform2 = options2.platform || process.platform;
      if (platform2 !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    pathKey$1.exports = pathKey;
    pathKey$1.exports.default = pathKey;
    var path$7 = path__default;
    var which = which_1;
    var getPathKey = pathKey$1.exports;
    function resolveCommandAttempt(parsed, withoutPathExt) {
      const env2 = parsed.options.env || process.env;
      const cwd = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;
      const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd) {
        try {
          process.chdir(parsed.options.cwd);
        } catch (err) {
        }
      }
      let resolved;
      try {
        resolved = which.sync(parsed.command, {
          path: env2[getPathKey({ env: env2 })],
          pathExt: withoutPathExt ? path$7.delimiter : void 0
        });
      } catch (e2) {
      } finally {
        if (shouldSwitchCwd) {
          process.chdir(cwd);
        }
      }
      if (resolved) {
        resolved = path$7.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
      }
      return resolved;
    }
    function resolveCommand$1(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    var resolveCommand_1 = resolveCommand$1;
    var _escape = {};
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      arg = arg.replace(metaCharsRegExp, "^$1");
      return arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      arg = `${arg}`;
      arg = arg.replace(/(\\*)"/g, '$1$1\\"');
      arg = arg.replace(/(\\*)$/, "$1$1");
      arg = `"${arg}"`;
      arg = arg.replace(metaCharsRegExp, "^$1");
      if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, "^$1");
      }
      return arg;
    }
    _escape.command = escapeCommand;
    _escape.argument = escapeArgument;
    var shebangRegex$1 = /^#!(.*)/;
    var shebangRegex = shebangRegex$1;
    var shebangCommand$1 = (string2 = "") => {
      const match2 = string2.match(shebangRegex);
      if (!match2) {
        return null;
      }
      const [path2, argument] = match2[0].replace(/#! ?/, "").split(" ");
      const binary2 = path2.split("/").pop();
      if (binary2 === "env") {
        return argument;
      }
      return argument ? `${binary2} ${argument}` : binary2;
    };
    var fs$2 = fs__default;
    var shebangCommand = shebangCommand$1;
    function readShebang$1(command2) {
      const size = 150;
      const buffer = Buffer.alloc(size);
      let fd;
      try {
        fd = fs$2.openSync(command2, "r");
        fs$2.readSync(fd, buffer, 0, size, 0);
        fs$2.closeSync(fd);
      } catch (e2) {
      }
      return shebangCommand(buffer.toString());
    }
    var readShebang_1 = readShebang$1;
    var path$6 = path__default;
    var resolveCommand = resolveCommand_1;
    var escape = _escape;
    var readShebang = readShebang_1;
    var isWin$2 = process.platform === "win32";
    var isExecutableRegExp = /\.(?:com|exe)$/i;
    var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      const shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
      }
      return parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin$2) {
        return parsed;
      }
      const commandFile = detectShebang(parsed);
      const needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path$6.normalize(parsed.command);
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    function parse$4(command2, args, options2) {
      if (args && !Array.isArray(args)) {
        options2 = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options2 = Object.assign({}, options2);
      const parsed = {
        command: command2,
        args,
        options: options2,
        file: void 0,
        original: {
          command: command2,
          args
        }
      };
      return options2.shell ? parsed : parseNonShell(parsed);
    }
    var parse_1 = parse$4;
    var isWin$1 = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp2, parsed) {
      if (!isWin$1) {
        return;
      }
      const originalEmit = cp2.emit;
      cp2.emit = function(name, arg1) {
        if (name === "exit") {
          const err = verifyENOENT(arg1, parsed);
          if (err) {
            return originalEmit.call(cp2, "error", err);
          }
        }
        return originalEmit.apply(cp2, arguments);
      };
    }
    function verifyENOENT(status2, parsed) {
      if (isWin$1 && status2 === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status2, parsed) {
      if (isWin$1 && status2 === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      return null;
    }
    var enoent$1 = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
    var cp = require$$1__default$5;
    var parse$3 = parse_1;
    var enoent = enoent$1;
    function spawn(command2, args, options2) {
      const parsed = parse$3(command2, args, options2);
      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync(command2, args, options2) {
      const parsed = parse$3(command2, args, options2);
      const result2 = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      result2.error = result2.error || enoent.verifyENOENTSync(result2.status, parsed);
      return result2;
    }
    crossSpawn$1.exports = spawn;
    crossSpawn$1.exports.spawn = spawn;
    crossSpawn$1.exports.sync = spawnSync;
    crossSpawn$1.exports._parse = parse$3;
    crossSpawn$1.exports._enoent = enoent;
    var stripFinalNewline$1 = (input) => {
      const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
      const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
      if (input[input.length - 1] === LF) {
        input = input.slice(0, input.length - 1);
      }
      if (input[input.length - 1] === CR) {
        input = input.slice(0, input.length - 1);
      }
      return input;
    };
    var npmRunPath$1 = { exports: {} };
    (function(module2) {
      const path2 = path__default;
      const pathKey2 = pathKey$1.exports;
      const npmRunPath2 = (options2) => {
        options2 = __spreadValues2({
          cwd: process.cwd(),
          path: process.env[pathKey2()],
          execPath: process.execPath
        }, options2);
        let previous;
        let cwdPath = path2.resolve(options2.cwd);
        const result2 = [];
        while (previous !== cwdPath) {
          result2.push(path2.join(cwdPath, "node_modules/.bin"));
          previous = cwdPath;
          cwdPath = path2.resolve(cwdPath, "..");
        }
        const execPathDir = path2.resolve(options2.cwd, options2.execPath, "..");
        result2.push(execPathDir);
        return result2.concat(options2.path).join(path2.delimiter);
      };
      module2.exports = npmRunPath2;
      module2.exports.default = npmRunPath2;
      module2.exports.env = (options2) => {
        options2 = __spreadValues2({
          env: process.env
        }, options2);
        const env2 = __spreadValues2({}, options2.env);
        const path3 = pathKey2({ env: env2 });
        options2.path = env2[path3];
        env2[path3] = module2.exports(options2);
        return env2;
      };
    })(npmRunPath$1);
    var onetime$2 = { exports: {} };
    var mimicFn$2 = { exports: {} };
    var mimicFn$1 = (to2, from) => {
      for (const prop of Reflect.ownKeys(from)) {
        Object.defineProperty(to2, prop, Object.getOwnPropertyDescriptor(from, prop));
      }
      return to2;
    };
    mimicFn$2.exports = mimicFn$1;
    mimicFn$2.exports.default = mimicFn$1;
    var mimicFn = mimicFn$2.exports;
    var calledFunctions = new WeakMap();
    var onetime$1 = (function_, options2 = {}) => {
      if (typeof function_ !== "function") {
        throw new TypeError("Expected a function");
      }
      let returnValue;
      let callCount = 0;
      const functionName = function_.displayName || function_.name || "<anonymous>";
      const onetime2 = function(...arguments_) {
        calledFunctions.set(onetime2, ++callCount);
        if (callCount === 1) {
          returnValue = function_.apply(this, arguments_);
          function_ = null;
        } else if (options2.throw === true) {
          throw new Error(`Function \`${functionName}\` can only be called once`);
        }
        return returnValue;
      };
      mimicFn(onetime2, function_);
      calledFunctions.set(onetime2, callCount);
      return onetime2;
    };
    onetime$2.exports = onetime$1;
    onetime$2.exports.default = onetime$1;
    onetime$2.exports.callCount = (function_) => {
      if (!calledFunctions.has(function_)) {
        throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
      }
      return calledFunctions.get(function_);
    };
    var main$2 = {};
    var signals$2 = {};
    var core = {};
    Object.defineProperty(core, "__esModule", { value: true });
    core.SIGNALS = void 0;
    var SIGNALS = [
      {
        name: "SIGHUP",
        number: 1,
        action: "terminate",
        description: "Terminal closed",
        standard: "posix"
      },
      {
        name: "SIGINT",
        number: 2,
        action: "terminate",
        description: "User interruption with CTRL-C",
        standard: "ansi"
      },
      {
        name: "SIGQUIT",
        number: 3,
        action: "core",
        description: "User interruption with CTRL-\\",
        standard: "posix"
      },
      {
        name: "SIGILL",
        number: 4,
        action: "core",
        description: "Invalid machine instruction",
        standard: "ansi"
      },
      {
        name: "SIGTRAP",
        number: 5,
        action: "core",
        description: "Debugger breakpoint",
        standard: "posix"
      },
      {
        name: "SIGABRT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "ansi"
      },
      {
        name: "SIGIOT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "bsd"
      },
      {
        name: "SIGBUS",
        number: 7,
        action: "core",
        description: "Bus error due to misaligned, non-existing address or paging error",
        standard: "bsd"
      },
      {
        name: "SIGEMT",
        number: 7,
        action: "terminate",
        description: "Command should be emulated but is not implemented",
        standard: "other"
      },
      {
        name: "SIGFPE",
        number: 8,
        action: "core",
        description: "Floating point arithmetic error",
        standard: "ansi"
      },
      {
        name: "SIGKILL",
        number: 9,
        action: "terminate",
        description: "Forced termination",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGUSR1",
        number: 10,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGSEGV",
        number: 11,
        action: "core",
        description: "Segmentation fault",
        standard: "ansi"
      },
      {
        name: "SIGUSR2",
        number: 12,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGPIPE",
        number: 13,
        action: "terminate",
        description: "Broken pipe or socket",
        standard: "posix"
      },
      {
        name: "SIGALRM",
        number: 14,
        action: "terminate",
        description: "Timeout or timer",
        standard: "posix"
      },
      {
        name: "SIGTERM",
        number: 15,
        action: "terminate",
        description: "Termination",
        standard: "ansi"
      },
      {
        name: "SIGSTKFLT",
        number: 16,
        action: "terminate",
        description: "Stack is empty or overflowed",
        standard: "other"
      },
      {
        name: "SIGCHLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "posix"
      },
      {
        name: "SIGCLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "other"
      },
      {
        name: "SIGCONT",
        number: 18,
        action: "unpause",
        description: "Unpaused",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGSTOP",
        number: 19,
        action: "pause",
        description: "Paused",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGTSTP",
        number: 20,
        action: "pause",
        description: 'Paused using CTRL-Z or "suspend"',
        standard: "posix"
      },
      {
        name: "SIGTTIN",
        number: 21,
        action: "pause",
        description: "Background process cannot read terminal input",
        standard: "posix"
      },
      {
        name: "SIGBREAK",
        number: 21,
        action: "terminate",
        description: "User interruption with CTRL-BREAK",
        standard: "other"
      },
      {
        name: "SIGTTOU",
        number: 22,
        action: "pause",
        description: "Background process cannot write to terminal output",
        standard: "posix"
      },
      {
        name: "SIGURG",
        number: 23,
        action: "ignore",
        description: "Socket received out-of-band data",
        standard: "bsd"
      },
      {
        name: "SIGXCPU",
        number: 24,
        action: "core",
        description: "Process timed out",
        standard: "bsd"
      },
      {
        name: "SIGXFSZ",
        number: 25,
        action: "core",
        description: "File too big",
        standard: "bsd"
      },
      {
        name: "SIGVTALRM",
        number: 26,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGPROF",
        number: 27,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGWINCH",
        number: 28,
        action: "ignore",
        description: "Terminal window size changed",
        standard: "bsd"
      },
      {
        name: "SIGIO",
        number: 29,
        action: "terminate",
        description: "I/O is available",
        standard: "other"
      },
      {
        name: "SIGPOLL",
        number: 29,
        action: "terminate",
        description: "Watched event",
        standard: "other"
      },
      {
        name: "SIGINFO",
        number: 29,
        action: "ignore",
        description: "Request for process information",
        standard: "other"
      },
      {
        name: "SIGPWR",
        number: 30,
        action: "terminate",
        description: "Device running out of power",
        standard: "systemv"
      },
      {
        name: "SIGSYS",
        number: 31,
        action: "core",
        description: "Invalid system call",
        standard: "other"
      },
      {
        name: "SIGUNUSED",
        number: 31,
        action: "terminate",
        description: "Invalid system call",
        standard: "other"
      }
    ];
    core.SIGNALS = SIGNALS;
    var realtime = {};
    Object.defineProperty(realtime, "__esModule", { value: true });
    realtime.SIGRTMAX = realtime.getRealtimeSignals = void 0;
    var getRealtimeSignals = function() {
      const length = SIGRTMAX - SIGRTMIN + 1;
      return Array.from({ length }, getRealtimeSignal);
    };
    realtime.getRealtimeSignals = getRealtimeSignals;
    var getRealtimeSignal = function(value, index2) {
      return {
        name: `SIGRT${index2 + 1}`,
        number: SIGRTMIN + index2,
        action: "terminate",
        description: "Application-specific signal (realtime)",
        standard: "posix"
      };
    };
    var SIGRTMIN = 34;
    var SIGRTMAX = 64;
    realtime.SIGRTMAX = SIGRTMAX;
    Object.defineProperty(signals$2, "__esModule", { value: true });
    signals$2.getSignals = void 0;
    var _os$1 = require$$0__default$1;
    var _core = core;
    var _realtime$1 = realtime;
    var getSignals = function() {
      const realtimeSignals = (0, _realtime$1.getRealtimeSignals)();
      const signals2 = [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal);
      return signals2;
    };
    signals$2.getSignals = getSignals;
    var normalizeSignal = function({
      name,
      number: defaultNumber,
      description,
      action,
      forced = false,
      standard: standard2
    }) {
      const {
        signals: { [name]: constantSignal }
      } = _os$1.constants;
      const supported = constantSignal !== void 0;
      const number = supported ? constantSignal : defaultNumber;
      return { name, number, description, supported, action, forced, standard: standard2 };
    };
    Object.defineProperty(main$2, "__esModule", { value: true });
    main$2.signalsByNumber = main$2.signalsByName = void 0;
    var _os = require$$0__default$1;
    var _signals = signals$2;
    var _realtime = realtime;
    var getSignalsByName = function() {
      const signals2 = (0, _signals.getSignals)();
      return signals2.reduce(getSignalByName, {});
    };
    var getSignalByName = function(signalByNameMemo, { name, number, description, supported, action, forced, standard: standard2 }) {
      return __spreadProps2(__spreadValues2({}, signalByNameMemo), {
        [name]: { name, number, description, supported, action, forced, standard: standard2 }
      });
    };
    var signalsByName$1 = getSignalsByName();
    main$2.signalsByName = signalsByName$1;
    var getSignalsByNumber = function() {
      const signals2 = (0, _signals.getSignals)();
      const length = _realtime.SIGRTMAX + 1;
      const signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals2));
      return Object.assign({}, ...signalsA);
    };
    var getSignalByNumber = function(number, signals2) {
      const signal = findSignalByNumber(number, signals2);
      if (signal === void 0) {
        return {};
      }
      const { name, description, supported, action, forced, standard: standard2 } = signal;
      return {
        [number]: {
          name,
          number,
          description,
          supported,
          action,
          forced,
          standard: standard2
        }
      };
    };
    var findSignalByNumber = function(number, signals2) {
      const signal = signals2.find(({ name }) => _os.constants.signals[name] === number);
      if (signal !== void 0) {
        return signal;
      }
      return signals2.find((signalA) => signalA.number === number);
    };
    var signalsByNumber = getSignalsByNumber();
    main$2.signalsByNumber = signalsByNumber;
    var { signalsByName } = main$2;
    var getErrorPrefix = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => {
      if (timedOut) {
        return `timed out after ${timeout} milliseconds`;
      }
      if (isCanceled) {
        return "was canceled";
      }
      if (errorCode !== void 0) {
        return `failed with ${errorCode}`;
      }
      if (signal !== void 0) {
        return `was killed with ${signal} (${signalDescription})`;
      }
      if (exitCode !== void 0) {
        return `failed with exit code ${exitCode}`;
      }
      return "failed";
    };
    var makeError$1 = ({
      stdout,
      stderr,
      all,
      error: error2,
      signal,
      exitCode,
      command: command2,
      escapedCommand,
      timedOut,
      isCanceled,
      killed,
      parsed: { options: { timeout } }
    }) => {
      exitCode = exitCode === null ? void 0 : exitCode;
      signal = signal === null ? void 0 : signal;
      const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;
      const errorCode = error2 && error2.code;
      const prefix = getErrorPrefix({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled });
      const execaMessage = `Command ${prefix}: ${command2}`;
      const isError = Object.prototype.toString.call(error2) === "[object Error]";
      const shortMessage = isError ? `${execaMessage}
${error2.message}` : execaMessage;
      const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
      if (isError) {
        error2.originalMessage = error2.message;
        error2.message = message;
      } else {
        error2 = new Error(message);
      }
      error2.shortMessage = shortMessage;
      error2.command = command2;
      error2.escapedCommand = escapedCommand;
      error2.exitCode = exitCode;
      error2.signal = signal;
      error2.signalDescription = signalDescription;
      error2.stdout = stdout;
      error2.stderr = stderr;
      if (all !== void 0) {
        error2.all = all;
      }
      if ("bufferedData" in error2) {
        delete error2.bufferedData;
      }
      error2.failed = true;
      error2.timedOut = Boolean(timedOut);
      error2.isCanceled = isCanceled;
      error2.killed = killed && !timedOut;
      return error2;
    };
    var error = makeError$1;
    var stdio = { exports: {} };
    var aliases = ["stdin", "stdout", "stderr"];
    var hasAlias = (options2) => aliases.some((alias2) => options2[alias2] !== void 0);
    var normalizeStdio$1 = (options2) => {
      if (!options2) {
        return;
      }
      const { stdio: stdio2 } = options2;
      if (stdio2 === void 0) {
        return aliases.map((alias2) => options2[alias2]);
      }
      if (hasAlias(options2)) {
        throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias2) => `\`${alias2}\``).join(", ")}`);
      }
      if (typeof stdio2 === "string") {
        return stdio2;
      }
      if (!Array.isArray(stdio2)) {
        throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio2}\``);
      }
      const length = Math.max(stdio2.length, aliases.length);
      return Array.from({ length }, (value, index2) => stdio2[index2]);
    };
    stdio.exports = normalizeStdio$1;
    stdio.exports.node = (options2) => {
      const stdio2 = normalizeStdio$1(options2);
      if (stdio2 === "ipc") {
        return "ipc";
      }
      if (stdio2 === void 0 || typeof stdio2 === "string") {
        return [stdio2, stdio2, stdio2, "ipc"];
      }
      if (stdio2.includes("ipc")) {
        return stdio2;
      }
      return [...stdio2, "ipc"];
    };
    var signalExit = { exports: {} };
    var signals$1 = { exports: {} };
    (function(module2) {
      module2.exports = [
        "SIGABRT",
        "SIGALRM",
        "SIGHUP",
        "SIGINT",
        "SIGTERM"
      ];
      if (process.platform !== "win32") {
        module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
      }
      if (process.platform === "linux") {
        module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
      }
    })(signals$1);
    var process$1 = commonjsGlobal.process;
    if (typeof process$1 !== "object" || !process$1) {
      signalExit.exports = function() {
      };
    } else {
      assert = require$$5__default;
      signals = signals$1.exports;
      isWin = /^win/i.test(process$1.platform);
      EE = require$$0__default$4;
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      if (process$1.__signal_exit_emitter__) {
        emitter = process$1.__signal_exit_emitter__;
      } else {
        emitter = process$1.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      signalExit.exports = function(cb, opts) {
        if (commonjsGlobal.process !== process$1) {
          return;
        }
        assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load();
        }
        var ev = "exit";
        if (opts && opts.alwaysLast) {
          ev = "afterexit";
        }
        var remove2 = function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        };
        emitter.on(ev, cb);
        return remove2;
      };
      unload = function unload2() {
        if (!loaded || commonjsGlobal.process !== process$1) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process$1.removeListener(sig, sigListeners[sig]);
          } catch (er2) {
          }
        });
        process$1.emit = originalProcessEmit;
        process$1.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      };
      signalExit.exports.unload = unload;
      emit = function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      };
      sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = function listener2() {
          if (process$1 !== commonjsGlobal.process) {
            return;
          }
          var listeners = process$1.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process$1.kill(process$1.pid, sig);
          }
        };
      });
      signalExit.exports.signals = function() {
        return signals;
      };
      loaded = false;
      load = function load2() {
        if (loaded || process$1 !== commonjsGlobal.process) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process$1.on(sig, sigListeners[sig]);
            return true;
          } catch (er2) {
            return false;
          }
        });
        process$1.emit = processEmit;
        process$1.reallyExit = processReallyExit;
      };
      signalExit.exports.load = load;
      originalProcessReallyExit = process$1.reallyExit;
      processReallyExit = function processReallyExit2(code) {
        if (process$1 !== commonjsGlobal.process) {
          return;
        }
        process$1.exitCode = code || 0;
        emit("exit", process$1.exitCode, null);
        emit("afterexit", process$1.exitCode, null);
        originalProcessReallyExit.call(process$1, process$1.exitCode);
      };
      originalProcessEmit = process$1.emit;
      processEmit = function processEmit2(ev, arg) {
        if (ev === "exit" && process$1 === commonjsGlobal.process) {
          if (arg !== void 0) {
            process$1.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process$1.exitCode, null);
          emit("afterexit", process$1.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      };
    }
    var assert;
    var signals;
    var isWin;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
    var os$2 = require$$0__default$1;
    var onExit = signalExit.exports;
    var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
    var spawnedKill$1 = (kill2, signal = "SIGTERM", options2 = {}) => {
      const killResult = kill2(signal);
      setKillTimeout(kill2, signal, options2, killResult);
      return killResult;
    };
    var setKillTimeout = (kill2, signal, options2, killResult) => {
      if (!shouldForceKill(signal, options2, killResult)) {
        return;
      }
      const timeout = getForceKillAfterTimeout(options2);
      const t = setTimeout(() => {
        kill2("SIGKILL");
      }, timeout);
      if (t.unref) {
        t.unref();
      }
    };
    var shouldForceKill = (signal, { forceKillAfterTimeout }, killResult) => {
      return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
    };
    var isSigterm = (signal) => {
      return signal === os$2.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
    };
    var getForceKillAfterTimeout = ({ forceKillAfterTimeout = true }) => {
      if (forceKillAfterTimeout === true) {
        return DEFAULT_FORCE_KILL_TIMEOUT;
      }
      if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
        throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
      }
      return forceKillAfterTimeout;
    };
    var spawnedCancel$1 = (spawned, context2) => {
      const killResult = spawned.kill();
      if (killResult) {
        context2.isCanceled = true;
      }
    };
    var timeoutKill = (spawned, signal, reject) => {
      spawned.kill(signal);
      reject(Object.assign(new Error("Timed out"), { timedOut: true, signal }));
    };
    var setupTimeout$1 = (spawned, { timeout, killSignal = "SIGTERM" }, spawnedPromise) => {
      if (timeout === 0 || timeout === void 0) {
        return spawnedPromise;
      }
      let timeoutId;
      const timeoutPromise = new Promise((resolve2, reject) => {
        timeoutId = setTimeout(() => {
          timeoutKill(spawned, killSignal, reject);
        }, timeout);
      });
      const safeSpawnedPromise = spawnedPromise.finally(() => {
        clearTimeout(timeoutId);
      });
      return Promise.race([timeoutPromise, safeSpawnedPromise]);
    };
    var validateTimeout$1 = ({ timeout }) => {
      if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {
        throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
      }
    };
    var setExitHandler$1 = async (spawned, { cleanup, detached }, timedPromise) => {
      if (!cleanup || detached) {
        return timedPromise;
      }
      const removeExitHandler = onExit(() => {
        spawned.kill();
      });
      return timedPromise.finally(() => {
        removeExitHandler();
      });
    };
    var kill = {
      spawnedKill: spawnedKill$1,
      spawnedCancel: spawnedCancel$1,
      setupTimeout: setupTimeout$1,
      validateTimeout: validateTimeout$1,
      setExitHandler: setExitHandler$1
    };
    var isStream$1 = (stream2) => stream2 !== null && typeof stream2 === "object" && typeof stream2.pipe === "function";
    isStream$1.writable = (stream2) => isStream$1(stream2) && stream2.writable !== false && typeof stream2._write === "function" && typeof stream2._writableState === "object";
    isStream$1.readable = (stream2) => isStream$1(stream2) && stream2.readable !== false && typeof stream2._read === "function" && typeof stream2._readableState === "object";
    isStream$1.duplex = (stream2) => isStream$1.writable(stream2) && isStream$1.readable(stream2);
    isStream$1.transform = (stream2) => isStream$1.duplex(stream2) && typeof stream2._transform === "function";
    var isStream_1 = isStream$1;
    var getStream$2 = { exports: {} };
    var { PassThrough: PassThroughStream } = require$$0__default$3;
    var bufferStream$1 = (options2) => {
      options2 = __spreadValues2({}, options2);
      const { array: array2 } = options2;
      let { encoding: encoding2 } = options2;
      const isBuffer = encoding2 === "buffer";
      let objectMode = false;
      if (array2) {
        objectMode = !(encoding2 || isBuffer);
      } else {
        encoding2 = encoding2 || "utf8";
      }
      if (isBuffer) {
        encoding2 = null;
      }
      const stream2 = new PassThroughStream({ objectMode });
      if (encoding2) {
        stream2.setEncoding(encoding2);
      }
      let length = 0;
      const chunks = [];
      stream2.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream2.getBufferedValue = () => {
        if (array2) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream2.getBufferedLength = () => length;
      return stream2;
    };
    var { constants: BufferConstants } = require$$0__default$7;
    var stream$1 = require$$0__default$3;
    var { promisify } = require$$0__default$2;
    var bufferStream = bufferStream$1;
    var streamPipelinePromisified = promisify(stream$1.pipeline);
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    async function getStream$1(inputStream, options2) {
      if (!inputStream) {
        throw new Error("Expected a stream");
      }
      options2 = __spreadValues2({
        maxBuffer: Infinity
      }, options2);
      const { maxBuffer } = options2;
      const stream2 = bufferStream(options2);
      await new Promise((resolve2, reject) => {
        const rejectPromise = (error2) => {
          if (error2 && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
            error2.bufferedData = stream2.getBufferedValue();
          }
          reject(error2);
        };
        (async () => {
          try {
            await streamPipelinePromisified(inputStream, stream2);
            resolve2();
          } catch (error2) {
            rejectPromise(error2);
          }
        })();
        stream2.on("data", () => {
          if (stream2.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      });
      return stream2.getBufferedValue();
    }
    getStream$2.exports = getStream$1;
    getStream$2.exports.buffer = (stream2, options2) => getStream$1(stream2, __spreadProps2(__spreadValues2({}, options2), { encoding: "buffer" }));
    getStream$2.exports.array = (stream2, options2) => getStream$1(stream2, __spreadProps2(__spreadValues2({}, options2), { array: true }));
    getStream$2.exports.MaxBufferError = MaxBufferError;
    var { PassThrough } = require$$0__default$3;
    var mergeStream$1 = function() {
      var sources = [];
      var output = new PassThrough({ objectMode: true });
      output.setMaxListeners(0);
      output.add = add;
      output.isEmpty = isEmpty2;
      output.on("unpipe", remove2);
      Array.prototype.slice.call(arguments).forEach(add);
      return output;
      function add(source2) {
        if (Array.isArray(source2)) {
          source2.forEach(add);
          return this;
        }
        sources.push(source2);
        source2.once("end", remove2.bind(null, source2));
        source2.once("error", output.emit.bind(output, "error"));
        source2.pipe(output, { end: false });
        return this;
      }
      function isEmpty2() {
        return sources.length == 0;
      }
      function remove2(source2) {
        sources = sources.filter(function(it2) {
          return it2 !== source2;
        });
        if (!sources.length && output.readable) {
          output.end();
        }
      }
    };
    var isStream = isStream_1;
    var getStream = getStream$2.exports;
    var mergeStream = mergeStream$1;
    var handleInput$1 = (spawned, input) => {
      if (input === void 0 || spawned.stdin === void 0) {
        return;
      }
      if (isStream(input)) {
        input.pipe(spawned.stdin);
      } else {
        spawned.stdin.end(input);
      }
    };
    var makeAllStream$1 = (spawned, { all }) => {
      if (!all || !spawned.stdout && !spawned.stderr) {
        return;
      }
      const mixed = mergeStream();
      if (spawned.stdout) {
        mixed.add(spawned.stdout);
      }
      if (spawned.stderr) {
        mixed.add(spawned.stderr);
      }
      return mixed;
    };
    var getBufferedData = async (stream2, streamPromise) => {
      if (!stream2) {
        return;
      }
      stream2.destroy();
      try {
        return await streamPromise;
      } catch (error2) {
        return error2.bufferedData;
      }
    };
    var getStreamPromise = (stream2, { encoding: encoding2, buffer, maxBuffer }) => {
      if (!stream2 || !buffer) {
        return;
      }
      if (encoding2) {
        return getStream(stream2, { encoding: encoding2, maxBuffer });
      }
      return getStream.buffer(stream2, { maxBuffer });
    };
    var getSpawnedResult$1 = async ({ stdout, stderr, all }, { encoding: encoding2, buffer, maxBuffer }, processDone) => {
      const stdoutPromise = getStreamPromise(stdout, { encoding: encoding2, buffer, maxBuffer });
      const stderrPromise = getStreamPromise(stderr, { encoding: encoding2, buffer, maxBuffer });
      const allPromise = getStreamPromise(all, { encoding: encoding2, buffer, maxBuffer: maxBuffer * 2 });
      try {
        return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
      } catch (error2) {
        return Promise.all([
          { error: error2, signal: error2.signal, timedOut: error2.timedOut },
          getBufferedData(stdout, stdoutPromise),
          getBufferedData(stderr, stderrPromise),
          getBufferedData(all, allPromise)
        ]);
      }
    };
    var validateInputSync$1 = ({ input }) => {
      if (isStream(input)) {
        throw new TypeError("The `input` option cannot be a stream in sync mode");
      }
    };
    var stream = {
      handleInput: handleInput$1,
      makeAllStream: makeAllStream$1,
      getSpawnedResult: getSpawnedResult$1,
      validateInputSync: validateInputSync$1
    };
    var nativePromisePrototype = (async () => {
    })().constructor.prototype;
    var descriptors = ["then", "catch", "finally"].map((property) => [
      property,
      Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
    ]);
    var mergePromise$1 = (spawned, promise2) => {
      for (const [property, descriptor] of descriptors) {
        const value = typeof promise2 === "function" ? (...args) => Reflect.apply(descriptor.value, promise2(), args) : descriptor.value.bind(promise2);
        Reflect.defineProperty(spawned, property, __spreadProps2(__spreadValues2({}, descriptor), { value }));
      }
      return spawned;
    };
    var getSpawnedPromise$1 = (spawned) => {
      return new Promise((resolve2, reject) => {
        spawned.on("exit", (exitCode, signal) => {
          resolve2({ exitCode, signal });
        });
        spawned.on("error", (error2) => {
          reject(error2);
        });
        if (spawned.stdin) {
          spawned.stdin.on("error", (error2) => {
            reject(error2);
          });
        }
      });
    };
    var promise = {
      mergePromise: mergePromise$1,
      getSpawnedPromise: getSpawnedPromise$1
    };
    var normalizeArgs = (file, args = []) => {
      if (!Array.isArray(args)) {
        return [file];
      }
      return [file, ...args];
    };
    var NO_ESCAPE_REGEXP = /^[\w.-]+$/;
    var DOUBLE_QUOTES_REGEXP = /"/g;
    var escapeArg = (arg) => {
      if (typeof arg !== "string" || NO_ESCAPE_REGEXP.test(arg)) {
        return arg;
      }
      return `"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`;
    };
    var joinCommand$1 = (file, args) => {
      return normalizeArgs(file, args).join(" ");
    };
    var getEscapedCommand$1 = (file, args) => {
      return normalizeArgs(file, args).map((arg) => escapeArg(arg)).join(" ");
    };
    var SPACES_REGEXP = / +/g;
    var parseCommand$1 = (command2) => {
      const tokens = [];
      for (const token of command2.trim().split(SPACES_REGEXP)) {
        const previousToken = tokens[tokens.length - 1];
        if (previousToken && previousToken.endsWith("\\")) {
          tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
        } else {
          tokens.push(token);
        }
      }
      return tokens;
    };
    var command = {
      joinCommand: joinCommand$1,
      getEscapedCommand: getEscapedCommand$1,
      parseCommand: parseCommand$1
    };
    var path$5 = path__default;
    var childProcess$2 = require$$1__default$5;
    var crossSpawn = crossSpawn$1.exports;
    var stripFinalNewline = stripFinalNewline$1;
    var npmRunPath = npmRunPath$1.exports;
    var onetime = onetime$2.exports;
    var makeError = error;
    var normalizeStdio = stdio.exports;
    var { spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler } = kill;
    var { handleInput, getSpawnedResult, makeAllStream, validateInputSync } = stream;
    var { mergePromise, getSpawnedPromise } = promise;
    var { joinCommand, parseCommand, getEscapedCommand } = command;
    var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
    var getEnv = ({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {
      const env2 = extendEnv ? __spreadValues2(__spreadValues2({}, process.env), envOption) : envOption;
      if (preferLocal) {
        return npmRunPath.env({ env: env2, cwd: localDir, execPath });
      }
      return env2;
    };
    var handleArguments = (file, args, options2 = {}) => {
      const parsed = crossSpawn._parse(file, args, options2);
      file = parsed.command;
      args = parsed.args;
      options2 = parsed.options;
      options2 = __spreadValues2({
        maxBuffer: DEFAULT_MAX_BUFFER,
        buffer: true,
        stripFinalNewline: true,
        extendEnv: true,
        preferLocal: false,
        localDir: options2.cwd || process.cwd(),
        execPath: process.execPath,
        encoding: "utf8",
        reject: true,
        cleanup: true,
        all: false,
        windowsHide: true
      }, options2);
      options2.env = getEnv(options2);
      options2.stdio = normalizeStdio(options2);
      if (process.platform === "win32" && path$5.basename(file, ".exe") === "cmd") {
        args.unshift("/q");
      }
      return { file, args, options: options2, parsed };
    };
    var handleOutput = (options2, value, error2) => {
      if (typeof value !== "string" && !Buffer.isBuffer(value)) {
        return error2 === void 0 ? void 0 : "";
      }
      if (options2.stripFinalNewline) {
        return stripFinalNewline(value);
      }
      return value;
    };
    var execa = (file, args, options2) => {
      const parsed = handleArguments(file, args, options2);
      const command2 = joinCommand(file, args);
      const escapedCommand = getEscapedCommand(file, args);
      validateTimeout(parsed.options);
      let spawned;
      try {
        spawned = childProcess$2.spawn(parsed.file, parsed.args, parsed.options);
      } catch (error2) {
        const dummySpawned = new childProcess$2.ChildProcess();
        const errorPromise = Promise.reject(makeError({
          error: error2,
          stdout: "",
          stderr: "",
          all: "",
          command: command2,
          escapedCommand,
          parsed,
          timedOut: false,
          isCanceled: false,
          killed: false
        }));
        return mergePromise(dummySpawned, errorPromise);
      }
      const spawnedPromise = getSpawnedPromise(spawned);
      const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
      const processDone = setExitHandler(spawned, parsed.options, timedPromise);
      const context2 = { isCanceled: false };
      spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
      spawned.cancel = spawnedCancel.bind(null, spawned, context2);
      const handlePromise = async () => {
        const [{ error: error2, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
        const stdout = handleOutput(parsed.options, stdoutResult);
        const stderr = handleOutput(parsed.options, stderrResult);
        const all = handleOutput(parsed.options, allResult);
        if (error2 || exitCode !== 0 || signal !== null) {
          const returnedError = makeError({
            error: error2,
            exitCode,
            signal,
            stdout,
            stderr,
            all,
            command: command2,
            escapedCommand,
            parsed,
            timedOut,
            isCanceled: context2.isCanceled,
            killed: spawned.killed
          });
          if (!parsed.options.reject) {
            return returnedError;
          }
          throw returnedError;
        }
        return {
          command: command2,
          escapedCommand,
          exitCode: 0,
          stdout,
          stderr,
          all,
          failed: false,
          timedOut: false,
          isCanceled: false,
          killed: false
        };
      };
      const handlePromiseOnce = onetime(handlePromise);
      handleInput(spawned, parsed.options.input);
      spawned.all = makeAllStream(spawned, parsed.options);
      return mergePromise(spawned, handlePromiseOnce);
    };
    execa$2.exports = execa;
    execa$2.exports.sync = (file, args, options2) => {
      const parsed = handleArguments(file, args, options2);
      const command2 = joinCommand(file, args);
      const escapedCommand = getEscapedCommand(file, args);
      validateInputSync(parsed.options);
      let result2;
      try {
        result2 = childProcess$2.spawnSync(parsed.file, parsed.args, parsed.options);
      } catch (error2) {
        throw makeError({
          error: error2,
          stdout: "",
          stderr: "",
          all: "",
          command: command2,
          escapedCommand,
          parsed,
          timedOut: false,
          isCanceled: false,
          killed: false
        });
      }
      const stdout = handleOutput(parsed.options, result2.stdout, result2.error);
      const stderr = handleOutput(parsed.options, result2.stderr, result2.error);
      if (result2.error || result2.status !== 0 || result2.signal !== null) {
        const error2 = makeError({
          stdout,
          stderr,
          error: result2.error,
          signal: result2.signal,
          exitCode: result2.status,
          command: command2,
          escapedCommand,
          parsed,
          timedOut: result2.error && result2.error.code === "ETIMEDOUT",
          isCanceled: false,
          killed: result2.signal !== null
        });
        if (!parsed.options.reject) {
          return error2;
        }
        throw error2;
      }
      return {
        command: command2,
        escapedCommand,
        exitCode: 0,
        stdout,
        stderr,
        failed: false,
        timedOut: false,
        isCanceled: false,
        killed: false
      };
    };
    execa$2.exports.command = (command2, options2) => {
      const [file, ...args] = parseCommand(command2);
      return execa(file, args, options2);
    };
    execa$2.exports.commandSync = (command2, options2) => {
      const [file, ...args] = parseCommand(command2);
      return execa.sync(file, args, options2);
    };
    execa$2.exports.node = (scriptPath, args, options2 = {}) => {
      if (args && !Array.isArray(args) && typeof args === "object") {
        options2 = args;
        args = [];
      }
      const stdio2 = normalizeStdio.node(options2);
      const defaultExecArgv = process.execArgv.filter((arg) => !arg.startsWith("--inspect"));
      const {
        nodePath = process.execPath,
        nodeOptions = defaultExecArgv
      } = options2;
      return execa(nodePath, [
        ...nodeOptions,
        scriptPath,
        ...Array.isArray(args) ? args : []
      ], __spreadProps2(__spreadValues2({}, options2), {
        stdin: void 0,
        stdout: void 0,
        stderr: void 0,
        stdio: stdio2,
        shell: false
      }));
    };
    var execa$1 = execa$2.exports;
    var OSX_CHROME = "google chrome";
    function openBrowser(url2, opt, logger) {
      const browser2 = typeof opt === "string" ? opt : process.env.BROWSER || "";
      if (browser2.toLowerCase().endsWith(".js")) {
        return executeNodeScript(browser2, url2, logger);
      } else if (browser2.toLowerCase() !== "none") {
        return startBrowserProcess(browser2, url2);
      }
      return false;
    }
    function executeNodeScript(scriptPath, url2, logger) {
      const extraArgs = process.argv.slice(2);
      const child = execa$1("node", [scriptPath, ...extraArgs, url2], {
        stdio: "inherit"
      });
      child.on("close", (code) => {
        if (code !== 0) {
          logger.error(source.red(`
The script specified as BROWSER environment variable failed.

${source.cyan(scriptPath)} exited with code ${code}.`), { error: null });
        }
      });
      return true;
    }
    function startBrowserProcess(browser2, url2) {
      const shouldTryOpenChromeWithAppleScript = process.platform === "darwin" && (browser2 === "" || browser2 === OSX_CHROME);
      if (shouldTryOpenChromeWithAppleScript) {
        try {
          require$$1$5.execSync('ps cax | grep "Google Chrome"');
          require$$1$5.execSync('osascript openChrome.applescript "' + encodeURI(url2) + '"', {
            cwd: path__default.dirname(__require.resolve("vite/bin/openChrome.applescript")),
            stdio: "ignore"
          });
          return true;
        } catch (err) {
        }
      }
      if (process.platform === "darwin" && browser2 === "open") {
        browser2 = void 0;
      }
      try {
        const options2 = browser2 ? { app: { name: browser2 } } : {};
        open_1(url2, options2).catch(() => {
        });
        return true;
      } catch (err) {
        return false;
      }
    }
    var picocolors = { exports: {} };
    var tty = require$$0__default;
    var isColorSupported = !("NO_COLOR" in process.env || process.argv.includes("--no-color")) && ("FORCE_COLOR" in process.env || process.argv.includes("--color") || process.platform === "win32" || tty.isatty(1) && process.env.TERM !== "dumb" || "CI" in process.env);
    var formatter = (open2, close2, replace2 = open2) => (input) => {
      let string2 = "" + input;
      let index2 = string2.indexOf(close2, open2.length);
      return ~index2 ? open2 + replaceClose(string2, close2, replace2, index2) + close2 : open2 + string2 + close2;
    };
    var replaceClose = (string2, close2, replace2, index2) => {
      let start = string2.substring(0, index2) + replace2;
      let end = string2.substring(index2 + close2.length);
      let nextIndex = end.indexOf(close2);
      return ~nextIndex ? start + replaceClose(end, close2, replace2, nextIndex) : start + end;
    };
    var createColors = (enabled = isColorSupported) => ({
      isColorSupported: enabled,
      reset: enabled ? (s2) => `[0m${s2}[0m` : String,
      bold: enabled ? formatter("[1m", "[22m", "[22m[1m") : String,
      dim: enabled ? formatter("[2m", "[22m", "[22m[2m") : String,
      italic: enabled ? formatter("[3m", "[23m") : String,
      underline: enabled ? formatter("[4m", "[24m") : String,
      inverse: enabled ? formatter("[7m", "[27m") : String,
      hidden: enabled ? formatter("[8m", "[28m") : String,
      strikethrough: enabled ? formatter("[9m", "[29m") : String,
      black: enabled ? formatter("[30m", "[39m") : String,
      red: enabled ? formatter("[31m", "[39m") : String,
      green: enabled ? formatter("[32m", "[39m") : String,
      yellow: enabled ? formatter("[33m", "[39m") : String,
      blue: enabled ? formatter("[34m", "[39m") : String,
      magenta: enabled ? formatter("[35m", "[39m") : String,
      cyan: enabled ? formatter("[36m", "[39m") : String,
      white: enabled ? formatter("[37m", "[39m") : String,
      gray: enabled ? formatter("[90m", "[39m") : String,
      bgBlack: enabled ? formatter("[40m", "[49m") : String,
      bgRed: enabled ? formatter("[41m", "[49m") : String,
      bgGreen: enabled ? formatter("[42m", "[49m") : String,
      bgYellow: enabled ? formatter("[43m", "[49m") : String,
      bgBlue: enabled ? formatter("[44m", "[49m") : String,
      bgMagenta: enabled ? formatter("[45m", "[49m") : String,
      bgCyan: enabled ? formatter("[46m", "[49m") : String,
      bgWhite: enabled ? formatter("[47m", "[49m") : String
    });
    picocolors.exports = createColors();
    picocolors.exports.createColors = createColors;
    var shellQuote$1 = {};
    shellQuote$1.quote = function(xs2) {
      return xs2.map(function(s2) {
        if (s2 && typeof s2 === "object") {
          return s2.op.replace(/(.)/g, "\\$1");
        } else if (/["\s]/.test(s2) && !/'/.test(s2)) {
          return "'" + s2.replace(/(['\\])/g, "\\$1") + "'";
        } else if (/["'\s]/.test(s2)) {
          return '"' + s2.replace(/(["\\$`!])/g, "\\$1") + '"';
        } else {
          return String(s2).replace(/([A-Za-z]:)?([#!"$&'()*,:;<=>?@\[\\\]^`{|}])/g, "$1\\$2");
        }
      }).join(" ");
    };
    var CONTROL = "(?:" + [
      "\\|\\|",
      "\\&\\&",
      ";;",
      "\\|\\&",
      "\\<\\(",
      ">>",
      ">\\&",
      "[&;()|<>]"
    ].join("|") + ")";
    var META = "|&;()<> \\t";
    var BAREWORD = `(\\\\['"` + META + `]|[^\\s'"` + META + "])+";
    var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
    var DOUBLE_QUOTE = "'((\\\\'|[^'])*?)'";
    var TOKEN = "";
    for (i = 0; i < 4; i++) {
      TOKEN += (Math.pow(16, 8) * Math.random()).toString(16);
    }
    var i;
    shellQuote$1.parse = function(s2, env2, opts) {
      var mapped = parse$2(s2, env2, opts);
      if (typeof env2 !== "function")
        return mapped;
      return mapped.reduce(function(acc, s3) {
        if (typeof s3 === "object")
          return acc.concat(s3);
        var xs2 = s3.split(RegExp("(" + TOKEN + ".*?" + TOKEN + ")", "g"));
        if (xs2.length === 1)
          return acc.concat(xs2[0]);
        return acc.concat(xs2.filter(Boolean).map(function(x2) {
          if (RegExp("^" + TOKEN).test(x2)) {
            return JSON.parse(x2.split(TOKEN)[1]);
          } else
            return x2;
        }));
      }, []);
    };
    function parse$2(s2, env2, opts) {
      var chunker = new RegExp([
        "(" + CONTROL + ")",
        "(" + BAREWORD + "|" + SINGLE_QUOTE + "|" + DOUBLE_QUOTE + ")*"
      ].join("|"), "g");
      var match2 = s2.match(chunker).filter(Boolean);
      var commented = false;
      if (!match2)
        return [];
      if (!env2)
        env2 = {};
      if (!opts)
        opts = {};
      return match2.map(function(s3, j2) {
        if (commented) {
          return;
        }
        if (RegExp("^" + CONTROL + "$").test(s3)) {
          return { op: s3 };
        }
        var SQ = "'";
        var DQ = '"';
        var DS = "$";
        var BS = opts.escape || "\\";
        var quote = false;
        var esc = false;
        var out2 = "";
        var isGlob2 = false;
        for (var i2 = 0, len = s3.length; i2 < len; i2++) {
          var c2 = s3.charAt(i2);
          isGlob2 = isGlob2 || !quote && (c2 === "*" || c2 === "?");
          if (esc) {
            out2 += c2;
            esc = false;
          } else if (quote) {
            if (c2 === quote) {
              quote = false;
            } else if (quote == SQ) {
              out2 += c2;
            } else {
              if (c2 === BS) {
                i2 += 1;
                c2 = s3.charAt(i2);
                if (c2 === DQ || c2 === BS || c2 === DS) {
                  out2 += c2;
                } else {
                  out2 += BS + c2;
                }
              } else if (c2 === DS) {
                out2 += parseEnvVar();
              } else {
                out2 += c2;
              }
            }
          } else if (c2 === DQ || c2 === SQ) {
            quote = c2;
          } else if (RegExp("^" + CONTROL + "$").test(c2)) {
            return { op: s3 };
          } else if (RegExp("^#$").test(c2)) {
            commented = true;
            if (out2.length) {
              return [out2, { comment: s3.slice(i2 + 1) + match2.slice(j2 + 1).join(" ") }];
            }
            return [{ comment: s3.slice(i2 + 1) + match2.slice(j2 + 1).join(" ") }];
          } else if (c2 === BS) {
            esc = true;
          } else if (c2 === DS) {
            out2 += parseEnvVar();
          } else
            out2 += c2;
        }
        if (isGlob2)
          return { op: "glob", pattern: out2 };
        return out2;
        function parseEnvVar() {
          i2 += 1;
          var varend, varname;
          if (s3.charAt(i2) === "{") {
            i2 += 1;
            if (s3.charAt(i2) === "}") {
              throw new Error("Bad substitution: " + s3.substr(i2 - 2, 3));
            }
            varend = s3.indexOf("}", i2);
            if (varend < 0) {
              throw new Error("Bad substitution: " + s3.substr(i2));
            }
            varname = s3.substr(i2, varend - i2);
            i2 = varend;
          } else if (/[*@#?$!_\-]/.test(s3.charAt(i2))) {
            varname = s3.charAt(i2);
            i2 += 1;
          } else {
            varend = s3.substr(i2).match(/[^\w\d_]/);
            if (!varend) {
              varname = s3.substr(i2);
              i2 = s3.length;
            } else {
              varname = s3.substr(i2, varend.index);
              i2 += varend.index - 1;
            }
          }
          return getVar(null, "", varname);
        }
      }).reduce(function(prev, arg) {
        if (arg === void 0) {
          return prev;
        }
        return prev.concat(arg);
      }, []);
      function getVar(_2, pre, key) {
        var r2 = typeof env2 === "function" ? env2(key) : env2[key];
        if (r2 === void 0 && key != "")
          r2 = "";
        else if (r2 === void 0)
          r2 = "$";
        if (typeof r2 === "object") {
          return pre + TOKEN + JSON.stringify(r2) + TOKEN;
        } else
          return pre + r2;
      }
    }
    var osx = {
      "/Applications/Atom.app/Contents/MacOS/Atom": "atom",
      "/Applications/Atom Beta.app/Contents/MacOS/Atom Beta": "/Applications/Atom Beta.app/Contents/MacOS/Atom Beta",
      "/Applications/Brackets.app/Contents/MacOS/Brackets": "brackets",
      "/Applications/Sublime Text.app/Contents/MacOS/Sublime Text": "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl",
      "/Applications/Sublime Text.app/Contents/MacOS/sublime_text": "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl",
      "/Applications/Sublime Text 2.app/Contents/MacOS/Sublime Text 2": "/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl",
      "/Applications/Sublime Text Dev.app/Contents/MacOS/Sublime Text": "/Applications/Sublime Text Dev.app/Contents/SharedSupport/bin/subl",
      "/Applications/Visual Studio Code.app/Contents/MacOS/Electron": "code",
      "/Applications/Visual Studio Code - Insiders.app/Contents/MacOS/Electron": "code-insiders",
      "/Applications/AppCode.app/Contents/MacOS/appcode": "/Applications/AppCode.app/Contents/MacOS/appcode",
      "/Applications/CLion.app/Contents/MacOS/clion": "/Applications/CLion.app/Contents/MacOS/clion",
      "/Applications/IntelliJ IDEA.app/Contents/MacOS/idea": "/Applications/IntelliJ IDEA.app/Contents/MacOS/idea",
      "/Applications/PhpStorm.app/Contents/MacOS/phpstorm": "/Applications/PhpStorm.app/Contents/MacOS/phpstorm",
      "/Applications/PyCharm.app/Contents/MacOS/pycharm": "/Applications/PyCharm.app/Contents/MacOS/pycharm",
      "/Applications/PyCharm CE.app/Contents/MacOS/pycharm": "/Applications/PyCharm CE.app/Contents/MacOS/pycharm",
      "/Applications/RubyMine.app/Contents/MacOS/rubymine": "/Applications/RubyMine.app/Contents/MacOS/rubymine",
      "/Applications/WebStorm.app/Contents/MacOS/webstorm": "/Applications/WebStorm.app/Contents/MacOS/webstorm"
    };
    var linux = {
      atom: "atom",
      Brackets: "brackets",
      code: "code",
      emacs: "emacs",
      "idea.sh": "idea",
      "phpstorm.sh": "phpstorm",
      "pycharm.sh": "pycharm",
      "rubymine.sh": "rubymine",
      sublime_text: "subl",
      vim: "vim",
      "webstorm.sh": "webstorm"
    };
    var windows = [
      "Brackets.exe",
      "Code.exe",
      "atom.exe",
      "sublime_text.exe",
      "notepad++.exe",
      "clion.exe",
      "clion64.exe",
      "idea.exe",
      "idea64.exe",
      "phpstorm.exe",
      "phpstorm64.exe",
      "pycharm.exe",
      "pycharm64.exe",
      "rubymine.exe",
      "rubymine64.exe",
      "webstorm.exe",
      "webstorm64.exe"
    ];
    var path$4 = path__default;
    var shellQuote = shellQuote$1;
    var childProcess$1 = require$$1__default$5;
    var COMMON_EDITORS_OSX = osx;
    var COMMON_EDITORS_LINUX = linux;
    var COMMON_EDITORS_WIN = windows;
    var guess = function guessEditor2(specifiedEditor) {
      if (specifiedEditor) {
        return shellQuote.parse(specifiedEditor);
      }
      try {
        if (process.platform === "darwin") {
          const output = childProcess$1.execSync("ps x").toString();
          const processNames = Object.keys(COMMON_EDITORS_OSX);
          for (let i2 = 0; i2 < processNames.length; i2++) {
            const processName = processNames[i2];
            if (output.indexOf(processName) !== -1) {
              return [COMMON_EDITORS_OSX[processName]];
            }
          }
        } else if (process.platform === "win32") {
          const output = childProcess$1.execSync('powershell -Command "Get-Process | Select-Object Path"', {
            stdio: ["pipe", "pipe", "ignore"]
          }).toString();
          const runningProcesses = output.split("\r\n");
          for (let i2 = 0; i2 < runningProcesses.length; i2++) {
            if (!runningProcesses[i2]) {
              continue;
            }
            const fullProcessPath = runningProcesses[i2].trim();
            const shortProcessName = path$4.basename(fullProcessPath);
            if (COMMON_EDITORS_WIN.indexOf(shortProcessName) !== -1) {
              return [fullProcessPath];
            }
          }
        } else if (process.platform === "linux") {
          const output = childProcess$1.execSync("ps x --no-heading -o comm --sort=comm").toString();
          const processNames = Object.keys(COMMON_EDITORS_LINUX);
          for (let i2 = 0; i2 < processNames.length; i2++) {
            const processName = processNames[i2];
            if (output.indexOf(processName) !== -1) {
              return [COMMON_EDITORS_LINUX[processName]];
            }
          }
        }
      } catch (error2) {
      }
      if (process.env.VISUAL) {
        return [process.env.VISUAL];
      } else if (process.env.EDITOR) {
        return [process.env.EDITOR];
      }
      return [null];
    };
    var path$3 = path__default;
    var getArgs = function getArgumentsForPosition2(editor, fileName, lineNumber, columnNumber = 1) {
      const editorBasename = path$3.basename(editor).replace(/\.(exe|cmd|bat)$/i, "");
      switch (editorBasename) {
        case "atom":
        case "Atom":
        case "Atom Beta":
        case "subl":
        case "sublime":
        case "sublime_text":
        case "wstorm":
        case "charm":
          return [`${fileName}:${lineNumber}:${columnNumber}`];
        case "notepad++":
          return ["-n" + lineNumber, fileName];
        case "vim":
        case "mvim":
          return [`+call cursor(${lineNumber}, ${columnNumber})`, fileName];
        case "joe":
          return [`+${lineNumber}`, fileName];
        case "emacs":
        case "emacsclient":
          return [`+${lineNumber}:${columnNumber}`, fileName];
        case "rmate":
        case "mate":
        case "mine":
          return ["--line", lineNumber, fileName];
        case "code":
        case "code-insiders":
        case "Code":
          return ["-r", "-g", `${fileName}:${lineNumber}:${columnNumber}`];
        case "appcode":
        case "clion":
        case "clion64":
        case "idea":
        case "idea64":
        case "phpstorm":
        case "phpstorm64":
        case "pycharm":
        case "pycharm64":
        case "rubymine":
        case "rubymine64":
        case "webstorm":
        case "webstorm64":
          return ["--line", lineNumber, fileName];
      }
      return [fileName];
    };
    var fs$1 = fs__default;
    var os$1 = require$$0__default$1;
    var path$2 = path__default;
    var colors = picocolors.exports;
    var childProcess = require$$1__default$5;
    var guessEditor = guess;
    var getArgumentsForPosition = getArgs;
    function wrapErrorCallback(cb) {
      return (fileName, errorMessage) => {
        console.log();
        console.log(colors.red("Could not open " + path$2.basename(fileName) + " in the editor."));
        if (errorMessage) {
          if (errorMessage[errorMessage.length - 1] !== ".") {
            errorMessage += ".";
          }
          console.log(colors.red("The editor process exited with an error: " + errorMessage));
        }
        console.log();
        if (cb)
          cb(fileName, errorMessage);
      };
    }
    function isTerminalEditor(editor) {
      switch (editor) {
        case "vim":
        case "emacs":
        case "nano":
          return true;
      }
      return false;
    }
    var positionRE = /:(\d+)(:(\d+))?$/;
    function parseFile(file) {
      const fileName = file.replace(positionRE, "");
      const match2 = file.match(positionRE);
      const lineNumber = match2 && match2[1];
      const columnNumber = match2 && match2[3];
      return {
        fileName,
        lineNumber,
        columnNumber
      };
    }
    var _childProcess = null;
    function launchEditor(file, specifiedEditor, onErrorCallback) {
      const parsed = parseFile(file);
      let { fileName } = parsed;
      const { lineNumber, columnNumber } = parsed;
      if (!fs$1.existsSync(fileName)) {
        return;
      }
      if (typeof specifiedEditor === "function") {
        onErrorCallback = specifiedEditor;
        specifiedEditor = void 0;
      }
      onErrorCallback = wrapErrorCallback(onErrorCallback);
      const [editor, ...args] = guessEditor(specifiedEditor);
      if (!editor) {
        onErrorCallback(fileName, null);
        return;
      }
      if (process.platform === "linux" && fileName.startsWith("/mnt/") && /Microsoft/i.test(os$1.release())) {
        fileName = path$2.relative("", fileName);
      }
      if (lineNumber) {
        const extraArgs = getArgumentsForPosition(editor, fileName, lineNumber, columnNumber);
        args.push.apply(args, extraArgs);
      } else {
        args.push(fileName);
      }
      if (_childProcess && isTerminalEditor(editor)) {
        _childProcess.kill("SIGKILL");
      }
      if (process.platform === "win32") {
        _childProcess = childProcess.spawn("cmd.exe", ["/C", editor].concat(args), { stdio: "inherit" });
      } else {
        _childProcess = childProcess.spawn(editor, args, { stdio: "inherit" });
      }
      _childProcess.on("exit", function(errorCode) {
        _childProcess = null;
        if (errorCode) {
          onErrorCallback(fileName, "(code " + errorCode + ")");
        }
      });
      _childProcess.on("error", function(error2) {
        onErrorCallback(fileName, error2.message);
      });
    }
    var launchEditor_1 = launchEditor;
    var url = require$$0__default$5;
    var path$1 = path__default;
    var launch = launchEditor_1;
    var launchEditorMiddleware = (specifiedEditor, srcRoot, onErrorCallback) => {
      if (typeof specifiedEditor === "function") {
        onErrorCallback = specifiedEditor;
        specifiedEditor = void 0;
      }
      if (typeof srcRoot === "function") {
        onErrorCallback = srcRoot;
        srcRoot = void 0;
      }
      srcRoot = srcRoot || process.cwd();
      return function launchEditorMiddleware2(req2, res, next) {
        const { file } = url.parse(req2.url, true).query || {};
        if (!file) {
          res.statusCode = 500;
          res.end(`launch-editor-middleware: required query param "file" is missing.`);
        } else {
          launch(path$1.resolve(srcRoot, file), specifiedEditor, onErrorCallback);
          res.end();
        }
      };
    };
    var externalTypes = [
      "css",
      "less",
      "sass",
      "scss",
      "styl",
      "stylus",
      "pcss",
      "postcss",
      "vue",
      "svelte",
      "marko",
      "astro",
      "jsx",
      "tsx",
      ...KNOWN_ASSET_TYPES
    ];
    function esbuildDepPlugin(qualified, exportsData, config2, ssr) {
      const _resolve = config2.createResolver({ asSrc: false });
      const _resolveRequire = config2.createResolver({
        asSrc: false,
        isRequire: true
      });
      const resolve2 = (id, importer, kind, resolveDir) => {
        let _importer;
        if (resolveDir) {
          _importer = normalizePath$4(path__default.join(resolveDir, "*"));
        } else {
          _importer = importer in qualified ? qualified[importer] : importer;
        }
        const resolver = kind.startsWith("require") ? _resolveRequire : _resolve;
        return resolver(id, _importer, void 0, ssr);
      };
      return {
        name: "vite:dep-pre-bundle",
        setup(build2) {
          build2.onResolve({
            filter: new RegExp(`\\.(` + externalTypes.join("|") + `)(\\?.*)?$`)
          }, async ({ path: id, importer, kind }) => {
            const resolved = await resolve2(id, importer, kind);
            if (resolved) {
              return {
                path: resolved,
                external: true
              };
            }
          });
          function resolveEntry(id) {
            const flatId = flattenId(id);
            if (flatId in qualified) {
              return {
                path: flatId,
                namespace: "dep"
              };
            }
          }
          build2.onResolve({ filter: /^[\w@][^:]/ }, async ({ path: id, importer, kind }) => {
            var _a2;
            if (moduleListContains((_a2 = config2.optimizeDeps) === null || _a2 === void 0 ? void 0 : _a2.exclude, id)) {
              return {
                path: id,
                external: true
              };
            }
            let entry2;
            if (!importer) {
              if (entry2 = resolveEntry(id))
                return entry2;
              const aliased = await _resolve(id, void 0, true);
              if (aliased && (entry2 = resolveEntry(aliased))) {
                return entry2;
              }
            }
            const resolved = await resolve2(id, importer, kind);
            if (resolved) {
              if (resolved.startsWith(browserExternalId)) {
                return {
                  path: id,
                  namespace: "browser-external"
                };
              }
              if (isExternalUrl(resolved)) {
                return {
                  path: resolved,
                  external: true
                };
              }
              return {
                path: path__default.resolve(resolved)
              };
            }
          });
          const root = path__default.resolve(config2.root);
          build2.onLoad({ filter: /.*/, namespace: "dep" }, ({ path: id }) => {
            const entryFile = qualified[id];
            let relativePath = normalizePath$4(path__default.relative(root, entryFile));
            if (!relativePath.startsWith("./") && !relativePath.startsWith("../") && relativePath !== ".") {
              relativePath = `./${relativePath}`;
            }
            let contents = "";
            const data2 = exportsData[id];
            const [imports, exports2] = data2;
            if (!imports.length && !exports2.length) {
              contents += `export default require("${relativePath}");`;
            } else {
              if (exports2.includes("default")) {
                contents += `import d from "${relativePath}";export default d;`;
              }
              if (data2.hasReExports || exports2.length > 1 || exports2[0] !== "default") {
                contents += `
export * from "${relativePath}"`;
              }
            }
            let ext2 = path__default.extname(entryFile).slice(1);
            if (ext2 === "mjs")
              ext2 = "js";
            return {
              loader: ext2,
              contents,
              resolveDir: root
            };
          });
          build2.onLoad({ filter: /.*/, namespace: "browser-external" }, ({ path: id }) => {
            return {
              contents: `export default new Proxy({}, {
  get() {
    throw new Error('Module "${id}" has been externalized for browser compatibility and cannot be accessed in client code.')
  }
})`
            };
          });
          if (isRunningWithYarnPnp) {
            build2.onResolve({ filter: /.*/ }, async ({ path: path2, importer, kind, resolveDir }) => ({
              path: await resolve2(path2, importer, kind, resolveDir)
            }));
            build2.onLoad({ filter: /.*/ }, async (args) => ({
              contents: await (init_fs(), fs_exports).promises.readFile(args.path),
              loader: "default"
            }));
          }
        }
      };
    }
    var debug$3 = createDebugger("vite:deps");
    async function optimizeDeps(config2, force = config2.server.force, asCommand = false, newDeps, ssr) {
      var _a2, _b, _c, _d;
      config2 = __spreadProps2(__spreadValues2({}, config2), {
        command: "build"
      });
      const { root, logger, cacheDir } = config2;
      const log2 = asCommand ? logger.info : debug$3;
      if (!cacheDir) {
        log2(`No cache directory. Skipping.`);
        return null;
      }
      const dataPath = path__default.join(cacheDir, "_metadata.json");
      const mainHash = getDepHash(root, config2);
      const data2 = {
        hash: mainHash,
        browserHash: mainHash,
        optimized: {}
      };
      if (!force) {
        let prevData;
        try {
          prevData = JSON.parse(fs__default.readFileSync(dataPath, "utf-8"));
        } catch (e2) {
        }
        if (prevData && prevData.hash === data2.hash) {
          log2("Hash is consistent. Skipping. Use --force to override.");
          return prevData;
        }
      }
      if (fs__default.existsSync(cacheDir)) {
        emptyDir(cacheDir);
      } else {
        fs__default.mkdirSync(cacheDir, { recursive: true });
      }
      writeFile(path__default.resolve(cacheDir, "package.json"), JSON.stringify({ type: "module" }));
      let deps, missing;
      if (!newDeps) {
        ({ deps, missing } = await scanImports(config2));
      } else {
        deps = newDeps;
        missing = {};
      }
      data2.browserHash = require$$1$1.createHash("sha256").update(data2.hash + JSON.stringify(deps)).digest("hex").substring(0, 8);
      const missingIds = Object.keys(missing);
      if (missingIds.length) {
        throw new Error(`The following dependencies are imported but could not be resolved:

  ${missingIds.map((id) => `${source.cyan(id)} ${source.white.dim(`(imported by ${missing[id]})`)}`).join(`
  `)}

Are they installed?`);
      }
      const include = (_a2 = config2.optimizeDeps) === null || _a2 === void 0 ? void 0 : _a2.include;
      if (include) {
        const resolve2 = config2.createResolver({ asSrc: false });
        for (const id of include) {
          const normalizedId = normalizeId$1(id);
          if (!deps[normalizedId]) {
            const entry2 = await resolve2(id);
            if (entry2) {
              deps[normalizedId] = entry2;
            } else {
              throw new Error(`Failed to resolve force included dependency: ${source.cyan(id)}`);
            }
          }
        }
      }
      const qualifiedIds = Object.keys(deps);
      if (!qualifiedIds.length) {
        writeFile(dataPath, JSON.stringify(data2, null, 2));
        log2(`No dependencies to bundle. Skipping.


`);
        return data2;
      }
      const total = qualifiedIds.length;
      const maxListed = 5;
      const listed = Math.min(total, maxListed);
      const extra = Math.max(0, total - maxListed);
      const depsString = source.yellow(qualifiedIds.slice(0, listed).join(`
  `) + (extra > 0 ? `
  (...and ${extra} more)` : ``));
      if (!asCommand) {
        if (!newDeps) {
          logger.info(source.greenBright(`Pre-bundling dependencies:
  ${depsString}`));
          logger.info(`(this will be run only when your dependencies or config have changed)`);
        }
      } else {
        logger.info(source.greenBright(`Optimizing dependencies:
  ${depsString}`));
      }
      const flatIdDeps = {};
      const idToExports = {};
      const flatIdToExports = {};
      const _a3 = (_c = (_b = config2.optimizeDeps) === null || _b === void 0 ? void 0 : _b.esbuildOptions) !== null && _c !== void 0 ? _c : {}, { plugins: plugins2 = [] } = _a3, esbuildOptions = __objRest(_a3, ["plugins"]);
      await init;
      for (const id in deps) {
        const flatId = flattenId(id);
        const filePath = flatIdDeps[flatId] = deps[id];
        const entryContent = fs__default.readFileSync(filePath, "utf-8");
        let exportsData;
        try {
          exportsData = parse$f(entryContent);
        } catch {
          debug$3(`Unable to parse dependency: ${id}. Trying again with a JSX transform.`);
          const transformed = await transformWithEsbuild(entryContent, filePath, {
            loader: "jsx"
          });
          esbuildOptions.loader = __spreadValues2({
            ".js": "jsx"
          }, esbuildOptions.loader);
          exportsData = parse$f(transformed.code);
        }
        for (const { ss: ss2, se: se2 } of exportsData[0]) {
          const exp = entryContent.slice(ss2, se2);
          if (/export\s+\*\s+from/.test(exp)) {
            exportsData.hasReExports = true;
          }
        }
        idToExports[id] = exportsData;
        flatIdToExports[flatId] = exportsData;
      }
      const define2 = {
        "process.env.NODE_ENV": JSON.stringify(config2.mode)
      };
      for (const key in config2.define) {
        const value = config2.define[key];
        define2[key] = typeof value === "string" ? value : JSON.stringify(value);
      }
      const start = perf_hooks.performance.now();
      const result2 = await esbuild.build(__spreadValues2({
        absWorkingDir: process.cwd(),
        entryPoints: Object.keys(flatIdDeps),
        bundle: true,
        format: "esm",
        target: config2.build.target || void 0,
        external: (_d = config2.optimizeDeps) === null || _d === void 0 ? void 0 : _d.exclude,
        logLevel: "error",
        splitting: true,
        sourcemap: true,
        outdir: cacheDir,
        ignoreAnnotations: true,
        metafile: true,
        define: define2,
        plugins: [
          ...plugins2,
          esbuildDepPlugin(flatIdDeps, flatIdToExports, config2, ssr)
        ]
      }, esbuildOptions));
      const meta = result2.metafile;
      const cacheDirOutputPath = path__default.relative(process.cwd(), cacheDir);
      for (const id in deps) {
        const entry2 = deps[id];
        data2.optimized[id] = {
          file: normalizePath$4(path__default.resolve(cacheDir, flattenId(id) + ".js")),
          src: entry2,
          needsInterop: needsInterop(id, idToExports[id], meta.outputs, cacheDirOutputPath)
        };
      }
      writeFile(dataPath, JSON.stringify(data2, null, 2));
      debug$3(`deps bundled in ${(perf_hooks.performance.now() - start).toFixed(2)}ms`);
      return data2;
    }
    var KNOWN_INTEROP_IDS = new Set(["moment"]);
    function needsInterop(id, exportsData, outputs, cacheDirOutputPath) {
      if (KNOWN_INTEROP_IDS.has(id)) {
        return true;
      }
      const [imports, exports2] = exportsData;
      if (!exports2.length && !imports.length) {
        return true;
      }
      const flatId = flattenId(id) + ".js";
      let generatedExports;
      for (const output in outputs) {
        if (normalizePath$4(output) === normalizePath$4(path__default.join(cacheDirOutputPath, flatId))) {
          generatedExports = outputs[output].exports;
          break;
        }
      }
      if (!generatedExports || isSingleDefaultExport(generatedExports) && !isSingleDefaultExport(exports2)) {
        return true;
      }
      return false;
    }
    function isSingleDefaultExport(exports2) {
      return exports2.length === 1 && exports2[0] === "default";
    }
    var lockfileFormats = ["package-lock.json", "yarn.lock", "pnpm-lock.yaml"];
    function getDepHash(root, config2) {
      var _a2, _b;
      let content2 = lookupFile(root, lockfileFormats) || "";
      content2 += JSON.stringify({
        mode: config2.mode,
        root: config2.root,
        resolve: config2.resolve,
        assetsInclude: config2.assetsInclude,
        plugins: config2.plugins.map((p2) => p2.name),
        optimizeDeps: {
          include: (_a2 = config2.optimizeDeps) === null || _a2 === void 0 ? void 0 : _a2.include,
          exclude: (_b = config2.optimizeDeps) === null || _b === void 0 ? void 0 : _b.exclude
        }
      }, (_2, value) => {
        if (typeof value === "function" || value instanceof RegExp) {
          return value.toString();
        }
        return value;
      });
      return require$$1$1.createHash("sha256").update(content2).digest("hex").substring(0, 8);
    }
    var index$1 = {
      __proto__: null,
      optimizeDeps
    };
    var sourceMapGenerator = {};
    var base64Vlq = {};
    var base64$1 = {};
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    base64$1.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    base64$1.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash2 = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash2) {
        return 63;
      }
      return -1;
    };
    var base64 = base64$1;
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative2 = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative2 ? -shifted : shifted;
    }
    base64Vlq.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result2 = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result2 = result2 + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result2);
      aOutParam.rest = aIndex;
    };
    var util$5 = {};
    (function(exports2) {
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports2.getArg = getArg;
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
      function urlParse(aUrl) {
        var match2 = aUrl.match(urlRegexp);
        if (!match2) {
          return null;
        }
        return {
          scheme: match2[1],
          auth: match2[2],
          host: match2[3],
          port: match2[4],
          path: match2[5]
        };
      }
      exports2.urlParse = urlParse;
      function urlGenerate(aParsedUrl) {
        var url2 = "";
        if (aParsedUrl.scheme) {
          url2 += aParsedUrl.scheme + ":";
        }
        url2 += "//";
        if (aParsedUrl.auth) {
          url2 += aParsedUrl.auth + "@";
        }
        if (aParsedUrl.host) {
          url2 += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url2 += ":" + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
          url2 += aParsedUrl.path;
        }
        return url2;
      }
      exports2.urlGenerate = urlGenerate;
      function normalize(aPath) {
        var path2 = aPath;
        var url2 = urlParse(aPath);
        if (url2) {
          if (!url2.path) {
            return aPath;
          }
          path2 = url2.path;
        }
        var isAbsolute2 = exports2.isAbsolute(path2);
        var parts = path2.split(/\/+/);
        for (var part, up = 0, i2 = parts.length - 1; i2 >= 0; i2--) {
          part = parts[i2];
          if (part === ".") {
            parts.splice(i2, 1);
          } else if (part === "..") {
            up++;
          } else if (up > 0) {
            if (part === "") {
              parts.splice(i2 + 1, up);
              up = 0;
            } else {
              parts.splice(i2, 2);
              up--;
            }
          }
        }
        path2 = parts.join("/");
        if (path2 === "") {
          path2 = isAbsolute2 ? "/" : ".";
        }
        if (url2) {
          url2.path = path2;
          return urlGenerate(url2);
        }
        return path2;
      }
      exports2.normalize = normalize;
      function join(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || "/";
        }
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
        var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports2.join = join;
      exports2.isAbsolute = function(aPath) {
        return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
      };
      function relative(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        aRoot = aRoot.replace(/\/$/, "");
        var level = 0;
        while (aPath.indexOf(aRoot + "/") !== 0) {
          var index2 = aRoot.lastIndexOf("/");
          if (index2 < 0) {
            return aPath;
          }
          aRoot = aRoot.slice(0, index2);
          if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
          }
          ++level;
        }
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      exports2.relative = relative;
      var supportsNullProto = function() {
        var obj = Object.create(null);
        return !("__proto__" in obj);
      }();
      function identity(s2) {
        return s2;
      }
      function toSetString(aStr) {
        if (isProtoString(aStr)) {
          return "$" + aStr;
        }
        return aStr;
      }
      exports2.toSetString = supportsNullProto ? identity : toSetString;
      function fromSetString(aStr) {
        if (isProtoString(aStr)) {
          return aStr.slice(1);
        }
        return aStr;
      }
      exports2.fromSetString = supportsNullProto ? identity : fromSetString;
      function isProtoString(s2) {
        if (!s2) {
          return false;
        }
        var length = s2.length;
        if (length < 9) {
          return false;
        }
        if (s2.charCodeAt(length - 1) !== 95 || s2.charCodeAt(length - 2) !== 95 || s2.charCodeAt(length - 3) !== 111 || s2.charCodeAt(length - 4) !== 116 || s2.charCodeAt(length - 5) !== 111 || s2.charCodeAt(length - 6) !== 114 || s2.charCodeAt(length - 7) !== 112 || s2.charCodeAt(length - 8) !== 95 || s2.charCodeAt(length - 9) !== 95) {
          return false;
        }
        for (var i2 = length - 10; i2 >= 0; i2--) {
          if (s2.charCodeAt(i2) !== 36) {
            return false;
          }
        }
        return true;
      }
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports2.compareByOriginalPositions = compareByOriginalPositions;
      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
      function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
          return 0;
        }
        if (aStr1 === null) {
          return 1;
        }
        if (aStr2 === null) {
          return -1;
        }
        if (aStr1 > aStr2) {
          return 1;
        }
        return -1;
      }
      function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
      function parseSourceMapInput(str) {
        return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
      }
      exports2.parseSourceMapInput = parseSourceMapInput;
      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
        sourceURL = sourceURL || "";
        if (sourceRoot) {
          if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
            sourceRoot += "/";
          }
          sourceURL = sourceRoot + sourceURL;
        }
        if (sourceMapURL) {
          var parsed = urlParse(sourceMapURL);
          if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
          }
          if (parsed.path) {
            var index2 = parsed.path.lastIndexOf("/");
            if (index2 >= 0) {
              parsed.path = parsed.path.substring(0, index2 + 1);
            }
          }
          sourceURL = join(urlGenerate(parsed), sourceURL);
        }
        return normalize(sourceURL);
      }
      exports2.computeSourceURL = computeSourceURL;
    })(util$5);
    var arraySet = {};
    var util$4 = util$5;
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet$2() {
      this._array = [];
      this._set = hasNativeMap ? new Map() : Object.create(null);
    }
    ArraySet$2.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set2 = new ArraySet$2();
      for (var i2 = 0, len = aArray.length; i2 < len; i2++) {
        set2.add(aArray[i2], aAllowDuplicates);
      }
      return set2;
    };
    ArraySet$2.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet$2.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util$4.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet$2.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util$4.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet$2.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util$4.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet$2.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet$2.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    arraySet.ArraySet = ArraySet$2;
    var mappingList = {};
    var util$3 = util$5;
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util$3.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList$1() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList$1.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList$1.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList$1.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util$3.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    mappingList.MappingList = MappingList$1;
    var base64VLQ$1 = base64Vlq;
    var util$2 = util$5;
    var ArraySet$1 = arraySet.ArraySet;
    var MappingList = mappingList.MappingList;
    function SourceMapGenerator$1(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util$2.getArg(aArgs, "file", null);
      this._sourceRoot = util$2.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util$2.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet$1();
      this._names = new ArraySet$1();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator$1.prototype._version = 3;
    SourceMapGenerator$1.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator$1({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util$2.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util$2.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content2 = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content2 != null) {
          generator.setSourceContent(sourceFile, content2);
        }
      });
      return generator;
    };
    SourceMapGenerator$1.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util$2.getArg(aArgs, "generated");
      var original = util$2.getArg(aArgs, "original", null);
      var source2 = util$2.getArg(aArgs, "source", null);
      var name = util$2.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source2, name);
      }
      if (source2 != null) {
        source2 = String(source2);
        if (!this._sources.has(source2)) {
          this._sources.add(source2);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source2,
        name
      });
    };
    SourceMapGenerator$1.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source2 = aSourceFile;
      if (this._sourceRoot != null) {
        source2 = util$2.relative(this._sourceRoot, source2);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util$2.toSetString(source2)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util$2.toSetString(source2)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator$1.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util$2.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet$1();
      var newNames = new ArraySet$1();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util$2.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util$2.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source2 = mapping.source;
        if (source2 != null && !newSources.has(source2)) {
          newSources.add(source2);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content2 = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content2 != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util$2.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util$2.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content2);
        }
      }, this);
    };
    SourceMapGenerator$1.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator$1.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result2 = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i2 = 0, len = mappings.length; i2 < len; i2++) {
        mapping = mappings[i2];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i2 > 0) {
            if (!util$2.compareByGeneratedPositionsInflated(mapping, mappings[i2 - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ$1.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ$1.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ$1.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ$1.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ$1.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result2 += next;
      }
      return result2;
    };
    SourceMapGenerator$1.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source2) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source2 = util$2.relative(aSourceRoot, source2);
        }
        var key = util$2.toSetString(source2);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator$1.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map2 = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map2.file = this._file;
      }
      if (this._sourceRoot != null) {
        map2.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map2.sourcesContent = this._generateSourcesContent(map2.sources, map2.sourceRoot);
      }
      return map2;
    };
    SourceMapGenerator$1.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    sourceMapGenerator.SourceMapGenerator = SourceMapGenerator$1;
    var sourceMapConsumer = {};
    var binarySearch$1 = {};
    (function(exports2) {
      exports2.GREATEST_LOWER_BOUND = 1;
      exports2.LEAST_UPPER_BOUND = 2;
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          return mid;
        } else if (cmp > 0) {
          if (aHigh - mid > 1) {
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports2.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
          } else {
            return mid;
          }
        } else {
          if (mid - aLow > 1) {
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports2.LEAST_UPPER_BOUND) {
            return mid;
          } else {
            return aLow < 0 ? -1 : aLow;
          }
        }
      }
      exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) {
          return -1;
        }
        var index2 = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports2.GREATEST_LOWER_BOUND);
        if (index2 < 0) {
          return -1;
        }
        while (index2 - 1 >= 0) {
          if (aCompare(aHaystack[index2], aHaystack[index2 - 1], true) !== 0) {
            break;
          }
          --index2;
        }
        return index2;
      };
    })(binarySearch$1);
    var quickSort$1 = {};
    function swap(ary, x2, y3) {
      var temp = ary[x2];
      ary[x2] = ary[y3];
      ary[y3] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p2, r2) {
      if (p2 < r2) {
        var pivotIndex = randomIntInRange(p2, r2);
        var i2 = p2 - 1;
        swap(ary, pivotIndex, r2);
        var pivot = ary[r2];
        for (var j2 = p2; j2 < r2; j2++) {
          if (comparator(ary[j2], pivot) <= 0) {
            i2 += 1;
            swap(ary, i2, j2);
          }
        }
        swap(ary, i2 + 1, j2);
        var q2 = i2 + 1;
        doQuickSort(ary, comparator, p2, q2 - 1);
        doQuickSort(ary, comparator, q2 + 1, r2);
      }
    }
    quickSort$1.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
    var util$1 = util$5;
    var binarySearch = binarySearch$1;
    var ArraySet = arraySet.ArraySet;
    var base64VLQ = base64Vlq;
    var quickSort = quickSort$1.quickSort;
    function SourceMapConsumer$1(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util$1.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer$1.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer$1.prototype._version = 3;
    SourceMapConsumer$1.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer$1.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer$1.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer$1.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer$1.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index2) {
      var c2 = aStr.charAt(index2);
      return c2 === ";" || c2 === ",";
    };
    SourceMapConsumer$1.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer$1.GENERATED_ORDER = 1;
    SourceMapConsumer$1.ORIGINAL_ORDER = 2;
    SourceMapConsumer$1.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer$1.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer$1.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context2 = aContext || null;
      var order = aOrder || SourceMapConsumer$1.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer$1.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer$1.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source2 = mapping.source === null ? null : this._sources.at(mapping.source);
        source2 = util$1.computeSourceURL(sourceRoot, source2, this._sourceMapURL);
        return {
          source: source2,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context2);
    };
    SourceMapConsumer$1.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util$1.getArg(aArgs, "line");
      var needle = {
        source: util$1.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util$1.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index2 = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$1.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
      if (index2 >= 0) {
        var mapping = this._originalMappings[index2];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util$1.getArg(mapping, "generatedLine", null),
              column: util$1.getArg(mapping, "generatedColumn", null),
              lastColumn: util$1.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index2];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util$1.getArg(mapping, "generatedLine", null),
              column: util$1.getArg(mapping, "generatedColumn", null),
              lastColumn: util$1.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index2];
          }
        }
      }
      return mappings;
    };
    sourceMapConsumer.SourceMapConsumer = SourceMapConsumer$1;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util$1.parseSourceMapInput(aSourceMap);
      }
      var version2 = util$1.getArg(sourceMap, "version");
      var sources = util$1.getArg(sourceMap, "sources");
      var names = util$1.getArg(sourceMap, "names", []);
      var sourceRoot = util$1.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util$1.getArg(sourceMap, "sourcesContent", null);
      var mappings = util$1.getArg(sourceMap, "mappings");
      var file = util$1.getArg(sourceMap, "file", null);
      if (version2 != this._version) {
        throw new Error("Unsupported version: " + version2);
      }
      if (sourceRoot) {
        sourceRoot = util$1.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util$1.normalize).map(function(source2) {
        return sourceRoot && util$1.isAbsolute(sourceRoot) && util$1.isAbsolute(source2) ? util$1.relative(sourceRoot, source2) : source2;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s2) {
        return util$1.computeSourceURL(sourceRoot, s2, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer$1;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util$1.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i2;
      for (i2 = 0; i2 < this._absoluteSources.length; ++i2) {
        if (this._absoluteSources[i2] == aSource) {
          return i2;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s2) {
        return util$1.computeSourceURL(smc.sourceRoot, s2, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i2 = 0, length = generatedMappings.length; i2 < length; i2++) {
        var srcMapping = generatedMappings[i2];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util$1.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index2 = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index2 < length) {
        if (aStr.charAt(index2) === ";") {
          generatedLine++;
          index2++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index2) === ",") {
          index2++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index2; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index2, end);
          segment = cachedSegments[str];
          if (segment) {
            index2 += str.length;
          } else {
            segment = [];
            while (index2 < end) {
              base64VLQ.decode(aStr, index2, temp);
              value = temp.value;
              index2 = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util$1.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util$1.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index2 = 0; index2 < this._generatedMappings.length; ++index2) {
        var mapping = this._generatedMappings[index2];
        if (index2 + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index2 + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util$1.getArg(aArgs, "line"),
        generatedColumn: util$1.getArg(aArgs, "column")
      };
      var index2 = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util$1.compareByGeneratedPositionsDeflated, util$1.getArg(aArgs, "bias", SourceMapConsumer$1.GREATEST_LOWER_BOUND));
      if (index2 >= 0) {
        var mapping = this._generatedMappings[index2];
        if (mapping.generatedLine === needle.generatedLine) {
          var source2 = util$1.getArg(mapping, "source", null);
          if (source2 !== null) {
            source2 = this._sources.at(source2);
            source2 = util$1.computeSourceURL(this.sourceRoot, source2, this._sourceMapURL);
          }
          var name = util$1.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source: source2,
            line: util$1.getArg(mapping, "originalLine", null),
            column: util$1.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index2 = this._findSourceIndex(aSource);
      if (index2 >= 0) {
        return this.sourcesContent[index2];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util$1.relative(this.sourceRoot, relativeSource);
      }
      var url2;
      if (this.sourceRoot != null && (url2 = util$1.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url2.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url2.path || url2.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source2 = util$1.getArg(aArgs, "source");
      source2 = this._findSourceIndex(source2);
      if (source2 < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source: source2,
        originalLine: util$1.getArg(aArgs, "line"),
        originalColumn: util$1.getArg(aArgs, "column")
      };
      var index2 = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$1.compareByOriginalPositions, util$1.getArg(aArgs, "bias", SourceMapConsumer$1.GREATEST_LOWER_BOUND));
      if (index2 >= 0) {
        var mapping = this._originalMappings[index2];
        if (mapping.source === needle.source) {
          return {
            line: util$1.getArg(mapping, "generatedLine", null),
            column: util$1.getArg(mapping, "generatedColumn", null),
            lastColumn: util$1.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util$1.parseSourceMapInput(aSourceMap);
      }
      var version2 = util$1.getArg(sourceMap, "version");
      var sections = util$1.getArg(sourceMap, "sections");
      if (version2 != this._version) {
        throw new Error("Unsupported version: " + version2);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s2) {
        if (s2.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset2 = util$1.getArg(s2, "offset");
        var offsetLine = util$1.getArg(offset2, "line");
        var offsetColumn = util$1.getArg(offset2, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset2;
        return {
          generatedOffset: {
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer$1(util$1.getArg(s2, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer$1;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i2 = 0; i2 < this._sections.length; i2++) {
          for (var j2 = 0; j2 < this._sections[i2].consumer.sources.length; j2++) {
            sources.push(this._sections[i2].consumer.sources[j2]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util$1.getArg(aArgs, "line"),
        generatedColumn: util$1.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
        var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }
        return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
      });
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s2) {
        return s2.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        var content2 = section.consumer.sourceContentFor(aSource, true);
        if (content2) {
          return content2;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        if (section.consumer._findSourceIndex(util$1.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        var section = this._sections[i2];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j2 = 0; j2 < sectionMappings.length; j2++) {
          var mapping = sectionMappings[j2];
          var source2 = section.consumer._sources.at(mapping.source);
          source2 = util$1.computeSourceURL(section.consumer.sourceRoot, source2, this._sourceMapURL);
          this._sources.add(source2);
          source2 = this._sources.indexOf(source2);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source: source2,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util$1.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util$1.compareByOriginalPositions);
    };
    sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    var SourceMapGenerator = sourceMapGenerator.SourceMapGenerator;
    var util = util$5;
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node2 = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node2.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node2.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node2.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content2 = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content2 != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node2.setSourceContent(sourceFile, content2);
        }
      });
      return node2;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node2.add(code);
        } else {
          var source2 = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node2.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source2, code, mapping.name));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i2 = aChunk.length - 1; i2 >= 0; i2--) {
          this.prepend(aChunk[i2]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i2 = 0, len = this.children.length; i2 < len; i2++) {
        chunk = this.children[i2];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i2;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i2 = 0; i2 < len - 1; i2++) {
          newChildren.push(this.children[i2]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i2]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i2 = 0, len = this.children.length; i2 < len; i2++) {
        if (this.children[i2][isSourceNode]) {
          this.children[i2].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i2 = 0, len = sources.length; i2 < len; i2++) {
        aFn(util.fromSetString(sources[i2]), this.sourceContents[sources[i2]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map2 = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map2.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map2.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map2.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map2.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map: map2 };
    };
    var SourceMapConsumer = sourceMapConsumer.SourceMapConsumer;
    var offset;
    try {
      new Function("throw new Error(1)")();
    } catch (e2) {
      const match2 = /:(\d+):\d+\)$/.exec(e2.stack.split("\n")[1]);
      offset = match2 ? +match2[1] - 1 : 0;
    }
    function ssrRewriteStacktrace(stack, moduleGraph) {
      return stack.split("\n").map((line) => {
        return line.replace(/^ {4}at (?:(.+?)\s+\()?(?:(.+?):(\d+)(?::(\d+))?)\)?/, (input, varName, url2, line2, column) => {
          var _a2;
          if (!url2)
            return input;
          const mod = moduleGraph.urlToModuleMap.get(url2);
          const rawSourceMap = (_a2 = mod === null || mod === void 0 ? void 0 : mod.ssrTransformResult) === null || _a2 === void 0 ? void 0 : _a2.map;
          if (!rawSourceMap) {
            return input;
          }
          const consumer = new SourceMapConsumer(rawSourceMap);
          const pos = consumer.originalPositionFor({
            line: Number(line2) - offset,
            column: Number(column),
            bias: SourceMapConsumer.LEAST_UPPER_BOUND
          });
          if (!pos.source) {
            return input;
          }
          const source2 = `${pos.source}:${pos.line || 0}:${pos.column || 0}`;
          if (!varName || varName === "eval") {
            return `    at ${source2}`;
          } else {
            return `    at ${varName} (${source2})`;
          }
        });
      }).join("\n");
    }
    function rebindErrorStacktrace(e2, stacktrace) {
      const { configurable, writable } = Object.getOwnPropertyDescriptor(e2, "stack");
      if (configurable) {
        Object.defineProperty(e2, "stack", {
          value: stacktrace,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else if (writable) {
        e2.stack = stacktrace;
      }
    }
    function ssrRequireHookPlugin(config2) {
      var _a2, _b;
      if (config2.command !== "build" || !((_a2 = config2.resolve.dedupe) === null || _a2 === void 0 ? void 0 : _a2.length) || ((_b = config2.ssr) === null || _b === void 0 ? void 0 : _b.noExternal) === true || isBuildOutputEsm(config2)) {
        return null;
      }
      return {
        name: "vite:ssr-require-hook",
        transform(code, id) {
          const moduleInfo = this.getModuleInfo(id);
          if (moduleInfo === null || moduleInfo === void 0 ? void 0 : moduleInfo.isEntry) {
            const s2 = new MagicString(code);
            s2.prepend(`;(${dedupeRequire.toString()})(${JSON.stringify(config2.resolve.dedupe)});
`);
            return {
              code: s2.toString(),
              map: s2.generateMap({
                source: id,
                hires: true
              })
            };
          }
        }
      };
    }
    function dedupeRequire(dedupe) {
      const Module2 = (init_module(), module_exports);
      const resolveFilename = Module2._resolveFilename;
      Module2._resolveFilename = function(request, parent, isMain, options2) {
        if (request[0] !== "." && request[0] !== "/") {
          const parts = request.split("/");
          const pkgName = parts[0][0] === "@" ? parts[0] + "/" + parts[1] : parts[0];
          if (dedupe.includes(pkgName)) {
            parent = module;
          }
        }
        return resolveFilename(request, parent, isMain, options2);
      };
    }
    function hookNodeResolve(getResolver) {
      const Module2 = (init_module(), module_exports);
      const prevResolver = Module2._resolveFilename;
      Module2._resolveFilename = getResolver(prevResolver);
      return () => {
        Module2._resolveFilename = prevResolver;
      };
    }
    function isBuildOutputEsm(config2) {
      var _a2;
      const outputs = arraify((_a2 = config2.build.rollupOptions) === null || _a2 === void 0 ? void 0 : _a2.output);
      return outputs.some((output) => (output === null || output === void 0 ? void 0 : output.format) === "es" || (output === null || output === void 0 ? void 0 : output.format) === "esm");
    }
    var pendingModules = new Map();
    var pendingImports = new Map();
    async function ssrLoadModule(url2, server2, context2 = { global }, urlStack = []) {
      url2 = unwrapId$1(url2);
      const pending = pendingModules.get(url2);
      if (pending) {
        return pending;
      }
      const modulePromise = instantiateModule(url2, server2, context2, urlStack);
      pendingModules.set(url2, modulePromise);
      modulePromise.catch(() => {
        pendingImports.delete(url2);
      }).finally(() => {
        pendingModules.delete(url2);
      });
      return modulePromise;
    }
    async function instantiateModule(url2, server2, context2 = { global }, urlStack = []) {
      const { moduleGraph } = server2;
      const mod = await moduleGraph.ensureEntryFromUrl(url2);
      if (mod.ssrModule) {
        return mod.ssrModule;
      }
      const result2 = mod.ssrTransformResult || await transformRequest(url2, server2, { ssr: true });
      if (!result2) {
        throw new Error(`failed to load module for ssr: ${url2}`);
      }
      const ssrModule = {
        [Symbol.toStringTag]: "Module"
      };
      Object.defineProperty(ssrModule, "__esModule", { value: true });
      mod.ssrModule = ssrModule;
      const ssrImportMeta = {
        url: require$$0$6.pathToFileURL(mod.file).toString()
      };
      urlStack = urlStack.concat(url2);
      const isCircular = (url3) => urlStack.includes(url3);
      const { isProduction, resolve: { dedupe, preserveSymlinks }, root } = server2.config;
      const resolveOptions = {
        dedupe,
        extensions: [".js", ".cjs", ".json"],
        isBuild: true,
        isProduction,
        isRequire: true,
        mainFields: ["main"],
        preserveSymlinks,
        root
      };
      const pendingDeps = [];
      const ssrImport = async (dep) => {
        var _a2, _b;
        if (dep[0] !== "." && dep[0] !== "/") {
          return nodeImport(dep, mod.file, resolveOptions);
        }
        dep = unwrapId$1(dep);
        if (!isCircular(dep) && !((_a2 = pendingImports.get(dep)) === null || _a2 === void 0 ? void 0 : _a2.some(isCircular))) {
          pendingDeps.push(dep);
          if (pendingDeps.length === 1) {
            pendingImports.set(url2, pendingDeps);
          }
          const mod2 = await ssrLoadModule(dep, server2, context2, urlStack);
          if (pendingDeps.length === 1) {
            pendingImports.delete(url2);
          } else {
            pendingDeps.splice(pendingDeps.indexOf(dep), 1);
          }
          return mod2;
        }
        return (_b = moduleGraph.urlToModuleMap.get(dep)) === null || _b === void 0 ? void 0 : _b.ssrModule;
      };
      const ssrDynamicImport = (dep) => {
        if (dep[0] === ".") {
          dep = path__default.posix.resolve(path__default.dirname(url2), dep);
        }
        return ssrImport(dep);
      };
      function ssrExportAll(sourceModule) {
        for (const key in sourceModule) {
          if (key !== "default") {
            Object.defineProperty(ssrModule, key, {
              enumerable: true,
              configurable: true,
              get() {
                return sourceModule[key];
              }
            });
          }
        }
      }
      try {
        const AsyncFunction = async function() {
        }.constructor;
        const initModule = new AsyncFunction(`global`, ssrModuleExportsKey, ssrImportMetaKey, ssrImportKey, ssrDynamicImportKey, ssrExportAllKey, result2.code + `
//# sourceURL=${mod.url}`);
        await initModule(context2.global, ssrModule, ssrImportMeta, ssrImport, ssrDynamicImport, ssrExportAll);
      } catch (e2) {
        const stacktrace = ssrRewriteStacktrace(e2.stack, moduleGraph);
        rebindErrorStacktrace(e2, stacktrace);
        server2.config.logger.error(`Error when evaluating SSR module ${url2}:
${stacktrace}`, {
          timestamp: true,
          clear: server2.config.clearScreen,
          error: e2
        });
        throw e2;
      }
      return Object.freeze(ssrModule);
    }
    async function nodeImport(id, importer, resolveOptions) {
      const viteResolve = (id2, importer2, options2 = resolveOptions) => {
        const resolved = tryNodeResolve(id2, importer2, options2, false);
        if (!resolved) {
          const err = new Error(`Cannot find module '${id2}' imported from '${importer2}'`);
          err.code = "ERR_MODULE_NOT_FOUND";
          throw err;
        }
        return resolved.id;
      };
      const unhookNodeResolve = hookNodeResolve((nodeResolve) => (id2, parent, isMain, options2) => {
        if (id2[0] === "." || isBuiltin(id2) || id2.endsWith(".node")) {
          return nodeResolve(id2, parent, isMain, options2);
        }
        if (parent) {
          return viteResolve(id2, parent.id);
        }
        return id2;
      });
      let url2;
      if (id.startsWith("node:") || isBuiltin(id)) {
        url2 = id;
      } else {
        url2 = viteResolve(id, importer, typeof jest === "undefined" ? __spreadProps2(__spreadValues2({}, resolveOptions), { tryEsmOnly: true }) : resolveOptions);
        if (usingDynamicImport) {
          url2 = require$$0$6.pathToFileURL(url2).toString();
        }
      }
      try {
        const mod = await dynamicImport(url2);
        return proxyESM(mod);
      } finally {
        unhookNodeResolve();
      }
    }
    function proxyESM(mod) {
      if (isPrimitive(mod))
        return { default: mod };
      let defaultExport = "default" in mod ? mod.default : mod;
      if (!isPrimitive(defaultExport) && "__esModule" in defaultExport) {
        mod = defaultExport;
        if ("default" in defaultExport) {
          defaultExport = defaultExport.default;
        }
      }
      return new Proxy(mod, {
        get(mod2, prop) {
          var _a2;
          if (prop === "default")
            return defaultExport;
          return (_a2 = mod2[prop]) !== null && _a2 !== void 0 ? _a2 : defaultExport === null || defaultExport === void 0 ? void 0 : defaultExport[prop];
        }
      });
    }
    function isPrimitive(value) {
      return !value || typeof value !== "object" && typeof value !== "function";
    }
    var debounceMs = 100;
    function createMissingImporterRegisterFn(server2) {
      const { logger } = server2.config;
      let knownOptimized = server2._optimizeDepsMetadata.optimized;
      let currentMissing = {};
      let handle;
      let pendingResolve = null;
      async function rerun(ssr) {
        const newDeps = currentMissing;
        currentMissing = {};
        logger.info(source.yellow(`new dependencies found: ${Object.keys(newDeps).join(", ")}, updating...`), {
          timestamp: true
        });
        for (const id in knownOptimized) {
          newDeps[id] = knownOptimized[id].src;
        }
        try {
          server2._isRunningOptimizer = true;
          server2._optimizeDepsMetadata = null;
          const newData = server2._optimizeDepsMetadata = await optimizeDeps(server2.config, true, false, newDeps, ssr);
          knownOptimized = newData.optimized;
          server2._ssrExternals = resolveSSRExternal(server2.config, Object.keys(knownOptimized));
          logger.info(source.greenBright(`\u2728 dependencies updated, reloading page...`), { timestamp: true });
        } catch (e2) {
          logger.error(source.red(`error while updating dependencies:
${e2.stack}`), { timestamp: true, error: e2 });
        } finally {
          server2._isRunningOptimizer = false;
          if (!handle) {
            pendingResolve && pendingResolve();
            server2._pendingReload = pendingResolve = null;
          }
        }
        server2.moduleGraph.invalidateAll();
        server2.ws.send({
          type: "full-reload",
          path: "*"
        });
      }
      return function registerMissingImport(id, resolved, ssr) {
        if (!knownOptimized[id]) {
          currentMissing[id] = resolved;
          if (handle)
            clearTimeout(handle);
          handle = setTimeout(() => {
            handle = void 0;
            rerun(ssr);
          }, debounceMs);
          if (!server2._pendingReload) {
            server2._pendingReload = new Promise((r2) => {
              pendingResolve = r2;
            });
          }
        }
      };
    }
    var ROOT_FILES = [
      "pnpm-workspace.yaml"
    ];
    function hasWorkspacePackageJSON(root) {
      const path2 = path$t.join(root, "package.json");
      if (!isFileReadable(path2)) {
        return false;
      }
      const content2 = JSON.parse(fs__default.readFileSync(path2, "utf-8")) || {};
      return !!content2.workspaces;
    }
    function hasRootFile(root) {
      return ROOT_FILES.some((file) => fs__default.existsSync(path$t.join(root, file)));
    }
    function hasPackageJSON(root) {
      const path2 = path$t.join(root, "package.json");
      return fs__default.existsSync(path2);
    }
    function searchForPackageRoot(current, root = current) {
      if (hasPackageJSON(current))
        return current;
      const dir = path$t.dirname(current);
      if (!dir || dir === current)
        return root;
      return searchForPackageRoot(dir, root);
    }
    function searchForWorkspaceRoot(current, root = searchForPackageRoot(current)) {
      if (hasRootFile(current))
        return current;
      if (hasWorkspacePackageJSON(current))
        return current;
      const dir = path$t.dirname(current);
      if (!dir || dir === current)
        return root;
      return searchForWorkspaceRoot(dir, root);
    }
    async function createServer(inlineConfig = {}) {
      const config2 = await resolveConfig(inlineConfig, "serve", "development");
      const root = config2.root;
      const serverConfig = config2.server;
      const httpsOptions = await resolveHttpsConfig(config2.server.https);
      let { middlewareMode } = serverConfig;
      if (middlewareMode === true) {
        middlewareMode = "ssr";
      }
      const middlewares = connect();
      const httpServer = middlewareMode ? null : await resolveHttpServer(serverConfig, middlewares, httpsOptions);
      const ws2 = createWebSocketServer(httpServer, config2, httpsOptions);
      const _a2 = serverConfig.watch || {}, { ignored = [] } = _a2, watchOptions = __objRest(_a2, ["ignored"]);
      const watcher = chokidar.watch(path__default.resolve(root), __spreadValues2({
        ignored: [
          "**/node_modules/**",
          "**/.git/**",
          ...Array.isArray(ignored) ? ignored : [ignored]
        ],
        ignoreInitial: true,
        ignorePermissionErrors: true,
        disableGlobbing: true
      }, watchOptions));
      const moduleGraph = new ModuleGraph((url2) => container.resolveId(url2));
      const container = await createPluginContainer(config2, moduleGraph, watcher);
      const closeHttpServer = createServerCloseFn(httpServer);
      let exitProcess;
      const server2 = {
        config: config2,
        middlewares,
        get app() {
          config2.logger.warn(`ViteDevServer.app is deprecated. Use ViteDevServer.middlewares instead.`);
          return middlewares;
        },
        httpServer,
        watcher,
        pluginContainer: container,
        ws: ws2,
        moduleGraph,
        ssrTransform,
        transformWithEsbuild,
        transformRequest(url2, options2) {
          return transformRequest(url2, server2, options2);
        },
        transformIndexHtml: null,
        ssrLoadModule(url2) {
          server2._ssrExternals || (server2._ssrExternals = resolveSSRExternal(config2, server2._optimizeDepsMetadata ? Object.keys(server2._optimizeDepsMetadata.optimized) : []));
          return ssrLoadModule(url2, server2);
        },
        ssrFixStacktrace(e2) {
          if (e2.stack) {
            const stacktrace = ssrRewriteStacktrace(e2.stack, moduleGraph);
            rebindErrorStacktrace(e2, stacktrace);
          }
        },
        listen(port, isRestart) {
          return startServer(server2, port, isRestart);
        },
        async close() {
          process.off("SIGTERM", exitProcess);
          if (!middlewareMode && process.env.CI !== "true") {
            process.stdin.off("end", exitProcess);
          }
          await Promise.all([
            watcher.close(),
            ws2.close(),
            container.close(),
            closeHttpServer()
          ]);
        },
        printUrls() {
          if (httpServer) {
            printCommonServerUrls(httpServer, config2.server, config2);
          } else {
            throw new Error("cannot print server URLs in middleware mode.");
          }
        },
        async restart(forceOptimize) {
          if (!server2._restartPromise) {
            server2._forceOptimizeOnRestart = !!forceOptimize;
            server2._restartPromise = restartServer(server2).finally(() => {
              server2._restartPromise = null;
              server2._forceOptimizeOnRestart = false;
            });
          }
          return server2._restartPromise;
        },
        _optimizeDepsMetadata: null,
        _ssrExternals: null,
        _globImporters: Object.create(null),
        _restartPromise: null,
        _forceOptimizeOnRestart: false,
        _isRunningOptimizer: false,
        _registerMissingImport: null,
        _pendingReload: null,
        _pendingRequests: new Map()
      };
      server2.transformIndexHtml = createDevHtmlTransformFn(server2);
      exitProcess = async () => {
        try {
          await server2.close();
        } finally {
          process.exit(0);
        }
      };
      process.once("SIGTERM", exitProcess);
      if (!middlewareMode && process.env.CI !== "true") {
        process.stdin.on("end", exitProcess);
      }
      const { packageCache } = config2;
      const setPackageData = packageCache.set.bind(packageCache);
      packageCache.set = (id, pkg) => {
        if (id.endsWith(".json")) {
          watcher.add(id);
        }
        return setPackageData(id, pkg);
      };
      watcher.on("change", async (file) => {
        file = normalizePath$4(file);
        if (file.endsWith("/package.json")) {
          return invalidatePackageData(packageCache, file);
        }
        moduleGraph.onFileChange(file);
        if (serverConfig.hmr !== false) {
          try {
            await handleHMRUpdate(file, server2);
          } catch (err) {
            ws2.send({
              type: "error",
              err: prepareError(err)
            });
          }
        }
      });
      watcher.on("add", (file) => {
        handleFileAddUnlink(normalizePath$4(file), server2);
      });
      watcher.on("unlink", (file) => {
        handleFileAddUnlink(normalizePath$4(file), server2, true);
      });
      if (!middlewareMode && httpServer) {
        httpServer.once("listening", () => {
          serverConfig.port = httpServer.address().port;
        });
      }
      const postHooks = [];
      for (const plugin of config2.plugins) {
        if (plugin.configureServer) {
          postHooks.push(await plugin.configureServer(server2));
        }
      }
      if (process.env.DEBUG) {
        middlewares.use(timeMiddleware(root));
      }
      const { cors } = serverConfig;
      if (cors !== false) {
        middlewares.use(corsMiddleware(typeof cors === "boolean" ? {} : cors));
      }
      const { proxy } = serverConfig;
      if (proxy) {
        middlewares.use(proxyMiddleware(httpServer, config2));
      }
      if (config2.base !== "/") {
        middlewares.use(baseMiddleware(server2));
      }
      middlewares.use("/__open-in-editor", launchEditorMiddleware());
      middlewares.use("/__vite_ping", function viteHMRPingMiddleware(_2, res) {
        res.end("pong");
      });
      if (config2.publicDir) {
        middlewares.use(servePublicMiddleware(config2.publicDir));
      }
      middlewares.use(transformMiddleware(server2));
      middlewares.use(serveRawFsMiddleware(server2));
      middlewares.use(serveStaticMiddleware(root, server2));
      if (!middlewareMode || middlewareMode === "html") {
        middlewares.use(spaFallbackMiddleware(root));
      }
      postHooks.forEach((fn2) => fn2 && fn2());
      if (!middlewareMode || middlewareMode === "html") {
        middlewares.use(indexHtmlMiddleware(server2));
        middlewares.use(function vite404Middleware(_2, res) {
          res.statusCode = 404;
          res.end();
        });
      }
      middlewares.use(errorMiddleware(server2, !!middlewareMode));
      const runOptimize = async () => {
        if (config2.cacheDir) {
          server2._isRunningOptimizer = true;
          try {
            server2._optimizeDepsMetadata = await optimizeDeps(config2, config2.server.force || server2._forceOptimizeOnRestart);
          } finally {
            server2._isRunningOptimizer = false;
          }
          server2._registerMissingImport = createMissingImporterRegisterFn(server2);
        }
      };
      if (!middlewareMode && httpServer) {
        let isOptimized = false;
        const listen = httpServer.listen.bind(httpServer);
        httpServer.listen = async (port, ...args) => {
          if (!isOptimized) {
            try {
              await container.buildStart({});
              await runOptimize();
              isOptimized = true;
            } catch (e2) {
              httpServer.emit("error", e2);
              return;
            }
          }
          return listen(port, ...args);
        };
      } else {
        await container.buildStart({});
        await runOptimize();
      }
      return server2;
    }
    async function startServer(server2, inlinePort, isRestart = false) {
      const httpServer = server2.httpServer;
      if (!httpServer) {
        throw new Error("Cannot call server.listen in middleware mode.");
      }
      const options2 = server2.config.server;
      const port = inlinePort || options2.port || 3e3;
      const hostname = resolveHostname(options2.host);
      const protocol = options2.https ? "https" : "http";
      const info = server2.config.logger.info;
      const base2 = server2.config.base;
      const serverPort = await httpServerStart(httpServer, {
        port,
        strictPort: options2.strictPort,
        host: hostname.host,
        logger: server2.config.logger
      });
      const profileSession = global.__vite_profile_session;
      if (profileSession) {
        profileSession.post("Profiler.stop", (err, { profile }) => {
          if (!err) {
            const outPath = path__default.resolve("./vite-profile.cpuprofile");
            fs__default.writeFileSync(outPath, JSON.stringify(profile));
            info(source.yellow(`  CPU profile written to ${source.white.dim(outPath)}
`));
          } else {
            throw err;
          }
        });
      }
      if (options2.open && !isRestart) {
        const path2 = typeof options2.open === "string" ? options2.open : base2;
        openBrowser(path2.startsWith("http") ? path2 : `${protocol}://${hostname.name}:${serverPort}${path2}`, true, server2.config.logger);
      }
      return server2;
    }
    function createServerCloseFn(server2) {
      if (!server2) {
        return () => {
        };
      }
      let hasListened = false;
      const openSockets = new Set();
      server2.on("connection", (socket) => {
        openSockets.add(socket);
        socket.on("close", () => {
          openSockets.delete(socket);
        });
      });
      server2.once("listening", () => {
        hasListened = true;
      });
      return () => new Promise((resolve2, reject) => {
        openSockets.forEach((s2) => s2.destroy());
        if (hasListened) {
          server2.close((err) => {
            if (err) {
              reject(err);
            } else {
              resolve2();
            }
          });
        } else {
          resolve2();
        }
      });
    }
    function resolvedAllowDir(root, dir) {
      return ensureLeadingSlash(normalizePath$4(path__default.resolve(root, dir)));
    }
    function resolveServerOptions(root, raw) {
      var _a2, _b, _c, _d;
      const server2 = __spreadValues2({
        preTransformRequests: true
      }, raw);
      let allowDirs = (_a2 = server2.fs) === null || _a2 === void 0 ? void 0 : _a2.allow;
      const deny = ((_b = server2.fs) === null || _b === void 0 ? void 0 : _b.deny) || [".env", ".env.*", "*.{crt,pem}"];
      if (!allowDirs) {
        allowDirs = [searchForWorkspaceRoot(root)];
      }
      allowDirs = allowDirs.map((i2) => resolvedAllowDir(root, i2));
      const resolvedClientDir = resolvedAllowDir(root, CLIENT_DIR);
      if (!allowDirs.some((i2) => resolvedClientDir.startsWith(i2))) {
        allowDirs.push(resolvedClientDir);
      }
      server2.fs = {
        strict: (_d = (_c = server2.fs) === null || _c === void 0 ? void 0 : _c.strict) !== null && _d !== void 0 ? _d : true,
        allow: allowDirs,
        deny
      };
      return server2;
    }
    async function restartServer(server2) {
      global.__vite_start_time = perf_hooks.performance.now();
      const { port: prevPort, host: prevHost } = server2.config.server;
      await server2.close();
      let newServer = null;
      try {
        newServer = await createServer(server2.config.inlineConfig);
      } catch (err) {
        server2.config.logger.error(err.message, {
          timestamp: true
        });
        return;
      }
      for (const key in newServer) {
        if (key !== "app") {
          server2[key] = newServer[key];
        }
      }
      const { logger, server: { port, host, middlewareMode } } = server2.config;
      if (!middlewareMode) {
        await server2.listen(port, true);
        logger.info("server restarted.", { timestamp: true });
        if (port !== prevPort || host !== prevHost) {
          logger.info("");
          server2.printUrls();
        }
      } else {
        logger.info("server restarted.", { timestamp: true });
      }
    }
    var index = {
      __proto__: null,
      createServer,
      resolveServerOptions,
      searchForWorkspaceRoot
    };
    var compression$2 = { exports: {} };
    var negotiator = { exports: {} };
    var charset = { exports: {} };
    charset.exports = preferredCharsets;
    charset.exports.preferredCharsets = preferredCharsets;
    var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseAcceptCharset(accept) {
      var accepts2 = accept.split(",");
      for (var i2 = 0, j2 = 0; i2 < accepts2.length; i2++) {
        var charset2 = parseCharset(accepts2[i2].trim(), i2);
        if (charset2) {
          accepts2[j2++] = charset2;
        }
      }
      accepts2.length = j2;
      return accepts2;
    }
    function parseCharset(str, i2) {
      var match2 = simpleCharsetRegExp.exec(str);
      if (!match2)
        return null;
      var charset2 = match2[1];
      var q2 = 1;
      if (match2[2]) {
        var params = match2[2].split(";");
        for (var j2 = 0; j2 < params.length; j2++) {
          var p2 = params[j2].trim().split("=");
          if (p2[0] === "q") {
            q2 = parseFloat(p2[1]);
            break;
          }
        }
      }
      return {
        charset: charset2,
        q: q2,
        i: i2
      };
    }
    function getCharsetPriority(charset2, accepted, index2) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i2 = 0; i2 < accepted.length; i2++) {
        var spec = specify$3(charset2, accepted[i2], index2);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify$3(charset2, spec, index2) {
      var s2 = 0;
      if (spec.charset.toLowerCase() === charset2.toLowerCase()) {
        s2 |= 1;
      } else if (spec.charset !== "*") {
        return null;
      }
      return {
        i: index2,
        o: spec.i,
        q: spec.q,
        s: s2
      };
    }
    function preferredCharsets(accept, provided) {
      var accepts2 = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
      if (!provided) {
        return accepts2.filter(isQuality$3).sort(compareSpecs$3).map(getFullCharset);
      }
      var priorities = provided.map(function getPriority(type, index2) {
        return getCharsetPriority(type, accepts2, index2);
      });
      return priorities.filter(isQuality$3).sort(compareSpecs$3).map(function getCharset(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs$3(a2, b2) {
      return b2.q - a2.q || b2.s - a2.s || a2.o - b2.o || a2.i - b2.i || 0;
    }
    function getFullCharset(spec) {
      return spec.charset;
    }
    function isQuality$3(spec) {
      return spec.q > 0;
    }
    var encoding = { exports: {} };
    encoding.exports = preferredEncodings;
    encoding.exports.preferredEncodings = preferredEncodings;
    var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseAcceptEncoding(accept) {
      var accepts2 = accept.split(",");
      var hasIdentity = false;
      var minQuality = 1;
      for (var i2 = 0, j2 = 0; i2 < accepts2.length; i2++) {
        var encoding2 = parseEncoding(accepts2[i2].trim(), i2);
        if (encoding2) {
          accepts2[j2++] = encoding2;
          hasIdentity = hasIdentity || specify$2("identity", encoding2);
          minQuality = Math.min(minQuality, encoding2.q || 1);
        }
      }
      if (!hasIdentity) {
        accepts2[j2++] = {
          encoding: "identity",
          q: minQuality,
          i: i2
        };
      }
      accepts2.length = j2;
      return accepts2;
    }
    function parseEncoding(str, i2) {
      var match2 = simpleEncodingRegExp.exec(str);
      if (!match2)
        return null;
      var encoding2 = match2[1];
      var q2 = 1;
      if (match2[2]) {
        var params = match2[2].split(";");
        for (var j2 = 0; j2 < params.length; j2++) {
          var p2 = params[j2].trim().split("=");
          if (p2[0] === "q") {
            q2 = parseFloat(p2[1]);
            break;
          }
        }
      }
      return {
        encoding: encoding2,
        q: q2,
        i: i2
      };
    }
    function getEncodingPriority(encoding2, accepted, index2) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i2 = 0; i2 < accepted.length; i2++) {
        var spec = specify$2(encoding2, accepted[i2], index2);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify$2(encoding2, spec, index2) {
      var s2 = 0;
      if (spec.encoding.toLowerCase() === encoding2.toLowerCase()) {
        s2 |= 1;
      } else if (spec.encoding !== "*") {
        return null;
      }
      return {
        i: index2,
        o: spec.i,
        q: spec.q,
        s: s2
      };
    }
    function preferredEncodings(accept, provided) {
      var accepts2 = parseAcceptEncoding(accept || "");
      if (!provided) {
        return accepts2.filter(isQuality$2).sort(compareSpecs$2).map(getFullEncoding);
      }
      var priorities = provided.map(function getPriority(type, index2) {
        return getEncodingPriority(type, accepts2, index2);
      });
      return priorities.filter(isQuality$2).sort(compareSpecs$2).map(function getEncoding(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs$2(a2, b2) {
      return b2.q - a2.q || b2.s - a2.s || a2.o - b2.o || a2.i - b2.i || 0;
    }
    function getFullEncoding(spec) {
      return spec.encoding;
    }
    function isQuality$2(spec) {
      return spec.q > 0;
    }
    var language = { exports: {} };
    language.exports = preferredLanguages;
    language.exports.preferredLanguages = preferredLanguages;
    var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
    function parseAcceptLanguage(accept) {
      var accepts2 = accept.split(",");
      for (var i2 = 0, j2 = 0; i2 < accepts2.length; i2++) {
        var language2 = parseLanguage(accepts2[i2].trim(), i2);
        if (language2) {
          accepts2[j2++] = language2;
        }
      }
      accepts2.length = j2;
      return accepts2;
    }
    function parseLanguage(str, i2) {
      var match2 = simpleLanguageRegExp.exec(str);
      if (!match2)
        return null;
      var prefix = match2[1], suffix = match2[2], full = prefix;
      if (suffix)
        full += "-" + suffix;
      var q2 = 1;
      if (match2[3]) {
        var params = match2[3].split(";");
        for (var j2 = 0; j2 < params.length; j2++) {
          var p2 = params[j2].split("=");
          if (p2[0] === "q")
            q2 = parseFloat(p2[1]);
        }
      }
      return {
        prefix,
        suffix,
        q: q2,
        i: i2,
        full
      };
    }
    function getLanguagePriority(language2, accepted, index2) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i2 = 0; i2 < accepted.length; i2++) {
        var spec = specify$1(language2, accepted[i2], index2);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify$1(language2, spec, index2) {
      var p2 = parseLanguage(language2);
      if (!p2)
        return null;
      var s2 = 0;
      if (spec.full.toLowerCase() === p2.full.toLowerCase()) {
        s2 |= 4;
      } else if (spec.prefix.toLowerCase() === p2.full.toLowerCase()) {
        s2 |= 2;
      } else if (spec.full.toLowerCase() === p2.prefix.toLowerCase()) {
        s2 |= 1;
      } else if (spec.full !== "*") {
        return null;
      }
      return {
        i: index2,
        o: spec.i,
        q: spec.q,
        s: s2
      };
    }
    function preferredLanguages(accept, provided) {
      var accepts2 = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
      if (!provided) {
        return accepts2.filter(isQuality$1).sort(compareSpecs$1).map(getFullLanguage);
      }
      var priorities = provided.map(function getPriority(type, index2) {
        return getLanguagePriority(type, accepts2, index2);
      });
      return priorities.filter(isQuality$1).sort(compareSpecs$1).map(function getLanguage(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs$1(a2, b2) {
      return b2.q - a2.q || b2.s - a2.s || a2.o - b2.o || a2.i - b2.i || 0;
    }
    function getFullLanguage(spec) {
      return spec.full;
    }
    function isQuality$1(spec) {
      return spec.q > 0;
    }
    var mediaType = { exports: {} };
    mediaType.exports = preferredMediaTypes;
    mediaType.exports.preferredMediaTypes = preferredMediaTypes;
    var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
    function parseAccept(accept) {
      var accepts2 = splitMediaTypes(accept);
      for (var i2 = 0, j2 = 0; i2 < accepts2.length; i2++) {
        var mediaType2 = parseMediaType(accepts2[i2].trim(), i2);
        if (mediaType2) {
          accepts2[j2++] = mediaType2;
        }
      }
      accepts2.length = j2;
      return accepts2;
    }
    function parseMediaType(str, i2) {
      var match2 = simpleMediaTypeRegExp.exec(str);
      if (!match2)
        return null;
      var params = Object.create(null);
      var q2 = 1;
      var subtype = match2[2];
      var type = match2[1];
      if (match2[3]) {
        var kvps = splitParameters(match2[3]).map(splitKeyValuePair);
        for (var j2 = 0; j2 < kvps.length; j2++) {
          var pair = kvps[j2];
          var key = pair[0].toLowerCase();
          var val = pair[1];
          var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
          if (key === "q") {
            q2 = parseFloat(value);
            break;
          }
          params[key] = value;
        }
      }
      return {
        type,
        subtype,
        params,
        q: q2,
        i: i2
      };
    }
    function getMediaTypePriority(type, accepted, index2) {
      var priority = { o: -1, q: 0, s: 0 };
      for (var i2 = 0; i2 < accepted.length; i2++) {
        var spec = specify(type, accepted[i2], index2);
        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }
      return priority;
    }
    function specify(type, spec, index2) {
      var p2 = parseMediaType(type);
      var s2 = 0;
      if (!p2) {
        return null;
      }
      if (spec.type.toLowerCase() == p2.type.toLowerCase()) {
        s2 |= 4;
      } else if (spec.type != "*") {
        return null;
      }
      if (spec.subtype.toLowerCase() == p2.subtype.toLowerCase()) {
        s2 |= 2;
      } else if (spec.subtype != "*") {
        return null;
      }
      var keys = Object.keys(spec.params);
      if (keys.length > 0) {
        if (keys.every(function(k2) {
          return spec.params[k2] == "*" || (spec.params[k2] || "").toLowerCase() == (p2.params[k2] || "").toLowerCase();
        })) {
          s2 |= 1;
        } else {
          return null;
        }
      }
      return {
        i: index2,
        o: spec.i,
        q: spec.q,
        s: s2
      };
    }
    function preferredMediaTypes(accept, provided) {
      var accepts2 = parseAccept(accept === void 0 ? "*/*" : accept || "");
      if (!provided) {
        return accepts2.filter(isQuality).sort(compareSpecs).map(getFullType);
      }
      var priorities = provided.map(function getPriority(type, index2) {
        return getMediaTypePriority(type, accepts2, index2);
      });
      return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
        return provided[priorities.indexOf(priority)];
      });
    }
    function compareSpecs(a2, b2) {
      return b2.q - a2.q || b2.s - a2.s || a2.o - b2.o || a2.i - b2.i || 0;
    }
    function getFullType(spec) {
      return spec.type + "/" + spec.subtype;
    }
    function isQuality(spec) {
      return spec.q > 0;
    }
    function quoteCount(string2) {
      var count = 0;
      var index2 = 0;
      while ((index2 = string2.indexOf('"', index2)) !== -1) {
        count++;
        index2++;
      }
      return count;
    }
    function splitKeyValuePair(str) {
      var index2 = str.indexOf("=");
      var key;
      var val;
      if (index2 === -1) {
        key = str;
      } else {
        key = str.substr(0, index2);
        val = str.substr(index2 + 1);
      }
      return [key, val];
    }
    function splitMediaTypes(accept) {
      var accepts2 = accept.split(",");
      for (var i2 = 1, j2 = 0; i2 < accepts2.length; i2++) {
        if (quoteCount(accepts2[j2]) % 2 == 0) {
          accepts2[++j2] = accepts2[i2];
        } else {
          accepts2[j2] += "," + accepts2[i2];
        }
      }
      accepts2.length = j2 + 1;
      return accepts2;
    }
    function splitParameters(str) {
      var parameters = str.split(";");
      for (var i2 = 1, j2 = 0; i2 < parameters.length; i2++) {
        if (quoteCount(parameters[j2]) % 2 == 0) {
          parameters[++j2] = parameters[i2];
        } else {
          parameters[j2] += ";" + parameters[i2];
        }
      }
      parameters.length = j2 + 1;
      for (var i2 = 0; i2 < parameters.length; i2++) {
        parameters[i2] = parameters[i2].trim();
      }
      return parameters;
    }
    var modules = Object.create(null);
    negotiator.exports = Negotiator$1;
    negotiator.exports.Negotiator = Negotiator$1;
    function Negotiator$1(request) {
      if (!(this instanceof Negotiator$1)) {
        return new Negotiator$1(request);
      }
      this.request = request;
    }
    Negotiator$1.prototype.charset = function charset2(available) {
      var set2 = this.charsets(available);
      return set2 && set2[0];
    };
    Negotiator$1.prototype.charsets = function charsets(available) {
      var preferredCharsets2 = loadModule("charset").preferredCharsets;
      return preferredCharsets2(this.request.headers["accept-charset"], available);
    };
    Negotiator$1.prototype.encoding = function encoding2(available) {
      var set2 = this.encodings(available);
      return set2 && set2[0];
    };
    Negotiator$1.prototype.encodings = function encodings(available) {
      var preferredEncodings2 = loadModule("encoding").preferredEncodings;
      return preferredEncodings2(this.request.headers["accept-encoding"], available);
    };
    Negotiator$1.prototype.language = function language2(available) {
      var set2 = this.languages(available);
      return set2 && set2[0];
    };
    Negotiator$1.prototype.languages = function languages(available) {
      var preferredLanguages2 = loadModule("language").preferredLanguages;
      return preferredLanguages2(this.request.headers["accept-language"], available);
    };
    Negotiator$1.prototype.mediaType = function mediaType2(available) {
      var set2 = this.mediaTypes(available);
      return set2 && set2[0];
    };
    Negotiator$1.prototype.mediaTypes = function mediaTypes(available) {
      var preferredMediaTypes2 = loadModule("mediaType").preferredMediaTypes;
      return preferredMediaTypes2(this.request.headers.accept, available);
    };
    Negotiator$1.prototype.preferredCharset = Negotiator$1.prototype.charset;
    Negotiator$1.prototype.preferredCharsets = Negotiator$1.prototype.charsets;
    Negotiator$1.prototype.preferredEncoding = Negotiator$1.prototype.encoding;
    Negotiator$1.prototype.preferredEncodings = Negotiator$1.prototype.encodings;
    Negotiator$1.prototype.preferredLanguage = Negotiator$1.prototype.language;
    Negotiator$1.prototype.preferredLanguages = Negotiator$1.prototype.languages;
    Negotiator$1.prototype.preferredMediaType = Negotiator$1.prototype.mediaType;
    Negotiator$1.prototype.preferredMediaTypes = Negotiator$1.prototype.mediaTypes;
    function loadModule(moduleName) {
      var module2 = modules[moduleName];
      if (module2 !== void 0) {
        return module2;
      }
      switch (moduleName) {
        case "charset":
          module2 = charset.exports;
          break;
        case "encoding":
          module2 = encoding.exports;
          break;
        case "language":
          module2 = language.exports;
          break;
        case "mediaType":
          module2 = mediaType.exports;
          break;
        default:
          throw new Error("Cannot find module '" + moduleName + "'");
      }
      modules[moduleName] = module2;
      return module2;
    }
    var mimeTypes = {};
    var require$$0 = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: [
          "ez"
        ]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: [
          "aw"
        ]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "atom"
        ]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "atomcat"
        ]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "atomdeleted"
        ]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "atomsvc"
        ]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "dwd"
        ]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "held"
        ]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "rsat"
        ]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: [
          "bdoc"
        ]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xcs"
        ]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "ccxml"
        ]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "cdfx"
        ]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: [
          "cdmia"
        ]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: [
          "cdmic"
        ]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: [
          "cdmid"
        ]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: [
          "cdmio"
        ]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: [
          "cdmiq"
        ]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: [
          "cu"
        ]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mpd"
        ]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "davmount"
        ]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "dbk"
        ]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: [
          "dssc"
        ]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xdssc"
        ]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: [
          "es",
          "ecma"
        ]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "emma"
        ]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "emotionml"
        ]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: [
          "epub"
        ]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: [
          "exi"
        ]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: [
          "exp"
        ]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "fdt"
        ]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: [
          "pfr"
        ]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: [
          "geojson"
        ]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "gml"
        ]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "gpx"
        ]
      },
      "application/gxf": {
        source: "apache",
        extensions: [
          "gxf"
        ]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: [
          "gz"
        ]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: [
          "hjson"
        ]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: [
          "stk"
        ]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "ink",
          "inkml"
        ]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: [
          "ipfix"
        ]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "its"
        ]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: [
          "jar",
          "war",
          "ear"
        ]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: [
          "ser"
        ]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: [
          "class"
        ]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
          "js",
          "mjs"
        ]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
          "json",
          "map"
        ]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: [
          "json5"
        ]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: [
          "jsonml"
        ]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: [
          "jsonld"
        ]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "lgr"
        ]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "lostxml"
        ]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: [
          "hqx"
        ]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: [
          "cpt"
        ]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mads"
        ]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
          "webmanifest"
        ]
      },
      "application/marc": {
        source: "iana",
        extensions: [
          "mrc"
        ]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mrcx"
        ]
      },
      "application/mathematica": {
        source: "iana",
        extensions: [
          "ma",
          "nb",
          "mb"
        ]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mathml"
        ]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: [
          "mbox"
        ]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mscml"
        ]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "metalink"
        ]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "meta4"
        ]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mets"
        ]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "maei"
        ]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "musd"
        ]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mods"
        ]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: [
          "m21",
          "mp21"
        ]
      },
      "application/mp4": {
        source: "iana",
        extensions: [
          "mp4s",
          "m4p"
        ]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: [
          "doc",
          "dot"
        ]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: [
          "mxf"
        ]
      },
      "application/n-quads": {
        source: "iana",
        extensions: [
          "nq"
        ]
      },
      "application/n-triples": {
        source: "iana",
        extensions: [
          "nt"
        ]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: [
          "cjs"
        ]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: [
          "bin",
          "dms",
          "lrf",
          "mar",
          "so",
          "dist",
          "distz",
          "pkg",
          "bpk",
          "dump",
          "elc",
          "deploy",
          "exe",
          "dll",
          "deb",
          "dmg",
          "iso",
          "img",
          "msi",
          "msp",
          "msm",
          "buffer"
        ]
      },
      "application/oda": {
        source: "iana",
        extensions: [
          "oda"
        ]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "opf"
        ]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: [
          "ogx"
        ]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "omdoc"
        ]
      },
      "application/onenote": {
        source: "apache",
        extensions: [
          "onetoc",
          "onetoc2",
          "onetmp",
          "onepkg"
        ]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: [
          "oxps"
        ]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "relo"
        ]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xer"
        ]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: [
          "pdf"
        ]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: [
          "pgp"
        ]
      },
      "application/pgp-keys": {
        source: "iana"
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: [
          "asc",
          "sig"
        ]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: [
          "prf"
        ]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: [
          "p10"
        ]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: [
          "p7m",
          "p7c"
        ]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: [
          "p7s"
        ]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: [
          "p8"
        ]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: [
          "ac"
        ]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: [
          "cer"
        ]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: [
          "crl"
        ]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: [
          "pkipath"
        ]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: [
          "pki"
        ]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "pls"
        ]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: [
          "ai",
          "eps",
          "ps"
        ]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "provx"
        ]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: [
          "cww"
        ]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "pskcxml"
        ]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: [
          "raml"
        ]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "rdf",
          "owl"
        ]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "rif"
        ]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: [
          "rnc"
        ]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "rl"
        ]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "rld"
        ]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "rs"
        ]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "rapd"
        ]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "sls"
        ]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "rusd"
        ]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: [
          "gbr"
        ]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: [
          "mft"
        ]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: [
          "roa"
        ]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "rsd"
        ]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "rss"
        ]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: [
          "rtf"
        ]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "sbml"
        ]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: [
          "scq"
        ]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: [
          "scs"
        ]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: [
          "spq"
        ]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: [
          "spp"
        ]
      },
      "application/sdp": {
        source: "iana",
        extensions: [
          "sdp"
        ]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "senmlx"
        ]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "sensmlx"
        ]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: [
          "setpay"
        ]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: [
          "setreg"
        ]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "shf"
        ]
      },
      "application/sieve": {
        source: "iana",
        extensions: [
          "siv",
          "sieve"
        ]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "smi",
          "smil"
        ]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: [
          "rq"
        ]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "srx"
        ]
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: [
          "gram"
        ]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "grxml"
        ]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "sru"
        ]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "ssdl"
        ]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "ssml"
        ]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "swidtag"
        ]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "tei",
          "teicorpus"
        ]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "tfi"
        ]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: [
          "tsd"
        ]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: [
          "toml"
        ]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: [
          "trig"
        ]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "ttml"
        ]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: [
          "ubj"
        ]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "rsheet"
        ]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "td"
        ]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "1km"
        ]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: [
          "plb"
        ]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: [
          "psb"
        ]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: [
          "pvb"
        ]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: [
          "tcap"
        ]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: [
          "pwn"
        ]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: [
          "aso"
        ]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: [
          "imp"
        ]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: [
          "acu"
        ]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: [
          "atc",
          "acutc"
        ]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: [
          "air"
        ]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: [
          "fcdt"
        ]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: [
          "fxp",
          "fxpl"
        ]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xdp"
        ]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: [
          "xfdf"
        ]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: [
          "ahead"
        ]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: [
          "azf"
        ]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: [
          "azs"
        ]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: [
          "azw"
        ]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: [
          "acc"
        ]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: [
          "ami"
        ]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: [
          "apk"
        ]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: [
          "cii"
        ]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: [
          "fti"
        ]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: [
          "atx"
        ]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mpkg"
        ]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: [
          "key"
        ]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: [
          "m3u8"
        ]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: [
          "numbers"
        ]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: [
          "pages"
        ]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: [
          "pkpass"
        ]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: [
          "swi"
        ]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: [
          "iota"
        ]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: [
          "aep"
        ]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "bmml"
        ]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: [
          "mpm"
        ]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: [
          "bmi"
        ]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: [
          "rep"
        ]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "cdxml"
        ]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: [
          "mmd"
        ]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: [
          "cdy"
        ]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "csl"
        ]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: [
          "cla"
        ]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: [
          "rp9"
        ]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: [
          "c4g",
          "c4d",
          "c4f",
          "c4p",
          "c4u"
        ]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: [
          "c11amc"
        ]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: [
          "c11amz"
        ]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: [
          "csp"
        ]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: [
          "cdbcmsg"
        ]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: [
          "cmc"
        ]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: [
          "clkx"
        ]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: [
          "clkk"
        ]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: [
          "clkp"
        ]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: [
          "clkt"
        ]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: [
          "clkw"
        ]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "wbs"
        ]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: [
          "pml"
        ]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: [
          "ppd"
        ]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: [
          "car"
        ]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: [
          "pcurl"
        ]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: [
          "dart"
        ]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: [
          "rdz"
        ]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: [
          "dbf"
        ]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: [
          "uvf",
          "uvvf",
          "uvd",
          "uvvd"
        ]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "uvt",
          "uvvt"
        ]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: [
          "uvx",
          "uvvx"
        ]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: [
          "uvz",
          "uvvz"
        ]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: [
          "fe_launch"
        ]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: [
          "dna"
        ]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: [
          "mlp"
        ]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: [
          "dpg"
        ]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: [
          "dfac"
        ]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: [
          "kpxx"
        ]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: [
          "ait"
        ]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: [
          "svc"
        ]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: [
          "geo"
        ]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: [
          "mag"
        ]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: [
          "nml"
        ]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: [
          "esf"
        ]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: [
          "msf"
        ]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: [
          "qam"
        ]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: [
          "slt"
        ]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: [
          "ssf"
        ]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "es3",
          "et3"
        ]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: [
          "ez2"
        ]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: [
          "ez3"
        ]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: [
          "fdf"
        ]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: [
          "mseed"
        ]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: [
          "seed",
          "dataless"
        ]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: [
          "gph"
        ]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: [
          "ftc"
        ]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: [
          "fm",
          "frame",
          "maker",
          "book"
        ]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: [
          "fnc"
        ]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: [
          "ltf"
        ]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: [
          "fsc"
        ]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: [
          "oas"
        ]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: [
          "oa2"
        ]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: [
          "oa3"
        ]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: [
          "fg5"
        ]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: [
          "bh2"
        ]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: [
          "ddd"
        ]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: [
          "xdw"
        ]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: [
          "xbd"
        ]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: [
          "fzs"
        ]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: [
          "txd"
        ]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: [
          "ggb"
        ]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: [
          "ggt"
        ]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: [
          "gex",
          "gre"
        ]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: [
          "gxt"
        ]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: [
          "g2w"
        ]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: [
          "g3w"
        ]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: [
          "gmx"
        ]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: [
          "gdoc"
        ]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: [
          "gslides"
        ]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: [
          "gsheet"
        ]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "kml"
        ]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: [
          "kmz"
        ]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: [
          "gqf",
          "gqs"
        ]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: [
          "gac"
        ]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: [
          "ghf"
        ]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: [
          "gim"
        ]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: [
          "grv"
        ]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: [
          "gtm"
        ]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: [
          "tpl"
        ]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: [
          "vcg"
        ]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "hal"
        ]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "zmm"
        ]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: [
          "hbci"
        ]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: [
          "les"
        ]
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: [
          "hpgl"
        ]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: [
          "hpid"
        ]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: [
          "hps"
        ]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: [
          "jlt"
        ]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: [
          "pcl"
        ]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: [
          "pclxl"
        ]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: [
          "sfd-hdstx"
        ]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: [
          "mpy"
        ]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: [
          "afp",
          "listafp",
          "list3820"
        ]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: [
          "irm"
        ]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: [
          "sc"
        ]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: [
          "icc",
          "icm"
        ]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: [
          "igl"
        ]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: [
          "ivp"
        ]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: [
          "ivu"
        ]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: [
          "igm"
        ]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: [
          "xpw",
          "xpx"
        ]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: [
          "i2g"
        ]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: [
          "qbo"
        ]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: [
          "qfx"
        ]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: [
          "rcprofile"
        ]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "irp"
        ]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: [
          "xpr"
        ]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: [
          "fcs"
        ]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: [
          "jam"
        ]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: [
          "rms"
        ]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: [
          "jisp"
        ]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: [
          "joda"
        ]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: [
          "ktz",
          "ktr"
        ]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: [
          "karbon"
        ]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: [
          "chrt"
        ]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: [
          "kfo"
        ]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: [
          "flw"
        ]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: [
          "kon"
        ]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: [
          "kpr",
          "kpt"
        ]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: [
          "ksp"
        ]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: [
          "kwd",
          "kwt"
        ]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: [
          "htke"
        ]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: [
          "kia"
        ]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: [
          "kne",
          "knp"
        ]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: [
          "skp",
          "skd",
          "skt",
          "skm"
        ]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: [
          "sse"
        ]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "lasxml"
        ]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: [
          "lbd"
        ]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "lbe"
        ]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: [
          "123"
        ]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: [
          "apr"
        ]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: [
          "pre"
        ]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: [
          "nsf"
        ]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: [
          "org"
        ]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: [
          "scm"
        ]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: [
          "lwp"
        ]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: [
          "portpkg"
        ]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: [
          "mvt"
        ]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: [
          "mcd"
        ]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: [
          "mc1"
        ]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: [
          "cdkey"
        ]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: [
          "mwf"
        ]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: [
          "mfm"
        ]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: [
          "flo"
        ]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: [
          "igx"
        ]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: [
          "mif"
        ]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: [
          "daf"
        ]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: [
          "dis"
        ]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: [
          "mbk"
        ]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: [
          "mqy"
        ]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: [
          "msl"
        ]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: [
          "plc"
        ]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: [
          "txf"
        ]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: [
          "mpn"
        ]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: [
          "mpc"
        ]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xul"
        ]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: [
          "cil"
        ]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: [
          "cab"
        ]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: [
          "xls",
          "xlm",
          "xla",
          "xlc",
          "xlt",
          "xlw"
        ]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: [
          "xlam"
        ]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: [
          "xlsb"
        ]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: [
          "xlsm"
        ]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: [
          "xltm"
        ]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: [
          "eot"
        ]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: [
          "chm"
        ]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: [
          "ims"
        ]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: [
          "lrm"
        ]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: [
          "thmx"
        ]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: [
          "msg"
        ]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: [
          "cat"
        ]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: [
          "stl"
        ]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: [
          "ppt",
          "pps",
          "pot"
        ]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: [
          "ppam"
        ]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: [
          "pptm"
        ]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: [
          "sldm"
        ]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: [
          "ppsm"
        ]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: [
          "potm"
        ]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: [
          "mpp",
          "mpt"
        ]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: [
          "docm"
        ]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: [
          "dotm"
        ]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: [
          "wps",
          "wks",
          "wcm",
          "wdb"
        ]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: [
          "wpl"
        ]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: [
          "xps"
        ]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: [
          "mseq"
        ]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: [
          "mus"
        ]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: [
          "msty"
        ]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: [
          "taglet"
        ]
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: [
          "nlu"
        ]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: [
          "ntf",
          "nitf"
        ]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: [
          "nnd"
        ]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: [
          "nns"
        ]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: [
          "nnw"
        ]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "ac"
        ]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: [
          "ngdat"
        ]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: [
          "n-gage"
        ]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: [
          "rpst"
        ]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: [
          "rpss"
        ]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: [
          "edm"
        ]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: [
          "edx"
        ]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: [
          "ext"
        ]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: [
          "odc"
        ]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: [
          "otc"
        ]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: [
          "odb"
        ]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: [
          "odf"
        ]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: [
          "odft"
        ]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: [
          "odg"
        ]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: [
          "otg"
        ]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: [
          "odi"
        ]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: [
          "oti"
        ]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: [
          "odp"
        ]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: [
          "otp"
        ]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: [
          "ods"
        ]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: [
          "ots"
        ]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: [
          "odt"
        ]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: [
          "odm"
        ]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: [
          "ott"
        ]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: [
          "oth"
        ]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: [
          "xo"
        ]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "dd2"
        ]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "obgx"
        ]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: [
          "oxt"
        ]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "osm"
        ]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: [
          "pptx"
        ]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: [
          "sldx"
        ]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: [
          "ppsx"
        ]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: [
          "potx"
        ]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: [
          "xlsx"
        ]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: [
          "xltx"
        ]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: [
          "docx"
        ]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: [
          "dotx"
        ]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: [
          "mgp"
        ]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: [
          "dp"
        ]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: [
          "esa"
        ]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: [
          "pdb",
          "pqa",
          "oprc"
        ]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: [
          "paw"
        ]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: [
          "str"
        ]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: [
          "ei6"
        ]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: [
          "efif"
        ]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: [
          "wg"
        ]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: [
          "plf"
        ]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: [
          "pbd"
        ]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: [
          "box"
        ]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: [
          "mgz"
        ]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: [
          "qps"
        ]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: [
          "ptid"
        ]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: [
          "qxd",
          "qxt",
          "qwd",
          "qwt",
          "qxl",
          "qxb"
        ]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: [
          "rar"
        ]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: [
          "bed"
        ]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: [
          "mxl"
        ]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "musicxml"
        ]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: [
          "cryptonote"
        ]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: [
          "cod"
        ]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: [
          "rm"
        ]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: [
          "rmvb"
        ]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "link66"
        ]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: [
          "st"
        ]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: [
          "see"
        ]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: [
          "sema"
        ]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: [
          "semd"
        ]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: [
          "semf"
        ]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: [
          "ifm"
        ]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: [
          "itp"
        ]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: [
          "iif"
        ]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: [
          "ipk"
        ]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: [
          "twd",
          "twds"
        ]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: [
          "mmf"
        ]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: [
          "teacher"
        ]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "fo"
        ]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "sdkm",
          "sdkd"
        ]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: [
          "dxp"
        ]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: [
          "sfs"
        ]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: [
          "sdc"
        ]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: [
          "sda"
        ]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: [
          "sdd"
        ]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: [
          "smf"
        ]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: [
          "sdw",
          "vor"
        ]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: [
          "sgl"
        ]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: [
          "smzip"
        ]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: [
          "sm"
        ]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "wadl"
        ]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: [
          "sxc"
        ]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: [
          "stc"
        ]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: [
          "sxd"
        ]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: [
          "std"
        ]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: [
          "sxi"
        ]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: [
          "sti"
        ]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: [
          "sxm"
        ]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: [
          "sxw"
        ]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: [
          "sxg"
        ]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: [
          "stw"
        ]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: [
          "sus",
          "susp"
        ]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: [
          "svd"
        ]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: [
          "sis",
          "sisx"
        ]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
          "xsm"
        ]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: [
          "bdm"
        ]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
          "xdm"
        ]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
          "ddf"
        ]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: [
          "tao"
        ]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: [
          "pcap",
          "cap",
          "dmp"
        ]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: [
          "tmo"
        ]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: [
          "tpt"
        ]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: [
          "mxs"
        ]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: [
          "tra"
        ]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: [
          "ufd",
          "ufdl"
        ]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: [
          "utz"
        ]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: [
          "umj"
        ]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: [
          "unityweb"
        ]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "uoml"
        ]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: [
          "vcx"
        ]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: [
          "vsd",
          "vst",
          "vss",
          "vsw"
        ]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: [
          "vis"
        ]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: [
          "vsf"
        ]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: [
          "wbxml"
        ]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: [
          "wmlc"
        ]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: [
          "wmlsc"
        ]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: [
          "wtb"
        ]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: [
          "nbp"
        ]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: [
          "wpd"
        ]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: [
          "wqd"
        ]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: [
          "stf"
        ]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: [
          "xar"
        ]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: [
          "xfdl"
        ]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: [
          "hvd"
        ]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: [
          "hvs"
        ]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: [
          "hvp"
        ]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: [
          "osf"
        ]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "osfpvg"
        ]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: [
          "saf"
        ]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: [
          "spf"
        ]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: [
          "cmp"
        ]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: [
          "zir",
          "zirz"
        ]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "zaz"
        ]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "vxml"
        ]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: [
          "wasm"
        ]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: [
          "wgt"
        ]
      },
      "application/winhlp": {
        source: "apache",
        extensions: [
          "hlp"
        ]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "wsdl"
        ]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "wspolicy"
        ]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: [
          "7z"
        ]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: [
          "abw"
        ]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: [
          "ace"
        ]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: [
          "dmg"
        ]
      },
      "application/x-arj": {
        compressible: false,
        extensions: [
          "arj"
        ]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: [
          "aab",
          "x32",
          "u32",
          "vox"
        ]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: [
          "aam"
        ]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: [
          "aas"
        ]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: [
          "bcpio"
        ]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: [
          "bdoc"
        ]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: [
          "torrent"
        ]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: [
          "blb",
          "blorb"
        ]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: [
          "bz"
        ]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: [
          "bz2",
          "boz"
        ]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: [
          "cbr",
          "cba",
          "cbt",
          "cbz",
          "cb7"
        ]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: [
          "vcd"
        ]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: [
          "cfs"
        ]
      },
      "application/x-chat": {
        source: "apache",
        extensions: [
          "chat"
        ]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: [
          "pgn"
        ]
      },
      "application/x-chrome-extension": {
        extensions: [
          "crx"
        ]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: [
          "cco"
        ]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: [
          "nsc"
        ]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: [
          "cpio"
        ]
      },
      "application/x-csh": {
        source: "apache",
        extensions: [
          "csh"
        ]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: [
          "deb",
          "udeb"
        ]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: [
          "dgc"
        ]
      },
      "application/x-director": {
        source: "apache",
        extensions: [
          "dir",
          "dcr",
          "dxr",
          "cst",
          "cct",
          "cxt",
          "w3d",
          "fgd",
          "swa"
        ]
      },
      "application/x-doom": {
        source: "apache",
        extensions: [
          "wad"
        ]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "ncx"
        ]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "dtb"
        ]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "res"
        ]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: [
          "dvi"
        ]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: [
          "evy"
        ]
      },
      "application/x-eva": {
        source: "apache",
        extensions: [
          "eva"
        ]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: [
          "bdf"
        ]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: [
          "gsf"
        ]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: [
          "psf"
        ]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: [
          "pcf"
        ]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: [
          "snf"
        ]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: [
          "pfa",
          "pfb",
          "pfm",
          "afm"
        ]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: [
          "arc"
        ]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: [
          "spl"
        ]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: [
          "gca"
        ]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: [
          "ulx"
        ]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: [
          "gnumeric"
        ]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: [
          "gramps"
        ]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: [
          "gtar"
        ]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: [
          "hdf"
        ]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: [
          "php"
        ]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: [
          "install"
        ]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: [
          "iso"
        ]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: [
          "key"
        ]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: [
          "numbers"
        ]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: [
          "pages"
        ]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: [
          "jardiff"
        ]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: [
          "jnlp"
        ]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: [
          "kdbx"
        ]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: [
          "latex"
        ]
      },
      "application/x-lua-bytecode": {
        extensions: [
          "luac"
        ]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: [
          "lzh",
          "lha"
        ]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: [
          "run"
        ]
      },
      "application/x-mie": {
        source: "apache",
        extensions: [
          "mie"
        ]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: [
          "prc",
          "mobi"
        ]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: [
          "application"
        ]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: [
          "lnk"
        ]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: [
          "wmd"
        ]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: [
          "wmz"
        ]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: [
          "xbap"
        ]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: [
          "mdb"
        ]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: [
          "obd"
        ]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: [
          "crd"
        ]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: [
          "clp"
        ]
      },
      "application/x-msdos-program": {
        extensions: [
          "exe"
        ]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: [
          "exe",
          "dll",
          "com",
          "bat",
          "msi"
        ]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: [
          "mvb",
          "m13",
          "m14"
        ]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: [
          "wmf",
          "wmz",
          "emf",
          "emz"
        ]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: [
          "mny"
        ]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: [
          "pub"
        ]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: [
          "scd"
        ]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: [
          "trm"
        ]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: [
          "wri"
        ]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: [
          "nc",
          "cdf"
        ]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: [
          "pac"
        ]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: [
          "nzb"
        ]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: [
          "pl",
          "pm"
        ]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: [
          "prc",
          "pdb"
        ]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: [
          "p12",
          "pfx"
        ]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: [
          "p7b",
          "spc"
        ]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: [
          "p7r"
        ]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: [
          "rar"
        ]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: [
          "rpm"
        ]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: [
          "ris"
        ]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: [
          "sea"
        ]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: [
          "sh"
        ]
      },
      "application/x-shar": {
        source: "apache",
        extensions: [
          "shar"
        ]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: [
          "swf"
        ]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: [
          "xap"
        ]
      },
      "application/x-sql": {
        source: "apache",
        extensions: [
          "sql"
        ]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: [
          "sit"
        ]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: [
          "sitx"
        ]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: [
          "srt"
        ]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: [
          "sv4cpio"
        ]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: [
          "sv4crc"
        ]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: [
          "t3"
        ]
      },
      "application/x-tads": {
        source: "apache",
        extensions: [
          "gam"
        ]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: [
          "tar"
        ]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: [
          "tcl",
          "tk"
        ]
      },
      "application/x-tex": {
        source: "apache",
        extensions: [
          "tex"
        ]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: [
          "tfm"
        ]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: [
          "texinfo",
          "texi"
        ]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: [
          "obj"
        ]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: [
          "ustar"
        ]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: [
          "hdd"
        ]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: [
          "ova"
        ]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: [
          "ovf"
        ]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: [
          "vbox"
        ]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: [
          "vbox-extpack"
        ]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: [
          "vdi"
        ]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: [
          "vhd"
        ]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: [
          "vmdk"
        ]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: [
          "src"
        ]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: [
          "webapp"
        ]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: [
          "der",
          "crt",
          "pem"
        ]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: [
          "fig"
        ]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "xlf"
        ]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: [
          "xpi"
        ]
      },
      "application/x-xz": {
        source: "apache",
        extensions: [
          "xz"
        ]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: [
          "z1",
          "z2",
          "z3",
          "z4",
          "z5",
          "z6",
          "z7",
          "z8"
        ]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "xaml"
        ]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xav"
        ]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xca"
        ]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xdf"
        ]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xel"
        ]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xns"
        ]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xenc"
        ]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xhtml",
          "xht"
        ]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xlf"
        ]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xml",
          "xsl",
          "xsd",
          "rng"
        ]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: [
          "dtd"
        ]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xop"
        ]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "xpl"
        ]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xsl",
          "xslt"
        ]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: [
          "xspf"
        ]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "mxml",
          "xhvml",
          "xvml",
          "xvm"
        ]
      },
      "application/yang": {
        source: "iana",
        extensions: [
          "yang"
        ]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "yin"
        ]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: [
          "zip"
        ]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: [
          "3gpp"
        ]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: [
          "adp"
        ]
      },
      "audio/amr": {
        source: "iana",
        extensions: [
          "amr"
        ]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: [
          "au",
          "snd"
        ]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: [
          "mid",
          "midi",
          "kar",
          "rmi"
        ]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: [
          "mxmf"
        ]
      },
      "audio/mp3": {
        compressible: false,
        extensions: [
          "mp3"
        ]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: [
          "m4a",
          "mp4a"
        ]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: [
          "mpga",
          "mp2",
          "mp2a",
          "mp3",
          "m2a",
          "m3a"
        ]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: [
          "oga",
          "ogg",
          "spx",
          "opus"
        ]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: [
          "s3m"
        ]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: [
          "sil"
        ]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: [
          "uva",
          "uvva"
        ]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: [
          "eol"
        ]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: [
          "dra"
        ]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: [
          "dts"
        ]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: [
          "dtshd"
        ]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: [
          "lvp"
        ]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: [
          "pya"
        ]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: [
          "ecelp4800"
        ]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: [
          "ecelp7470"
        ]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: [
          "ecelp9600"
        ]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: [
          "rip"
        ]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: [
          "wav"
        ]
      },
      "audio/wave": {
        compressible: false,
        extensions: [
          "wav"
        ]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: [
          "weba"
        ]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: [
          "aac"
        ]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: [
          "aif",
          "aiff",
          "aifc"
        ]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: [
          "caf"
        ]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: [
          "flac"
        ]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: [
          "m4a"
        ]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: [
          "mka"
        ]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: [
          "m3u"
        ]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: [
          "wax"
        ]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: [
          "wma"
        ]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: [
          "ram",
          "ra"
        ]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: [
          "rmp"
        ]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: [
          "ra"
        ]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: [
          "wav"
        ]
      },
      "audio/xm": {
        source: "apache",
        extensions: [
          "xm"
        ]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: [
          "cdx"
        ]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: [
          "cif"
        ]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: [
          "cmdf"
        ]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: [
          "cml"
        ]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: [
          "csml"
        ]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: [
          "xyz"
        ]
      },
      "font/collection": {
        source: "iana",
        extensions: [
          "ttc"
        ]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: [
          "otf"
        ]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: [
          "ttf"
        ]
      },
      "font/woff": {
        source: "iana",
        extensions: [
          "woff"
        ]
      },
      "font/woff2": {
        source: "iana",
        extensions: [
          "woff2"
        ]
      },
      "image/aces": {
        source: "iana",
        extensions: [
          "exr"
        ]
      },
      "image/apng": {
        compressible: false,
        extensions: [
          "apng"
        ]
      },
      "image/avci": {
        source: "iana"
      },
      "image/avcs": {
        source: "iana"
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: [
          "avif"
        ]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: [
          "bmp"
        ]
      },
      "image/cgm": {
        source: "iana",
        extensions: [
          "cgm"
        ]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: [
          "drle"
        ]
      },
      "image/emf": {
        source: "iana",
        extensions: [
          "emf"
        ]
      },
      "image/fits": {
        source: "iana",
        extensions: [
          "fits"
        ]
      },
      "image/g3fax": {
        source: "iana",
        extensions: [
          "g3"
        ]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: [
          "gif"
        ]
      },
      "image/heic": {
        source: "iana",
        extensions: [
          "heic"
        ]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: [
          "heics"
        ]
      },
      "image/heif": {
        source: "iana",
        extensions: [
          "heif"
        ]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: [
          "heifs"
        ]
      },
      "image/hej2k": {
        source: "iana",
        extensions: [
          "hej2"
        ]
      },
      "image/hsj2": {
        source: "iana",
        extensions: [
          "hsj2"
        ]
      },
      "image/ief": {
        source: "iana",
        extensions: [
          "ief"
        ]
      },
      "image/jls": {
        source: "iana",
        extensions: [
          "jls"
        ]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: [
          "jp2",
          "jpg2"
        ]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: [
          "jpeg",
          "jpg",
          "jpe"
        ]
      },
      "image/jph": {
        source: "iana",
        extensions: [
          "jph"
        ]
      },
      "image/jphc": {
        source: "iana",
        extensions: [
          "jhc"
        ]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: [
          "jpm"
        ]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: [
          "jpx",
          "jpf"
        ]
      },
      "image/jxr": {
        source: "iana",
        extensions: [
          "jxr"
        ]
      },
      "image/jxra": {
        source: "iana",
        extensions: [
          "jxra"
        ]
      },
      "image/jxrs": {
        source: "iana",
        extensions: [
          "jxrs"
        ]
      },
      "image/jxs": {
        source: "iana",
        extensions: [
          "jxs"
        ]
      },
      "image/jxsc": {
        source: "iana",
        extensions: [
          "jxsc"
        ]
      },
      "image/jxsi": {
        source: "iana",
        extensions: [
          "jxsi"
        ]
      },
      "image/jxss": {
        source: "iana",
        extensions: [
          "jxss"
        ]
      },
      "image/ktx": {
        source: "iana",
        extensions: [
          "ktx"
        ]
      },
      "image/ktx2": {
        source: "iana",
        extensions: [
          "ktx2"
        ]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: [
          "png"
        ]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: [
          "btif"
        ]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: [
          "pti"
        ]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: [
          "sgi"
        ]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "svg",
          "svgz"
        ]
      },
      "image/t38": {
        source: "iana",
        extensions: [
          "t38"
        ]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: [
          "tif",
          "tiff"
        ]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: [
          "tfx"
        ]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: [
          "psd"
        ]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: [
          "azv"
        ]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: [
          "uvi",
          "uvvi",
          "uvg",
          "uvvg"
        ]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: [
          "djvu",
          "djv"
        ]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: [
          "sub"
        ]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: [
          "dwg"
        ]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: [
          "dxf"
        ]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: [
          "fbs"
        ]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: [
          "fpx"
        ]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: [
          "fst"
        ]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: [
          "mmr"
        ]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: [
          "rlc"
        ]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        extensions: [
          "ico"
        ]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        extensions: [
          "dds"
        ]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: [
          "mdi"
        ]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: [
          "wdp"
        ]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: [
          "npx"
        ]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: [
          "b16"
        ]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: [
          "tap"
        ]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: [
          "vtf"
        ]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: [
          "wbmp"
        ]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: [
          "xif"
        ]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: [
          "pcx"
        ]
      },
      "image/webp": {
        source: "apache",
        extensions: [
          "webp"
        ]
      },
      "image/wmf": {
        source: "iana",
        extensions: [
          "wmf"
        ]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: [
          "3ds"
        ]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: [
          "ras"
        ]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: [
          "cmx"
        ]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: [
          "fh",
          "fhc",
          "fh4",
          "fh5",
          "fh7"
        ]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: [
          "ico"
        ]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: [
          "jng"
        ]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: [
          "sid"
        ]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: [
          "bmp"
        ]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: [
          "pcx"
        ]
      },
      "image/x-pict": {
        source: "apache",
        extensions: [
          "pic",
          "pct"
        ]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: [
          "pnm"
        ]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: [
          "pbm"
        ]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: [
          "pgm"
        ]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: [
          "ppm"
        ]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: [
          "rgb"
        ]
      },
      "image/x-tga": {
        source: "apache",
        extensions: [
          "tga"
        ]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: [
          "xbm"
        ]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: [
          "xpm"
        ]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: [
          "xwd"
        ]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: [
          "u8msg"
        ]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: [
          "u8dsn"
        ]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: [
          "u8mdn"
        ]
      },
      "message/global-headers": {
        source: "iana",
        extensions: [
          "u8hdr"
        ]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: [
          "eml",
          "mime"
        ]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: [
          "wsc"
        ]
      },
      "model/3mf": {
        source: "iana",
        extensions: [
          "3mf"
        ]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: [
          "gltf"
        ]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: [
          "glb"
        ]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: [
          "igs",
          "iges"
        ]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: [
          "msh",
          "mesh",
          "silo"
        ]
      },
      "model/mtl": {
        source: "iana",
        extensions: [
          "mtl"
        ]
      },
      "model/obj": {
        source: "iana",
        extensions: [
          "obj"
        ]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "stpx"
        ]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: [
          "stpz"
        ]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: [
          "stpxz"
        ]
      },
      "model/stl": {
        source: "iana",
        extensions: [
          "stl"
        ]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "dae"
        ]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: [
          "dwf"
        ]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: [
          "gdl"
        ]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: [
          "gtw"
        ]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: [
          "mts"
        ]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: [
          "ogex"
        ]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: [
          "x_b"
        ]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: [
          "x_t"
        ]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: [
          "vds"
        ]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: [
          "usdz"
        ]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: [
          "bsp"
        ]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: [
          "vtu"
        ]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: [
          "wrl",
          "vrml"
        ]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: [
          "x3db",
          "x3dbz"
        ]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: [
          "x3db"
        ]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: [
          "x3dv",
          "x3dvz"
        ]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "x3d",
          "x3dz"
        ]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: [
          "x3dv"
        ]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: [
          "appcache",
          "manifest"
        ]
      },
      "text/calendar": {
        source: "iana",
        extensions: [
          "ics",
          "ifb"
        ]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: [
          "coffee",
          "litcoffee"
        ]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
          "css"
        ]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: [
          "csv"
        ]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: [
          "html",
          "htm",
          "shtml"
        ]
      },
      "text/jade": {
        extensions: [
          "jade"
        ]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: [
          "jsx"
        ]
      },
      "text/less": {
        compressible: true,
        extensions: [
          "less"
        ]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: [
          "markdown",
          "md"
        ]
      },
      "text/mathml": {
        source: "nginx",
        extensions: [
          "mml"
        ]
      },
      "text/mdx": {
        compressible: true,
        extensions: [
          "mdx"
        ]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
          "n3"
        ]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: [
          "txt",
          "text",
          "conf",
          "def",
          "list",
          "log",
          "in",
          "ini"
        ]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: [
          "dsc"
        ]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: [
          "rtx"
        ]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: [
          "rtf"
        ]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: [
          "sgml",
          "sgm"
        ]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: [
          "shex"
        ]
      },
      "text/slim": {
        extensions: [
          "slim",
          "slm"
        ]
      },
      "text/spdx": {
        source: "iana",
        extensions: [
          "spdx"
        ]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: [
          "stylus",
          "styl"
        ]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: [
          "tsv"
        ]
      },
      "text/troff": {
        source: "iana",
        extensions: [
          "t",
          "tr",
          "roff",
          "man",
          "me",
          "ms"
        ]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: [
          "ttl"
        ]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: [
          "uri",
          "uris",
          "urls"
        ]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: [
          "vcard"
        ]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: [
          "curl"
        ]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: [
          "dcurl"
        ]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: [
          "mcurl"
        ]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: [
          "scurl"
        ]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: [
          "sub"
        ]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: [
          "fly"
        ]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: [
          "flx"
        ]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: [
          "gv"
        ]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: [
          "3dml"
        ]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: [
          "spot"
        ]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: [
          "jad"
        ]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: [
          "wml"
        ]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: [
          "wmls"
        ]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: [
          "vtt"
        ]
      },
      "text/x-asm": {
        source: "apache",
        extensions: [
          "s",
          "asm"
        ]
      },
      "text/x-c": {
        source: "apache",
        extensions: [
          "c",
          "cc",
          "cxx",
          "cpp",
          "h",
          "hh",
          "dic"
        ]
      },
      "text/x-component": {
        source: "nginx",
        extensions: [
          "htc"
        ]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: [
          "f",
          "for",
          "f77",
          "f90"
        ]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: [
          "hbs"
        ]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: [
          "java"
        ]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: [
          "lua"
        ]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: [
          "mkd"
        ]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: [
          "nfo"
        ]
      },
      "text/x-opml": {
        source: "apache",
        extensions: [
          "opml"
        ]
      },
      "text/x-org": {
        compressible: true,
        extensions: [
          "org"
        ]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: [
          "p",
          "pas"
        ]
      },
      "text/x-processing": {
        compressible: true,
        extensions: [
          "pde"
        ]
      },
      "text/x-sass": {
        extensions: [
          "sass"
        ]
      },
      "text/x-scss": {
        extensions: [
          "scss"
        ]
      },
      "text/x-setext": {
        source: "apache",
        extensions: [
          "etx"
        ]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: [
          "sfv"
        ]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: [
          "ymp"
        ]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: [
          "uu"
        ]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: [
          "vcs"
        ]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: [
          "vcf"
        ]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: [
          "xml"
        ]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: [
          "yaml",
          "yml"
        ]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: [
          "3gp",
          "3gpp"
        ]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: [
          "3g2"
        ]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: [
          "h261"
        ]
      },
      "video/h263": {
        source: "iana",
        extensions: [
          "h263"
        ]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: [
          "h264"
        ]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: [
          "m4s"
        ]
      },
      "video/jpeg": {
        source: "iana",
        extensions: [
          "jpgv"
        ]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: [
          "jpm",
          "jpgm"
        ]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: [
          "mj2",
          "mjp2"
        ]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: [
          "ts"
        ]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: [
          "mp4",
          "mp4v",
          "mpg4"
        ]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: [
          "mpeg",
          "mpg",
          "mpe",
          "m1v",
          "m2v"
        ]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: [
          "ogv"
        ]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: [
          "qt",
          "mov"
        ]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: [
          "uvh",
          "uvvh"
        ]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: [
          "uvm",
          "uvvm"
        ]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: [
          "uvp",
          "uvvp"
        ]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: [
          "uvs",
          "uvvs"
        ]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: [
          "uvv",
          "uvvv"
        ]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: [
          "dvb"
        ]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: [
          "fvt"
        ]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: [
          "mxu",
          "m4u"
        ]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: [
          "pyv"
        ]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: [
          "uvu",
          "uvvu"
        ]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: [
          "viv"
        ]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: [
          "webm"
        ]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: [
          "f4v"
        ]
      },
      "video/x-fli": {
        source: "apache",
        extensions: [
          "fli"
        ]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: [
          "flv"
        ]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: [
          "m4v"
        ]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: [
          "mkv",
          "mk3d",
          "mks"
        ]
      },
      "video/x-mng": {
        source: "apache",
        extensions: [
          "mng"
        ]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: [
          "asf",
          "asx"
        ]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: [
          "vob"
        ]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: [
          "wm"
        ]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: [
          "wmv"
        ]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: [
          "wmx"
        ]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: [
          "wvx"
        ]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: [
          "avi"
        ]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: [
          "movie"
        ]
      },
      "video/x-smv": {
        source: "apache",
        extensions: [
          "smv"
        ]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: [
          "ice"
        ]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
    var mimeDb = require$$0;
    (function(exports2) {
      var db2 = mimeDb;
      var extname = path__default.extname;
      var EXTRACT_TYPE_REGEXP2 = /^\s*([^;\s]*)(?:;|\s|$)/;
      var TEXT_TYPE_REGEXP = /^text\//i;
      exports2.charset = charset2;
      exports2.charsets = { lookup: charset2 };
      exports2.contentType = contentType;
      exports2.extension = extension2;
      exports2.extensions = Object.create(null);
      exports2.lookup = lookup2;
      exports2.types = Object.create(null);
      populateMaps(exports2.extensions, exports2.types);
      function charset2(type) {
        if (!type || typeof type !== "string") {
          return false;
        }
        var match2 = EXTRACT_TYPE_REGEXP2.exec(type);
        var mime2 = match2 && db2[match2[1].toLowerCase()];
        if (mime2 && mime2.charset) {
          return mime2.charset;
        }
        if (match2 && TEXT_TYPE_REGEXP.test(match2[1])) {
          return "UTF-8";
        }
        return false;
      }
      function contentType(str) {
        if (!str || typeof str !== "string") {
          return false;
        }
        var mime2 = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
        if (!mime2) {
          return false;
        }
        if (mime2.indexOf("charset") === -1) {
          var charset3 = exports2.charset(mime2);
          if (charset3)
            mime2 += "; charset=" + charset3.toLowerCase();
        }
        return mime2;
      }
      function extension2(type) {
        if (!type || typeof type !== "string") {
          return false;
        }
        var match2 = EXTRACT_TYPE_REGEXP2.exec(type);
        var exts = match2 && exports2.extensions[match2[1].toLowerCase()];
        if (!exts || !exts.length) {
          return false;
        }
        return exts[0];
      }
      function lookup2(path2) {
        if (!path2 || typeof path2 !== "string") {
          return false;
        }
        var extension3 = extname("x." + path2).toLowerCase().substr(1);
        if (!extension3) {
          return false;
        }
        return exports2.types[extension3] || false;
      }
      function populateMaps(extensions2, types2) {
        var preference = ["nginx", "apache", void 0, "iana"];
        Object.keys(db2).forEach(function forEachMimeType(type) {
          var mime2 = db2[type];
          var exts = mime2.extensions;
          if (!exts || !exts.length) {
            return;
          }
          extensions2[type] = exts;
          for (var i2 = 0; i2 < exts.length; i2++) {
            var extension3 = exts[i2];
            if (types2[extension3]) {
              var from = preference.indexOf(db2[types2[extension3]].source);
              var to2 = preference.indexOf(mime2.source);
              if (types2[extension3] !== "application/octet-stream" && (from > to2 || from === to2 && types2[extension3].substr(0, 12) === "application/")) {
                continue;
              }
            }
            types2[extension3] = type;
          }
        });
      }
    })(mimeTypes);
    var Negotiator = negotiator.exports;
    var mime = mimeTypes;
    var accepts$1 = Accepts;
    function Accepts(req2) {
      if (!(this instanceof Accepts)) {
        return new Accepts(req2);
      }
      this.headers = req2.headers;
      this.negotiator = new Negotiator(req2);
    }
    Accepts.prototype.type = Accepts.prototype.types = function(types_) {
      var types2 = types_;
      if (types2 && !Array.isArray(types2)) {
        types2 = new Array(arguments.length);
        for (var i2 = 0; i2 < types2.length; i2++) {
          types2[i2] = arguments[i2];
        }
      }
      if (!types2 || types2.length === 0) {
        return this.negotiator.mediaTypes();
      }
      if (!this.headers.accept) {
        return types2[0];
      }
      var mimes2 = types2.map(extToMime);
      var accepts2 = this.negotiator.mediaTypes(mimes2.filter(validMime));
      var first2 = accepts2[0];
      return first2 ? types2[mimes2.indexOf(first2)] : false;
    };
    Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
      var encodings = encodings_;
      if (encodings && !Array.isArray(encodings)) {
        encodings = new Array(arguments.length);
        for (var i2 = 0; i2 < encodings.length; i2++) {
          encodings[i2] = arguments[i2];
        }
      }
      if (!encodings || encodings.length === 0) {
        return this.negotiator.encodings();
      }
      return this.negotiator.encodings(encodings)[0] || false;
    };
    Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
      var charsets = charsets_;
      if (charsets && !Array.isArray(charsets)) {
        charsets = new Array(arguments.length);
        for (var i2 = 0; i2 < charsets.length; i2++) {
          charsets[i2] = arguments[i2];
        }
      }
      if (!charsets || charsets.length === 0) {
        return this.negotiator.charsets();
      }
      return this.negotiator.charsets(charsets)[0] || false;
    };
    Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
      var languages = languages_;
      if (languages && !Array.isArray(languages)) {
        languages = new Array(arguments.length);
        for (var i2 = 0; i2 < languages.length; i2++) {
          languages[i2] = arguments[i2];
        }
      }
      if (!languages || languages.length === 0) {
        return this.negotiator.languages();
      }
      return this.negotiator.languages(languages)[0] || false;
    };
    function extToMime(type) {
      return type.indexOf("/") === -1 ? mime.lookup(type) : type;
    }
    function validMime(type) {
      return typeof type === "string";
    }
    var bytes$2 = { exports: {} };
    bytes$2.exports = bytes$1;
    bytes$2.exports.format = format;
    bytes$2.exports.parse = parse$1;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: (1 << 30) * 1024
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb)$/i;
    function bytes$1(value, options2) {
      if (typeof value === "string") {
        return parse$1(value);
      }
      if (typeof value === "number") {
        return format(value, options2);
      }
      return null;
    }
    function format(value, options2) {
      if (!Number.isFinite(value)) {
        return null;
      }
      var mag = Math.abs(value);
      var thousandsSeparator = options2 && options2.thousandsSeparator || "";
      var unitSeparator = options2 && options2.unitSeparator || "";
      var decimalPlaces = options2 && options2.decimalPlaces !== void 0 ? options2.decimalPlaces : 2;
      var fixedDecimals = Boolean(options2 && options2.fixedDecimals);
      var unit = options2 && options2.unit || "";
      if (!unit || !map[unit.toLowerCase()]) {
        if (mag >= map.tb) {
          unit = "TB";
        } else if (mag >= map.gb) {
          unit = "GB";
        } else if (mag >= map.mb) {
          unit = "MB";
        } else if (mag >= map.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value / map[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.replace(formatThousandsRegExp, thousandsSeparator);
      }
      return str + unitSeparator + unit;
    }
    function parse$1(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      return Math.floor(map[unit] * floatValue);
    }
    var db = mimeDb;
    var COMPRESSIBLE_TYPE_REGEXP = /^text\/|\+(?:json|text|xml)$/i;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var compressible_1 = compressible$1;
    function compressible$1(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match2 = EXTRACT_TYPE_REGEXP.exec(type);
      var mime2 = match2 && match2[1].toLowerCase();
      var data2 = db[mime2];
      if (data2 && data2.compressible !== void 0) {
        return data2.compressible;
      }
      return COMPRESSIBLE_TYPE_REGEXP.test(mime2) || void 0;
    }
    var onHeaders_1 = onHeaders$1;
    function createWriteHead(prevWriteHead, listener2) {
      var fired = false;
      return function writeHead(statusCode) {
        var args = setWriteHeadHeaders.apply(this, arguments);
        if (!fired) {
          fired = true;
          listener2.call(this);
          if (typeof args[0] === "number" && this.statusCode !== args[0]) {
            args[0] = this.statusCode;
            args.length = 1;
          }
        }
        return prevWriteHead.apply(this, args);
      };
    }
    function onHeaders$1(res, listener2) {
      if (!res) {
        throw new TypeError("argument res is required");
      }
      if (typeof listener2 !== "function") {
        throw new TypeError("argument listener must be a function");
      }
      res.writeHead = createWriteHead(res.writeHead, listener2);
    }
    function setHeadersFromArray(res, headers) {
      for (var i2 = 0; i2 < headers.length; i2++) {
        res.setHeader(headers[i2][0], headers[i2][1]);
      }
    }
    function setHeadersFromObject(res, headers) {
      var keys = Object.keys(headers);
      for (var i2 = 0; i2 < keys.length; i2++) {
        var k2 = keys[i2];
        if (k2)
          res.setHeader(k2, headers[k2]);
      }
    }
    function setWriteHeadHeaders(statusCode) {
      var length = arguments.length;
      var headerIndex = length > 1 && typeof arguments[1] === "string" ? 2 : 1;
      var headers = length >= headerIndex + 1 ? arguments[headerIndex] : void 0;
      this.statusCode = statusCode;
      if (Array.isArray(headers)) {
        setHeadersFromArray(this, headers);
      } else if (headers) {
        setHeadersFromObject(this, headers);
      }
      var args = new Array(Math.min(length, headerIndex));
      for (var i2 = 0; i2 < args.length; i2++) {
        args[i2] = arguments[i2];
      }
      return args;
    }
    var accepts = accepts$1;
    var Buffer$1 = safeBuffer.exports.Buffer;
    var bytes = bytes$2.exports;
    var compressible = compressible_1;
    var debug$2 = src.exports("compression");
    var onHeaders = onHeaders_1;
    var vary = vary$2.exports;
    var zlib = require$$0__default$6;
    compression$2.exports = compression;
    compression$2.exports.filter = shouldCompress;
    var cacheControlNoTransformRegExp = /(?:^|,)\s*?no-transform\s*?(?:,|$)/;
    function compression(options2) {
      var opts = options2 || {};
      var filter2 = opts.filter || shouldCompress;
      var threshold = bytes.parse(opts.threshold);
      if (threshold == null) {
        threshold = 1024;
      }
      return function compression2(req2, res, next) {
        var ended = false;
        var length;
        var listeners = [];
        var stream2;
        var _end = res.end;
        var _on = res.on;
        var _write = res.write;
        res.flush = function flush() {
          if (stream2) {
            stream2.flush();
          }
        };
        res.write = function write(chunk, encoding2) {
          if (ended) {
            return false;
          }
          if (!this._header) {
            this._implicitHeader();
          }
          return stream2 ? stream2.write(toBuffer(chunk, encoding2)) : _write.call(this, chunk, encoding2);
        };
        res.end = function end(chunk, encoding2) {
          if (ended) {
            return false;
          }
          if (!this._header) {
            if (!this.getHeader("Content-Length")) {
              length = chunkLength(chunk, encoding2);
            }
            this._implicitHeader();
          }
          if (!stream2) {
            return _end.call(this, chunk, encoding2);
          }
          ended = true;
          return chunk ? stream2.end(toBuffer(chunk, encoding2)) : stream2.end();
        };
        res.on = function on2(type, listener2) {
          if (!listeners || type !== "drain") {
            return _on.call(this, type, listener2);
          }
          if (stream2) {
            return stream2.on(type, listener2);
          }
          listeners.push([type, listener2]);
          return this;
        };
        function nocompress(msg) {
          debug$2("no compression: %s", msg);
          addListeners(res, _on, listeners);
          listeners = null;
        }
        onHeaders(res, function onResponseHeaders() {
          if (!filter2(req2, res)) {
            nocompress("filtered");
            return;
          }
          if (!shouldTransform(req2, res)) {
            nocompress("no transform");
            return;
          }
          vary(res, "Accept-Encoding");
          if (Number(res.getHeader("Content-Length")) < threshold || length < threshold) {
            nocompress("size below threshold");
            return;
          }
          var encoding2 = res.getHeader("Content-Encoding") || "identity";
          if (encoding2 !== "identity") {
            nocompress("already encoded");
            return;
          }
          if (req2.method === "HEAD") {
            nocompress("HEAD request");
            return;
          }
          var accept = accepts(req2);
          var method = accept.encoding(["gzip", "deflate", "identity"]);
          if (method === "deflate" && accept.encoding(["gzip"])) {
            method = accept.encoding(["gzip", "identity"]);
          }
          if (!method || method === "identity") {
            nocompress("not acceptable");
            return;
          }
          debug$2("%s compression", method);
          stream2 = method === "gzip" ? zlib.createGzip(opts) : zlib.createDeflate(opts);
          addListeners(stream2, stream2.on, listeners);
          res.setHeader("Content-Encoding", method);
          res.removeHeader("Content-Length");
          stream2.on("data", function onStreamData(chunk) {
            if (_write.call(res, chunk) === false) {
              stream2.pause();
            }
          });
          stream2.on("end", function onStreamEnd() {
            _end.call(res);
          });
          _on.call(res, "drain", function onResponseDrain() {
            stream2.resume();
          });
        });
        next();
      };
    }
    function addListeners(stream2, on2, listeners) {
      for (var i2 = 0; i2 < listeners.length; i2++) {
        on2.apply(stream2, listeners[i2]);
      }
    }
    function chunkLength(chunk, encoding2) {
      if (!chunk) {
        return 0;
      }
      return !Buffer$1.isBuffer(chunk) ? Buffer$1.byteLength(chunk, encoding2) : chunk.length;
    }
    function shouldCompress(req2, res) {
      var type = res.getHeader("Content-Type");
      if (type === void 0 || !compressible(type)) {
        debug$2("%s not compressible", type);
        return false;
      }
      return true;
    }
    function shouldTransform(req2, res) {
      var cacheControl = res.getHeader("Cache-Control");
      return !cacheControl || !cacheControlNoTransformRegExp.test(cacheControl);
    }
    function toBuffer(chunk, encoding2) {
      return !Buffer$1.isBuffer(chunk) ? Buffer$1.from(chunk, encoding2) : chunk;
    }
    var compression$1 = compression$2.exports;
    function resolvePreviewOptions(preview2, server2) {
      var _a2, _b, _c, _d, _e2, _f;
      return {
        port: preview2 === null || preview2 === void 0 ? void 0 : preview2.port,
        strictPort: (_a2 = preview2 === null || preview2 === void 0 ? void 0 : preview2.strictPort) !== null && _a2 !== void 0 ? _a2 : server2.strictPort,
        host: (_b = preview2 === null || preview2 === void 0 ? void 0 : preview2.host) !== null && _b !== void 0 ? _b : server2.host,
        https: (_c = preview2 === null || preview2 === void 0 ? void 0 : preview2.https) !== null && _c !== void 0 ? _c : server2.https,
        open: (_d = preview2 === null || preview2 === void 0 ? void 0 : preview2.open) !== null && _d !== void 0 ? _d : server2.open,
        proxy: (_e2 = preview2 === null || preview2 === void 0 ? void 0 : preview2.proxy) !== null && _e2 !== void 0 ? _e2 : server2.proxy,
        cors: (_f = preview2 === null || preview2 === void 0 ? void 0 : preview2.cors) !== null && _f !== void 0 ? _f : server2.cors
      };
    }
    async function preview(inlineConfig) {
      var _a2, _b;
      const config2 = await resolveConfig(inlineConfig, "serve", "production");
      const app = connect();
      const httpServer = await resolveHttpServer(config2.preview, app, await resolveHttpsConfig((_a2 = config2.preview) === null || _a2 === void 0 ? void 0 : _a2.https, config2.cacheDir));
      const { cors } = config2.preview;
      if (cors !== false) {
        app.use(corsMiddleware(typeof cors === "boolean" ? {} : cors));
      }
      if (config2.preview.proxy) {
        app.use(proxyMiddleware(httpServer, config2));
      }
      app.use(compression$1());
      const distDir = path__default.resolve(config2.root, config2.build.outDir);
      app.use(config2.base, sirv(distDir, {
        etag: true,
        dev: true,
        single: true
      }));
      const options2 = config2.preview;
      const hostname = resolveHostname(options2.host);
      const port = (_b = options2.port) !== null && _b !== void 0 ? _b : 5e3;
      const protocol = options2.https ? "https" : "http";
      const logger = config2.logger;
      const base2 = config2.base;
      const serverPort = await httpServerStart(httpServer, {
        port,
        strictPort: options2.strictPort,
        host: hostname.host,
        logger
      });
      if (options2.open) {
        const path2 = typeof options2.open === "string" ? options2.open : base2;
        openBrowser(path2.startsWith("http") ? path2 : `${protocol}://${hostname.name}:${serverPort}${path2}`, true, logger);
      }
      return {
        config: config2,
        httpServer,
        printUrls() {
          printCommonServerUrls(httpServer, config2.preview, config2);
        }
      };
    }
    var noop = () => null;
    function matches(pattern2, importee) {
      if (pattern2 instanceof RegExp) {
        return pattern2.test(importee);
      }
      if (importee.length < pattern2.length) {
        return false;
      }
      if (importee === pattern2) {
        return true;
      }
      const importeeStartsWithKey = importee.indexOf(pattern2) === 0;
      const importeeHasSlashAfterKey = importee.substring(pattern2.length)[0] === "/";
      return importeeStartsWithKey && importeeHasSlashAfterKey;
    }
    function normalizeId(id) {
      return id;
    }
    function getEntries({ entries }) {
      if (!entries) {
        return [];
      }
      if (Array.isArray(entries)) {
        return entries;
      }
      return Object.entries(entries).map(([key, value]) => {
        return { find: key, replacement: value };
      });
    }
    function getCustomResolver({ customResolver }, options2) {
      if (typeof customResolver === "function") {
        return customResolver;
      }
      if (customResolver && typeof customResolver.resolveId === "function") {
        return customResolver.resolveId;
      }
      if (typeof options2.customResolver === "function") {
        return options2.customResolver;
      }
      if (options2.customResolver && typeof options2.customResolver.resolveId === "function") {
        return options2.customResolver.resolveId;
      }
      return null;
    }
    function alias(options2 = {}) {
      const entries = getEntries(options2);
      if (entries.length === 0) {
        return {
          name: "alias",
          resolveId: noop
        };
      }
      return {
        name: "alias",
        buildStart(inputOptions) {
          return Promise.all([...entries, options2].map(({ customResolver }) => customResolver && typeof customResolver === "object" && typeof customResolver.buildStart === "function" && customResolver.buildStart.call(this, inputOptions))).then(() => {
          });
        },
        resolveId(importee, importer, resolveOptions) {
          const importeeId = normalizeId(importee);
          const importerId = normalizeId(importer);
          const matchedEntry = entries.find((entry2) => matches(entry2.find, importeeId));
          if (!matchedEntry || !importerId) {
            return null;
          }
          const updatedId = normalizeId(importeeId.replace(matchedEntry.find, matchedEntry.replacement));
          const customResolver = getCustomResolver(matchedEntry, options2);
          if (customResolver) {
            return customResolver.call(this, updatedId, importerId, resolveOptions);
          }
          return this.resolve(updatedId, importer, Object.assign({ skipSelf: true }, resolveOptions)).then((resolved) => {
            let finalResult = resolved;
            if (!finalResult) {
              finalResult = { id: updatedId };
            }
            return finalResult;
          });
        }
      };
    }
    var jsonExtRE = /\.json($|\?)(?!commonjs-(proxy|external))/;
    function jsonPlugin(options2 = {}, isBuild) {
      return {
        name: "vite:json",
        transform(json2, id) {
          if (!jsonExtRE.test(id))
            return null;
          if (SPECIAL_QUERY_RE.test(id))
            return null;
          try {
            if (options2.stringify) {
              if (isBuild) {
                return {
                  code: `export default JSON.parse(${JSON.stringify(JSON.stringify(JSON.parse(json2)))})`,
                  map: { mappings: "" }
                };
              } else {
                return `export default JSON.parse(${JSON.stringify(json2)})`;
              }
            }
            const parsed = JSON.parse(json2);
            return {
              code: dataToEsm(parsed, {
                preferConst: true,
                namedExports: options2.namedExports
              }),
              map: { mappings: "" }
            };
          } catch (e2) {
            const errorMessageList = /[\d]+/.exec(e2.message);
            const position = errorMessageList && parseInt(errorMessageList[0], 10);
            const msg = position ? `, invalid JSON syntax found at line ${position}` : `.`;
            this.error(`Failed to parse JSON file` + msg, e2.idx);
          }
        }
      };
    }
    var isDebug = !!process.env.DEBUG;
    var debug$1 = createDebugger("vite:import-analysis");
    var clientDir = normalizePath$4(CLIENT_DIR);
    var skipRE = /\.(map|json)$/;
    var canSkip = (id) => skipRE.test(id) || isDirectCSSRequest(id);
    function isExplicitImportRequired(url2) {
      return !isJSRequest(cleanUrl(url2)) && !isCSSRequest(url2);
    }
    function markExplicitImport(url2) {
      if (isExplicitImportRequired(url2)) {
        return injectQuery(url2, "import");
      }
      return url2;
    }
    function importAnalysisPlugin(config2) {
      const { root, base: base2 } = config2;
      const clientPublicPath = path__default.posix.join(base2, CLIENT_PUBLIC_PATH);
      let server2;
      return {
        name: "vite:import-analysis",
        configureServer(_server) {
          server2 = _server;
        },
        async transform(source$1, importer, options2) {
          const ssr = (options2 === null || options2 === void 0 ? void 0 : options2.ssr) === true;
          const prettyImporter = prettifyUrl(importer, root);
          if (canSkip(importer)) {
            isDebug && debug$1(source.dim(`[skipped] ${prettyImporter}`));
            return null;
          }
          const start = perf_hooks.performance.now();
          await init;
          let imports = [];
          if (source$1.charCodeAt(0) === 65279) {
            source$1 = source$1.slice(1);
          }
          try {
            imports = parse$f(source$1)[0];
          } catch (e2) {
            const isVue = importer.endsWith(".vue");
            const maybeJSX = !isVue && isJSRequest(importer);
            const msg = isVue ? `Install @vitejs/plugin-vue to handle .vue files.` : maybeJSX ? `If you are using JSX, make sure to name the file with the .jsx or .tsx extension.` : `You may need to install appropriate plugins to handle the ${path__default.extname(importer)} file format.`;
            this.error(`Failed to parse source for import analysis because the content contains invalid JS syntax. ` + msg, e2.idx);
          }
          if (!imports.length) {
            isDebug && debug$1(`${timeFrom(start)} ${source.dim(`[no imports] ${prettyImporter}`)}`);
            return source$1;
          }
          let hasHMR = false;
          let isSelfAccepting = false;
          let hasEnv = false;
          let needQueryInjectHelper = false;
          let s2;
          const str = () => s2 || (s2 = new MagicString(source$1));
          const { moduleGraph } = server2;
          const importerModule = moduleGraph.getModuleById(importer);
          const importedUrls = new Set();
          const staticImportedUrls = new Set();
          const acceptedUrls = new Set();
          const toAbsoluteUrl = (url2) => path__default.posix.resolve(path__default.posix.dirname(importerModule.url), url2);
          const normalizeUrl = async (url2, pos) => {
            var _a2;
            if (base2 !== "/" && url2.startsWith(base2)) {
              url2 = url2.replace(base2, "/");
            }
            let importerFile = importer;
            if (moduleListContains((_a2 = config2.optimizeDeps) === null || _a2 === void 0 ? void 0 : _a2.exclude, url2) && server2._optimizeDepsMetadata) {
              for (const optimizedModule of Object.values(server2._optimizeDepsMetadata.optimized)) {
                if (optimizedModule.file === importerModule.file) {
                  importerFile = optimizedModule.src;
                }
              }
            }
            const resolved = await this.resolve(url2, importerFile);
            if (!resolved) {
              this.error(`Failed to resolve import "${url2}" from "${path__default.relative(process.cwd(), importerFile)}". Does the file exist?`, pos);
            }
            const isRelative = url2.startsWith(".");
            const isSelfImport = !isRelative && cleanUrl(url2) === cleanUrl(importer);
            if (resolved.id.startsWith(root + "/")) {
              url2 = resolved.id.slice(root.length);
            } else if (fs__default.existsSync(cleanUrl(resolved.id))) {
              url2 = path__default.posix.join(FS_PREFIX + resolved.id);
            } else {
              url2 = resolved.id;
            }
            if (isExternalUrl(url2)) {
              return [url2, url2];
            }
            if (!url2.startsWith(".") && !url2.startsWith("/")) {
              url2 = VALID_ID_PREFIX + resolved.id.replace("\0", NULL_BYTE_PLACEHOLDER);
            }
            if (!ssr) {
              url2 = markExplicitImport(url2);
              if ((isRelative || isSelfImport) && !/[\?&]import=?\b/.test(url2)) {
                const versionMatch = importer.match(DEP_VERSION_RE);
                if (versionMatch) {
                  url2 = injectQuery(url2, versionMatch[1]);
                }
              }
              try {
                const depModule = await moduleGraph.ensureEntryFromUrl(url2);
                if (depModule.lastHMRTimestamp > 0) {
                  url2 = injectQuery(url2, `t=${depModule.lastHMRTimestamp}`);
                }
              } catch (e2) {
                e2.pos = pos;
                throw e2;
              }
              url2 = base2 + url2.replace(/^\//, "");
            }
            return [url2, resolved.id];
          };
          for (let index2 = 0; index2 < imports.length; index2++) {
            const {
              s: start2,
              e: end,
              ss: expStart,
              se: expEnd,
              d: dynamicIndex,
              n: specifier
            } = imports[index2];
            const rawUrl = source$1.slice(start2, end);
            if (rawUrl === "import.meta") {
              const prop = source$1.slice(end, end + 4);
              if (prop === ".hot") {
                hasHMR = true;
                if (source$1.slice(end + 4, end + 11) === ".accept") {
                  if (lexAcceptedHmrDeps(source$1, source$1.indexOf("(", end + 11) + 1, acceptedUrls)) {
                    isSelfAccepting = true;
                  }
                }
              } else if (prop === ".env") {
                hasEnv = true;
              } else if (prop === ".glo" && source$1[end + 4] === "b") {
                const { imports: imports2, importsString, exp, endIndex, base: base3, pattern: pattern2, isEager } = await transformImportGlob(source$1, start2, importer, index2, root, normalizeUrl);
                str().prepend(importsString);
                str().overwrite(expStart, endIndex, exp);
                imports2.forEach((url2) => {
                  url2 = url2.replace(base3, "/");
                  importedUrls.add(url2);
                  if (isEager)
                    staticImportedUrls.add(url2);
                });
                if (!(importerModule.file in server2._globImporters)) {
                  server2._globImporters[importerModule.file] = {
                    module: importerModule,
                    importGlobs: []
                  };
                }
                server2._globImporters[importerModule.file].importGlobs.push({
                  base: base3,
                  pattern: pattern2
                });
              }
              continue;
            }
            const isDynamicImport = dynamicIndex >= 0;
            if (specifier) {
              if (isExternalUrl(specifier) || isDataUrl(specifier)) {
                continue;
              }
              if (ssr) {
                if (server2._ssrExternals && shouldExternalizeForSSR(specifier, server2._ssrExternals)) {
                  continue;
                }
                if (isBuiltin(specifier)) {
                  continue;
                }
              }
              if (specifier === clientPublicPath) {
                continue;
              }
              if (specifier.startsWith("/") && !config2.assetsInclude(cleanUrl(specifier)) && !specifier.endsWith(".json") && checkPublicFile(specifier, config2)) {
                throw new Error(`Cannot import non-asset file ${specifier} which is inside /public.JS/CSS files inside /public are copied as-is on build and can only be referenced via <script src> or <link href> in html.`);
              }
              const [normalizedUrl, resolvedId] = await normalizeUrl(specifier, start2);
              let url2 = normalizedUrl;
              server2 === null || server2 === void 0 ? void 0 : server2.moduleGraph.safeModulesPath.add(cleanUrl(url2).slice(4));
              if (url2 !== specifier) {
                if (resolvedId.endsWith(`&es-interop`)) {
                  url2 = url2.slice(0, -11);
                  if (isDynamicImport) {
                    str().overwrite(dynamicIndex, end + 1, `import('${url2}').then(m => m.default && m.default.__esModule ? m.default : ({ ...m.default, default: m.default }))`);
                  } else {
                    const exp = source$1.slice(expStart, expEnd);
                    const rewritten = transformCjsImport(exp, url2, rawUrl, index2);
                    if (rewritten) {
                      str().overwrite(expStart, expEnd, rewritten);
                    } else {
                      str().overwrite(start2, end, url2);
                    }
                  }
                } else {
                  str().overwrite(start2, end, isDynamicImport ? `'${url2}'` : url2);
                }
              }
              const urlWithoutBase = url2.replace(base2, "/");
              importedUrls.add(urlWithoutBase);
              if (!isDynamicImport) {
                staticImportedUrls.add(urlWithoutBase);
              }
            } else if (!importer.startsWith(clientDir) && !ssr) {
              const hasViteIgnore = /\/\*\s*@vite-ignore\s*\*\//.test(rawUrl);
              const url2 = rawUrl.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, "").trim();
              if (!hasViteIgnore && !isSupportedDynamicImport(url2)) {
                this.warn(`
` + source.cyan(importerModule.file) + `
` + generateCodeFrame(source$1, start2) + `
The above dynamic import cannot be analyzed by vite.
See ${source.blue(`https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#limitations`)} for supported dynamic import formats. If this is intended to be left as-is, you can use the /* @vite-ignore */ comment inside the import() call to suppress this warning.
`);
              }
              if (!/^('.*'|".*"|`.*`)$/.test(url2) || isExplicitImportRequired(url2.slice(1, -1))) {
                needQueryInjectHelper = true;
                str().overwrite(start2, end, `__vite__injectQuery(${url2}, 'import')`);
              }
            }
          }
          if (hasEnv) {
            let env2 = `import.meta.env = ${JSON.stringify(__spreadProps2(__spreadValues2({}, config2.env), {
              SSR: !!ssr
            }))};`;
            for (const key in config2.define) {
              if (key.startsWith(`import.meta.env.`)) {
                const val = config2.define[key];
                env2 += `${key} = ${typeof val === "string" ? val : JSON.stringify(val)};`;
              }
            }
            str().prepend(env2);
          }
          if (hasHMR && !ssr) {
            debugHmr(`${isSelfAccepting ? `[self-accepts]` : acceptedUrls.size ? `[accepts-deps]` : `[detected api usage]`} ${prettyImporter}`);
            str().prepend(`import { createHotContext as __vite__createHotContext } from "${clientPublicPath}";import.meta.hot = __vite__createHotContext(${JSON.stringify(importerModule.url)});`);
          }
          if (needQueryInjectHelper) {
            str().prepend(`import { injectQuery as __vite__injectQuery } from "${clientPublicPath}";`);
          }
          const normalizedAcceptedUrls = new Set();
          for (const { url: url2, start: start2, end } of acceptedUrls) {
            const [normalized] = await moduleGraph.resolveUrl(toAbsoluteUrl(markExplicitImport(url2)));
            normalizedAcceptedUrls.add(normalized);
            str().overwrite(start2, end, JSON.stringify(normalized));
          }
          if (!isCSSRequest(importer)) {
            const pluginImports = this._addedImports;
            if (pluginImports) {
              (await Promise.all([...pluginImports].map((id) => normalizeUrl(id, 0)))).forEach(([url2]) => importedUrls.add(url2));
            }
            if (ssr && importerModule.isSelfAccepting) {
              isSelfAccepting = true;
            }
            const prunedImports = await moduleGraph.updateModuleInfo(importerModule, importedUrls, normalizedAcceptedUrls, isSelfAccepting);
            if (hasHMR && prunedImports) {
              handlePrunedModules(prunedImports, server2);
            }
          }
          isDebug && debug$1(`${timeFrom(start)} ${source.dim(`[${importedUrls.size} imports rewritten] ${prettyImporter}`)}`);
          if (config2.server.preTransformRequests && staticImportedUrls.size) {
            staticImportedUrls.forEach((url2) => {
              transformRequest(unwrapId$1(removeImportQuery(url2)), server2, { ssr });
            });
          }
          if (s2) {
            return s2.toString();
          } else {
            return source$1;
          }
        }
      };
    }
    function isSupportedDynamicImport(url2) {
      url2 = url2.trim().slice(1, -1);
      if (!url2.startsWith("./") && !url2.startsWith("../")) {
        return false;
      }
      if (!path__default.extname(url2)) {
        return false;
      }
      if (url2.startsWith("./${") && url2.indexOf("/") === url2.lastIndexOf("/")) {
        return false;
      }
      return true;
    }
    function transformCjsImport(importExp, url2, rawUrl, importIndex) {
      const node2 = parse$c(importExp, {
        ecmaVersion: "latest",
        sourceType: "module"
      }).body[0];
      if (node2.type === "ImportDeclaration" || node2.type === "ExportNamedDeclaration") {
        if (!node2.specifiers.length) {
          return `import "${url2}"`;
        }
        const importNames = [];
        const exportNames = [];
        let defaultExports = "";
        for (const spec of node2.specifiers) {
          if (spec.type === "ImportSpecifier" && spec.imported.type === "Identifier") {
            const importedName = spec.imported.name;
            const localName = spec.local.name;
            importNames.push({ importedName, localName });
          } else if (spec.type === "ImportDefaultSpecifier") {
            importNames.push({
              importedName: "default",
              localName: spec.local.name
            });
          } else if (spec.type === "ImportNamespaceSpecifier") {
            importNames.push({ importedName: "*", localName: spec.local.name });
          } else if (spec.type === "ExportSpecifier" && spec.exported.type === "Identifier") {
            const importedName = spec.local.name;
            const exportedName = spec.exported.name;
            if (exportedName === "default") {
              defaultExports = makeLegalIdentifier$1(`__vite__cjsExportDefault_${importIndex}`);
              importNames.push({ importedName, localName: defaultExports });
            } else {
              importNames.push({ importedName, localName: exportedName });
              exportNames.push(exportedName);
            }
          }
        }
        const cjsModuleName = makeLegalIdentifier$1(`__vite__cjsImport${importIndex}_${rawUrl}`);
        const lines = [`import ${cjsModuleName} from "${url2}"`];
        importNames.forEach(({ importedName, localName }) => {
          if (importedName === "*") {
            lines.push(`const ${localName} = ${cjsModuleName}`);
          } else if (importedName === "default") {
            lines.push(`const ${localName} = ${cjsModuleName}.__esModule ? ${cjsModuleName}.default : ${cjsModuleName}`);
          } else {
            lines.push(`const ${localName} = ${cjsModuleName}["${importedName}"]`);
          }
        });
        if (defaultExports) {
          lines.push(`export default ${defaultExports}`);
        }
        if (exportNames.length) {
          lines.push(`export { ${exportNames.join(", ")} }`);
        }
        return lines.join("; ");
      }
    }
    var normalizedClientEntry = normalizePath$4(CLIENT_ENTRY);
    var normalizedEnvEntry = normalizePath$4(ENV_ENTRY);
    function clientInjectionsPlugin(config2) {
      return {
        name: "vite:client-inject",
        transform(code, id) {
          if (id === normalizedClientEntry || id === normalizedEnvEntry) {
            let options2 = config2.server.hmr;
            options2 = options2 && typeof options2 !== "boolean" ? options2 : {};
            const host = options2.host || null;
            const protocol = options2.protocol || null;
            const timeout = options2.timeout || 3e4;
            const overlay = options2.overlay !== false;
            let port;
            if (isObject$3(config2.server.hmr)) {
              port = config2.server.hmr.clientPort || config2.server.hmr.port;
            }
            if (config2.server.middlewareMode) {
              port = String(port || 24678);
            } else {
              port = String(port || options2.port || config2.server.port);
            }
            let hmrBase = config2.base;
            if (options2.path) {
              hmrBase = path__default.posix.join(hmrBase, options2.path);
            }
            if (hmrBase !== "/") {
              port = path__default.posix.normalize(`${port}${hmrBase}`);
            }
            return code.replace(`__MODE__`, JSON.stringify(config2.mode)).replace(`__BASE__`, JSON.stringify(config2.base)).replace(`__DEFINES__`, serializeDefine(config2.define || {})).replace(`__HMR_PROTOCOL__`, JSON.stringify(protocol)).replace(`__HMR_HOSTNAME__`, JSON.stringify(host)).replace(`__HMR_PORT__`, JSON.stringify(port)).replace(`__HMR_TIMEOUT__`, JSON.stringify(timeout)).replace(`__HMR_ENABLE_OVERLAY__`, JSON.stringify(overlay));
          } else if (code.includes("process.env.NODE_ENV")) {
            return code.replace(/\bprocess\.env\.NODE_ENV\b/g, JSON.stringify(config2.mode));
          }
        }
      };
    }
    function serializeDefine(define2) {
      let res = `{`;
      for (const key in define2) {
        const val = define2[key];
        res += `${JSON.stringify(key)}: ${typeof val === "string" ? `(${val})` : JSON.stringify(val)}, `;
      }
      return res + `}`;
    }
    var wasmHelperId = "/__vite-wasm-helper";
    var wasmHelper = async (opts = {}, url2) => {
      let result2;
      if (url2.startsWith("data:")) {
        const binaryString = atob(url2.replace(/^data:.*?base64,/, ""));
        const bytes2 = new Uint8Array(binaryString.length);
        for (let i2 = 0; i2 < binaryString.length; i2++) {
          bytes2[i2] = binaryString.charCodeAt(i2);
        }
        result2 = await WebAssembly.instantiate(bytes2, opts);
      } else {
        const response = await fetch(url2);
        const contentType = response.headers.get("Content-Type") || "";
        if ("instantiateStreaming" in WebAssembly && contentType.startsWith("application/wasm")) {
          result2 = await WebAssembly.instantiateStreaming(response, opts);
        } else {
          const buffer = await response.arrayBuffer();
          result2 = await WebAssembly.instantiate(buffer, opts);
        }
      }
      return result2.instance.exports;
    };
    var wasmHelperCode = wasmHelper.toString();
    var wasmPlugin = (config2) => {
      return {
        name: "vite:wasm",
        resolveId(id) {
          if (id === wasmHelperId) {
            return id;
          }
        },
        async load(id) {
          if (id === wasmHelperId) {
            return `export default ${wasmHelperCode}`;
          }
          if (!id.endsWith(".wasm")) {
            return;
          }
          const url2 = await fileToUrl(id, config2, this);
          return `
import initWasm from "${wasmHelperId}"
export default opts => initWasm(opts, ${JSON.stringify(url2)})
`;
        }
      };
    };
    function parseWorkerRequest(id) {
      const { search } = require$$0$6.parse(id);
      if (!search) {
        return null;
      }
      return Object.fromEntries(new require$$0$6.URLSearchParams(search.slice(1)));
    }
    var WorkerFileId = "worker_file";
    function webWorkerPlugin(config2) {
      const isBuild = config2.command === "build";
      return {
        name: "vite:worker",
        load(id) {
          var _a2;
          if (isBuild) {
            const parsedQuery = parseWorkerRequest(id);
            if (parsedQuery && ((_a2 = parsedQuery.worker) !== null && _a2 !== void 0 ? _a2 : parsedQuery.sharedworker) != null) {
              return "";
            }
          }
        },
        async transform(_2, id) {
          var _a2;
          const query = parseWorkerRequest(id);
          if (query && query[WorkerFileId] != null) {
            return {
              code: `import '${ENV_PUBLIC_PATH}'
` + _2
            };
          }
          if (query == null || query && ((_a2 = query.worker) !== null && _a2 !== void 0 ? _a2 : query.sharedworker) == null) {
            return;
          }
          let url2;
          if (isBuild) {
            const rollup = (init_rollup_browser(), rollup_browser_exports);
            const bundle = await rollup.rollup({
              input: cleanUrl(id),
              plugins: await resolvePlugins(__spreadValues2({}, config2), [], [], []),
              onwarn(warning, warn2) {
                onRollupWarning(warning, warn2, config2);
              }
            });
            let code;
            try {
              const { output } = await bundle.generate({
                format: "iife",
                sourcemap: config2.build.sourcemap
              });
              code = output[0].code;
            } finally {
              await bundle.close();
            }
            const content2 = Buffer.from(code);
            if (query.inline != null) {
              return `const encodedJs = "${content2.toString("base64")}";
            const blob = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs)], { type: "text/javascript;charset=utf-8" });
            export default function WorkerWrapper() {
              const objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);
              try {
                return objURL ? new Worker(objURL) : new Worker("data:application/javascript;base64," + encodedJs, {type: "module"});
              } finally {
                objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
              }
            }`;
            } else {
              const basename = path__default.parse(cleanUrl(id)).name;
              const contentHash = getAssetHash(content2);
              const fileName = path__default.posix.join(config2.build.assetsDir, `${basename}.${contentHash}.js`);
              url2 = `__VITE_ASSET__${this.emitFile({
                fileName,
                type: "asset",
                source: code
              })}__`;
            }
          } else {
            url2 = await fileToUrl(cleanUrl(id), config2, this);
            url2 = injectQuery(url2, WorkerFileId);
          }
          const workerConstructor = query.sharedworker != null ? "SharedWorker" : "Worker";
          const workerOptions = { type: "module" };
          return `export default function WorkerWrapper() {
        return new ${workerConstructor}(${JSON.stringify(url2)}, ${JSON.stringify(workerOptions, null, 2)})
      }`;
        }
      };
    }
    function preAliasPlugin() {
      let server2;
      return {
        name: "vite:pre-alias",
        configureServer(_server) {
          server2 = _server;
        },
        resolveId(id, importer, options2) {
          if (!(options2 === null || options2 === void 0 ? void 0 : options2.ssr) && bareImportRE.test(id)) {
            return tryOptimizedResolve(id, server2, importer);
          }
        }
      };
    }
    function definePlugin(config2) {
      const isBuild = config2.command === "build";
      const processNodeEnv = {
        "process.env.NODE_ENV": JSON.stringify("development"),
        "global.process.env.NODE_ENV": JSON.stringify("development"),
        "globalThis.process.env.NODE_ENV": JSON.stringify("development")
      };
      const userDefine = {};
      for (const key in config2.define) {
        const val = config2.define[key];
        userDefine[key] = typeof val === "string" ? val : JSON.stringify(val);
      }
      const importMetaKeys = {};
      if (isBuild) {
        const env2 = __spreadProps2(__spreadValues2({}, config2.env), {
          SSR: !!config2.build.ssr
        });
        for (const key in env2) {
          importMetaKeys[`import.meta.env.${key}`] = JSON.stringify(env2[key]);
        }
        Object.assign(importMetaKeys, {
          "import.meta.env.": `({}).`,
          "import.meta.env": JSON.stringify(config2.env),
          "import.meta.hot": `false`
        });
      }
      function generatePattern(ssr) {
        var _a2;
        const processEnv = {};
        if (!ssr || ((_a2 = config2.ssr) === null || _a2 === void 0 ? void 0 : _a2.target) === "webworker") {
          Object.assign(processEnv, {
            "process.env.": `({}).`,
            "global.process.env.": `({}).`,
            "globalThis.process.env.": `({}).`
          });
        }
        const replacements = __spreadValues2(__spreadValues2(__spreadValues2(__spreadValues2({}, processNodeEnv), userDefine), importMetaKeys), processEnv);
        const pattern2 = new RegExp("(?<!(?<!\\.\\.)\\.)\\b(" + Object.keys(replacements).map((str) => {
          return str.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&");
        }).join("|") + ")\\b", "g");
        return [replacements, pattern2];
      }
      const defaultPattern = generatePattern(false);
      const ssrPattern = generatePattern(true);
      return {
        name: "vite:define",
        transform(code, id, options2) {
          const ssr = (options2 === null || options2 === void 0 ? void 0 : options2.ssr) === true;
          if (!ssr && !isBuild) {
            return;
          }
          if (isCSSRequest(id) || config2.assetsInclude(id)) {
            return;
          }
          const [replacements, pattern2] = ssr ? ssrPattern : defaultPattern;
          if (ssr && !isBuild) {
            return code.replace(pattern2, (_2, match3) => {
              return "" + replacements[match3];
            });
          }
          const s2 = new MagicString(code);
          let hasReplaced = false;
          let match2;
          while (match2 = pattern2.exec(code)) {
            hasReplaced = true;
            const start = match2.index;
            const end = start + match2[0].length;
            const replacement2 = "" + replacements[match2[1]];
            s2.overwrite(start, end, replacement2);
          }
          if (!hasReplaced) {
            return null;
          }
          const result2 = { code: s2.toString() };
          if (config2.build.sourcemap) {
            result2.map = s2.generateMap({ hires: true });
          }
          return result2;
        }
      };
    }
    async function resolvePlugins(config2, prePlugins, normalPlugins, postPlugins) {
      const isBuild = config2.command === "build";
      const buildPlugins = isBuild ? (await Promise.resolve().then(function() {
        return build$1;
      })).resolveBuildPlugins(config2) : { pre: [], post: [] };
      return [
        isBuild ? null : preAliasPlugin(),
        alias({ entries: config2.resolve.alias }),
        ...prePlugins,
        config2.build.polyfillModulePreload ? modulePreloadPolyfillPlugin(config2) : null,
        resolvePlugin(__spreadProps2(__spreadValues2({}, config2.resolve), {
          root: config2.root,
          isProduction: config2.isProduction,
          isBuild,
          packageCache: config2.packageCache,
          ssrConfig: config2.ssr,
          asSrc: true
        })),
        htmlInlineScriptProxyPlugin(config2),
        cssPlugin(config2),
        config2.esbuild !== false ? esbuildPlugin(config2.esbuild) : null,
        jsonPlugin(__spreadValues2({
          namedExports: true
        }, config2.json), isBuild),
        wasmPlugin(config2),
        webWorkerPlugin(config2),
        assetPlugin(config2),
        ...normalPlugins,
        definePlugin(config2),
        cssPostPlugin(config2),
        config2.build.ssr ? ssrRequireHookPlugin(config2) : null,
        ...buildPlugins.pre,
        ...postPlugins,
        ...buildPlugins.post,
        ...isBuild ? [] : [clientInjectionsPlugin(config2), importAnalysisPlugin(config2)]
      ].filter(Boolean);
    }
    var main$1 = {};
    var fs = fs__default;
    var path = path__default;
    var os = require$$0__default$1;
    function log(message) {
      console.log(`[dotenv][DEBUG] ${message}`);
    }
    var NEWLINE = "\n";
    var RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
    var RE_NEWLINES = /\\n/g;
    var NEWLINES_MATCH = /\r\n|\n|\r/;
    function parse(src2, options2) {
      const debug2 = Boolean(options2 && options2.debug);
      const obj = {};
      src2.toString().split(NEWLINES_MATCH).forEach(function(line, idx) {
        const keyValueArr = line.match(RE_INI_KEY_VAL);
        if (keyValueArr != null) {
          const key = keyValueArr[1];
          let val = keyValueArr[2] || "";
          const end = val.length - 1;
          const isDoubleQuoted = val[0] === '"' && val[end] === '"';
          const isSingleQuoted = val[0] === "'" && val[end] === "'";
          if (isSingleQuoted || isDoubleQuoted) {
            val = val.substring(1, end);
            if (isDoubleQuoted) {
              val = val.replace(RE_NEWLINES, NEWLINE);
            }
          } else {
            val = val.trim();
          }
          obj[key] = val;
        } else if (debug2) {
          log(`did not match key and value when parsing line ${idx + 1}: ${line}`);
        }
      });
      return obj;
    }
    function resolveHome(envPath) {
      return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function config(options2) {
      let dotenvPath = path.resolve(process.cwd(), ".env");
      let encoding2 = "utf8";
      let debug2 = false;
      if (options2) {
        if (options2.path != null) {
          dotenvPath = resolveHome(options2.path);
        }
        if (options2.encoding != null) {
          encoding2 = options2.encoding;
        }
        if (options2.debug != null) {
          debug2 = true;
        }
      }
      try {
        const parsed = parse(fs.readFileSync(dotenvPath, { encoding: encoding2 }), { debug: debug2 });
        Object.keys(parsed).forEach(function(key) {
          if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
            process.env[key] = parsed[key];
          } else if (debug2) {
            log(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
          }
        });
        return { parsed };
      } catch (e2) {
        return { error: e2 };
      }
    }
    main$1.config = config;
    main$1.parse = parse;
    var dotenvExpand = function(config2) {
      var environment = config2.ignoreProcessEnv ? {} : process.env;
      var interpolate = function(envValue) {
        var matches2 = envValue.match(/(.?\${?(?:[a-zA-Z0-9_]+)?}?)/g) || [];
        return matches2.reduce(function(newEnv, match2) {
          var parts = /(.?)\${?([a-zA-Z0-9_]+)?}?/g.exec(match2);
          var prefix = parts[1];
          var value2, replacePart;
          if (prefix === "\\") {
            replacePart = parts[0];
            value2 = replacePart.replace("\\$", "$");
          } else {
            var key = parts[2];
            replacePart = parts[0].substring(prefix.length);
            value2 = environment.hasOwnProperty(key) ? environment[key] : config2.parsed[key] || "";
            value2 = interpolate(value2);
          }
          return newEnv.replace(replacePart, value2);
        }, envValue);
      };
      for (var configKey in config2.parsed) {
        var value = environment.hasOwnProperty(configKey) ? environment[configKey] : config2.parsed[configKey];
        config2.parsed[configKey] = interpolate(value);
      }
      for (var processKey in config2.parsed) {
        environment[processKey] = config2.parsed[processKey];
      }
      return config2;
    };
    var main = dotenvExpand;
    var debug = createDebugger("vite:config");
    function defineConfig(config2) {
      return config2;
    }
    async function resolveConfig(inlineConfig, command2, defaultMode = "development") {
      var _a2, _b, _c, _d, _e2, _f, _g, _h2, _j;
      let config2 = inlineConfig;
      let configFileDependencies = [];
      let mode2 = inlineConfig.mode || defaultMode;
      if (mode2 === "production") {
        "development" = "production";
      }
      const configEnv = {
        mode: mode2,
        command: command2
      };
      let { configFile } = config2;
      if (configFile !== false) {
        const loadResult = await loadConfigFromFile(configEnv, configFile, config2.root, config2.logLevel);
        if (loadResult) {
          config2 = mergeConfig(loadResult.config, config2);
          configFile = loadResult.path;
          configFileDependencies = loadResult.dependencies;
        }
      }
      const logger = createLogger(config2.logLevel, {
        allowClearScreen: config2.clearScreen,
        customLogger: config2.customLogger
      });
      mode2 = inlineConfig.mode || config2.mode || mode2;
      configEnv.mode = mode2;
      const rawUserPlugins = (config2.plugins || []).flat().filter((p2) => {
        if (!p2) {
          return false;
        } else if (!p2.apply) {
          return true;
        } else if (typeof p2.apply === "function") {
          return p2.apply(__spreadProps2(__spreadValues2({}, config2), { mode: mode2 }), configEnv);
        } else {
          return p2.apply === command2;
        }
      });
      const [prePlugins, normalPlugins, postPlugins] = sortUserPlugins(rawUserPlugins);
      const userPlugins = [...prePlugins, ...normalPlugins, ...postPlugins];
      for (const p2 of userPlugins) {
        if (p2.config) {
          const res = await p2.config(config2, configEnv);
          if (res) {
            config2 = mergeConfig(config2, res);
          }
        }
      }
      const resolvedRoot = normalizePath$4(config2.root ? path__default.resolve(config2.root) : process.cwd());
      const clientAlias = [
        { find: /^[\/]?@vite\/env/, replacement: () => ENV_ENTRY },
        { find: /^[\/]?@vite\/client/, replacement: () => CLIENT_ENTRY }
      ];
      const resolvedAlias = mergeAlias(clientAlias, ((_a2 = config2.resolve) === null || _a2 === void 0 ? void 0 : _a2.alias) || config2.alias || []);
      const resolveOptions = __spreadProps2(__spreadValues2({
        dedupe: config2.dedupe
      }, config2.resolve), {
        alias: resolvedAlias
      });
      const envDir = config2.envDir ? normalizePath$4(path__default.resolve(resolvedRoot, config2.envDir)) : resolvedRoot;
      const userEnv = inlineConfig.envFile !== false && loadEnv(mode2, envDir, resolveEnvPrefix(config2));
      const isProduction = (process.env.VITE_USER_NODE_ENV || mode2) === "production";
      if (isProduction) {
        "development" = "production";
      }
      const BASE_URL = resolveBaseUrl(config2.base, command2 === "build", logger);
      const resolvedBuildOptions = resolveBuildOptions(resolvedRoot, config2.build, command2 === "build");
      const pkgPath = lookupFile(resolvedRoot, [`package.json`], true);
      const cacheDir = config2.cacheDir ? path__default.resolve(resolvedRoot, config2.cacheDir) : pkgPath && path__default.join(path__default.dirname(pkgPath), `node_modules/.vite`);
      const assetsFilter = config2.assetsInclude ? createFilter$1(config2.assetsInclude) : () => false;
      const createResolver = (options2) => {
        let aliasContainer;
        let resolverContainer;
        return async (id, importer, aliasOnly, ssr) => {
          var _a3;
          let container;
          if (aliasOnly) {
            container = aliasContainer || (aliasContainer = await createPluginContainer(__spreadProps2(__spreadValues2({}, resolved), {
              plugins: [alias({ entries: resolved.resolve.alias })]
            })));
          } else {
            container = resolverContainer || (resolverContainer = await createPluginContainer(__spreadProps2(__spreadValues2({}, resolved), {
              plugins: [
                alias({ entries: resolved.resolve.alias }),
                resolvePlugin(__spreadValues2(__spreadProps2(__spreadValues2({}, resolved.resolve), {
                  root: resolvedRoot,
                  isProduction,
                  isBuild: command2 === "build",
                  ssrConfig: resolved.ssr,
                  asSrc: true,
                  preferRelative: false,
                  tryIndex: true
                }), options2))
              ]
            })));
          }
          return (_a3 = await container.resolveId(id, importer, { ssr })) === null || _a3 === void 0 ? void 0 : _a3.id;
        };
      };
      const { publicDir } = config2;
      const resolvedPublicDir = publicDir !== false && publicDir !== "" ? path__default.resolve(resolvedRoot, typeof publicDir === "string" ? publicDir : "public") : "";
      const server2 = resolveServerOptions(resolvedRoot, config2.server);
      const resolved = __spreadProps2(__spreadValues2({}, config2), {
        configFile: configFile ? normalizePath$4(configFile) : void 0,
        configFileDependencies,
        inlineConfig,
        root: resolvedRoot,
        base: BASE_URL,
        resolve: resolveOptions,
        publicDir: resolvedPublicDir,
        cacheDir,
        command: command2,
        mode: mode2,
        isProduction,
        plugins: userPlugins,
        server: server2,
        build: resolvedBuildOptions,
        preview: resolvePreviewOptions(config2.preview, server2),
        env: __spreadProps2(__spreadValues2({}, userEnv), {
          BASE_URL,
          MODE: mode2,
          DEV: !isProduction,
          PROD: isProduction
        }),
        assetsInclude(file) {
          return DEFAULT_ASSETS_RE.test(file) || assetsFilter(file);
        },
        logger,
        packageCache: new Map(),
        createResolver,
        optimizeDeps: __spreadProps2(__spreadValues2({}, config2.optimizeDeps), {
          esbuildOptions: __spreadValues2({
            keepNames: (_b = config2.optimizeDeps) === null || _b === void 0 ? void 0 : _b.keepNames,
            preserveSymlinks: (_c = config2.resolve) === null || _c === void 0 ? void 0 : _c.preserveSymlinks
          }, (_d = config2.optimizeDeps) === null || _d === void 0 ? void 0 : _d.esbuildOptions)
        })
      });
      resolved.plugins = await resolvePlugins(resolved, prePlugins, normalPlugins, postPlugins);
      await Promise.all(userPlugins.map((p2) => {
        var _a3;
        return (_a3 = p2.configResolved) === null || _a3 === void 0 ? void 0 : _a3.call(p2, resolved);
      }));
      if (process.env.DEBUG) {
        debug(`using resolved config: %O`, __spreadProps2(__spreadValues2({}, resolved), {
          plugins: resolved.plugins.map((p2) => p2.name)
        }));
      }
      const logDeprecationWarning = (deprecatedOption, hint, error2) => {
        logger.warn(source.yellow.bold(`(!) "${deprecatedOption}" option is deprecated. ${hint}${error2 ? `
${error2.stack}` : ""}`));
      };
      if ((_e2 = config2.build) === null || _e2 === void 0 ? void 0 : _e2.base) {
        logDeprecationWarning("build.base", '"base" is now a root-level config option.');
        config2.base = config2.build.base;
      }
      Object.defineProperty(resolvedBuildOptions, "base", {
        enumerable: false,
        get() {
          logDeprecationWarning("build.base", '"base" is now a root-level config option.', new Error());
          return resolved.base;
        }
      });
      if (config2.alias) {
        logDeprecationWarning("alias", 'Use "resolve.alias" instead.');
      }
      Object.defineProperty(resolved, "alias", {
        enumerable: false,
        get() {
          logDeprecationWarning("alias", 'Use "resolve.alias" instead.', new Error());
          return resolved.resolve.alias;
        }
      });
      if (config2.dedupe) {
        logDeprecationWarning("dedupe", 'Use "resolve.dedupe" instead.');
      }
      Object.defineProperty(resolved, "dedupe", {
        enumerable: false,
        get() {
          logDeprecationWarning("dedupe", 'Use "resolve.dedupe" instead.', new Error());
          return resolved.resolve.dedupe;
        }
      });
      if ((_f = config2.optimizeDeps) === null || _f === void 0 ? void 0 : _f.keepNames) {
        logDeprecationWarning("optimizeDeps.keepNames", 'Use "optimizeDeps.esbuildOptions.keepNames" instead.');
      }
      Object.defineProperty(resolved.optimizeDeps, "keepNames", {
        enumerable: false,
        get() {
          var _a3;
          logDeprecationWarning("optimizeDeps.keepNames", 'Use "optimizeDeps.esbuildOptions.keepNames" instead.', new Error());
          return (_a3 = resolved.optimizeDeps.esbuildOptions) === null || _a3 === void 0 ? void 0 : _a3.keepNames;
        }
      });
      if ((_g = config2.build) === null || _g === void 0 ? void 0 : _g.polyfillDynamicImport) {
        logDeprecationWarning("build.polyfillDynamicImport", '"polyfillDynamicImport" has been removed. Please use @vitejs/plugin-legacy if your target browsers do not support dynamic imports.');
      }
      Object.defineProperty(resolvedBuildOptions, "polyfillDynamicImport", {
        enumerable: false,
        get() {
          logDeprecationWarning("build.polyfillDynamicImport", '"polyfillDynamicImport" has been removed. Please use @vitejs/plugin-legacy if your target browsers do not support dynamic imports.', new Error());
          return false;
        }
      });
      if ((_h2 = config2.build) === null || _h2 === void 0 ? void 0 : _h2.cleanCssOptions) {
        logDeprecationWarning("build.cleanCssOptions", "Vite now uses esbuild for CSS minification.");
      }
      if (((_j = config2.build) === null || _j === void 0 ? void 0 : _j.terserOptions) && config2.build.minify === "esbuild") {
        logger.warn(source.yellow(`build.terserOptions is specified but build.minify is not set to use Terser. Note Vite now defaults to use esbuild for minification. If you still prefer Terser, set build.minify to "terser".`));
      }
      return resolved;
    }
    function resolveBaseUrl(base2 = "/", isBuild, logger) {
      if (base2 === "" || base2 === "./") {
        return isBuild ? base2 : "/";
      }
      if (base2.startsWith(".")) {
        logger.warn(source.yellow.bold(`(!) invalid "base" option: ${base2}. The value can only be an absolute URL, ./, or an empty string.`));
        base2 = "/";
      }
      if (isExternalUrl(base2)) {
        if (!isBuild) {
          const parsed = require$$0$6.parse(base2);
          base2 = parsed.pathname || "/";
        }
      } else {
        if (!base2.startsWith("/")) {
          logger.warn(source.yellow.bold(`(!) "base" option should start with a slash.`));
          base2 = "/" + base2;
        }
      }
      if (!base2.endsWith("/")) {
        logger.warn(source.yellow.bold(`(!) "base" option should end with a slash.`));
        base2 += "/";
      }
      return base2;
    }
    function mergeConfigRecursively(defaults2, overrides, rootPath) {
      const merged = __spreadValues2({}, defaults2);
      for (const key in overrides) {
        const value = overrides[key];
        if (value == null) {
          continue;
        }
        const existing = merged[key];
        if (Array.isArray(existing) && Array.isArray(value)) {
          merged[key] = [...existing, ...value];
          continue;
        }
        if (isObject$3(existing) && isObject$3(value)) {
          merged[key] = mergeConfigRecursively(existing, value, rootPath ? `${rootPath}.${key}` : key);
          continue;
        }
        if (existing != null) {
          if (key === "alias" && (rootPath === "resolve" || rootPath === "")) {
            merged[key] = mergeAlias(existing, value);
            continue;
          } else if (key === "assetsInclude" && rootPath === "") {
            merged[key] = [].concat(existing, value);
            continue;
          } else if (key === "noExternal" && existing === true) {
            continue;
          }
        }
        merged[key] = value;
      }
      return merged;
    }
    function mergeConfig(defaults2, overrides, isRoot = true) {
      return mergeConfigRecursively(defaults2, overrides, isRoot ? "" : ".");
    }
    function mergeAlias(a2 = [], b2 = []) {
      return [...normalizeAlias(a2), ...normalizeAlias(b2)];
    }
    function normalizeAlias(o2) {
      return Array.isArray(o2) ? o2.map(normalizeSingleAlias) : Object.keys(o2).map((find2) => normalizeSingleAlias({
        find: find2,
        replacement: o2[find2]
      }));
    }
    function normalizeSingleAlias({ find: find2, replacement: replacement2 }) {
      if (typeof find2 === "string" && find2.endsWith("/") && replacement2.endsWith("/")) {
        find2 = find2.slice(0, find2.length - 1);
        replacement2 = replacement2.slice(0, replacement2.length - 1);
      }
      return { find: find2, replacement: replacement2 };
    }
    function sortUserPlugins(plugins2) {
      const prePlugins = [];
      const postPlugins = [];
      const normalPlugins = [];
      if (plugins2) {
        plugins2.flat().forEach((p2) => {
          if (p2.enforce === "pre")
            prePlugins.push(p2);
          else if (p2.enforce === "post")
            postPlugins.push(p2);
          else
            normalPlugins.push(p2);
        });
      }
      return [prePlugins, normalPlugins, postPlugins];
    }
    async function loadConfigFromFile(configEnv, configFile, configRoot = process.cwd(), logLevel) {
      const start = perf_hooks.performance.now();
      const getTime = () => `${(perf_hooks.performance.now() - start).toFixed(2)}ms`;
      let resolvedPath;
      let isTS = false;
      let isESM = false;
      let dependencies = [];
      try {
        const pkg = lookupFile(configRoot, ["package.json"]);
        if (pkg && JSON.parse(pkg).type === "module") {
          isESM = true;
        }
      } catch (e2) {
      }
      if (configFile) {
        resolvedPath = path__default.resolve(configFile);
        isTS = configFile.endsWith(".ts");
        if (configFile.endsWith(".mjs")) {
          isESM = true;
        }
      } else {
        const jsconfigFile = path__default.resolve(configRoot, "vite.config.js");
        if (fs__default.existsSync(jsconfigFile)) {
          resolvedPath = jsconfigFile;
        }
        if (!resolvedPath) {
          const mjsconfigFile = path__default.resolve(configRoot, "vite.config.mjs");
          if (fs__default.existsSync(mjsconfigFile)) {
            resolvedPath = mjsconfigFile;
            isESM = true;
          }
        }
        if (!resolvedPath) {
          const tsconfigFile = path__default.resolve(configRoot, "vite.config.ts");
          if (fs__default.existsSync(tsconfigFile)) {
            resolvedPath = tsconfigFile;
            isTS = true;
          }
        }
      }
      if (!resolvedPath) {
        debug("no config file found.");
        return null;
      }
      try {
        let userConfig;
        if (isESM) {
          const fileUrl = (init_url(), url_exports).pathToFileURL(resolvedPath);
          const bundled = await bundleConfigFile(resolvedPath, true);
          dependencies = bundled.dependencies;
          if (isTS) {
            fs__default.writeFileSync(resolvedPath + ".js", bundled.code);
            userConfig = (await dynamicImport(`${fileUrl}.js?t=${Date.now()}`)).default;
            fs__default.unlinkSync(resolvedPath + ".js");
            debug(`TS + native esm config loaded in ${getTime()}`, fileUrl);
          } else {
            userConfig = (await dynamicImport(`${fileUrl}?t=${Date.now()}`)).default;
            debug(`native esm config loaded in ${getTime()}`, fileUrl);
          }
        }
        if (!userConfig) {
          const bundled = await bundleConfigFile(resolvedPath);
          dependencies = bundled.dependencies;
          userConfig = await loadConfigFromBundledFile(resolvedPath, bundled.code);
          debug(`bundled config file loaded in ${getTime()}`);
        }
        const config2 = await (typeof userConfig === "function" ? userConfig(configEnv) : userConfig);
        if (!isObject$3(config2)) {
          throw new Error(`config must export or return an object.`);
        }
        return {
          path: normalizePath$4(resolvedPath),
          config: config2,
          dependencies
        };
      } catch (e2) {
        createLogger(logLevel).error(source.red(`failed to load config from ${resolvedPath}`), { error: e2 });
        throw e2;
      }
    }
    async function bundleConfigFile(fileName, isESM = false) {
      const result2 = await esbuild.build({
        absWorkingDir: process.cwd(),
        entryPoints: [fileName],
        outfile: "out.js",
        write: false,
        platform: "node",
        bundle: true,
        format: isESM ? "esm" : "cjs",
        sourcemap: "inline",
        metafile: true,
        plugins: [
          {
            name: "externalize-deps",
            setup(build2) {
              build2.onResolve({ filter: /.*/ }, (args) => {
                const id = args.path;
                if (id[0] !== "." && !path__default.isAbsolute(id)) {
                  return {
                    external: true
                  };
                }
              });
            }
          },
          {
            name: "replace-import-meta",
            setup(build2) {
              build2.onLoad({ filter: /\.[jt]s$/ }, async (args) => {
                const contents = await fs__default.promises.readFile(args.path, "utf8");
                return {
                  loader: args.path.endsWith(".ts") ? "ts" : "js",
                  contents: contents.replace(/\bimport\.meta\.url\b/g, JSON.stringify(`file://${args.path}`)).replace(/\b__dirname\b/g, JSON.stringify(path__default.dirname(args.path))).replace(/\b__filename\b/g, JSON.stringify(args.path))
                };
              });
            }
          }
        ]
      });
      const { text } = result2.outputFiles[0];
      return {
        code: text,
        dependencies: result2.metafile ? Object.keys(result2.metafile.inputs) : []
      };
    }
    async function loadConfigFromBundledFile(fileName, bundledCode) {
      const extension2 = path__default.extname(fileName);
      const defaultLoader = __require.extensions[extension2];
      __require.extensions[extension2] = (module2, filename2) => {
        if (filename2 === fileName) {
          module2._compile(bundledCode, filename2);
        } else {
          defaultLoader(module2, filename2);
        }
      };
      delete __require.cache[__require.resolve(fileName)];
      const raw = __require(fileName);
      const config2 = raw.__esModule ? raw.default : raw;
      __require.extensions[extension2] = defaultLoader;
      return config2;
    }
    function loadEnv(mode2, envDir, prefixes = "VITE_") {
      if (mode2 === "local") {
        throw new Error(`"local" cannot be used as a mode name because it conflicts with the .local postfix for .env files.`);
      }
      prefixes = arraify(prefixes);
      const env2 = {};
      const envFiles = [
        `.env.${mode2}.local`,
        `.env.${mode2}`,
        `.env.local`,
        `.env`
      ];
      for (const key in process.env) {
        if (prefixes.some((prefix) => key.startsWith(prefix)) && env2[key] === void 0) {
          env2[key] = process.env[key];
        }
      }
      for (const file of envFiles) {
        const path2 = lookupFile(envDir, [file], true);
        if (path2) {
          const parsed = main$1.parse(fs__default.readFileSync(path2), {
            debug: !!process.env.DEBUG || void 0
          });
          main({
            parsed,
            ignoreProcessEnv: true
          });
          for (const [key, value] of Object.entries(parsed)) {
            if (prefixes.some((prefix) => key.startsWith(prefix)) && env2[key] === void 0) {
              env2[key] = value;
            } else if (key === "NODE_ENV") {
              process.env.VITE_USER_NODE_ENV = value;
            }
          }
        }
      }
      return env2;
    }
    function resolveEnvPrefix({ envPrefix = "VITE_" }) {
      envPrefix = arraify(envPrefix);
      if (envPrefix.some((prefix) => prefix === "")) {
        throw new Error(`envPrefix option contains value '', which could lead unexpected exposure of sensitive information.`);
      }
      return envPrefix;
    }
    exports.build = build;
    exports.build$1 = build$1;
    exports.commonjsGlobal = commonjsGlobal;
    exports.createLogger = createLogger;
    exports.createServer = createServer;
    exports.defineConfig = defineConfig;
    exports.getAugmentedNamespace = getAugmentedNamespace;
    exports.getDefaultExportFromCjs = getDefaultExportFromCjs;
    exports.index = index$1;
    exports.index$1 = index;
    exports.loadConfigFromFile = loadConfigFromFile;
    exports.loadEnv = loadEnv;
    exports.mergeConfig = mergeConfig;
    exports.normalizePath = normalizePath$4;
    exports.optimizeDeps = optimizeDeps;
    exports.preview = preview;
    exports.printHttpServerUrls = printHttpServerUrls;
    exports.resolveConfig = resolveConfig;
    exports.resolveEnvPrefix = resolveEnvPrefix;
    exports.resolvePackageData = resolvePackageData;
    exports.resolvePackageEntry = resolvePackageEntry;
    exports.searchForWorkspaceRoot = searchForWorkspaceRoot;
    exports.send = send$1;
    exports.sortUserPlugins = sortUserPlugins;
    exports.source = source;
    exports.transformWithEsbuild = transformWithEsbuild;
  }
});

// node_modules/vite/dist/node/index.js
var require_node2 = __commonJS({
  "node_modules/vite/dist/node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var build2 = require_dep_76613303();
    init_fs();
    init_path();
    init_os();
    init_tty();
    init_util();
    init_net();
    init_events();
    init_url();
    init_http();
    init_stream();
    require_resolve();
    init_module();
    init_perf_hooks();
    init_https();
    init_zlib();
    init_crypto();
    init_tls();
    init_assert();
    init_buffer();
    init_querystring();
    require_main();
    init_child_process();
    init_worker_threads();
    init_readline();
    exports2.build = build2.build;
    exports2.createLogger = build2.createLogger;
    exports2.createServer = build2.createServer;
    exports2.defineConfig = build2.defineConfig;
    exports2.loadConfigFromFile = build2.loadConfigFromFile;
    exports2.loadEnv = build2.loadEnv;
    exports2.mergeConfig = build2.mergeConfig;
    exports2.normalizePath = build2.normalizePath;
    exports2.optimizeDeps = build2.optimizeDeps;
    exports2.preview = build2.preview;
    exports2.printHttpServerUrls = build2.printHttpServerUrls;
    exports2.resolveConfig = build2.resolveConfig;
    exports2.resolveEnvPrefix = build2.resolveEnvPrefix;
    exports2.resolvePackageData = build2.resolvePackageData;
    exports2.resolvePackageEntry = build2.resolvePackageEntry;
    exports2.searchForWorkspaceRoot = build2.searchForWorkspaceRoot;
    exports2.send = build2.send;
    exports2.sortUserPlugins = build2.sortUserPlugins;
    exports2.transformWithEsbuild = build2.transformWithEsbuild;
  }
});

// dep:vite
var vite_default = require_node2();
export {
  vite_default as default
};
/*
  @license
	Rollup.js v2.63.0
	Tue, 04 Jan 2022 07:30:25 GMT - commit ae674c9edde5efb8ce6d8ef845598a805938178c


	https://github.com/rollup/rollup

	Released under the MIT License.
*/
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 * Array of passes.
 *
 * A `pass` is just a function that is executed on `req, res, options`
 * so that you can easily add new checks while still keeping the base
 * flexible.
 */
/*!
 * Array of passes.
 *
 * A `pass` is just a function that is executed on `req, socket, options`
 * so that you can easily add new checks while still keeping the base
 * flexible.
 */
/*!
 * Caron dimonio, con occhi di bragia
 * loro accennando, tutte le raccoglie;
 * batte col remo qualunque sadagia 
 *
 * Charon the demon, with the eyes of glede,
 * Beckoning to them, collects them all together,
 * Beats with his oar whoever lags behind
 *          
 *          Dante - The Divine Comedy (Canto III)
 */
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
/*!
 * compressible
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Jeremiah Senkpiel
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * compression
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * connect
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * finalhandler
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * on-headers
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! https://mths.be/cssesc v3.0.0 by @mathias */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * Autoload Config for PostCSS
 *
 * @author Michael Ciniawsky @michael-ciniawsky <michael.ciniawsky@gmail.com>
 * @license MIT
 *
 * @module postcss-load-config
 * @version 2.1.0
 *
 * @requires comsiconfig
 * @requires ./options
 * @requires ./plugins
 */
//# sourceMappingURL=vite.js.map
